<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="https://shinichikudo-fe.github.io/atom.xml" rel="self"/>
  
  <link href="https://shinichikudo-fe.github.io/"/>
  <updated>2020-09-11T10:52:40.000Z</updated>
  <id>https://shinichikudo-fe.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>学习javascript应懂得33个概念之隐式，显式，名义和鸭子类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/11/Js/33/%E5%AD%A6%E4%B9%A0javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%9A%90%E5%BC%8F%EF%BC%8C%E6%98%BE%E5%BC%8F%EF%BC%8C%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/11/Js/33/%E5%AD%A6%E4%B9%A0javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E9%9A%90%E5%BC%8F%EF%BC%8C%E6%98%BE%E5%BC%8F%EF%BC%8C%E5%90%8D%E4%B9%89%E5%92%8C%E9%B8%AD%E5%AD%90%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-11T06:12:55.000Z</published>
    <updated>2020-09-11T10:52:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>javasciprt是属于弱类型的语言。灵活的同时也带来一些问题，有时我们修改一些代码时，看上去是对的，结果出现了我们意想不到的结果。</p><h2 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h2><p>在 JavaScript 中，当我们进行比较操作或者加减乘除四则运算操作时，常常会触发 JavaScript 的隐式类型转换机制；而这部分也往往是令人迷惑的地方。譬如浏览器中的 <code>console.log</code> 操作常常会将<strong>任何值都转化为字符串</strong>然后展示，而数学运算则会首先将值<strong>转化为数值类型</strong>（除了 <code>Date</code> 类型对象）然后进行操作。</p><h3 id="关系操作符（-lt-gt-lt-gt-）"><a href="#关系操作符（-lt-gt-lt-gt-）" class="headerlink" title="关系操作符（&lt;, &gt;, &lt;=, &gt;=）"></a>关系操作符（&lt;, &gt;, &lt;=, &gt;=）</h3><p>与上述操作符一样，<code>关系操作符</code>的操作值也可以是任意类型的，所以使用<code>非数值类型</code>参与比较时也需要系统进行<code>隐式类型转换</code>：<br>（1）如果两个操作值都是数值，则进行数值比较<br>（2）如果两个操作值都是字符串，则比较字符串对应的字符编码值<br>（3）如果只有一个操作值是数值，则将另一个操作值转换为数值，进行数值比较<br>（4）如果一个操作数是对象，则调用valueOf()方法（如果对象没有valueOf()方法则调用toString()方法），得到的结果按照前面的规则执行比较<br>（5）如果一个操作值是布尔值，则将其转换为数值，再进行比较<br>注：NaN是非常特殊的值，它不和任何类型的值相等，包括它自己，同时它与任何类型的值比较大小时都返回false。</p><h3 id="相等操作符（-）"><a href="#相等操作符（-）" class="headerlink" title="相等操作符（==）"></a>相等操作符（==）</h3><p><code>相等操作符</code>会对操作值进行隐式转换后进行比较：<br>（1）如果一个操作值为布尔值，则在比较之前先将其转换为数值<br>（2）如果一个操作值为字符串，另一个操作值为数值，则通过Number()函数将字符串转换为数值<br>（3）如果一个操作值是对象，另一个不是，则调用对象的valueOf()方法，得到的结果按照前面的规则进行比较<br>（4）null与undefined是相等的<br>（5）如果一个操作值为NaN，则相等比较返回false<br>（6）如果两个操作值都是对象，则比较它们是不是指向同一个对象</p><h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><pre><code class="js">function Person()&#123;&#125;Person.prototype = &#123;  toString() &#123; return &quot;ooo&quot;;&#125;,  valueOf() &#123; return 123;&#125;&#125;var p = new Person() ;// ️ result in chrome</code></pre><p><img src="https://upload-images.jianshu.io/upload_images/2591556-6e772a8971dd0cef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/680/format/webp" alt="demo"></p><h3 id="date类型转换出现的问题"><a href="#date类型转换出现的问题" class="headerlink" title="date类型转换出现的问题"></a>date类型转换出现的问题</h3><pre><code class="js">var date = new Date(&quot;1970/1/2 8:00:00&quot;);date.valueOf() ; //console of Chrome : 86400000date.toString(); //console of Chrome : &quot;Fri Jan 02 1970 08:00:00 GMT+0800 (CST)&quot; // &#39;&lt;=&#39; &#39;&lt;&#39; &#39;==&#39; don&#39;t have self-consistentdate &lt;= 86400000 //console of Chrome : truedate &lt;  86400000 //console of Chrome : falsedate == 86400000 //console of Chrome : false // Oh! It&#39;s awesome!//This make sensedate == date.toString() //console of Chrome : truedate &lt;= date.toString() //console of Chrome : false// Oh! It really make sense because 864000 &lt;= &quot;string&quot; is equal to 864000 &lt;= 0</code></pre><p>date 在遇到<code>&#39;&lt;&#39; &#39;&lt;=&#39;</code>的时候会默认转换至<code>.valueOf()</code> ,<br>而它遇到<code> &#39;==&#39;</code> 的时候明明有<code>.valueOf()</code>却还是选择转换为<code> .toString()</code></p><p><a href="https://juejin.im/post/5a7172d9f265da3e3245cbca#heading-6">解决该疑惑可以看</a></p><h2 id="显示类型转换"><a href="#显示类型转换" class="headerlink" title="显示类型转换"></a>显示类型转换</h2><p>显示的转换数据类型主要通过JS定义的数据转换方法。</p><h3 id="转换为布尔值："><a href="#转换为布尔值：" class="headerlink" title="转换为布尔值："></a>转换为布尔值：</h3><p>Boolean() :将一个值转换为其对应的Boolean值</p><pre><code class="js">var message = “Hello world!”;var messageAsBoolean = Boolean(message)console.log(messageAsBoolean);   //true</code></pre><p>各种数据类型及其对应的转换规则。</p><table><thead><tr><th align="left">数据类型</th><th align="center">转换为true的值</th><th align="right">转换为false的值</th></tr></thead><tbody><tr><td align="left">Boolean</td><td align="center">true</td><td align="right">false</td></tr><tr><td align="left">String</td><td align="center">任何非空字符串</td><td align="right">“” (空字符串)</td></tr><tr><td align="left">Number</td><td align="center">任何非零数字值(包括无穷大)</td><td align="right">0和NaN</td></tr></tbody></table><p>Object                     任何对象                                    null</p><p>Underfined                   n/a                                    undefined</p><h3 id="转换为数字："><a href="#转换为数字：" class="headerlink" title="转换为数字："></a>转换为数字：</h3><p>有3个函数可以把非数值转换为数值：<code>Number()</code>、<code>parseInt()</code>、<code>parseFloat()</code>。第一个函数，即转型函数<code>Number()</code>可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值。这三个函数对于同样的输入会返回不同的结果。</p><h3 id="转换为字符串"><a href="#转换为字符串" class="headerlink" title="转换为字符串"></a>转换为字符串</h3><p>要把一个值转换为一个字符串有两种方式。第一种是使用几乎每个值都有的<code>toString()</code>方法，这个方法唯一要做的就是返回相应值的字符串表现。数值、布尔值、对象、和字符串值(没错，每个字符串也都有一个<code>toString()</code>方法，该方法返回字符串的一个副本)都有<code>toString()</code>方法。但<code>null</code>和<code>undefined</code>值没有这个方法。</p><h2 id="动态类型及鸭子类型"><a href="#动态类型及鸭子类型" class="headerlink" title="动态类型及鸭子类型"></a>动态类型及鸭子类型</h2><p>动态类型语言的优点是<strong>编写的代码数量更少，看起来也更加简洁，程序员可以把精力更多地放在业务逻辑上面</strong>。虽然不区分类型在某些情况下会让程序变得难以理解，但整体而言，代码量越少，越专注于逻辑表达，对阅读程序是越有帮助的。</p><p>动态类型语言的缺点是<strong>无法保证变量的类型，从而在程序的运行期有可能发生跟类型相关的错误</strong>。这好像在商店买了一包牛肉辣条，但是要真正吃到嘴里才知道是不是牛肉味。</p><p>在JavaScript中，当我们对一个变量赋值时，显然不需要考虑它的类型，因此，JavaScript是一门典型的<strong>动态类型</strong>语言</p><p>这一切都建立在<code>鸭子类型（duck typing）</code>的概念上，鸭子类型的通俗说法是：<strong>“如果它走起路来像鸭子，叫起来也是鸭子，那么它就是鸭子。”</strong></p><p><code>鸭子类型</code>指导我们<strong>只关注对象的行为，而不关注对象本身</strong>，也就是关注HAS-A, 而不是IS-A。</p><pre><code class="js">var duck = &#123;      duckSinging: function()&#123;          console.log( &#39;嘎嘎嘎&#39; );      &#125;  &#125;;   var chicken = &#123;      duckSinging: function()&#123;          console.log( &#39;嘎嘎嘎&#39; );      &#125;  &#125;;   var choir = [];    // 合唱团   var joinChoir = function( animal )&#123;      if ( animal &amp;&amp; typeof animal.duckSinging === &#39;function&#39; )&#123;          choir.push( animal );          console.log( &#39;恭喜加入合唱团&#39; );          console.log( &#39;合唱团已有成员数量:&#39; + choir.length );      &#125;  &#125;;   joinChoir( duck );    // 恭喜加入合唱团  joinChoir( chicken );    // 恭喜加入合唱团 </code></pre><p>在动态类型语言的面向对象设计中，鸭子类型的概念至关重要。利用<code>鸭子类型</code>的思想，我们不必借助超类型的帮助，就能轻松地在动态类型语言中实现一个原则：<strong>“面向接口编程，而不是面向实现编程”</strong>。例如，一个对象若有push和pop方法，并且这些方法提供了正确的实现，它就可以被当作栈来使用。一个对象如果有length属性，也可以依照下标来存取属性（最好还要拥有slice和splice等方法），这个对象就可以被当作数组来使用。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;javasciprt是属于弱类型的语言。灵活的同时也带来一些问题，有时我们修改一些代码时，看上去是对的，结果出现了我们意想不到的结果。&lt;/p</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之值类型与引用类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/10/Js/33/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/10/Js/33/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%80%BC%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-10T02:03:16.000Z</published>
    <updated>2020-09-10T14:53:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.cnblogs.com/leiting/p/8081413.html#1959818612">原文地址</a></p><p><strong>值类型（基本数据类型）</strong>：字符串（string）、数值（number）、布尔值（boolean）、undefined、null  （这5种基本数据类型是按值访问的，因为可以操作保存在变量中的实际的值）(ECMAScript 2016新增了一种基本数据类型：symbol)、BigInt(ECMAScript 2020新增)</p><p><strong>引用类型</strong>：对象（Object）、数组（Array）、函数（Function）</p><h2 id="值类型与引用类型的区别"><a href="#值类型与引用类型的区别" class="headerlink" title="值类型与引用类型的区别"></a>值类型与引用类型的区别</h2><h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><p>1、<strong>占用空间固定，保存在栈中</strong>（当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；栈中存储的是基础变量以及一些对象的引用变量，<code>基础变量的值是存储在栈中</code>，而引用变量存储在栈中的是指向<code>堆中的数组或者对象的地址</code>，这就是<strong>为何修改引用类型总会影响到其他指向这个地址的引用变量</strong>。）</p><p>2、保存与复制的是值本身</p><p>3、使用<code>typeof</code>检测数据的类型</p><p>4、基本类型数据是值类型</p><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>1、<strong>占用空间不固定，保存在堆中</strong>（当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象<code>依然不会被销毁</code>，只有当一个对象<strong>没有任何引用变量引用它时</strong>，系统的垃圾回收机制才会在核实的时候回收它。）</p><p>2、保存与复制的是<strong>指向对象的一个指针</strong></p><p>3、使用<code>instanceof</code>检测数据类型</p><p>4、使用<code>new()</code>方法构造出的对象是引用型</p><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre><code class="js">// 值类型：Number、string、bollean、undefinedvar a = 100var b = aa = 200console.log(b) // 100 保存与复制的是值本身// 引用类型：对象、数组、函数、null(空指针)// 可以扩展属性var a = &#123;age:20&#125;var b = ab.age = 21 console.log(a.age) // 21 // 利用typeof来区分typeof undefined // undefinedtypeof &#39;abc&#39; // stringtypeof 123 // numbertypeof true // boolean// typeof 区分不出来引用类型（除了函数）typeof &#123;&#125; // objecttypeof [] // objecttypeof null // objecttypeof console.log //function// 用instanceof来区分引用类型// 如果变量是给定引用类型（根据它的原型链来识别）的实例，那么instanceof 操作符就会返回 true。console.log(person instanceof Object); // 变量 person 是 Object 吗？console.log(colors instanceof Array); // 变量 colors 是 Array 吗？console.log(pattern instanceof RegExp); // 变量 pattern 是 RegExp 吗？</code></pre><h2 id="几方面的区别举例："><a href="#几方面的区别举例：" class="headerlink" title="几方面的区别举例："></a>几方面的区别举例：</h2><p>（1）<strong>动态的属性</strong>： 定义基本类型值和引用类型值的方式是类似的。但是，当这个值保存到变量中以后，对不同类型值可以执行的操作则大相径庭。对于引用类型的值，我们可以为其添加属性和方法，也可以改变和删除其属性和方法，但是，我们不能给基本类型的值添加属性，只能给引用类型值动态地添加属性，以便将来使用。例如</p><pre><code class="js">var person = new Object(); person.name = &quot;Nicholas&quot;; alert(person.name); //&quot;Nicholas&quot;</code></pre><p>（2）<strong>复制变量值</strong>： 如果从一个变量向另一个变量复制基本类型值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。</p><pre><code class="js">var num1 = 5;var num2 = num1</code></pre><p>上述例子中，num1保存的值是5，当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。此后，<strong>这两个变量可以参与任何操作而不会相互影响</strong>。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储<em>在变量对象中的值复制一份放到为新变量分配的空间中</em>。不同的是，这个值的副本<strong>实际上是一个指针，而这个指针指向存储在堆中的一个对象</strong>。复制操作结束后，两个变量实际上引用同一个对象。因此，改变其中一个变量，就会影响另外一个变量：例</p><pre><code class="js">var obj1 = new Object(); var obj2 = obj1; obj1.name = &quot;Nicholas&quot;; alert(obj2.name); //&quot;Nicholas&quot; </code></pre><p>首先，变量 obj1 保存了一个对象的新实例。然后，这个值被复制到了 obj2 中；换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，因为这两个变量引用的都是同一个对象。<br>复制值类型的过程如下图：</p><p><img src="https://img2018.cnblogs.com/blog/1207871/201901/1207871-20190102110222496-978852296.png" alt="复制值类型"></p><p>（3）<strong>传递参数</strong>：在<em>向参数传递基本类型的值时，被传递的值会被复制给一个局部变量</em>（即命名参数，或者用ECMAScript 的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部。</p><pre><code class="js">function addTen(num) &#123;  num += 10;  return num; &#125; var count = 20; var result = addTen(count); alert(count); //20，没有变化alert(result); //30 </code></pre><p>在函数内部，参数 num 的值被加上了 10，但这一变化不会影响函数外部的 count 变量。参数num 与变量 count 互不相识，它们仅仅是具有相同的值。</p><pre><code class="js">function setName(obj) &#123;  obj.name = &quot;Nicholas&quot;; &#125; var person = new Object(); setName(person); alert(person.name); //&quot;Nicholas&quot; </code></pre><p>为了证明<strong>对象是按值传递的</strong>，我们再看一看下面这个经过修改的例子：</p><pre><code class="js">function setName(obj) &#123;  obj.name = &quot;Nicholas&quot;;  obj = new Object();  obj.name = &quot;Greg&quot;; &#125; var person = new Object(); setName(person); alert(person.name); //&quot;Nicholas&quot; </code></pre><p>如果 <code>person</code> 是按引用传递的，那么 <code>person</code> 就会自动被修改为指向其 <code>name</code> 属性值为”<code>Greg</code>“的新对象。但是，当接下来再访问 <code>person.name</code> 时，显示的值仍然是”<code>Nicholas</code>“。</p><p>这说明即使在函数内部修改了参数的值，但原始的引用仍然保持未变。实际上，当在函数内部重写 obj 时，这个变量引用的就是一个局部对象了。而这个局部对象会在函数执行完毕后立即被销毁。</p><h2 id="变量计算–强制类型转换"><a href="#变量计算–强制类型转换" class="headerlink" title="变量计算–强制类型转换"></a>变量计算–强制类型转换</h2><pre><code class="js">// 字符串拼接var a = 100 + 10 //100var b = 100 + &#39;10&#39; // &#39;10010&#39;// == 运算符100 == &#39;100&#39; //true0 == &#39;&#39; //truenull == undefined //true//  语句var a = trueif(a)&#123;&#125;var b = 100if(b)&#123;&#125; // 把数字转换为truevar c = &#39;&#39;if(c)&#123;&#125; // 把空字符串转换为false// 逻辑运算console.log(10&amp;&amp;0); // 0 把10转换成trueconsole.log(&#39;&#39; || &#39;abc&#39;); // &#39;abc&#39; 把空字符串转换为falseconsole.log(!window.abc); // window.abc是undefined 把非undefined转换成true//判断一个变量会被当做true还是falsevar a = 100console.log(!!a); // true</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/leiting/p/8081413.html#1959818612&quot;&gt;原文</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之原始类型</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/09/Js/33/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/09/Js/33/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E5%8E%9F%E5%A7%8B%E7%B1%BB%E5%9E%8B/</id>
    <published>2020-09-09T08:16:55.000Z</published>
    <updated>2020-09-09T15:07:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive">来自MDN</a></p><p>根据最新的ECMAScript的标准定义，<strong>基本类型</strong>（基本数值、基本数据类型）是一种既非对象也无方法的数据。在 JavaScript 中，共有7种基本类型：<code>string</code>，<code>number</code>，<code>bigint(ECMCScript 2020新增)</code>，<code>boolean</code>，<code>null</code>，<code>undefined</code>，<code>symbol (ECMAScript 2016新增)</code>。</p><p>多数情况下，<strong>基本类型直接代表了最底层的语言实现</strong>。</p><p><strong>所有基本类型的值都是不可改变的</strong>。但需要注意的是，<em>基本类型本身和一个赋值为基本类型的变量</em>的区别。变量会被赋予一个新值，而原值不能像数组、对象以及函数那样被改变。</p><p>除 Object 以外的所有类型都是不可变的（值本身无法被改变）。</p><h2 id="JavaScript-中的基本类型包装对象"><a href="#JavaScript-中的基本类型包装对象" class="headerlink" title="JavaScript 中的基本类型包装对象"></a>JavaScript 中的基本类型包装对象</h2><p>除了<code>null</code>与<code>undefined</code>之外，所有的基本类型都应对应的包装对象</p><blockquote><p><code>Null</code> 类型只有一个值： <code>null</code><br>一个没有被赋值的变量会有个默认值 <code>undefined</code></p></blockquote><ul><li><code>String</code> 为字符串基本类型。<blockquote><p>JavaScript的字符串类型用于表示文本数据</p></blockquote></li></ul><p>不同于类 C 语言，<code>JavaScript</code> 字符串是不可更改的。这意味着字符串一旦被创建，就不能被修改。但是，可以基于对<strong>原始字符串的操作来创建新的字符串</strong>。例如：</p><ul><li><p>获取一个字符串的子串可通过选择个别字母或者使用 <code>String.substr()</code>.</p></li><li><p>c两个字符串的连接使用连接操作符 (+) 或者 <code>String.concat()</code>.</p></li><li><p><code>Number</code> 为数值基本类型。</p><blockquote><p>基于 IEEE 754 标准的双精度 64 位二进制格式的值（-(253 -1) 到 253 -1）。<strong>它并没有为整数给出一种特定的类型</strong>。除了能够表示浮点数外，还有一些带符号的值：<code>+Infinity</code>，<code>-Infinity</code> 和 <code>NaN</code>(非数值，Not-a-Number)</p></blockquote></li><li><p><code>BigInt</code> 为大整数基本类型。</p><blockquote><p><code>BigInt</code>类型是 <code>JavaScript</code> 中的一个基础的数值类型，可以用任意精度表示整数。使用 <code>BigInt</code>，您可以安全地存储和操作大整数，甚至可以超过数字的安全整数限制。<code>BigInt</code>是通过在整数末尾附加 n 或调用构造函数来创建的。通过使用常量<code>Number.MAX_SAFE_INTEGER</code>，您可以获得可以用数字递增的最安全的值。通过引入 BigInt，您可以操作超过<code>Number.MAX_SAFE_INTEGER</code>的数字。</p></blockquote></li></ul><p>可以对<code>BigInt</code>使用运算符<code>+、*、-、**和%</code>，就像对数字一样。<code>BigInt</code> 严格来说并不等于一个数字，但它是松散的。</p><p>在将<code>BigInt</code>转换为<code>Boolean</code>时，它的行为类似于一个数字：<code>if、||、&amp;&amp;、Boolean 和!</code>。</p><p><code>BigInt</code>不能与数字互换操作。否则，将抛出<code>TypeError</code>。</p><pre><code class="js">&gt; const x = 2n ** 53n;9007199254740992n&gt; const y = x + 1n; 9007199254740993n</code></pre><ul><li><p><code>Boolean</code> 为布尔基本类型。</p><blockquote><p>布尔表示一个逻辑实体，可以有两个值：true 和 false。</p></blockquote></li><li><p><code>Symbol</code> 为字面量基本类型。</p><blockquote><p>符号类型是唯一的并且是不可修改的, 并且也可以用来作为Object的key的值(如下).</p></blockquote></li></ul><p>这个包裹对象的<code>valueOf()</code>方法返回基本类型值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Glossary/Primitive&quot;&gt;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>学习Javascript应懂得33个概念之调用堆栈</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/08/Js/33/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/08/Js/33/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5%E4%B9%8B%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88/</id>
    <published>2020-09-08T05:53:13.000Z</published>
    <updated>2020-09-09T13:36:14.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-1">原文学习地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>堆栈的概念对于我来说是熟悉又陌生的感觉，之前看过很多相关的文章及写过一些demo可后面用不到后，就慢慢淡忘了，今天要好好理解并记录下</p><h2 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h2><p>Google V8引擎是一个比较流行的javascript引擎示例，该引擎包括两个主要组件：</p><ul><li><ol><li>Memory Heap内存堆 — 这是内存分配的地方</li></ol></li><li><ol start="2"><li>call stack调用堆栈 — 这是你代码执行时栈帧存放的位置</li></ol></li></ul><h2 id="RunTime-运行时"><a href="#RunTime-运行时" class="headerlink" title="RunTime 运行时"></a>RunTime 运行时</h2><p><img src="https://static.oschina.net/uploads/space/2017/1213/104047_yNc9_2896879.png" alt="runtime"></p><h2 id="Call-Stack-调用堆栈"><a href="#Call-Stack-调用堆栈" class="headerlink" title="Call Stack 调用堆栈"></a>Call Stack 调用堆栈</h2><p>JavaScript 是一种<strong>单线程编程语言</strong>，这意味着它只有一个 <code>Call Stack</code> 。因此，它一次仅能做一件事。</p><p><code>Call Stack</code> 是一个数据结构，它基本上记录了我们在程序中的所处的位置。如果我们进入一个函数，我们把它放在堆栈的顶部。如果我们从一个函数中返回，我们弹出堆栈的顶部。这是所有的堆栈可以做的东西。</p><p>我们看一个示例：</p><pre><code class="js">function multiply(x,y)&#123;  return x * y&#125;function printSqure(x)&#123;  var s = multiply(x,x)  console.log(s)&#125;printSqure(5)</code></pre><p>当引擎开始执行这个代码时，Call Stack 将会变成空的。之后，执行的步骤如下：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104147_KJwy_2896879.png" alt="call stack"></p><p>Call Stack 的每个入口被称为 <strong>Stack Frame（栈帧）</strong>。</p><p>这正是在抛出异常时如何构建 <code>stack trace</code> 的方法 - 这基本上是在异常发生时的 <code>Call Stack</code> 的状态。看看下面的代码：</p><pre><code class="js">function foo()&#123;  throw new Error(&#39;SessionStack will help you resolve crashes :)&#39;);&#125;function bar()&#123;  foo()&#125;function start() &#123;  bar();&#125;start();</code></pre><p>如果这是在 Chrome 中执行的（假设这个代码在一个名为 foo.js 的文件中），那么会产生下面的 <code>stack trace</code>:</p><p><code>Blowing the stack</code>—当达到最大调用堆栈大小时，会发生这种情况。这可能会很容易发生，特别是如果你使用递归，而不是非常广泛地测试你的代码。看看这个示例代码：</p><pre><code class="js">function foo() &#123;    foo();&#125;foo();</code></pre><p>当引擎开始执行这个代码时，它首先调用函数“foo”。然而，这个函数是递归的，并且开始调用自己而没有任何终止条件。所以在执行的每个步骤中，同一个函数会一次又一次地添加到调用堆栈中。它看起来像这样：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104326_4B9u_2896879.png" alt="call stack 递归"></p><p>然而，在某些情况下，调用堆栈中函数调用的数量超出了调用堆栈的实际大小，浏览器通过抛出一个错误（如下所示）来决定采取行动：</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104350_JCtB_2896879.png" alt="max stack"></p><p>在单线程上运行代码可能非常容易，因为你不必处理多线程环境中出现的复杂场景，例如<strong>死锁</strong>。</p><p>但是在单线程上运行也是非常有限的。由于<code>JavaScript</code>只有一个调用堆栈，所以当事情很慢时会发生什么？</p><h2 id="并发与事件循环"><a href="#并发与事件循环" class="headerlink" title="并发与事件循环"></a>并发与事件循环</h2><p>如果在调用堆栈中执行的函数调用需要花费大量时间才能进行处理，会发生什么？ 例如，假设你想在浏览器中使用 <code>JavaScript</code> 进行一些复杂的图像转换。</p><p>你可能会问 - 为什么这会是一个问题？问题是，虽然调用堆栈有要执行的函数，浏览器实际上不能做任何事情 - 它被阻塞了。这意味着浏览器无法渲染，它不能运行任何其他代码，它就是被卡住了。如果你想在你的应用程序中使用流畅的 UI ，这就会产生问题。</p><p>而且这并不是唯一的问题。一旦你的浏览器开始在 Call Stack 中处理过多的任务，它可能会停止响应相当长的时间。大多数浏览器会通过触发错误来采取行动，询问你是否要终止网页。</p><p><img src="https://static.oschina.net/uploads/space/2017/1213/104412_G1jc_2896879.png" alt="阻塞"></p><p>所以，这并不是最好的用户体验，对吗？</p><p>那么，我们如何执行大量代码而不阻塞 UI 使得浏览器无法响应？ <strong>解决方案就是异步回调</strong>。</p><p>这将在“ JavaScript 工作原理”教程的第2部分中更详细地解释：<a href="https://www.oschina.net/translate/how-does-javascript-actually-work-part-2">“V8 引擎内部+关于如何编写优化代码的5个技巧”</a>。</p><p>同时，如果你在 JavaScript 应用程序中难以复现和理解问题，请查看 <code>SessionStack</code> 。 <code>SessionStack</code> 会记录你的 Web 应用中的所有东西：所有的 DOM 更改、用户交互、JavaScript 异常、堆栈跟踪、网络请求失败、调试消息等。</p><p>通过 SessionStack ，你可以以视频的方式重现问题，并查看发生在用户身上的所有事情。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>虽然JavaScript是单线程，但Event Loop是javascript的执行机制，可以很好的处理事件，它也分为同步与异步，当为同步时JavaScript的顺序必须一个完成之后才会完成下一个，如果前面出现无限循环后就会出现爆栈，导致后面的无法执行；而异步时又分为宏观任务（script，setTimeout，setInterval）及微观任务（Promise，process.nextTick）进入整体代码(宏任务)后，开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.oschina.net/translate/how-does-javascript-actually-work-part-1&quot;&gt;原文学习地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="学习Javascript应懂得33个概念" scheme="https://shinichikudo-fe.github.io/tags/%E5%AD%A6%E4%B9%A0Javascript%E5%BA%94%E6%87%82%E5%BE%9733%E4%B8%AA%E6%A6%82%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>深入 TypeScript 中的子类型、逆变、协变</title>
    <link href="https://shinichikudo-fe.github.io/2020/09/03/Ts/%E6%B7%B1%E5%85%A5-TypeScript-%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98/"/>
    <id>https://shinichikudo-fe.github.io/2020/09/03/Ts/%E6%B7%B1%E5%85%A5-TypeScript-%E4%B8%AD%E7%9A%84%E5%AD%90%E7%B1%BB%E5%9E%8B%E3%80%81%E9%80%86%E5%8F%98%E3%80%81%E5%8D%8F%E5%8F%98/</id>
    <published>2020-09-03T07:58:12.000Z</published>
    <updated>2020-09-07T11:53:44.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/6855517117778198542">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>TypeScript 中有很多地方涉及到子类型 <code>subtype</code>、父类型 <code>supertype</code>、逆变和协变<code>covariance and contravariance</code>的概念，如果搞不清这些概念，那么很可能被报错搞的无从下手，或者在写一些复杂类型的时候看到别人可以这么写，但是不知道为什么他可以生效。</p><h2 id="子类型"><a href="#子类型" class="headerlink" title="子类型"></a>子类型</h2><p>比如考虑如下的接口：</p><pre><code class="js">interface Animal &#123;  age: number&#125;interface Dog extends Animal &#123;  bark(): void&#125;</code></pre><p>在这个例子中，<code>Animal</code> 是 <code>Dog</code> 的父类，<code>Dog</code>是<code>Animal</code>的子类型，子类型的属性比父类型更多，更具体。</p><p>在类型系统中，属性更多的类型是子类型。<br>在集合论中，属性更少的集合是子集。</p><p>也就是说，子类型是父类型的超集，而父类型是子类型的子集，这是直觉上容易搞混的一点。<br>记住一个特征，<em>子类型比父类型更加具体</em>，这点很关键。</p><h2 id="可赋值性的assignable"><a href="#可赋值性的assignable" class="headerlink" title="可赋值性的assignable"></a>可赋值性的<font color="red">assignable</font></h2><p><code>assignable</code> 是类型系统中很重要的一个概念，当你把一个变量赋值给另一个变量时，就要检查这两个变量的类型之间是否可以相互赋值。</p><pre><code class="js">let animal: Animallet dog: Doganimal = dog // ✅okdog = animal // ❌error! animal 实例上缺少属性 &#39;bark&#39;</code></pre><p>从这个例子里可以看出，animal 是一个「更宽泛」的类型，它的属性比较少，所以更「具体」的子类型是可以赋值给它的，因为你是知道 animal 上只有 age 这个属性的，你只会去使用这个属性，dog 上拥有 animal 所拥有的一切类型，赋值给 animal 是不会出现类型安全问题的。</p><p>反之，如果 dog = animal，那么后续使用者会期望 dog 上拥有 bark 属性，当他调用了 dog.bark() 就会引发运行时的崩溃。</p><p>从可赋值性角度来说，子类型是可以赋值给父类型的，也就是<code> 父类型变量 = 子类型变量</code> 是安全的，因为子类型上涵盖了父类型所拥有的的一切属性。</p><p>当我初学的时候，我会觉得<code>T extends &#123;&#125;</code> 这样的语句很奇怪，为什么可以 <code>extends</code>一个空类型并且在传递任意类型时都成立呢？当搞明白上面的知识点，这个问题也自然迎刃而解了。</p><h2 id="在函数中的运用"><a href="#在函数中的运用" class="headerlink" title="在函数中的运用"></a>在函数中的运用</h2><p>假设我们有这样的一个函数：</p><pre><code class="js">function c(val:&#123;a:number,b:number&#125;)</code></pre><p>有这样两个变量：</p><pre><code class="js">let val1 = &#123; a: 1 &#125;let val2 = &#123; a: 1, b: 2, c: 3 &#125;</code></pre><p>调用 <code>f(val1)</code> 是会报错的，比较显而易见的来看是因为缺少属性 b，而函数 f 中很可能去访问 b 属性并且做一些操作，比如 <code>b.substr()</code>，这就会导致崩溃。</p><p>换成上面的知识点来看，val1 对应的类型是{ a: number }，它是 { a: number, b: number } 的父类型，调用 <code>f(val1)</code> 其实就相当于把函数定义中的形参 val 赋值成了 val1，把父类型的变量赋值给子类型的变量，这是危险的。</p><p>反之，调用 f(val2) 没有任何问题，因为 val2 的类型是 val类型的子类型，它拥有更多的属性，函数有可能使用的一切属性它都有。</p><p>假设我现在要开发一个 <code>redux</code>，在声明 <code>dispatch</code> 类型的时候，我就可以这样去做：</p><pre><code class="ts">interface Action &#123;  type: string&#125;declare function dispatch&lt;T extends Action&gt;(action: T)</code></pre><p>这样，就约束了传入的参数一定是 Action 的子类型。也就是说，必须有 type，其他的属性有没有，您随意。</p><h2 id="在联合类型中的运用"><a href="#在联合类型中的运用" class="headerlink" title="在联合类型中的运用"></a>在联合类型中的运用</h2><p>学习了以上知识点，再看联合类型的可赋值性，乍一看会比较反直觉， <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39;</code> 的子类型吗？它看起来属性更多诶？其实正相反，<code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 是 <code>&#39;a&#39; | &#39;b&#39;</code> 的父类型。因为<strong>前者比后者更「宽泛」，后者比前者更「具体」</strong>。</p><pre><code class="ts">type Parent = &#39;a&#39; | &#39;b&#39; | &#39;c&#39;type Son = &#39;a&#39; | &#39;b&#39;let parent: Parentlet son: Sonparent = son // ✅okson = parent // ❌error! parent 有可能是 &#39;c&#39;</code></pre><p>这里 son 是可以安全的赋值给 parent 的，因为 son 的所有可能性都被 parent 涵盖了。<br>而反之则不行，parent 太宽泛了，它有可能是 ‘c’，这是 Son 类型 hold 不住的。<br>这个例子看完以后，你应该可以理解为什么 <code>&#39;a&#39; | &#39;b&#39;</code> extends <code>&#39;a&#39; | &#39;b&#39; | &#39;c&#39;</code> 为 true 了，在书写 <code>conditional types</code>的时候更加灵活的运用吧。</p><h2 id="逆变和协变"><a href="#逆变和协变" class="headerlink" title="逆变和协变"></a>逆变和协变</h2><p>先来段<a href="https://zh.wikipedia.org/wiki/%E5%8D%8F%E5%8F%98%E4%B8%8E%E9%80%86%E5%8F%98">维基百科的定义</a>：</p><blockquote><p>协变与逆变(covariance and contravariance)是在计算机科学中，描述具有父/子型别关系的多个型别通过型别构造器、构造出的多个复杂型别之间是否有父/子型别关系的用语。</p></blockquote><p>描述的比较晦涩难懂，但是用我们上面的动物类型的例子来解释一波，现在我们还是有 <code>Animal</code> 和 <code>Dog</code> 两个父子类型。</p><h3 id="协变（Covariance）"><a href="#协变（Covariance）" class="headerlink" title="协变（Covariance）"></a>协变（Covariance）</h3><p>那么想象一下，现在我们分别有这两个子类型的数组，他们之间的父子关系应该是怎么样的呢？没错，Animal[] 依然是 Dog[] 的父类型，对于这样的一段代码，把子类型赋值给父类型依然是安全的：</p><pre><code class="js">let animals: Animal[]let dogs: Dog[]animals = dogsanimals[0].age // ✅ok</code></pre><p>转变成数组之后，对于父类型的变量，我们依然只会去 <code>Dog</code> 类型中一定有的那些属性。</p><p>那么，对于 <code>type MakeArray&lt;T&gt; = T[]</code> 这个类型构造器来说，它就是 协变（Covariance） 的。</p><h3 id="逆变（Contravariance）"><a href="#逆变（Contravariance）" class="headerlink" title="逆变（Contravariance）"></a>逆变（Contravariance）</h3><p>有这样两个函数：</p><pre><code class="js">let visitAnimal = (animal: Animal) =&gt; void;let visitDog = (dog: Dog) =&gt; void;</code></pre><p><code>animal = dog</code> 是类型安全的，那么 <code>visitAnimal = visitDog</code> 好像也是可行的？其实不然，想象一下这两个函数的实现：</p><pre><code class="ts">let visitAnimal = (animal: Animal) =&gt; &#123;  animal.age&#125;let visitDog = (dog: Dog) =&gt; &#123;  dog.age  dog.bark()&#125;</code></pre><p>由于 visitDog 的参数期望的是一个更具体的带有 bark 属性的子类型，所以如果 visitAnimal = visitDog 后，我们可能会用一个不带 bark 属性的普通的 animal 类型来传给 visitDog。</p><pre><code class="ts">visitAnimal = visitDoglet animal = &#123; age: 5 &#125;visitAnimal(animal) // ❌</code></pre><p>这会造成运行时错误，<code>animal.bark</code> 根本不存在，去调用这个方法会引发崩溃。<br>但是反过来，<code>visitDog = visitAnimal</code> 却是完全可行的。因为后续调用方会传入一个比 animal 属性更具体的 dog，函数体内部的一切访问都是安全的。</p><p>在对 Animal 和 Dog 类型分别调用如下的类型构造器之后：</p><pre><code class="ts">  type MakeFunction&lt;T&gt; = (arg: T) =&gt; void</code></pre><p>父子类型关系逆转了，这就是 逆变（Contravariance）。</p><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>当然，在 <code>TypeScript</code> 中，由于灵活性等权衡，对于函数参数默认的处理是<code>双向协变</code> 的。也就是既可以 visitAnimal = visitDog，也可以 visitDog = visitAnimal。在开启了 tsconfig 中的 <strong><code>strictFunctionType</code></strong> 后才会严格按照 <code>逆变</code> 来约束赋值关系。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/6855517117778198542&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;T</summary>
      
    
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/categories/Ts/"/>
    
    
    <category term="Ts" scheme="https://shinichikudo-fe.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>重学React(三)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%B8%89)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%B8%89)/</id>
    <published>2020-08-11T09:50:07.000Z</published>
    <updated>2020-08-18T15:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>终于到了期盼已久的HOOK环节了，我最初学react的时候是版本为15.4.2(特地去看了react仓库看了<a href="https://github.com/facebook/react/blob/master/CHANGELOG.md#1562-september-25-2017">更新日志</a>)算是很早的学习，可惜自己学的东西在工作中实践不了，当时也刚参加工作，又推动不了新技术的落地。无奈过段时间就忘了。计算机技术只有不断敲，看了用不到7天内就会忘得差不多了。当时看到class组件的时候觉得帅呆了，因为那时es6正当时，看到很多人都是使用jsx语法，class声明组件等等，觉得自己赶上了好时机。后来情况就是用不到放弃了，虽然用不到但是平时关注一些新的技术，react HOOK 发布时，也看了一些文章，一些大佬也推荐使用hook的语法写react,到了现在版本16.13.1，我才开始真正接触HOOK</p><p>根据官网的介绍：</p><p><Big><strong>Hook 是 React 16.8 的新增特性。它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性</strong><Big>。</p><blockquote><p>Hook的三个特性</p></blockquote><ul><li>完全可选的</li><li>100%向后兼容的</li><li>现在就用 </li></ul><h2 id="使用Hook的动机"><a href="#使用Hook的动机" class="headerlink" title="使用Hook的动机"></a>使用Hook的动机</h2><p><a href="https://react.docschina.org/docs/hooks-intro.html#motivation">具体介绍</a><br>1.在组件之间复用状态逻辑很难</p><p>2.复杂组件变得难以理解</p><p>3.难以理解的 class</p><h2 id="使用State-Hook"><a href="#使用State-Hook" class="headerlink" title="使用State Hook"></a>使用State Hook</h2><pre><code class="js">// demoimport React, &#123; useState &#125; from &#39;react&#39;;function Example() &#123;  // 声明一个叫 &quot;count&quot; 的 state 变量  const [count, setCount] = useState(0);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;;// 等价class组件class Example extends React.Component &#123;  constructor(props) &#123;    super(props);    this.state = &#123;      count: 0    &#125;;  &#125;  render() &#123;    return (      &lt;div&gt;        &lt;p&gt;You clicked &#123;this.state.count&#125; times&lt;/p&gt;        &lt;button onClick=&#123;() =&gt; this.setState(&#123; count: this.state.count + 1 &#125;)&#125;&gt;          Click me        &lt;/button&gt;      &lt;/div&gt;    );  &#125;&#125;</code></pre><p>在函数组件中，我们没有 this，所以我们不能分配或读取 this.state。</p><h2 id="使用Effect-Hook"><a href="#使用Effect-Hook" class="headerlink" title="使用Effect Hook"></a>使用Effect Hook</h2><p><code>Effect Hook</code> 可以让你在函数组件中执行副作用操作</p><pre><code class="js">import React, &#123; useState, useEffect &#125; from &#39;react&#39;;function Example() &#123;  const [count, setCount] = useState(0);  // Similar to componentDidMount and componentDidUpdate:  useEffect(() =&gt; &#123;    // Update the document title using the browser API    document.title = `You clicked $&#123;count&#125; times`;  &#125;);  return (    &lt;div&gt;      &lt;p&gt;You clicked &#123;count&#125; times&lt;/p&gt;      &lt;button onClick=&#123;() =&gt; setCount(count + 1)&#125;&gt;        Click me      &lt;/button&gt;    &lt;/div&gt;  );&#125;</code></pre><p><em>有些副作用可能需要清除，所以需要返回一个函数：</em></p><pre><code class="js">useEffect(() =&gt; &#123;  function handleStatusChange(status) &#123;    setIsOnline(status.isOnline);  &#125;  ChatAPI.subscribeToFriendStatus(props.friend.id, handleStatusChange);  return () =&gt; &#123;    ChatAPI.unsubscribeFromFriendStatus(props.friend.id, handleStatusChange);  &#125;;&#125;);</code></pre><p><em>其他的 effect 可能不必清除，所以不需要返回。</em></p><pre><code class="js">useEffect(() =&gt; &#123;  document.title = `You clicked $&#123;count&#125; times`;&#125;);</code></pre><h2 id="Hook的规则"><a href="#Hook的规则" class="headerlink" title="Hook的规则"></a>Hook的规则</h2><p>1.只在最顶层使用 Hook</p><p><strong>不要在循环，条件或嵌套函数中调用 Hook</strong>， 确保总是在你的 React 函数的最顶层调用他们。</p><p>2.只在 React 函数中调用 Hook</p><p><strong>不要在普通的 JavaScript 函数中调用 Hook</strong></p><p>可以在：</p><ul><li>在 React 的函数组件中调用 Hook</li><li>在自定义 Hook 中调用其他 Hook</li></ul><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><p><a href="https://react.docschina.org/docs/hooks-faq.html#which-versions-of-react-include-hooks">更多</a></p><p>为什么要在 effect 中返回一个函数？<br><strong>这是 effect 可选的清除机制</strong>。每个 effect 都可以返回一个清除函数。如此可以将添加和移除订阅的逻辑放在一起。它们都属于 effect 的一部分。</p><p>React 何时清除 effect？<br><strong>React 会在组件卸载的时候执行清除操作</strong>。正如之前学到的，effect 在每次渲染的时候都会执行。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;终于到了期盼已久的HOOK环节了，我最初学react的时候是版本为15.4.2(特地去看了react仓库看了&lt;a href=&quot;https:/</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学React(二)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%BA%8C)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/11/React/%E9%87%8D%E5%AD%A6React(%E4%BA%8C)/</id>
    <published>2020-08-11T09:45:34.000Z</published>
    <updated>2020-08-18T15:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上一篇看了react的核心概念后，大概心里对react的五脏六腑有个形状了，接着看文档中的高级指引部分</p><h2 id="react文档中高级指引部分的重点"><a href="#react文档中高级指引部分的重点" class="headerlink" title="react文档中高级指引部分的重点"></a>react文档中高级指引部分的重点</h2><h3 id="代码分割"><a href="#代码分割" class="headerlink" title="代码分割"></a>代码分割</h3><p>在通过动态 import() 语法。</p><pre><code class="js">import(&quot;./math&quot;).then(math =&gt; &#123;  console.log(math.add(16, 26));&#125;);</code></pre><p><strong>使用React.Lazy</strong></p><p><code>React.lazy</code> 函数能让你像渲染常规组件一样处理动态引入（的组件）</p><pre><code class="js">const OtherComponent = React.lazy(() =&gt; import(&#39;./OtherComponent&#39;));</code></pre><h3 id="context（常用）"><a href="#context（常用）" class="headerlink" title="context（常用）"></a>context（常用）</h3><p>内部的一个组件状态通信的一个方法</p><p>定义：<strong>Context 提供了一个无需为每层组件手动添加 props，就能在组件树间进行数据传递的方法</strong>。</p><p><code>theme-context.js</code></p><pre><code class="js">// 确保传递给 createContext 的默认值数据结构是调用的组件（consumers）所能匹配的！export const ThemeContext = React.createContext(&#123;  theme: themes.dark,  toggleTheme: () =&gt; &#123;&#125;,&#125;);</code></pre><p><code>theme-toggler-button.js</code></p><pre><code class="js">// 有两种显示方式&lt;MyContext.Provider value=&#123;/* 某个值 */&#125;&gt;&lt;MyContext.Consumer&gt;  &#123;value =&gt; /* 基于 context 值进行渲染*/&#125;&lt;/MyContext.Consumer&gt;</code></pre><pre><code class="js">import &#123;ThemeContext&#125; from &#39;./theme-context&#39;;function ThemeTogglerButton() &#123;  // Theme Toggler 按钮不仅仅只获取 theme 值，它也从 context 中获取到一个 toggleTheme 函数  return (    &lt;ThemeContext.Consumer&gt;      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (        &lt;button          onClick=&#123;toggleTheme&#125;          style=&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt;          Toggle Theme        &lt;/button&gt;      )&#125;    &lt;/ThemeContext.Consumer&gt;  );&#125;export default ThemeTogglerButton;</code></pre><p><code>app.js</code></p><pre><code class="js">import &#123;ThemeContext, themes&#125; from &#39;./theme-context&#39;;import ThemeTogglerButton from &#39;./theme-toggler-button&#39;;class App extends React.Component &#123;  constructor(props) &#123;    super(props);    this.toggleTheme = () =&gt; &#123;      this.setState(state =&gt; (&#123;        theme:          state.theme === themes.dark            ? themes.light            : themes.dark,      &#125;));    &#125;;    // State 也包含了更新函数，因此它会被传递进 context provider。    this.state = &#123;      theme: themes.light,      toggleTheme: this.toggleTheme,    &#125;;  &#125;  render() &#123;    // 整个 state 都被传递进 provider    return (      &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt;        &lt;Content /&gt;      &lt;/ThemeContext.Provider&gt;    );  &#125;&#125;function Content() &#123;  return (    &lt;div&gt;      &lt;ThemeTogglerButton /&gt;    &lt;/div&gt;  );&#125;ReactDOM.render(&lt;App /&gt;, document.root);</code></pre><h2 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h2><p><strong>Ref 转发是一项将 ref 自动地通过组件传递到其一子组件的技巧,<code>render prop</code> 是一个用于告知组件需要渲染什么内容的函数 prop。</strong><br>类似vue中的 <code>refs</code>,获取真实dom的属性</p><h3 id="何时使用refs"><a href="#何时使用refs" class="headerlink" title="何时使用refs"></a>何时使用refs</h3><ul><li><ol><li>管理焦点，文本选择或媒体播放。</li></ol></li><li><ol start="2"><li>触发强制动画。</li></ol></li><li><ol start="3"><li>集成第三方 DOM 库。</li></ol></li></ul><h2 id="如何使用refs"><a href="#如何使用refs" class="headerlink" title="如何使用refs"></a>如何使用refs</h2><ol><li>创建Refs</li></ol><pre><code class="js">this.myRef = React.createRef()</code></pre><ol start="2"><li>访问Refs</li></ol><pre><code class="js">const node = this.myRef.current;</code></pre><p><strong>默认情况下，你不能在函数组件上使用 <code>ref</code> 属性，因为它们没有实例,在hook函数中useRef,指向一个DOM元素或class组件</strong></p><h2 id="Render-Props"><a href="#Render-Props" class="headerlink" title="Render Props"></a>Render Props</h2><p>指一种在 React 组件之间使用一个值为<strong>函数的 prop</strong>共享代码的简单技术</p><pre><code class="js">&lt;DataProvider render=&#123;data =&gt; (  &lt;h1&gt;Hello &#123;data.target&#125;&lt;/h1&gt;)&#125;/&gt;</code></pre><h2 id="静态类型检查"><a href="#静态类型检查" class="headerlink" title="静态类型检查"></a>静态类型检查</h2><p>有两种方式一种是<code>Flow</code>语法，这个我没有用过。所以重点学习另一种<code>TypeScript</code></p><ol><li>在 <code>Create React App</code> 中使用 TypeScript</li></ol><pre><code class="js">npx create-react-app my-app --template typescript</code></pre><ol start="2"><li>添加相关依赖包</li></ol><pre><code class="js">npm install --save typescript @types/node @types/react @types/react-dom @types/jest//oryarn add typescript @types/node @types/react @types/react-dom @types/jest</code></pre><h2 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h2><p>如果你还是不清楚在某个特殊场景中应该使用哪种组件，那么 这篇关于<a href="https://goshakkk.name/controlled-vs-uncontrolled-inputs-react/">受控和非受控输入组件的文章</a> 会很有帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;上一篇看了react的核心概念后，大概心里对react的五脏六腑有个形状了，接着看文档中的高级指引部分&lt;/p&gt;
&lt;h2 id=&quot;react文</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>重学React(一)</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/06/React/%E9%87%8D%E5%AD%A6React(%E4%B8%80)/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/06/React/%E9%87%8D%E5%AD%A6React(%E4%B8%80)/</id>
    <published>2020-08-06T05:45:44.000Z</published>
    <updated>2020-08-18T15:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>这几天手头里项目完成了一个阶段，下个阶段暂时有个星期的时间，正好有时间可以回顾下<code>react</code>。因为之前是选择react比vue要早，但是在之前公司里的技术栈是vue,没办法只有把react放到一旁，开始了<code>vue</code>的踩坑。</p><p>心里还是对react有感情的，这样说的我好像个渣男。。哈哈，确实挺喜欢这两个的框架。<br>既然是重学，自己就定位为react的初学者，要认真，充满激情，先从撸官网开始吧。<br><a href="https://react.docschina.org/">react中文文档</a></p><h2 id="新建一个react应用"><a href="#新建一个react应用" class="headerlink" title="新建一个react应用"></a>新建一个react应用</h2><p>我是通过<a href="https://www.html.cn/create-react-app/docs/getting-started/">create-react-app</a>脚手架工具搭建的react初始界面</p><p>简单的过了一遍<code>creact-react-app</code>的文档，发现自己使用vue开发过项目之后，再返回来学习react知识，感觉轻松多了，以前很多概念理解不了，不知道怎么实现，虽然现在看的是一些基础知识，但是给了自己很大的信心去重学react</p><p>使用下面命令，就可以看的一个简单的react应用了</p><pre><code class="js">npx create-react-app my-appcd my-appyarn start </code></pre><h2 id="开发前的准备"><a href="#开发前的准备" class="headerlink" title="开发前的准备"></a>开发前的准备</h2><ul><li><ol><li>下载了一些vscode中关于react的一些插件，如<code>Reactjs code snippets</code>等</li></ol></li><li><ol start="2"><li>安装<code>prettier，eslint</code>与vscode完美结合，减少一些格式上的错误</li></ol></li><li><ol start="3"><li>从react文档中的核心概念看起，边看边跟着敲敲</li></ol></li></ul><h2 id="文档中一些自己觉得常用的知识"><a href="#文档中一些自己觉得常用的知识" class="headerlink" title="文档中一些自己觉得常用的知识"></a>文档中一些自己觉得常用的知识</h2><h3 id="核心概念部分"><a href="#核心概念部分" class="headerlink" title="核心概念部分"></a>核心概念部分</h3><ul><li><ol><li>react是用jsx后缀名的文件来呈现代码的(ps:不是必须的),后面结合ts的话就是tsx后缀名的文件，总之jsx文件的概念就是<code>all in js</code>，react秉承的也是这种，vue则是数据和视图分离，<br><code>templete</code>标签里编写html部分，<code>script</code>标签中编写js部分，<code>style</code>标签中编写css部分，这种模式是和我们最初写一个网页的结构相似的，便于我们理解。react提倡的jsx理由是这样说的<strong>React 并没有采用将标记与逻辑进行分离到不同文件这种人为地分离方式，而是通过将二者共同存放在称之为“组件”的松散耦合单元之中，来实现关注点分离。</strong></li></ol></li></ul><p>一个简单的react示例：</p><pre><code class="js">const name = &#39;Josh Perez&#39;;const element = &lt;h1&gt;Hello, &#123;name&#125;&lt;/h1&gt;;ReactDOM.render(  element,  document.getElementById(&#39;root&#39;));</code></pre><ul><li><ol start="2"><li>react 数据传递是通过<code>props</code>自上而下传递，是属于单向数据流，且<code>props</code>是只读的不可更改的。而vue是可以双向数据绑定</li></ol></li></ul><p>目前为止，在 React 中有两种流行的方式来共享组件之间的状态逻辑: <a href="https://react.docschina.org/docs/render-props.html">render props</a> 和<a href="https://react.docschina.org/docs/higher-order-components.html">高阶组件</a></p><ul><li><ol start="3"><li><a href="https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/">react生命周期</a> <img src="https://static01.imgkr.com/temp/3d03a0c13a2f4da7a4763a1dba50289e.png" alt="react life"></li></ol></li><li><ol start="4"><li>react事件处理的几种方法<pre><code class="js">// 匿名箭头函数&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;// bind方法&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt;</code></pre></li></ol></li></ul><p>// 或者在方法中直接使用箭头函数，官网说这是实验性语法，不推荐使用，不过这个方法真的很简单明了啊<br> handleClick = () =&gt; {<br>  console.log(‘this is:’, this);<br>}</p><p>// 常见的方法 声明方法后在constructor中在声明一次，比较麻烦，<br>constructor(props) {<br>  super(props);<br>  this.state = {isToggleOn: true};</p><p>  // 为了在回调中使用 <code>this</code>，这个绑定是必不可少的<br>  this.handleClick = this.handleClick.bind(this);<br>}<br>handleClick() {<br>  this.setState(state =&gt; ({<br>    isToggleOn: !state.isToggleOn<br>  }));<br>}</p><pre><code>* 5. 通过花括号包裹代码，你可以在 [JSX 中嵌入任何表达式](https://react.docschina.org/docs/introducing-jsx.html#embedding-expressions-in-jsx), 就和写js文件一样* 6. 表单中的`受控组件`(如`&lt;input&gt;`、 `&lt;textarea&gt;` 和 `&lt;select&gt;`在 React 中，可变状态（mutable state）通常保存在组件的 state 属性中，并且只能通过使用 setState()来更新)与`非受控组件 `(在 React 中，`&lt;input type=&quot;file&quot; /&gt;` 始终是一个非受控组件，因为它的值只能由用户设置，而不能通过代码控制。) </code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;这几天手头里项目完成了一个阶段，下个阶段暂时有个星期的时间，正好有时间可以回顾下&lt;code&gt;react&lt;/code&gt;。因为之前是选择reac</summary>
      
    
    
    
    <category term="React" scheme="https://shinichikudo-fe.github.io/categories/React/"/>
    
    
    <category term="React" scheme="https://shinichikudo-fe.github.io/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>如何规范你的git提交?</title>
    <link href="https://shinichikudo-fe.github.io/2020/08/03/Tools/%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%E4%BD%A0%E7%9A%84git%E6%8F%90%E4%BA%A4/"/>
    <id>https://shinichikudo-fe.github.io/2020/08/03/Tools/%E5%A6%82%E4%BD%95%E8%A7%84%E8%8C%83%E4%BD%A0%E7%9A%84git%E6%8F%90%E4%BA%A4/</id>
    <published>2020-08-03T05:33:53.000Z</published>
    <updated>2020-08-18T15:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/5522df15c9ec">原文地址</a></p><h1 id="一、为什么需要规范？"><a href="#一、为什么需要规范？" class="headerlink" title="一、为什么需要规范？"></a>一、为什么需要规范？</h1><p>无规矩不成方圆，编程也一样。</p><p>如果你有一个项目，从始至终都是自己写，那么你想怎么写都可以，没有人可以干预你。可是如果在团队协作中，大家都张扬个性，那么代码将会是一团糟，好好的项目就被糟践了。不管是开发还是日后维护，都将是灾难。</p><p>这时候，有人提出了何不统一标准，大家都按照这个标准来。于是 ESLint，JSHint 等代码工具如雨后春笋般涌现，成为了项目构建的必备良品。</p><p><code>Git Commit</code> 规范可能并没有那么夸张，但如果你在版本回退的时候看到一大段糟心的 Commit，恐怕会懊恼不已吧。所以，严格遵守规范，利人利己。</p><p>二、具体规则</p><p>先来看看公式：</p><p><strong><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</code></strong></p><blockquote><p>type 用于说明 commit 的类别，只允许使用下面7个标识。</p></blockquote><ul><li>feat：新功能(feature)</li><li>fix：修补</li><li>bugdocs：文档(documentation)</li><li>style：格式(不影响代码运行的变动);</li><li>refactor：重构(即不是新增功能，也不是修改bug的代码变动)</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><blockquote><p>scope 用于说明 commit 影响的范围，比如<code>数据层、控制层、视图层</code>等等，视项目不同而不同。</p></blockquote><blockquote><p>subject 是 commit 目的的简短描述，不超过50个字符。</p></blockquote><ul><li>以动词开头，使用第一人称现在时，比如change，而不是changed或changes</li><li>第一个字母小写</li><li>结尾不加句号(.)</li></ul><h1 id="三、异常处理"><a href="#三、异常处理" class="headerlink" title="三、异常处理"></a>三、异常处理</h1><p>我们先来看看这个异常提醒：</p><pre><code class="js">INVALID COMMIT MSG: does not match &quot;&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;&quot; ! jartto:fix bug </code></pre><p>这里之所以报出这个警告，是因为我的提交出现了两个问题：</p><ul><li>其一，使用了规范外的关键字;</li><li>其二，很细节的问题，<code>jartto：</code>后少了空格;</li></ul><p>这时候我才回忆起来，当时提交一直失败，情急之下直接强制提交，所以以后的提交都会抱出这个异常。大致意思就是：</p><blockquote><p>你的之前的 Commit 不合格～你的之前的 Commit 不合格～你的之前的 Commit 不合格</p></blockquote><p>这时候就很烦了，我们只能去将之前的错误修正，那么如何操作呢?</p><h1 id="四、如何修改之前的-commit-信息？"><a href="#四、如何修改之前的-commit-信息？" class="headerlink" title="四、如何修改之前的 commit 信息？"></a>四、如何修改之前的 commit 信息？</h1><p>其实并不复杂，我们只需要这样做:</p><ul><li>1、将当前分支无关的工作状态进行暂存 <code>git stash</code></li><li>2、将 HEAD 移动到需要修改的 commit 上 <code>git rebase 9633cf0919^ --interactive</code></li><li>3、找到需要修改的 commit ,将首行的 pick 改成 edit</li><li>4、开始着手解决你的 bug</li><li>5、<code>git add </code>将改动文件添加到暂存</li><li>6、<code>git commit –amend</code> 追加改动到提交</li><li>7、<code>git rebase –continue</code> 移动 HEAD 回最新的 commit</li><li>8、恢复之前的工作状态 <code>git stash pop</code></li></ul><p>大功告成，是不是想把整个 Commit 都修改一遍</p><h1 id="五、项目中使用"><a href="#五、项目中使用" class="headerlink" title="五、项目中使用"></a>五、项目中使用</h1><p>这时候问题又来了，为什么我提交的时候会有警告，这个又是如何做到的呢?</p><p>这时候，我们需要一款 Node 插件 <code>validate-commit-msg</code> 来检查项目中 <code>Commit message</code> 是否规范。</p><ul><li>1.首先，安装插件：</li></ul><pre><code class="js">npm install --save-dev validate-commit-msg </code></pre><ul><li><p>2.使用方式一，建立 .vcmrc 文件：</p><pre><code class="js">&#123; &quot;types&quot;: [&quot;feat&quot;, &quot;fix&quot;, &quot;docs&quot;, &quot;style&quot;, &quot;refactor&quot;, &quot;perf&quot;, &quot;test&quot;, &quot;build&quot;, &quot;ci&quot;, &quot;chore&quot;, &quot;revert&quot;], &quot;scope&quot;: &#123;   &quot;required&quot;: false,   &quot;allowed&quot;: [&quot;*&quot;],   &quot;validate&quot;: false,   &quot;multiple&quot;: false &#125;, &quot;warnOnFail&quot;: false, &quot;maxSubjectLength&quot;: 100, &quot;subjectPattern&quot;: &quot;.+&quot;, &quot;subjectPatternErrorMsg&quot;: &quot;subject does not match subject pattern!&quot;, &quot;helpMessage&quot;: &quot;&quot;, &quot;autoFix&quot;: false &#125;</code></pre></li><li><p>3.使用方式二：写入 package.json</p></li></ul><pre><code class="json">&#123;   &quot;config&quot;: &#123;     &quot;validate-commit-msg&quot;: &#123;       /* your config here */     &#125;   &#125; &#125;</code></pre><ul><li>4.可是我们如果想自动使用 ghooks 钩子函数呢？</li></ul><pre><code class="js">&#123;   …   &quot;config&quot;: &#123;     &quot;ghooks&quot;: &#123;       &quot;pre-commit&quot;: &quot;gulp lint&quot;,       &quot;commit-msg&quot;: &quot;validate-commit-msg&quot;,       &quot;pre-push&quot;: &quot;make test&quot;,       &quot;post-merge&quot;: &quot;npm install&quot;,       &quot;post-rewrite&quot;: &quot;npm install&quot;,       …     &#125;   &#125;   … &#125; </code></pre><p>在 ghooks 中我们可以做很多事情，当然不只是 <code>validate-commit-msg</code>哦。</p><h1 id="六、Commit-规范的作用"><a href="#六、Commit-规范的作用" class="headerlink" title="六、Commit 规范的作用"></a>六、Commit 规范的作用</h1><ul><li>提供更多的信息，方便排查与回退;</li><li>过滤关键字，迅速定位;</li><li>方便生成文档;</li></ul><h1 id="七、生成-Change-log"><a href="#七、生成-Change-log" class="headerlink" title="七、生成 Change log"></a>七、生成 Change log</h1><p>正如上文提到的生成文档，如果我们的提交都按照规范的话，那就很简单了。生成的文档包括以下三个部分：</p><p><strong>New features</strong></p><p><strong>Bug fixes</strong></p><p><strong>Breaking changes</strong></p><p>每个部分都会罗列相关的 <code>commit</code> ，并且有指向这些 <code>commit</code> 的链接。当然，生成的文档允许手动修改，所以发布前，你还可以添加其他内容。</p><p>这里需要使用工具 <code>Conventional Changelog</code> 生成 <code>Change log</code>：</p><pre><code class="js">npm install -g conventional-changelog cd jartto-domo conventional-changelog -p angular -i CHANGELOG.md -w</code></pre><p>为了方便使用，可以将其写入 <code>package.json</code> 的 scripts 字段。</p><pre><code class="js">&#123;   &quot;scripts&quot;: &#123;     &quot;changelog&quot;: &quot;conventional-changelog -p angular -i CHANGELOG.md -w -r 0&quot;   &#125; &#125;</code></pre><p>这样，使用起来就很简单了：</p><pre><code class="js"> npm run changelog</code></pre><h1 id="八、总结"><a href="#八、总结" class="headerlink" title="八、总结"></a>八、总结</h1><p>看完文章，你还会如此放荡不羁吗?你还会随心所欲的编写 Commit 吗?你还会如此 git commit -m “hello world”提交吗?</p><p>答案是否定的，因为使用了钩子函数，你没有机会了，否则将是无穷无尽的恢复 Commit。这倒可以养成良好的提交习惯。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/5522df15c9ec&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;一、为什么需要规范？&quot;&gt;&lt;a href=&quot;#一、为什么需要规范？&quot; class=&quot;headerlink&quot; title=&quot;一、为什么需要</summary>
      
    
    
    
    <category term="Tools" scheme="https://shinichikudo-fe.github.io/categories/Tools/"/>
    
    
    <category term="git" scheme="https://shinichikudo-fe.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>响应式布局新方案</title>
    <link href="https://shinichikudo-fe.github.io/2020/07/30/HTML5/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E6%96%B0%E6%96%B9%E6%A1%88/"/>
    <id>https://shinichikudo-fe.github.io/2020/07/30/HTML5/%E5%93%8D%E5%BA%94%E5%BC%8F%E5%B8%83%E5%B1%80%E6%96%B0%E6%96%B9%E6%A1%88/</id>
    <published>2020-07-30T03:20:15.000Z</published>
    <updated>2020-08-18T15:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&mid=2247488692&idx=1&sn=5296bb93e4fcec284fe8dfe858634e9b&chksm=c0669522f7111c345f71416e84d2a6a32fe730be9e7734eee71a8c1bd93d61467df3c4075257&mpshare=1&scene=1&srcid=0730IrQ52ONYNC8eirsY5vf6&sharer_sharetime=1596079115612&sharer_shareid=857ca04011f1cc878c5f0c9e8e947d57&key=3c1b79f4d2f73bee114f16dcdfd3b504678f8d95031f428469c7a393e3314e043cbfa073c22cc8b27fd6e46074839d9dc6941a9801bc8145315e56cc9849f39ebd3a36532aadb9630bbd9d2ba5e887a6&ascene=1&uin=MTA4OTc2NTY3Mg==&devicetype=Windows+10+x64&version=62090538&lang=zh_CN&exportkey=A597mrIlaQ+2fkuWhB0UYgw=&pass_ticket=KFo0GUOexWMIpxp6jEIHplHkIy/bm272lNRA4DRRf+xq5hWFuvoJ7oFj7xf+oyh6">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>概念：融合响应式设计</p><p>本文中我们可以尝试得出一种新的解决方案，那就是利用 JavaScript 和 CSS 来进行媒体查询，是响应式设计与自适应设计结合的方案，我这里给起一个好记的名字叫做融合响应式设计（ <code>Fusion Web Design</code>，简称 FWD ）。</p><p>技术原则：</p><ul><li>JavaScript 判断尽量少</li><li>CSS 媒体查询的断点也尽量少</li></ul><p>UI效果</p><ul><li>在笔记本、平板电脑、智能手机上展示合适的 UI 效果</li><li>PC UI：给笔记本等设备上看的大屏效果</li><li>Mobile UI：给智能手机上看的小屏效果</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9F72dq8UWxDyh6qn8gbhYGKpZgmUTNUy5UibVnrzQ09SkYGwIOyiaaw79g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="demo"></p><p>但这里，还是有一个遗漏的为平板电脑上效果。</p><p>先前，<code>iPad Air</code> 或 <code>iPad Mini</code> 会被归类到智能手机的 Mobile UI 范围，但是这两年新出的 <code>iPad Pro</code> 的宽高单纯展示 PC UI 或 Mobile UI，效果都不是很理想。</p><ul><li>iPad Pro （横屏 1366px）展示 Mobile站点内容，中间内容区域只有 768px</li><li>iPad Mini （横屏 1024px）展示PC 站点内容，右侧容易被截取</li></ul><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FphodDhHCJQFcApagNClp7u7d7Hjcf9U8V56qXPnZSuathD4H7ibaICA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="ipad Demo"></p><h2 id="先说为何不能以-UserAgent-来作为依据"><a href="#先说为何不能以-UserAgent-来作为依据" class="headerlink" title="先说为何不能以 UserAgent 来作为依据"></a>先说为何不能以 UserAgent 来作为依据</h2><p>iPad 装着 iOS 系统，其 UserAgent 中包含着 iPad 字眼，一般可用来判断 iPad。</p><pre><code class="js">Mozilla/5.0 (iPad; CPU OS 11_0 like Mac OS X) AppleWebKit/604.1.34 (KHTML, like Gecko) Version/11.0 Mobile/15A5341f Safari/604.1</code></pre><p>那么，这里的一个的难点为不能使用 <code>UserAgent</code> 来判断 <code>iPad Pro（iPad OS）</code>，因为它的 <code>UserAgent</code> 太像 MacBook Pro。</p><p>iPad Pro 上装着 iPad OS 系统，其 <code>UserAgent</code> 为</p><pre><code class="js">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_4) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.2 Safari/605.1.15</code></pre><p>MacBook Pro 的 Safari 浏览器的 <code>UserAgent</code> 为</p><pre><code class="js">Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/13.1.1 Safari/605.1.15</code></pre><p>当然，也不能一直通过 UserAgent 来区分各种设备，因为以后新出的设备会更多。</p><ul><li>12.9 英寸 iPad Pro (第四、三、二、一代)</li><li>11 英寸 iPad Pro (第二、一代)</li><li>10.5 英寸 iPad Pro</li><li>9.7 英寸 iPad Pro</li><li>iPad (第七、六、五代)</li><li>iPad mini (第五、4代)</li><li>iPad Air (第三、2代)</li><li>…</li></ul><h2 id="依据设备横竖屏及宽高特点"><a href="#依据设备横竖屏及宽高特点" class="headerlink" title="依据设备横竖屏及宽高特点"></a>依据设备横竖屏及宽高特点</h2><p>这里，我先列举一下我的目标设备的网页宽高、设备特点。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FyjD73wjHTUiaZgcoWMWCd5KiaHLXUs9kzoG4D4CbfnHQptpbMUsBxs8Q/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="目标设备"></p><p>判断的主要依据：</p><ul><li>设备是否支持横竖屏切换</li><li>刚进页面时设备的宽高</li><li>设备在横竖屏切换后的宽高</li></ul><p>那么，常见的设备显示效果如下：</p><ul><li>常见笔记本电脑的最小宽高为 1280x800，显示的为 PC UI</li><li>常见智能手机的最大屏为 iPhone11 pro max，网页宽高为 414x896，无论是横竖屏都现实的是 Mobile UI。</li></ul><p>难点还是在 iPad 设备上，根据上面的表格我们发现，平板电脑支持横竖屏切换，竖屏范围在 768、834、1024 上，横屏范围在1024、1194、1366上。</p><p>最大的难点就在于，1024宽度应该显示 Mobile UI 还是PC UI呢？</p><p>这里我选择将判断的断点改为<code>1040px</code> 上，就是将最大宽不超过<code>1024px</code>的设备都认为 Mobile UI 。</p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FnvSymbRYKGqib8UHw5JR9a3RD7zEAqyPq7obdvB9xLvgSXM4Ek1Fdbg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="决定设备大小"></p><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FkX2A642fDoRVOia1Zle0o9Egll4pzkgABqOcCXgNbQIPbU9yXxFxA9g/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="效果图pc"><br><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9F9UGve7q7H6goDn42eY45Jn7RDDZ9xYT6PHVrKlF1UKPwia3Jgic3oO6A/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="效果图mobile"></p><blockquote><p>区分 Mobile UI 和 PC UI 的完整的判断逻辑如下：</p></blockquote><p>1.笔记本电脑，不支持 onorientationchange 横竖屏切换的，就认定为 PC</p><ul><li>不使用 onRisize 来监听网页的宽高，因为性能消耗大</li><li>并且当浏览器拖动小了，支持左右滚动</li></ul><p>2.进入页面时，竖屏时以 <code>window.innerWidth, window.innerHeight</code> 中数值小的那个来判断，横屏中以 <code>window.innerWidth, window.innerHeight</code> 数值大的来判断，当宽度大于 1040px 时认为是 PC ，宽度小于 1040px 时，认定为 Mobile 。</p><p>3.横竖屏切换时，重复第 2 步的判断</p><p>备注：</p><ul><li><code>window.innerWidth, window.innerHeight</code> 在安卓和 iOS 上的横竖屏切换上有不一致的地方，所以以最大值或最小值来做更准确。</li></ul><h2 id="源码示例"><a href="#源码示例" class="headerlink" title="源码示例"></a>源码示例</h2><pre><code class="js">import React from &#39;react&#39; // JavaScript 的媒体查询 const mqlMedia = window.matchMedia(&#39;(orientation: portrait)&#39;)function onMatchMediaChange(mql = window.matchMedia(&#39;(orientation: portrait)&#39;)) &#123;   if (mql.matches) &#123;     //竖屏     return &#39;portrait&#39;   &#125; else &#123;     //横屏     return &#39;horizontal&#39;   &#125; &#125; // 输出当前屏幕模式 const getUiMode = (uiMode = &#39;&#39;, mql) =&gt; &#123;   if (uiMode) return uiMode   if (!(&#39;onorientationchange&#39; in window)) return &#39;pc&#39;   let status = onMatchMediaChange(mql)   let width = status === &#39;portrait&#39; ? Math.min(window.innerWidth, window.innerHeight) : Math.max(window.innerWidth, window.innerHeight)   if (width &gt; 1040) return &#39;pc&#39;   return &#39;mobile&#39; &#125; const getIsPcMode = (uiMode) =&gt; uiMode === &#39;pc&#39; /**  * UI 模式，判断逻辑  * @export  * @param &#123;*&#125; Cmp  * @returns  */ export function withUiMode(Cmp, options = &#123;&#125;) &#123;   return class WithUIRem extends React.Component &#123;     constructor(props) &#123;       super(props)       let uiMode = getUiMode()       let isPCMode = getIsPcMode(uiMode)       this.state = &#123;         uiMode: uiMode,         isPCMode: isPCMode,       &#125;     &#125;     // 横竖屏切换监听     componentDidMount() &#123;       mqlMedia.addListener(this.changeUiMode)     &#125;     componentWillUnmount() &#123;       mqlMedia.removeListener(this.changeUiMode)     &#125;     changeUiMode = (mql) =&gt; &#123;       let newUiMode = getUiMode(&#39;&#39;, mql)       if (newUiMode !== this.state.uiMode) &#123;         this.setState(&#123;           isPCMode: getIsPcMode(newUiMode),           uiMode: newUiMode         &#125;)       &#125;     &#125;     render() &#123;       return &lt;Cmp &#123;...this.state&#125; &#123;...this.props&#125; /&gt;     &#125;   &#125; &#125; export default (options) =&gt; &#123;   return (Cmp) =&gt;  withUiMode(Cmp, options) &#125;</code></pre><h2 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h2><pre><code class="js">// 装饰器的方式来使用 @withUiMode() export default class Video extends React.Component &#123;   render() &#123;     const &#123; isPCMode, uiMode &#125; = this.props     return (       &lt;Page isPCMode=&#123;isPCMode&#125;&gt;&lt;/Page&gt;     )   &#125; &#125;</code></pre><h2 id="符合设计师需求的细节"><a href="#符合设计师需求的细节" class="headerlink" title="符合设计师需求的细节"></a>符合设计师需求的细节</h2><p>在区分好 PC UI 和 Mobile UI 的判断设定后，我们还要关心的是在一些常见的设备上的显示效果，比如 iPad 横竖屏、大屏显示器。</p><h3 id="Mobile-UI-效果中的优化"><a href="#Mobile-UI-效果中的优化" class="headerlink" title="Mobile UI 效果中的优化"></a>Mobile UI 效果中的优化</h3><p>在 Mobile UI 模式下，iPad Mini 显示效果如下：</p><ul><li>竖屏的为 768px，此时显示的平铺拉伸版效果</li><li>横屏的为 1024px，此时显示的平铺拉伸版效果</li></ul><p>所以 Mobile UI 就有了如下的 CSS 最大宽的设定：</p><pre><code class="css">// Mobile 模式下页面最大宽 $max-body-width = 768px // Mobile 模式下的内容宽度 $max-body-width-center = $max-body-width - 40px</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FjNWVjE6XFHS03VicrNNs5Me6s031m48QNvXf9xm8GJfqZesUd0LACAg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="mobile ui"></p><h3 id="PC-UI-效果中的优化"><a href="#PC-UI-效果中的优化" class="headerlink" title="PC UI 效果中的优化"></a>PC UI 效果中的优化</h3><p>在上面的 PC UI 的判定中，我们是以 1040px 作为判断区间的，那么在这个宽度下，推荐设计师以 960px 为设计宽度，这样两侧就各有 40px 的留白，以此来增加整个页面的呼吸感。</p><p>那么，市面上绝大部分的设备其实是比 1280px 还要大的。此时，可以选择以 1220px 作为更大屏的媒体查询断点。也就是说，我这里运用了响应式设计中的 CSS 媒体查询。</p><p>为何不选用 1400px 呢，因为在 CCtalk 上课的网师、学生所使用的主流设备分辨率宽度还是在 <code>1280px、1366px、1440px</code>这几个区间的。</p><p>所以，有如下 PC UI 的 CSS 最大宽设定：</p><pre><code class="css">// PC 模式下小屏的宽度断点 $page-min-width = 1040px // 小屏模式下的内容宽度 $page-min-width-center = $page-min-width - 80px // PC 模式下大屏的宽度断点 $page-max-width = 1220px // 触屏三合一上的最大宽 // 大屏模式下的内容宽度 $page-max-width-content = $page-max-width - 60px</code></pre><p><img src="https://mmbiz.qpic.cn/mmbiz_png/zewrLkrYfsPdXEmic1Nw35LXFqNUiawH9FPxUXzd4atVRN69Y2ya1ctHvbURjPhaHLiaz5uuBDuCOBTxWSjKN71fg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="pc ui"></p><h2 id="设计规范"><a href="#设计规范" class="headerlink" title="设计规范"></a>设计规范</h2><p>使用融合响应式设计时，需要尽量在设计师进行 UI 设计前就与其商量好设计规范。</p><p>我认为需要注意如下两点：</p><ul><li>1.只修改模块的宽度、边距</li><li>2.保证模块内的所有细节都不调整模块细节内容的 UI，如字体、宽高、间距</li></ul><p>如果 Mobile UI 与 PC UI 的细节差异很大，那无论是响应式设计、自适应设计，还是我认为的融合响应式设计，在网页制作过程中，都是非常难做的，后期维护成本也是非常高的。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>融合响应式设计（ Fusion Web Design，简称 FWD），利用 JavaScript 和 CSS 来进行媒体查询，是响应式设计与自适应设计结合的方案。</p><ul><li>自适应设计：根据设备特点，使用 JavaScript 来区分 PC UI 和 Mobile UI</li><li>响应式设计：在需要调整出更好的 UI 时，可以加入一些 CSS 媒体查询的断点，比如常见的大屏显示效果</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://mp.weixin.qq.com/s?__biz=Mzg5ODA5NTM1Mw==&amp;mid=2247488692&amp;idx=1&amp;sn=5296bb93e4fcec284fe8dfe858634e9b&amp;chksm=c0669522f7111c3</summary>
      
    
    
    
    <category term="HTML5" scheme="https://shinichikudo-fe.github.io/categories/HTML5/"/>
    
    
    <category term="响应式" scheme="https://shinichikudo-fe.github.io/tags/%E5%93%8D%E5%BA%94%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>拥抱Vue3系列之jsx语法</title>
    <link href="https://shinichikudo-fe.github.io/2020/07/07/Vue/%E6%8B%A5%E6%8A%B1Vue3%E7%B3%BB%E5%88%97%E4%B9%8Bjsx%E8%AF%AD%E6%B3%95/"/>
    <id>https://shinichikudo-fe.github.io/2020/07/07/Vue/%E6%8B%A5%E6%8A%B1Vue3%E7%B3%BB%E5%88%97%E4%B9%8Bjsx%E8%AF%AD%E6%B3%95/</id>
    <published>2020-07-07T05:48:26.000Z</published>
    <updated>2020-07-09T13:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5f01d7886fb9a07e6835601a?utm_source=gold_browser_extension#heading-6">原文地址</a></p><p>在过去的一年中，Vue 团队一直都在开发 Vue.js 的下一个主要版本，就在 6 月底，尤大更新同步了 Vue 3 及其周边生态的状态(<a href="https://github.com/vuejs/rfcs/issues/183">Vue 3: mid 2020 status update</a>)。</p><pre><code class="js">if (isTrue(&quot;I am planning to use Vue 3 for a new project&quot;)) &#123;  if (isTrue(&quot;I need IE11 support&quot;)) &#123;    await IE11CompatBuild() // July 2020  &#125;  if (isTrue(&quot;RFCs are too dense, I need an easy-to-read guide&quot;)) &#123;    await migrationGuide() // July 2020  &#125;  if (isTrue(&quot;I&#39;d rather wait until it&#39;s really ready&quot;) &#123;      await finalRelease() // Targeting early August 2020  &#125;)  run(`npm init vite-app hello-vue3`)  return&#125;</code></pre><p>我们可以看到，如果一切顺利的话，预计在 8 月份，Vue 3 的正式版本就可以和我们见面了，目前距离发布正式版还有一定的差距，还要做一些兼容性的工作。同时还会提供对 IE11 的支持。</p><p>Vue 3 为了达到更快、更小、更易于维护、更贴近原生、对开发者更友好的目的，在很多方面进行了重构：</p><blockquote><p>全面拥抱 TypeScript<br>重构 complier<br>重构 Virtual DOM<br>…</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是该系列文章的第一篇，后续会持续更新，覆盖 <code>Vue 3</code>生态常用库。</p><p>JSX 是一个小众群体使用开发方式，第一篇以 JSX 为切入点，目标是让大多数开发 Vue 的同学也对 JSX 有一定的认知，在用 Vue 开发复杂应用时，也能有更加灵活的方式。<br>比如当开始写一个只能通过 <code>level prop</code> 动态生成标题 (heading) 的组件时，你可能很快想到这样实现：</p><pre><code class="js">&lt;script type=&quot;text/x-template&quot; id=&quot;anchored-heading-template&quot;&gt;  &lt;h1 v-if=&quot;level === 1&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h1&gt;  &lt;h2 v-else-if=&quot;level === 2&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h2&gt;  &lt;h3 v-else-if=&quot;level === 3&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h3&gt;&lt;/script&gt;</code></pre><p>这里用模板并不是最好的选择，在每一个级别的标题中重复书写了 <code>&lt;slot&gt;&lt;/slot&gt;</code>，不够优雅。</p><p>如果尝试用 JSX 来写，代码就会变得简单很多。</p><pre><code class="js">const App = &#123;  render() &#123;    const tag = `h$&#123;this.level&#125;`    return &lt;tag&gt;&#123;this.$slots.default&#125;&lt;/tag&gt;  &#125;&#125;</code></pre><p>看过 <a href="https://github.com/vueComponent/ant-design-vue">Ant Design Vue</a> 源码 (下面简称为 <code>antdv</code>) 的同学应该知道， <code>antdv</code> 的底层是基于 JSX 来实现的，也是 Vue 生态中使用 JSX 的深度用户。</p><p>antd 为了尽快的兼容 Vue 3，和 Vue 官方展开合作，于是有了 <a href="https://github.com/vueComponent/jsx">@ant-design-vue/babel-plugin-jsx</a>。</p><h2 id="Vue-JSX-简介"><a href="#Vue-JSX-简介" class="headerlink" title="Vue JSX 简介"></a>Vue JSX 简介</h2><p>对于使用 React 的开发者来说，JSX 再熟悉不过了，但是如果你是一个 Vue 的重度用户，可能对 JSX 不是特别熟悉，甚至听到有同学说没有 template 的 Vue 项目没有灵魂。</p><p>先来看下面一段代码：</p><pre><code class="js">const el = &lt;div&gt;Vue 3&lt;/div&gt;;</code></pre><p>这段代码既不是 HTML 也不是字符串，被称之为 JSX，是 JavaScript 的扩展语法。JSX 可能会使人联想到模板语法，但是它具备 Javascript 的完全编程能力。</p><p>看到这里可能会有疑问，不少同学可能会以为 JSX 是 React 中特有的，其实不然。</p><p>大多数同学都知道，我们平常在 <code>.vue</code> 文件中开发的代码，实际上会被 vue-loader 处理，但可能少数同学去看过我们手把手写出的代码，会变编译成啥样。</p><p>有兴趣的同学可以戳这个地址来看下。<a href="https://vue-template-explorer.netlify.app/">vue-template-explorer</a> (因为众所周知的原因，可能访问略慢)</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;&#123;&#123; msg &#125;&#125;&lt;/div&gt;</code></pre><pre><code class="js">function render() &#123;  with(this) &#123;    return _c(&#39;div&#39;, &#123;      attrs: &#123;        &quot;id&quot;: &quot;app&quot;      &#125;    &#125;, [_v(_s(msg))])  &#125;&#125;</code></pre><p>观察上述代码我们发现，到运行阶段实际上都是 render 函数在执行。Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，就需要使用 render 函数，它比 template 更加灵活。</p><p>写过 render 函数的同学可能深有体会，书写复杂的 render 函数异常痛苦，而且难以维护，非常容易被称之为 “祖传代码”。好在2.0 的官方提供了一个 <a href="https://link.zhihu.com/?target=https://github.com/vuejs/babel-plugin-transform-vue-jsx">Babel 插件</a>，可以将更接近于模板语法的 JSX 转译成 JavaScript。</p><p>使用过 React 的同学对于如何写 JSX 语法一定非常熟悉了，然而，Vue 2 中 的 JSX 写法和 React 还是有一些略微的区别。React 中所有传递的数据都挂在顶层。</p><pre><code class="js">const App = &lt;A className=&quot;x&quot; style=&#123;style&#125; onChange=&#123;onChange&#125; /&gt;</code></pre><p>Vue 2 中，仅仅属性就有三种：<code>组件属性 props，普通 html 属性attrs，DOM 属性 domProps</code>。想要更多了解如何在 Vue 2 中写 JSX 语法，可以看这篇，<a href="https://zhuanlan.zhihu.com/p/37920151">在 Vue 中使用 JSX 的正确姿势</a>。</p><h2 id="Vue-3-中对-JSX-带来的改变"><a href="#Vue-3-中对-JSX-带来的改变" class="headerlink" title="Vue 3 中对 JSX 带来的改变"></a>Vue 3 中对 JSX 带来的改变</h2><h3 id="属性传递"><a href="#属性传递" class="headerlink" title="属性传递"></a>属性传递</h3><p>Vue 3 中，属性这块的传递和 React 类似，意味这不需要再传递 props，attrs 这些属性。</p><pre><code class="js">// before&#123;  class: [&#39;foo&#39;, &#39;bar&#39;],  style: &#123; color: &#39;red&#39; &#125;,  attrs: &#123; id: &#39;foo&#39; &#125;,  domProps: &#123; innerHTML: &#39;&#39; &#125;,  on: &#123; click: foo &#125;,  key: &#39;foo&#39;&#125;// after&#123;  class: [&#39;foo&#39;, &#39;bar&#39;],  style: &#123; color: &#39;red&#39; &#125;,  id: &#39;foo&#39;,  innerHTML: &#39;&#39;,  onClick: foo,  key: &#39;foo&#39;&#125;</code></pre><h3 id="指令改版"><a href="#指令改版" class="headerlink" title="指令改版"></a>指令改版</h3><p>Vue 3 把大多数全局 API 和 内部 helper 移到了 ES 模块中导出(譬如 <code>v-model、transition、teleport</code>)，从而使得 Vue 3 在增加了很多新特性之后，基线的体积反而小了。</p><p><code>v-model、v-show</code> 这些 API 全部通过模块导出的方式来引入</p><blockquote><p>基线体积： 无法舍弃的代码体积</p></blockquote><p>我们来看一段非常简单的代码 <code>&lt;input v-model=&quot;x&quot; /&gt;</code>，在 Vue 2 和 Vue 3 中的编译结果有何不同。</p><pre><code class="js">// Vue 2 beforefunction render() &#123;  with(this) &#123;    return _c(&#39;input&#39;, &#123;      directives: [&#123;        name: &quot;model&quot;,        rawName: &quot;v-model&quot;,        value: (x),        expression: &quot;x&quot;      &#125;],      domProps: &#123;        &quot;value&quot;: (x)      &#125;,      on: &#123;        &quot;input&quot;: function ($event) &#123;          if ($event.target.composing) return;          x = $event.target.value        &#125;      &#125;    &#125;)  &#125;&#125;</code></pre><pre><code class="js">// Vue 3 afterimport &#123; vModelText as _vModelText, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock &#125; from &quot;vue&quot;export function render(_ctx, _cache) &#123;  return _withDirectives((_openBlock(), _createBlock(&quot;input&quot;, &#123;    &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.x = $event)  &#125;, null, 8 /* PROPS */, [&quot;onUpdate:modelValue&quot;])), [    [_vModelText, _ctx.x]  ])&#125;</code></pre><p>可以看到在 Vue 3 中，对各个 API 做了更加细致的拆分，理想状态下，用户可以在构建时利用摇树优化 (<code>tree-shaking</code>) 去掉框架中不需要的特性，只保留自己用到的特性。</p><p>模版编译器会生成适合做 <code>tree-shaking</code> 的代码，不需要使用者去关心如何去做，这部分的改动同样需要在 JSX 写法中实现。</p><p>模板编译器中增加了 <code>PatchFlag</code>，在 JSX 的编译过程同样也做了处理，性能会有提升，但是考虑到 JSX 的灵活性，做了一些兼容处理，该功能还在测试阶段。</p><h2 id="从-Vue-2-到-Vue-3-的过渡"><a href="#从-Vue-2-到-Vue-3-的过渡" class="headerlink" title="从 Vue 2 到 Vue 3 的过渡"></a>从 Vue 2 到 Vue 3 的过渡</h2><p>Vue 3 虽然引入了一部分破坏性的更新，但对于绝大多数 Vue 2 的 API 还是兼容的。那么同样的，我们也要尽可能让使用 JSX 的用户通过最小的成本升级到 Vue 3，这是一个核心的目标。<br>写这篇文章的时候，antdv 已经使用 <a href="https://github.com/vueComponent/ant-design-vue">@ant-design-vue/babel-plugin-jsx</a> 重构了大约 70% 的功能，预计会在 Vue 3 正式版之前发布测试版，大概率会是东半球最快兼容 Vue 3 的企业级组件库。</p><h3 id="Vue-3-JSX-的-API-设计"><a href="#Vue-3-JSX-的-API-设计" class="headerlink" title="Vue 3 JSX 的 API 设计"></a>Vue 3 JSX 的 API 设计</h3><ul><li>函数式组件</li></ul><pre><code class="js">const App = () =&gt; &lt;div&gt;Vue 3 JSX&lt;/div&gt;</code></pre><ul><li>普通组件</li></ul><pre><code class="js">const App = &#123;  render() &#123;    return &lt;div&gt;Vue 3.0&lt;/div&gt;  &#125;&#125;</code></pre><pre><code class="js">const App = defineComponent(() =&gt; &#123;  const count = ref(0);  const inc = () =&gt; &#123;    count.value++;  &#125;;  return () =&gt; (    &lt;div onClick=&#123;inc&#125;&gt;      &#123;count.value&#125;    &lt;/div&gt;  )&#125;)</code></pre><ul><li>Fragment</li></ul><pre><code class="js">const App = () =&gt; (  &lt;&gt;    &lt;span&gt;I&#39;m&lt;/span&gt;    &lt;span&gt;Fragment&lt;/span&gt;  &lt;/&gt;)</code></pre><p>Fragment 参考 React 的写法，尽可能写起来更加方便。</p><ul><li>Attributes/Props</li></ul><pre><code class="js">const App = () =&gt; &lt;input type=&quot;email&quot; /&gt;const placeholderText = &#39;email&#39;const App = () =&gt; (  &lt;input    type=&quot;email&quot;    placeholder=&#123;placeholderText&#125;  /&gt;)</code></pre><ul><li>指令</li></ul><blockquote><p>建议在 JSX 中使用驼峰 (vModel)，但是 v-model 也能用</p></blockquote><p><strong>v-show</strong></p><pre><code class="js">const App = &#123;  data() &#123;    return &#123; visible: true &#125;;  &#125;,  render() &#123;    return &lt;input vShow=&#123;this.visible&#125; /&gt;;  &#125;,&#125;;</code></pre><p><strong>v-model</strong></p><blockquote><p>修饰符：使用 (_) 代替 (.) (vModel_trim={this.test})</p></blockquote><pre><code class="js">export default &#123; data: () =&gt; (&#123;   test: &#39;Hello World&#39;, &#125;), render() &#123;   return (     &lt;&gt;       &lt;input type=&quot;text&quot; vModel_trim=&#123;this.test&#125; /&gt;       &#123;this.test&#125;     &lt;/&gt;   ) &#125;,&#125;</code></pre><p><strong>自定义指令</strong></p><pre><code class="js">const App = &#123;  directives: &#123; antRef &#125;,  setup() &#123;    return () =&gt; (      &lt;a        vAntRef=&#123;(ref) =&gt; &#123; this.ref = ref; &#125;&#125;      /&gt;    );  &#125;,&#125;</code></pre><ul><li>插槽</li></ul><p>关于指令、插槽最终的 API 还在讨论中，有想法的可以去留言。<a href="https://github.com/vuejs/jsx/issues/141">Vue 3 JSX Design</a></p><h3 id="Vue-2-的-JSX-写法如何快速迁移到-Vue-3"><a href="#Vue-2-的-JSX-写法如何快速迁移到-Vue-3" class="headerlink" title="Vue 2 的 JSX 写法如何快速迁移到 Vue 3"></a>Vue 2 的 JSX 写法如何快速迁移到 Vue 3</h3><p>由于 antdv 的底层基本上都是基于 JSX 来写的，想要快速迁移到 Vue 3，就必须有一个比较好的插件来支持，这也是为什么会有这个插件的原因。当然在实现过程中也踩了很多坑。</p><p>目前用法和 Vue 2 的语法大多数是一致的，为了帮助更快迁移，在插件中做了针对旧 VNode 格式的兼容层，这里只能兼容一部分写法，以及部分语法的兼容会增加运行时的性能开销，所以我们希望能够将我们的经验分享给大家，让大家少走弯路！</p><pre><code class="js">&#123;  &quot;plugins&quot;: [&quot;@ant-design-vue/babel-plugin-jsx&quot;, &#123; &quot;transformOn&quot;: true, &quot;compatibleProps&quot;: true &#125;]&#125;</code></pre><ul><li>transformOn</li></ul><p>针对 Vue 2 中 <code>on: &#123; click: xx &#125;</code> 写法的兼容，在运行时中会转为 <code>onClick: xxx</code>。</p><ul><li>compatibleProps</li></ul><p>上文提到 Vue 3 对属性的传递做了变更，<code>props、attrs</code> 这些都不存在了，因此如果设置了这个属性为 true，在运行时也会被解构到第一层的属性中。</p><p>需要注意的一点，目前一旦开启这两个属性，在 <code>createVNode</code> 的第二个参数，都会包一个 <code>compatibleProps</code> 和 <code>transformOn</code> 方法，所以酌情开启这两个参数。对于使用 Vue 2 的 JSX 同学，如果没有使用到比较”不为人知“ 的 API的情况下，都可以快速得迁移。</p><p>那么 antdv 又是如何做迁移的呢？考虑到 antdv 是个组件库，都包一层 <code>compatibleProps</code> 势必不太优雅，因此没有选择开启这个两个开关。这里插一句，目前 antdv 的迁移还在进行中，相关的进度都在这个 issue 里面（<a href="https://github.com/vueComponent/ant-design-vue/issues/1913">Vue 3 支持</a>），有兴趣的同学可以关注下，提一些 PR 过去。</p><p>对于 props 的迁移工作比较简单，只需要把原有分散在 <code>props、on、attrs</code> 中的值直接铺开即可。</p><pre><code class="js"> const vcUploadProps = &#123;-  props: &#123;-    ...this.$props,-   prefixCls,-    beforeUpload: this.reBeforeUpload,-  &#125;,-  on: &#123;-    start: this.onStart,-    error: this.onError,-    progress: this.onProgress,-    success: this.onSuccess,-    reject: this.onReject,- &#125;,+  ...this.$props,+  prefixCls,+  beforeUpload: this.reBeforeUpload,+  onStart: this.onStart,+  onError: this.onError,+  onProgress: this.onProgress,+  onSuccess: this.onSuccess,+  onReject: this.onReject,+  ref: &#39;uploadRef&#39;,+  attrs: this.$attrs,+  ...this.$attrs,&#125;;</code></pre><p>但是关于 <code>inheritAttrs</code> 有个较为底层的变动，需要开发者根据实际情况去修改。<a href="https://cn.vuejs.org/v2/api/index.html#inheritAttrs">什么是inheritAttrs?</a> 在 Vue 2 中，这个选项不影响 class 和 style 绑定，但是在 Vue 3 中会影响到。因此可能在属性的传递上，需要额外对这两个参数做处理。</p><p>在事件的处理上，我们建议在 props 中声明，这样对后续的开发更加易维护，可以很直观地从 props 看出我这个组件到底会传递哪些事件。值得一提的是，在 props 中声明的事件，也可以通过 emit 来触发。例如声明了 onClick 事件，仍然可以使用 emit(‘click’)。</p><p>Vue 3 对 context 的 API 也做了改动，一般如果不是复杂的组件，不会涉及到这个 API。这部分的改动可以看原先 <code>Vue Compositon API</code> 的相关文档，<a href="https://composition-api.vuejs.org/api.html#dependency-injection">Dependency Injection</a>，注意一点，在 setup 中取不到 this。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5f01d7886fb9a07e6835601a?utm_source=gold_browser_extension#heading-6&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在过去的一年中，Vue 团队一直都在开</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>svg科普篇-向强大的svg迈进</title>
    <link href="https://shinichikudo-fe.github.io/2020/07/01/Tools/svg%E7%A7%91%E6%99%AE%E7%AF%87-%E5%90%91%E5%BC%BA%E5%A4%A7%E7%9A%84svg%E8%BF%88%E8%BF%9B/"/>
    <id>https://shinichikudo-fe.github.io/2020/07/01/Tools/svg%E7%A7%91%E6%99%AE%E7%AF%87-%E5%90%91%E5%BC%BA%E5%A4%A7%E7%9A%84svg%E8%BF%88%E8%BF%9B/</id>
    <published>2020-07-01T01:29:27.000Z</published>
    <updated>2020-07-09T13:18:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在掘金上突然看到京东凹凸实验室发布的一篇<a href="https://juejin.im/post/5ef1a698f265da02ce2181d0?utm_source=gold_browser_extension">《向强大的svg迈进》</a>，想到前几个月项目老大非得让我从svg图标换成iconfont字体图标，最后在我耐心给老大讲了svg的未来，对比了iconfont与普通png的区别后，老大妥协了，让我说服其他成员，代码保持一致就行，:( ，没办法，又得给其他同事讲下。所以今天为了科普svg，写来这篇</p><blockquote><p>SVG 即 <code>Scalable Vector Graphics</code> 可缩放矢量图形，使用XML格式定义图形。<br><a href="https://juejin.im/post/5ef1a698f265da02ce2181d0?utm_source=gold_browser_extension">原文地址</a></p></blockquote><h2 id="SVG印象"><a href="#SVG印象" class="headerlink" title="SVG印象"></a>SVG印象</h2><p>SVG 的应用十分广泛，得益于 SVG 强大的各种特性。</p><h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><p>可利用 SVG 矢量的特点，描出深圳地铁的轮廓：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff28ae2bb2f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="metro"></p><h3 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h3><p>SVG 可依据一定的规则，转成 iconfont 使用：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff28e7152486?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="iconfont"></p><h3 id="foreignObject"><a href="#foreignObject" class="headerlink" title="foreignObject"></a>foreignObject</h3><p>利用 SVG 的 <code>foreignObject</code> 标签实现截图功能，原理：<code>foreignObject</code> 内部嵌入 HTML 元素：</p><pre><code class="js">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;foreignObject width=&quot;120&quot; height=&quot;60&quot;&gt;        &lt;p style=&quot;font-size:20px;margin:0;&quot;&gt;凹凸实验室 欢迎您&lt;/p&gt;    &lt;/foreignObject&gt;&lt;/svg&gt;</code></pre><p>截图实现流程：</p><p>1.首先声明一个基础的 svg 模版，这个模版需要一些基础的描述信息，最重要的，它要有 <code>&lt;foreignObject&gt;&lt;/foreignObject&gt;</code> 这对标签；<br>2.将要渲染的 DOM 模版模版嵌入 <code>foreignObject</code> 即可；<br>3.利用 Blob 构建 svg 对象；<br>4.利用 <code>URL.createObjectURL(svg)</code> 取出 URL。</p><h3 id="SVG-SMIL"><a href="#SVG-SMIL" class="headerlink" title="SVG SMIL"></a>SVG SMIL</h3><p>由于微信编辑器不允许嵌入 <code>&lt;style&gt;&lt;script&gt;&lt;a&gt;</code> 标签，利用SVG SMIL 可进行微信公众号极具创意的图文排版设计，包括动画与交互。<br>但是也要注意，标签里不允许有id，否则会被过滤或替换掉。</p><p>点击 “凹凸实验室” 后，围绕 “凹凸实验室” 中心旋转 360度，点击0.5秒后 出现 <a href="https://aotu.io/">aotu.io/</a> ，动画只运行一次。</p><p>下图为 GIF循环演示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2914fb651d?imageslim" alt="demo"></p><p>代码如下：</p><pre><code class="js">&lt;svg width=&quot;360&quot; height=&quot;300&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;g&gt;        &lt;!-- 点击后 运行transform旋转动画，restart=&quot;never&quot;表示只运行一次 --&gt;        &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;rotate&quot; begin=&quot;click&quot; dur=&quot;0.5s&quot; from=&quot;0 100 80&quot; to=&quot;360 100 80&quot;  fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;        &lt;g&gt;            &lt;text font-family=&quot;microsoft yahei&quot; font-size=&quot;20&quot; x=&quot;50&quot; y=&quot;80&quot;&gt;                凹凸实验室            &lt;/text&gt;        &lt;/g&gt;        &lt;g style=&quot;opacity: 0;&quot;&gt;            &lt;!-- 同一个初始位置以及大致的宽高，触发点击事件 --&gt;            &lt;text font-family=&quot;microsoft yahei&quot; font-size=&quot;20&quot; x=&quot;50&quot; y=&quot;80&quot;&gt;https://aotu.io/&lt;/text&gt;            &lt;!-- 点击后 运行transform移动动画，改变文本的位置 --&gt;            &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;translate&quot; begin=&quot;click&quot; dur=&quot;0.1s&quot; to=&quot;0 40&quot;  fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;            &lt;!-- 点击0.5秒后 运行opacity显示动画 --&gt;            &lt;animate attributeName=&quot;opacity&quot; begin=&quot;click+0.5s&quot; from=&quot;0&quot; to=&quot;1&quot; dur=&quot;0.5s&quot; fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;        &lt;/g&gt;    &lt;/g&gt;&lt;/svg&gt;</code></pre><h2 id="SVG-实现非比例缩放"><a href="#SVG-实现非比例缩放" class="headerlink" title="SVG 实现非比例缩放"></a>SVG 实现非比例缩放</h2><p>我们熟知的 <code>iconfont</code>，可通过改变字体大小缩放，但是这是 <strong>比例缩放</strong>，那如何实现 SVG 的<strong>非比例缩放</strong>呢？ 如下图所示，<code>如何将 一只兔子 非比例缩放？</code></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2972d16d14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>划重点：<strong>实现非比例缩放主要涉及三个知识点：<code>viewport、viewBox和preserveAspectRatio</code>，<code>viewport 与viewBox</code> 结合可实现缩放的功能，<code>viewBox 与 preserveAspectRatio</code> 结合可实现非比例的功能</strong>。</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p><code>viewport</code> 表示SVG可见区域的大小。 <code>viewport</code> 就像是我们的显示器屏幕大小，超出区域则隐藏，原点位于左上角，x 轴水平向右，y 轴垂直向下。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff29abb23727?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>通过类似CSS的属性 <code>width、height</code> 指定视图大小：</p><pre><code class="js">&lt;svg width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/svg&gt;</code></pre><h3 id="viewBox"><a href="#viewBox" class="headerlink" title="viewBox"></a>viewBox</h3><p>viewBox值有4个数字：<code>x, y, width, height</code> 。 其中 x：左上角横坐标，y：左上角纵坐标，width：宽度，height：高度。<br>原点默认位于左上角，x 轴水平向右，y 轴垂直向下。</p><pre><code class="js">&lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0 200 100&quot;&gt;&lt;/svg&gt;</code></pre><p>显示器屏幕的画面，可以特写，可以全景，这就是 <code>viewBox</code>。 <code>viewBox</code> 可以想象成截屏工具选中的那个框框，和 <code>viewport</code> 作用的结果就是 把框框中的截屏内容再次在 显示器 中全屏显示。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff29e1dee892?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h3 id="preserveAspectRatio"><a href="#preserveAspectRatio" class="headerlink" title="preserveAspectRatio"></a>preserveAspectRatio</h3><p>上图的红色框框和蓝色框框，恰好和显示器的比例相同，如果是下图的绿色框框，怎样在显示器屏幕中显示呢?</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2a1f0c94f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>preserveAspectRatio</code> 作用的对象是 <code>viewBox</code>，使用方法如下：</p><pre><code class="js">preserveAspectRatio=&quot;[defer] &lt;align&gt; [&lt;meetOrSlice&gt;]&quot;// 例如 preserveAspectRatio=&quot;xMidYMid meet&quot;</code></pre><p>其中 <code>defer</code> 此时不是重点，暂且忽略，主要了解 <code>align</code> 和 <code>meetOrSlice</code> 的 用法：</p><p><code>align</code>：由两个名词组成，分别代表 <code>viewbox 与 viewport 的 x 方向、y方向</code>的对齐方式。</p><blockquote><p><code>meetOrSlice</code>：表示如何维持高宽的比例，有三个值 <code>meet</code>、<code>slice</code>、<code>none</code>。<br><code>meet</code> - 默认值，保持纵横比缩放 viewBox 适应 viewport，可能会有余留的空白。<br><code>slice</code> - 保持纵横比同时比例小的方向放大填满 viewport，超出的部分被剪裁掉。<br><code>none</code> - 扭曲纵横比以充分适应 viewport。</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例子1：<code>preserveAspectRatio=&quot;xMidYMid meet&quot;</code> 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2a71a181c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子2：<code>preserveAspectRatio=&quot;xMidYMin slice&quot;</code> 表示 绿色框框 与 显示器的 x 方向 中心点 对齐，Y 方向 上边缘对齐，保持比例放大填满 显示屏 后超出部分隐藏；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2aa4bade91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子3：preserveAspectRatio=”xMidYMid slice” 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐，保持比例放大填满显示屏 后超出部分隐藏；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2adcb56f90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子4：preserveAspectRatio=”none” 不管三七二十一，随意缩放绿色框框，填满 显示屏即可；这就是非比例缩放的答案了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2b10f609f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h2 id="SVG-vs-Image-SVG-vs-Iconfont"><a href="#SVG-vs-Image-SVG-vs-Iconfont" class="headerlink" title="SVG vs Image, SVG vs Iconfont"></a>SVG vs Image, SVG vs Iconfont</h2><p>SVG vs Image, SVG vs Iconfont 对比文章地址 <a href="https://blog.csdn.net/cpongo3/article/details/90258990?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.nonecase">原文地址</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在掘金上突然看到京东凹凸实验室发布的一篇&lt;a href=&quot;https://juejin.im/post/5ef1a698f265da02</summary>
      
    
    
    
    <category term="Tools" scheme="https://shinichikudo-fe.github.io/categories/Tools/"/>
    
    
    <category term="Svg" scheme="https://shinichikudo-fe.github.io/tags/Svg/"/>
    
  </entry>
  
  <entry>
    <title>实战技巧，Vue原来还可以这样写</title>
    <link href="https://shinichikudo-fe.github.io/2020/06/24/Vue/%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%EF%BC%8CVue%E5%8E%9F%E6%9D%A5%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%86%99/"/>
    <id>https://shinichikudo-fe.github.io/2020/06/24/Vue/%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%EF%BC%8CVue%E5%8E%9F%E6%9D%A5%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%86%99/</id>
    <published>2020-06-24T05:09:18.000Z</published>
    <updated>2020-07-01T15:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eef7799f265da02cd3b82fe?utm_source=gold_browser_extension">原文地址</a></p><h2 id="hookEvent-原来可以这样监听组件生命周期"><a href="#hookEvent-原来可以这样监听组件生命周期" class="headerlink" title="hookEvent,原来可以这样监听组件生命周期"></a>hookEvent,原来可以这样监听组件生命周期</h2><h3 id="1-内部监听生命周期函数"><a href="#1-内部监听生命周期函数" class="headerlink" title="1. 内部监听生命周期函数"></a>1. 内部监听生命周期函数</h3><p>今天产品经理又给我甩过来一个需求，需要开发一个图表，拿到需求，瞄了一眼，然后我就去echarts官网复制示例代码了，复制完改了改差不多了，改完代码长这样</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;echarts&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  mounted() &#123;    this.chart = echarts.init(this.$el)    // 请求数据，赋值数据 等等一系列操作...    // 监听窗口发生变化，resize组件    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)  &#125;,  updated() &#123;    // 干了一堆活  &#125;,  created() &#123;    // 干了一堆活  &#125;,  beforeDestroy() &#123;    // 组件销毁时，销毁监听事件    window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)  &#125;,  methods: &#123;    $_handleResizeChart() &#123;      this.chart.resize()    &#125;,    // 其他一堆方法  &#125;&#125;&lt;/script&gt;</code></pre><p>功能写完开开心心的提测了，测试没啥问题，产品经理表示做的很棒。然而<code>code review</code>时候，技术大佬说了，这样有问题。</p><ul><li>大佬：这样写不是很好，应该将监听<code>resize</code>事件与销毁<code>resize</code>事件放到一起，现在两段代码分开而且相隔几百行代码，可读性比较差</li><li>我：那我把两个生命周期钩子函数位置换一下，放到一起?</li><li>大佬： <code>hook</code>听过没？</li><li>我：<code>Vue3.0</code>才有啊，咋，咱要升级<code>Vue</code>?</li></ul><p>然后技术大佬就不理我了,并向我扔过来一段代码</p><pre><code class="js">export default &#123;  mounted() &#123;    this.chart = echarts.init(this.$el)    // 请求数据，赋值数据 等等一系列操作...        // 监听窗口发生变化，resize组件    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)    // 通过hook监听组件销毁钩子函数，并取消监听事件    this.$once(&#39;hook:beforeDestroy&#39;, () =&gt; &#123;      window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)    &#125;)  &#125;,  updated() &#123;&#125;,  created() &#123;&#125;,  methods: &#123;    $_handleResizeChart() &#123;      // this.chart.resize()    &#125;  &#125;&#125;</code></pre><p>看完代码，恍然大悟，大佬不愧是大佬，原来<code>Vue</code>还可以这样监听生命周期函数。</p><blockquote><p>在Vue组件中，可以用过<code>$on,$once</code>去监听所有的生命周期钩子函数，如监听组件的<code>updated</code>钩子函数可以写成 <code>this.$on(&#39;hook:updated&#39;, () =&gt; &#123;&#125;)</code></p></blockquote><h3 id="2-外部监听生命周期函数"><a href="#2-外部监听生命周期函数" class="headerlink" title="2. 外部监听生命周期函数"></a>2. 外部监听生命周期函数</h3><p>今天同事在公司群里问，想在外部监听组件的生命周期函数，有没有办法啊？</p><p>为什么会有这样的需求呢，原来同事用了一个第三方组件，需要监听第三方组件数据的变化，但是组件又没有提供<code>change</code>事件，同事也没办法了，才想出来要去在外部监听组件的<code>updated</code>钩子函数。查看了一番资料，发现<code>Vue支持在外部监听组件的生命周期钩子函数</code>。</p><pre><code class="html">&lt;template&gt;  &lt;!--通过@hook:updated监听组件的updated生命钩子函数--&gt;  &lt;!--组件的所有生命周期钩子都可以通过@hook:钩子函数名 来监听触发--&gt;  &lt;custom-select @hook:updated=&quot;$_handleSelectUpdated&quot; /&gt;&lt;/template&gt;&lt;script&gt;import CustomSelect from &#39;../components/custom-select&#39;export default &#123;  components: &#123;    CustomSelect  &#125;,  methods: &#123;    $_handleSelectUpdated() &#123;      console.log(&#39;custom-select组件的updated钩子函数被触发&#39;)    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="小项目还用Vuex-用Vue-observable手写一个状态管理吧"><a href="#小项目还用Vuex-用Vue-observable手写一个状态管理吧" class="headerlink" title="小项目还用Vuex?用Vue.observable手写一个状态管理吧"></a>小项目还用Vuex?用Vue.observable手写一个状态管理吧</h2><p>在前端项目中，有许多数据需要在各个组件之间进行传递共享，这时候就需要有一个状态管理工具，一般情况下，我们都会使用<code>Vuex</code>，但对于小型项目来说，就像<code>Vuex</code>官网所说：“如果您不打算开发大型单页应用，使用 <code>Vuex</code> 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 <code>Vuex</code>”。这时候我们就可以使用Vue2.6提供的新API <code>Vue.observable</code>手动打造一个<code>Vuex</code></p><h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><pre><code class="js">import Vue from &#39;vue&#39;// 通过Vue.observable创建一个可响应的对象export const store = Vue.observable(&#123;  userInfo: &#123;&#125;,  roleIds: []&#125;)// 定义 mutations, 修改属性export const mutations = &#123;  setUserInfo(userInfo) &#123;    store.userInfo = userInfo  &#125;,  setRoleIds(roleIds) &#123;    store.roleIds = roleIds  &#125;&#125;</code></pre><h3 id="在组件中引用"><a href="#在组件中引用" class="headerlink" title="在组件中引用"></a>在组件中引用</h3><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &#123;&#123; userInfo.name &#125;&#125;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import &#123; store, mutations &#125; from &#39;../store&#39;export default &#123;  computed: &#123;    userInfo() &#123;      return store.userInfo    &#125;  &#125;,  created() &#123;    mutations.setUserInfo(&#123;      name: &#39;白告&#39;    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><h2 id="开发全局组件，你可能需要了解一下Vue-extend"><a href="#开发全局组件，你可能需要了解一下Vue-extend" class="headerlink" title="开发全局组件，你可能需要了解一下Vue.extend"></a>开发全局组件，你可能需要了解一下Vue.extend</h2><p><code>Vue.extend</code>是一个全局Api,平时我们在开发业务的时候很少会用到它，但有时候我们希望可以开发一些全局组件比如Loading,Notify,Message等组件时，这时候就可以使用<code>Vue.extend</code>。</p><p>同学们在使用<code>element-ui</code>的<code>loading</code>时，在代码中可能会这样写</p><pre><code class="js">// 显示loadingconst loading = this.$loading()// 关闭loadingloading.close()</code></pre><p>这样写可能没什么特别的，但是如果你这样写</p><pre><code class="js">const loading = this.$loading()const loading1 = this.$loading()setTimeout(() =&gt; &#123;  loading.close()&#125;, 1000 * 3)</code></pre><p>这时候你会发现，我调用了两次loading,但是只出现了一个，而且我只关闭了loading，但是loading1也被关闭了。这是怎么实现的呢？我们现在就是用Vue.extend + 单例模式去实现一个loading</p><h3 id="开发loading组件"><a href="#开发loading组件" class="headerlink" title="开发loading组件"></a>开发loading组件</h3><pre><code class="html">&lt;template&gt;  &lt;transition name=&quot;custom-loading-fade&quot;&gt;    &lt;!--loading蒙版--&gt;    &lt;div v-show=&quot;visible&quot; class=&quot;custom-loading-mask&quot;&gt;      &lt;!--loading中间的图标--&gt;      &lt;div class=&quot;custom-loading-spinner&quot;&gt;        &lt;i class=&quot;custom-spinner-icon&quot;&gt;&lt;/i&gt;        &lt;!--loading上面显示的文字--&gt;        &lt;p class=&quot;custom-loading-text&quot;&gt;&#123;&#123; text &#125;&#125;&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;  // 是否显示loading    visible: &#123;      type: Boolean,      default: false    &#125;,    // loading上面的显示文字    text: &#123;      type: String,      default: &#39;&#39;    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="通过Vue-extend将组件转换为全局组件"><a href="#通过Vue-extend将组件转换为全局组件" class="headerlink" title="通过Vue.extend将组件转换为全局组件"></a>通过Vue.extend将组件转换为全局组件</h3><h4 id="改造loading组件，将组件的props改为data"><a href="#改造loading组件，将组件的props改为data" class="headerlink" title="改造loading组件，将组件的props改为data"></a>改造loading组件，将组件的props改为data</h4><pre><code class="js">export default &#123;  data() &#123;    return &#123;      text: &#39;&#39;,      visible: false    &#125;  &#125;&#125;</code></pre><h4 id="通过Vue-extend改造组件"><a href="#通过Vue-extend改造组件" class="headerlink" title="通过Vue.extend改造组件"></a>通过Vue.extend改造组件</h4><pre><code class="js">// loading/index.jsimport Vue from &#39;vue&#39;import LoadingComponent from &#39;./loading.vue&#39;// 通过Vue.extend将组件包装成一个子类const LoadingConstructor = Vue.extend(LoadingComponent)let loading = undefinedLoadingConstructor.prototype.close = function() &#123;  // 如果loading 有引用，则去掉引用  if (loading) &#123;    loading = undefined  &#125;  // 先将组件隐藏  this.visible = false  // 延迟300毫秒，等待loading关闭动画执行完之后销毁组件  setTimeout(() =&gt; &#123;    // 移除挂载的dom元素    if (this.$el &amp;&amp; this.$el.parentNode) &#123;      this.$el.parentNode.removeChild(this.$el)    &#125;    // 调用组件的$destroy方法进行组件销毁    this.$destroy()  &#125;, 300)&#125;const Loading = (options = &#123;&#125;) =&gt; &#123;  // 如果组件已渲染，则返回即可  if (loading) &#123;    return loading  &#125;  // 要挂载的元素  const parent = document.body  // 组件属性  const opts = &#123;    text: &#39;&#39;,    ...options  &#125;  // 通过构造函数初始化组件 相当于 new Vue()  const instance = new LoadingConstructor(&#123;    el: document.createElement(&#39;div&#39;),    data: opts  &#125;)  // 将loading元素挂在到parent上面  parent.appendChild(instance.$el)  // 显示loading  Vue.nextTick(() =&gt; &#123;    instance.visible = true  &#125;)  // 将组件实例赋值给loading  loading = instance  return instance&#125;export default Loading</code></pre><h4 id="在页面使用loading"><a href="#在页面使用loading" class="headerlink" title="在页面使用loading"></a>在页面使用loading</h4><pre><code class="js">import Loading from &#39;./loading/index.js&#39;export default &#123;  created() &#123;    const loading = Loading(&#123; text: &#39;正在加载。。。&#39; &#125;)    // 三秒钟后关闭    setTimeout(() =&gt; &#123;      loading.close()    &#125;, 3000)  &#125;&#125;</code></pre><p>通过上面的改造，<code>loading</code>已经可以在全局使用了，如果需要像<code>element-ui</code>一样挂载到<code>Vue.prototype</code>上面，通过<code>this.$loading</code>调用，还需要改造一下</p><h3 id="将组件挂载到Vue-prototype上面"><a href="#将组件挂载到Vue-prototype上面" class="headerlink" title="将组件挂载到Vue.prototype上面"></a>将组件挂载到Vue.prototype上面</h3><pre><code class="js">Vue.prototype.$loading = Loading// 在export之前将Loading方法进行绑定export default Loading// 在组件内使用this.$loading()</code></pre><h2 id="自定义指令，从底层解决问题"><a href="#自定义指令，从底层解决问题" class="headerlink" title="自定义指令，从底层解决问题"></a>自定义指令，从底层解决问题</h2><p>通过上一节我们开发了一个<code>loading</code>组件，开发完之后，其他开发在使用的时候又提出来了两个需求</p><p>1.可以将<code>loading</code>挂载到某一个元素上面，现在只能是全屏使用<br>2.可以使用指令在指定的元素上面挂载<code>loading</code></p><h3 id="开发v-loading指令"><a href="#开发v-loading指令" class="headerlink" title="开发v-loading指令"></a>开发v-loading指令</h3><pre><code class="js">import Vue from &#39;vue&#39;import LoadingComponent from &#39;./loading&#39;// 使用 Vue.extend构造组件子类const LoadingContructor = Vue.extend(LoadingComponent)// 定义一个名为loading的指令Vue.directive(&#39;loading&#39;, &#123;  /**   * 只调用一次，在指令第一次绑定到元素时调用，可以在这里做一些初始化的设置   * @param &#123;*&#125; el 指令要绑定的元素   * @param &#123;*&#125; binding 指令传入的信息，包括 &#123;name:&#39;指令名称&#39;, value: &#39;指令绑定的值&#39;,arg: &#39;指令参数 v-bind:text 对应 text&#39;&#125;   */  bind(el, binding) &#123;    const instance = new LoadingContructor(&#123;      el: document.createElement(&#39;div&#39;),      data: &#123;&#125;    &#125;)    el.appendChild(instance.$el)    el.instance = instance    Vue.nextTick(() =&gt; &#123;      el.instance.visible = binding.value    &#125;)  &#125;,  /**   * 所在组件的 VNode 更新时调用   * @param &#123;*&#125; el   * @param &#123;*&#125; binding   */  update(el, binding) &#123;    // 通过对比值的变化判断loading是否显示    if (binding.oldValue !== binding.value) &#123;      el.instance.visible = binding.value    &#125;  &#125;,  /**   * 只调用一次，在 指令与元素解绑时调用   * @param &#123;*&#125; el   */  unbind(el) &#123;    const mask = el.instance.$el    if (mask.parentNode) &#123;      mask.parentNode.removeChild(mask)    &#125;    el.instance.$destroy()    el.instance = undefined  &#125;&#125;)</code></pre><h3 id="在元素上面使用指令"><a href="#在元素上面使用指令" class="headerlink" title="在元素上面使用指令"></a>在元素上面使用指令</h3><pre><code class="html">&lt;template&gt;  &lt;div v-loading=&quot;visible&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      visible: false    &#125;  &#125;,  created() &#123;    this.visible = true    fetch().then(() =&gt; &#123;      this.visible = false    &#125;)  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="项目中哪些场景可以自定义指令"><a href="#项目中哪些场景可以自定义指令" class="headerlink" title="项目中哪些场景可以自定义指令"></a>项目中哪些场景可以自定义指令</h3><p>1.为组件添加<code>loading</code>效果<br>2.按钮级别权限控制 <code>v-permission</code><br>3.代码埋点,根据操作类型定义指令<br>4.input输入框自动获取焦点<br>5.其他等等。。。</p><h2 id="深度watch与watch立即触发回调-我可以监听到你的一举一动"><a href="#深度watch与watch立即触发回调-我可以监听到你的一举一动" class="headerlink" title="深度watch与watch立即触发回调,我可以监听到你的一举一动"></a>深度watch与watch立即触发回调,我可以监听到你的一举一动</h2><p>在开发Vue项目时，我们会经常性的使用到watch去监听数据的变化，然后在变化之后做一系列操作。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>比如一个列表页，我们希望用户在搜索框输入搜索关键字的时候，可以自动触发搜索,此时除了监听搜索框的<code>change</code>事件之外，我们也可以通过<code>watch</code>监听搜索关键字的变化</p><pre><code class="html">&lt;template&gt;  &lt;!--此处示例使用了element-ui--&gt;  &lt;div&gt;    &lt;div&gt;      &lt;span&gt;搜索&lt;/span&gt;      &lt;input v-model=&quot;searchValue&quot; /&gt;    &lt;/div&gt;    &lt;!--列表，代码省略--&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  data() &#123;    return &#123;      searchValue: &#39;&#39;    &#125;  &#125;,  watch: &#123;    // 在值发生变化之后，重新加载数据    searchValue(newValue, oldValue) &#123;      // 判断搜索      if (newValue !== oldValue) &#123;        this.$_loadData()      &#125;    &#125;  &#125;,  methods: &#123;    $_loadData() &#123;      // 重新加载数据，此处需要通过函数防抖    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="立即触发"><a href="#立即触发" class="headerlink" title="立即触发"></a>立即触发</h3><p>通过上面的代码，现在已经可以在值发生变化的时候触发加载数据了，但是如果要在页面初始化时候加载数据，我们还需要在<code>created</code>或者<code>mounted</code>生命周期钩子里面再次调用<code>$_loadData</code>方法。不过，现在可以不用这样写了，通过配置<code>watch</code>的立即触发属性，就可以满足需求了</p><pre><code class="js">// 改造watchexport default &#123;  watch: &#123;    // 在值发生变化之后，重新加载数据    searchValue: &#123;    // 通过handler来监听属性变化, 初次调用 newValue为&quot;&quot;空字符串， oldValue为 undefined      handler(newValue, oldValue) &#123;        if (newValue !== oldValue) &#123;          this.$_loadData()        &#125;      &#125;,      // 配置立即执行属性      immediate: true    &#125;  &#125;&#125;</code></pre><h3 id="深度监听（我可以看到你内心的一举一动）"><a href="#深度监听（我可以看到你内心的一举一动）" class="headerlink" title="深度监听（我可以看到你内心的一举一动）"></a>深度监听（我可以看到你内心的一举一动）</h3><p>一个表单页面，需求希望用户在修改表单的任意一项之后，表单页面就需要变更为被修改状态。如果按照上例中watch的写法，那么我们就需要去监听表单每一个属性，太麻烦了，这时候就需要用到<code>watch</code>的深度监听<code>deep</code></p><pre><code class="js">export default &#123;  data() &#123;    return &#123;      formData: &#123;        name: &#39;&#39;,        sex: &#39;&#39;,        age: 0,        deptId: &#39;&#39;      &#125;    &#125;  &#125;,  watch: &#123;    // 在值发生变化之后，重新加载数据    formData: &#123;      // 需要注意，因为对象引用的原因， newValue和oldValue的值一直相等      handler(newValue, oldValue) &#123;        // 在这里标记页面编辑状态      &#125;,      // 通过指定deep属性为true, watch会监听对象里面每一个值的变化      deep: true    &#125;  &#125;&#125;</code></pre><h2 id="函数式组件，函数是组件？"><a href="#函数式组件，函数是组件？" class="headerlink" title="函数式组件，函数是组件？"></a>函数式组件，函数是组件？</h2><p>什么是函数式组件？函数式组件就是函数是组件，感觉在玩文字游戏。使用过React的同学，应该不会对函数式组件感到陌生。函数式组件，我们可以理解为没有内部状态，没有生命周期钩子函数，没有this(不需要实例化的组件)。</p><p>在日常写bug的过程中，经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是只需要将外部传入的数据进行展现，不需要有内部状态，不需要在生命周期钩子函数里面做处理，这时候你就可以考虑使用函数式组件。</p><h3 id="先来一个函数式组件的代码"><a href="#先来一个函数式组件的代码" class="headerlink" title="先来一个函数式组件的代码"></a>先来一个函数式组件的代码</h3><pre><code class="js">export default &#123;  // 通过配置functional属性指定组件为函数式组件  functional: true,  // 组件接收的外部属性  props: &#123;    avatar: &#123;      type: String    &#125;  &#125;,  /**   * 渲染函数   * @param &#123;*&#125; h   * @param &#123;*&#125; context 函数式组件没有this, props, slots等都在context上面挂着   */  render(h, context) &#123;    const &#123; props &#125; = context    if (props.avatar) &#123;      return &lt;img src=&#123;props.avatar&#125;&gt;&lt;/img&gt;    &#125;    return &lt;img src=&quot;default-avatar.png&quot;&gt;&lt;/img&gt;  &#125;&#125;</code></pre><p>在上例中，我们定义了一个头像组件，如果外部传入头像，则显示传入的头像，否则显示默认头像。上面的代码中大家看到有一个<code>render</code>函数，这个是Vue使用<code>JSX</code>的写法，关于<code>JSX</code>,小编将在后续文章中会出详细的使用教程。</p><h3 id="为什么使用函数式组件"><a href="#为什么使用函数式组件" class="headerlink" title="为什么使用函数式组件"></a>为什么使用函数式组件</h3><p>1.最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件<br>2.函数式组件结构比较简单，代码结构更清晰</p><h3 id="函数式组件与普通组件的区别"><a href="#函数式组件与普通组件的区别" class="headerlink" title="函数式组件与普通组件的区别"></a>函数式组件与普通组件的区别</h3><p>1.函数式组件需要在声明组件是指定functional<br>2.函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替<br>3.函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等<br>4.函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件<br>5.因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement<br>6.函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</p><h3 id="我不想用JSX，能用函数式组件吗？"><a href="#我不想用JSX，能用函数式组件吗？" class="headerlink" title="我不想用JSX，能用函数式组件吗？"></a>我不想用JSX，能用函数式组件吗？</h3><p>在<code>Vue2.5</code>之前，使用函数式组件只能通过<code>JSX</code>的方式，在之后，可以通过模板语法来生命函数式组件</p><pre><code class="html">&lt;!--在template 上面添加 functional属性--&gt;&lt;template functional&gt;  &lt;img :src=&quot;props.avatar ? props.avatar : &#39;default-avatar.png&#39;&quot; /&gt;&lt;/template&gt;&lt;!--根据上一节第六条，可以省略声明props--&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eef7799f265da02cd3b82fe?utm_source=gold_browser_extension&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;hookEvent-原来可以这样监听组件生命周期</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES2020的新功能</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/25/Js/ES2020%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/25/Js/ES2020%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/</id>
    <published>2020-05-25T11:00:30.000Z</published>
    <updated>2020-07-01T15:40:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eca8607e51d457890602072?utm_source=gold_browser_extension#heading-15">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近年来，JavaScript 的发展非常迅速。 尤其是在2015 年 ES6 发布之后，情况变得更好。</p><p>现在 许多新的特性被提议包括在 <code>ES2020</code>版本中。好消息是这些已经已经敲定。 现在，我们获得了最终定稿的功能清单，它们将在被批准发布之后出现在备受期待的 <code>ES2020</code> 中。 其中一些功能使我非常兴奋，因为在它们存在之前编写代码时遇到将会遇到很多麻烦。 让我们看看它们是什么吧！</p><h2 id="可选链操作符（Optional-Chaining-Operator）"><a href="#可选链操作符（Optional-Chaining-Operator）" class="headerlink" title="可选链操作符（Optional Chaining Operator）"></a>可选链操作符（Optional Chaining Operator）</h2><p>对我个人来说，这是 ES2020最令人兴奋的特点之一。 我已经编写了很多程序，这些程序将会从这个新特性中获益匪浅。</p><p>可选链操作符<strong>允许您安全地访问对象的深嵌套属性，而不必检查每个属性是否存在</strong>。 让我们看看这个特性对我们有什么帮助。</p><h3 id="拥有可选链操作符之前"><a href="#拥有可选链操作符之前" class="headerlink" title="拥有可选链操作符之前"></a>拥有可选链操作符之前</h3><pre><code class="js">const user = &#123;  firstName: &quot;Joseph&quot;,  lastName: &quot;Kuruvilla&quot;,  age: 38,  address: &#123;    number: &quot;239&quot;,    street: &quot;Ludwig Lane&quot;,    city: &quot;Chennai&quot;,    zip: &quot;600028&quot;,    prop1: &#123;      prop2: &#123;        prop3: &#123;          prop4: &#123;            value: &quot;sample&quot;,          &#125;,        &#125;,      &#125;,    &#125;,  &#125;,&#125;;if (user &amp;&amp; user.address) &#123;  console.log(user.address.zip);  //600028&#125;if (  user &amp;&amp;  user.address &amp;&amp;  user.address.prop1 &amp;&amp;  user.address.prop1.prop2 &amp;&amp;  user.address.prop1.prop2.prop3 &amp;&amp;  user.address.prop1.prop2.prop3.prop4) &#123;  console.log(user.address.prop1.prop2.prop3.prop4.value);  //sample&#125;//Accessing unexisting propertyconsole.log(user.address.prop102.po);//Error</code></pre><p>正如您在上面看到的，您<strong>必须检查每个级别中是否存在该属性，以避免出现无法读取未定义属性“ po”的错误</strong>。 随着嵌套级别的增加，手动检查的属性数量也会增加。 这意味着我们必须检查每个级别，以确保它不会在遇到未定义或空对象时崩溃。</p><h3 id="拥有可选链式操作符之后"><a href="#拥有可选链式操作符之后" class="headerlink" title="拥有可选链式操作符之后"></a>拥有可选链式操作符之后</h3><p>随着<code>可选链式操作符 (Optional Chaining)</code> 的引入，我们前端的工作变得容易多了。 通过简单地使用可选链式操作符  <code>?.</code>  我们可以访问深嵌套的对象，而不必检查未定义或空对象。</p><pre><code class="js">const user = &#123;  firstName: &quot;Joseph&quot;,  lastName: &quot;Kuruvilla&quot;,  age: 38,  address: &#123;    number: &quot;239&quot;,    street: &quot;Ludwig Lane&quot;,    city: &quot;Chennai&quot;,    zip: &quot;600028&quot;,    prop1: &#123;      prop2: &#123;        prop3: &#123;          prop4: &#123;            value: &quot;sample&quot;,          &#125;,        &#125;,      &#125;,    &#125;,  &#125;,&#125;;console.log(user?.address?.zip);// 600028console.log(user?.address?.prop1?.prop2?.prop3?.prop4?.value);// sample//Accessing unexisting propertyconsole.log(user?.address?.prop102?.po);//undefined</code></pre><h2 id="空值合并操作符（Nullish-coalescing-operator）"><a href="#空值合并操作符（Nullish-coalescing-operator）" class="headerlink" title="空值合并操作符（Nullish coalescing operator）"></a>空值合并操作符（Nullish coalescing operator）</h2><p>这是另一个令我兴奋的功能，当我第一次在<strong>proposal stage</strong>， 了解到的时候，我由衷的喜欢这个特性，因为我已经历了编写单独的函数来手动检查这个特性的麻烦。</p><p><code>空值合并操作符</code>允许您检查  <code>nullish</code>  值而不是  <code>falsey</code>  值。 <code>Nullish</code> 值是指  <code>null 或 undefined</code> 的值。 而 falsey 值是诸如<code>空字符串、数字0、  undefined 、  null 、  false 、  NaN</code>  等等的值。 这对你来说可能听起来没什么不同，但是在现实中，这意味着很多。</p><h3 id="在有空值合并操作符之前"><a href="#在有空值合并操作符之前" class="headerlink" title="在有空值合并操作符之前"></a>在有空值合并操作符之前</h3><p>我最近做了一个项目，我需要允许黑暗模式（Dark Mode）切换功能。 我必须检查输入是  <code>true</code> 还是  <code>false</code> 。 如果用户没有设置任何值，则默认为  <code>true</code> 。 下面就是我如何在有<code>空值合并操作符</code>之前实现它的：</p><pre><code class="js">const darkModePreference1 = true;const darkModePreference2 = false;const darkModePreference3 = undefined;const darkModePreference4 = null;const getUserDarkModePreference = (darkModePreference) =&gt; &#123;  if (darkModePreference || darkModePreference === false) &#123;    return darkModePreference;  &#125;  return true;&#125;;getUserDarkModePreference(darkModePreference1);// truegetUserDarkModePreference(darkModePreference2);// falsegetUserDarkModePreference(darkModePreference3);// truegetUserDarkModePreference(darkModePreference4);// true</code></pre><h3 id="在有空值合并操作符之后"><a href="#在有空值合并操作符之后" class="headerlink" title="在有空值合并操作符之后"></a>在有空值合并操作符之后</h3><p>在有空值合并操作符之后，您所要做的就是使用  <code>??</code>  操作符。不需要  <code>if</code>  语句：\</p><pre><code class="js">const darkModePreference1 = true;const darkModePreference2 = false;const darkModePreference3 = undefined;const darkModePreference4 = null;const getUserDarkModePreference = (darkModePreference) =&gt; &#123;  return darkModePreference ?? true;&#125;;getUserDarkModePreference(darkModePreference1);// truegetUserDarkModePreference(darkModePreference2);// falsegetUserDarkModePreference(darkModePreference3);// truegetUserDarkModePreference(darkModePreference4);// true</code></pre><p>这里基本上发生的情况是，如果变量 darkModePreference 包含一个  <code>nullish</code>  值，那么将值 <code>true</code> 赋给它。 简单，简短，易于理解。</p><h2 id="动态-import（Dynamic-Imports）"><a href="#动态-import（Dynamic-Imports）" class="headerlink" title="动态 import（Dynamic Imports）"></a>动态 import（Dynamic Imports）</h2><p>这个特性将帮助您的应用程序更加高效的执行， <code>动态 import</code> 允许您将 JS 文件作为原生应用用程序中的模块动态导入。 在 <code>ES2020</code>之前，不管是否使用模块，都应该导入模块。<br>例如，假设我们需要添加一个功能来下载 pdf 格式的文件。<br>让我们看看如何在 <code>动态 import</code> 之前和之后实现这一点。</p><h3 id="在-动态-import-之前"><a href="#在-动态-import-之前" class="headerlink" title="在 动态 import  之前"></a>在 动态 import  之前</h3><p>实际上，不会所有的页面访问者使用下载 pdf 的选项。 但是，无论我们的访客是否使用它，它仍然需要被导入。 这意味着这个 pdf 模块也可以在页面加载期间被下载。</p><pre><code class="js">import &#123; exportAsPdf &#125; from &quot;./export-as-pdf.js&quot;;const exportPdfButton = document.querySelector(&quot;.exportPdfBtn&quot;);exportPdfButton.addEventListener(&quot;click&quot;, exportAsPdf);</code></pre><p>这种开销可以通过使用<code>延迟加载模块（lazy loaded modules</code>）来减少。 可以通过称为<code>代码分割 （code-splitting）</code>的方法来实现，这在 Webpack 或其他模块打包工具已经可以使用了。<br>但是对于 ES2020，我们可以直接使用它了，而不需要模块打包工具，如 Webpack。</p><h3 id="在动态导入（动态-import）之后"><a href="#在动态导入（动态-import）之后" class="headerlink" title="在动态导入（动态 import）之后"></a>在动态导入（动态 import）之后</h3><pre><code class="js">const exportPdfButton = document.querySelector(&#39;.exportPdfBtn&#39;);exportPdfButton.addEventListener(&#39;click&#39;, () =&gt; &#123;  import(&#39;./export-as-pdf.js&#39;)    .then(module =&gt; &#123;      module.exportAsPdf()    &#125;)    .catch(err =&gt; &#123;      // handle the error if the module fails to load    &#125;)&#125;)</code></pre><p>正如您在上面的代码中看到的，现在只有在需要模块时才延迟加载模块。 从而减少开销和页面加载时间。</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>如果你有一个场景，在所有 <code>Promise</code> 都完成之后必须执行一个任务，那么你可能使用  <code>Promise.all()</code> 方法。 但是这个方法有一个缺点。 当你的任何一个 <code>Promise</code> 被 <code>Rejected</code> 时，<code>Promise</code> 方法就会抛出一个错误。 这意味着您的代码不会等到所有的 <code>Promise</code> 都完成。<br>这可能不是你想要的。 如果你想要这样的东西: “我不在乎他们的结果。 只需全部运行” ，那么你可以使用新的  <code>Promise.allSettled()</code> 方法。 这种方法只有在你的所有 Promise 都  <code>settled</code> ーー 要么  <code>Resolved</code> ，要么  <code>Rejected</code> ーー 时才会  <code>Resolved</code> 。</p><h3 id="在拥有-Promise-allSettled-之前"><a href="#在拥有-Promise-allSettled-之前" class="headerlink" title="在拥有 Promise.allSettled 之前"></a>在拥有 Promise.allSettled 之前</h3><pre><code class="js">const PromiseArray = [  Promise.resolve(100),  Promise.reject(null),  Promise.resolve(&quot;Data release&quot;),  Promise.reject(new Error(&quot;Something went wrong&quot;)),];Promise.all(PromiseArray)  .then((data) =&gt;    console.log(&quot;all resolved! here are the resolve values:&quot;, data)  )  .catch((err) =&gt; console.log(&quot;got rejected! reason:&quot;, err));//got rejected! reason: null</code></pre><p>如上所述，当其中一个 Promise 被  rejected 时， Promise 就会抛出错误。</p><h3 id="在拥有-Promise-allSettled-之后"><a href="#在拥有-Promise-allSettled-之后" class="headerlink" title="在拥有 Promise.allSettled 之后"></a>在拥有 Promise.allSettled 之后</h3><pre><code class="js">const PromiseArray = [  Promise.resolve(100),  Promise.reject(null),  Promise.resolve(&quot;Data release&quot;),  Promise.reject(new Error(&quot;Something went wrong&quot;)),];Promise.allSettled(PromiseArray)  .then((res) =&gt; &#123;    console.log(res);  &#125;)  .catch((err) =&gt; console.log(err));//[//  &#123;status: &quot;fulfilled&quot;, value: 100&#125;,//  &#123;status: &quot;rejected&quot;, reason: null&#125;,//  &#123;status: &quot;fulfilled&quot;, value: &quot;Data release&quot;&#125;,//  &#123;status: &quot;rejected&quot;, reason: Error: Something went wrong ...&#125;//]</code></pre><p>尽管有些 Promise 被 rejected 了，Promise.allSettled 返回了所有的 Promise 的结果</p><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p><code>globalThis</code>  包含对全局对象的引用，与环境无关。 在浏览器中，全局对象是  <code>window 对象</code>。 在 Node 环境中，全局对象是   <code>global</code> 或者 Web workers 中的  <code>self</code>。</p><h3 id="在拥有-globalThis-之前"><a href="#在拥有-globalThis-之前" class="headerlink" title="在拥有 globalThis 之前"></a>在拥有 globalThis 之前</h3><p>我们在工作中会有需要编写一份同时运行在 Node 和浏览器中的通用代码，当我们要取得全局对象时，通常需要做很多工作和逻辑判断：</p><pre><code class="js">beforeGlobalThis = (typeof window !== &quot;undefined&quot;? window: (typeof process === &#39;object&#39; &amp;&amp;   typeof require === &#39;function&#39; &amp;&amp;   typeof global === &#39;object&#39;)    ? global    : this);beforeGlobalThis.tuture = &#39;小若燕雀，亦可一展宏图&#39;;</code></pre><h2 id="在拥有-globalThis-之后"><a href="#在拥有-globalThis-之后" class="headerlink" title="在拥有 globalThis 之后"></a>在拥有 globalThis 之后</h2><p>我们可以直接使用 <code>globalThis</code> 去引用全局对象，而不用去担心环境的问题：</p><pre><code class="js">globalThis.tuture = &#39;小若燕雀，亦可一展宏图&#39;;</code></pre><p>上面的代码在浏览器或者 Node 环境中都是通用的，你可以放心使用！</p><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>允许您使用大于 <code>Javascript</code> 中允许的最大值的数字。 这个数字是 <code> pow(2,53)-1</code> 。 尽管这不能向后兼容，因为传统的数字系统<code>(IEEE 754)</code>不能支持这种大小的数字。</p><h2 id="String-matchall"><a href="#String-matchall" class="headerlink" title="String.matchall"></a>String.matchall</h2><p><code>matchAll()</code> 是一个与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions">正则表达式</a>相关的方法。 此方法返回与正则表达式匹配的字符串的所有结果的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators">迭代器</a>，包括捕获组。 这个方法已经被添加到 String 原型中。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eca8607e51d457890602072?utm_source=gold_browser_extension#heading-15&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>了解下deno，与node的区别是什么？</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/17/Deno/%E4%BA%86%E8%A7%A3%E4%B8%8Bdeno%EF%BC%8C%E4%B8%8Enode%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/17/Deno/%E4%BA%86%E8%A7%A3%E4%B8%8Bdeno%EF%BC%8C%E4%B8%8Enode%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/</id>
    <published>2020-05-17T13:37:07.000Z</published>
    <updated>2020-05-24T12:05:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Deno-VS-Node"><a href="#Deno-VS-Node" class="headerlink" title="Deno VS Node"></a>Deno VS Node</h1><table><thead><tr><th>不同点</th><th align="right">Node</th><th align="center">Deno</th></tr></thead><tbody><tr><td>API 引用方式</td><td align="right">模块导入</td><td align="center">全局对象</td></tr><tr><td>模块系统</td><td align="right">CommonJS &amp; 新版 node 实验性 ES Module</td><td align="center">ES Module 浏览器实现</td></tr><tr><td>安全</td><td align="right">无安全限制</td><td align="center">默认安全</td></tr><tr><td>Typescript</td><td align="right">第三方，如通过 ts-node 支持</td><td align="center">原生支持</td></tr><tr><td>包管理</td><td align="right">npm + node_modules</td><td align="center">原生支持</td></tr><tr><td>异步操作</td><td align="right">回调</td><td align="center">Promise</td></tr><tr><td>包分发</td><td align="right">中心化 npmjs.com</td><td align="center">去中心化 import url</td></tr><tr><td>入口</td><td align="right">package.json 配置</td><td align="center">import url 直接引入</td></tr><tr><td>打包、测试、格式化</td><td align="right">第三方如 eslint、gulp、webpack、babel 等</td><td align="center">原生支持</td></tr></tbody></table><h2 id="1-内置-API-引用方式不同"><a href="#1-内置-API-引用方式不同" class="headerlink" title="1.内置 API 引用方式不同"></a>1.内置 API 引用方式不同</h2><p><strong>node 模块导入</strong></p><p>node 内置 API 通过模块导入的方式引用，例如：</p><pre><code class="js">const fs = require(&quot;fs&quot;);fs.readFileSync(&quot;./data.txt&quot;);</code></pre><p><strong>deno 全局对象</strong></p><p>而 deno 则是一个全局对象 Deno 的属性和方法：</p><pre><code class="js">Deno.readFileSync(&quot;./data.txt&quot;);具体 deno 有哪些方法，我们可以通过 repl 看一下：</code></pre><pre><code class="js">deno # 或 deno repl</code></pre><p>进入 <code>repl</code> 后，输入 Deno 回车，我们可以看到：</p><pre><code class="json">&#123; Buffer: [Function: Buffer], readAll: [AsyncFunction: readAll], readAllSync: [Function: readAllSync], writeAll: [AsyncFunction: writeAll], writeAllSync: [Function: writeAllSync], # .....&#125;</code></pre><p>这种处理的方式好处是<strong>简单、方便</strong>，坏处是<strong>没有分类</strong>，想查找忘记的 API 比较困难。总体来说见仁见智。</p><h2 id="2-模块系统"><a href="#2-模块系统" class="headerlink" title="2.模块系统"></a>2.模块系统</h2><p>我们再来看一下模块系统，这也是 deno 和 node <strong>差别最大的地方</strong>，同样也是 deno 和 node 不兼容的地方。</p><p><strong>node CommonJS 规范</strong><br>我们都知道 node 采用的是 CommonJS 规范，而 deno 则是采用的 ES Module 的浏览器实现，那么我们首先来认识一下：</p><p><strong>ES Module 的浏览器实现</strong><br>具体关于 ES Module 想必大家都早已熟知，但其浏览器实现可能大家还不是很熟悉，所以我们先看一下其浏览器实现：</p><pre><code class="html">&lt;body&gt;  &lt;!-- 注意这里一定要加上 type=&quot;module&quot; --&gt;  &lt;script type=&quot;module&quot;&gt;    // 从 URL 导入    import Vue from &quot;https://unpkg.com/vue@2.6.11/dist/vue.esm.browser.js&quot;;    // 从相对路径导入    import * as utils from &quot;./utils.js&quot;;    // 从绝对路径导入    import &quot;/index.js&quot;;    // 不支持    import foo from &quot;foo.js&quot;;    import bar from &quot;bar/index.js&quot;;    import zoo from &quot;./index&quot;; // 没有 .js 后缀  &lt;/script&gt;&lt;/body&gt;</code></pre><p><strong>deno 的模块规范</strong><br>deno 完全遵循 es module 浏览器实现，所以 deno 也是如此：</p><pre><code class="js">// 支持import * as fs from &quot;https://deno.land/std/fs/mod.ts&quot;;import &#123; deepCopy &#125; from &quot;./deepCopy.js&quot;;import foo from &quot;/foo.ts&quot;;// 不支持import foo from &quot;foo.ts&quot;;import bar from &quot;./bar&quot;; // 必须指定扩展名\</code></pre><p>我们发现其和我们平常在 webpack 或者 ts 使用 es module 最大的不同：</p><ul><li><p>可以通过 import url 直接引用线上资源；</p></li><li><p>资源不可省略扩展名和文件名。</p></li></ul><p>关于第 1 点，争议非常大，有人很看好，觉得极大的扩展了 deno 库的范围；有人则不太看好，觉得国内网速的原因，并不实用。</p><h2 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h2><p>如果模块规范是 node 和 deno 最大的不同，那么对安全的处理，则是另外一个让人摸不着头脑的地方。</p><p><strong>模拟盗号</strong></p><p>在介绍之前我们先思考一下这个场景会不会出现：</p><p>我做了一个基于命令行的一键上网工具 <code>breakwall</code>，每月 1 个 G 免费流量，然后将压缩后的 JS 代码发布到 npm 上，然后后在各种渠道宣传一波。</p><p>羊毛党兴高彩烈的 <code>cnpm install -g breakwall</code>，然后每次使用的时候，我偷偷的将诸位的 ssh 密钥和各种能偷的文档及图片偷偷上传到我的服务器，在设定期限到期后，删除电脑上资料，留下一句拿钱换资料，仅支持比特币。</p><p><strong>默认安全的 deno</strong></p><p>如果你觉得以上情况有可能出现，则会觉得下面的功能很实用。我们先用 deno 执行以下代码：</p><pre><code class="js">// index.jslet rsa = Deno.readFileSync(Deno.dir(&quot;home&quot;) + &quot;/.ssh/id_rsa&quot;);rsa = new TextDecoder().decode(rsa);fetch(&quot;http://jsonplaceholder.typicode.com/posts/1&quot;, &#123;  method: &quot;POST&quot;,  body: JSON.stringify(rsa)&#125;)  .then((res) =&gt; res.json())  .then((res) =&gt; console.log(&quot;密钥发送成功，嘿嘿嘿😜&quot;));console.log(&quot;start breakwall...&quot;);</code></pre><blockquote><p>PS: –unstable 是由于 Deno.dir API 不稳定</p></blockquote><pre><code class="js"> deno run --unstable index.js</code></pre><p>我们将会得到如下报错信息：</p><pre><code class="js">&gt; deno run --unstable  index.jserror: Uncaught PermissionDenied: access to environment variables, run again with the --allow-env flag    ...</code></pre><p>意思就是权限异常，需要访问环境变量，需要加上 <code>--allow-env</code>，我们加上这个参数再试一下。</p><pre><code class="js"> deno run --unstable --allow-env index.jserror: Uncaught PermissionDenied: read access to &quot;/Users/zhangchaojie/.ssh/id_rsa&quot;, run again with the --allow-read flag    ...</code></pre><p>如此反复，还需加上 <code>--allow-read</code>、<code>--allow-net</code> ，最终的结果是：</p><pre><code class="js">&gt; deno run --unstable --allow-env --allow-read --allow-net  index.jsstart breakwall...密钥发送成功，嘿嘿嘿😜</code></pre><p>经过一番折腾，总算是发送成功了，要想盗取密钥实属不易。</p><p><strong>白名单</strong></p><p>那有人就说了，如果我的应用确实需要访问网络和文件，但是有不想让它访问 .ssh 文件有没有办法？</p><p>当然有了，我们可以给 <code>--allow-read</code> 和 <code>--allow-net</code> 指定白名单，名单之外都不可访问，例如：</p><pre><code class="js">&gt; deno run --unstable --allow-env --allow-read --allow-net=https://www.baidu.com  index.jsstart breakwall...error: Uncaught PermissionDenied: network access to &quot;http://jsonplaceholder.typicode.com/posts/1&quot;, run again with the --allow-net flag    at unwrapResponse ($deno$/ops/dispatch_json.ts:43:11)    at Object.sendAsync ($deno$/ops/dispatch_json.ts:98:10)    at async fetch ($deno$/web/fetch.ts:591:27)</code></pre><p><strong>简化参数</strong></p><p>如果确认是没问题，或者是自己开发软件时，图个方便，可以直接使用 -A 或 –allow-all 参数允许所有权限：</p><pre><code class="js">&gt; deno -A --unstable index.jsstart breakwall...密钥发送成功，嘿嘿嘿😜</code></pre><p>安全这方面见仁见智，有人觉得是多余，有人觉得很好用，极大的增强了安全性。如果你属于觉得这个功能多余的，可以 deno run -A xxx 即可。</p><h2 id="4-兼容浏览器-API"><a href="#4-兼容浏览器-API" class="headerlink" title="4.兼容浏览器 API"></a>4.兼容浏览器 API</h2><p>关于为什么，我举个栗子大家就明白了：在设计 node 之处，关于输出函数本来叫 <code>print</code> 之类的，后来有人提议为什么不叫 <code>console.log</code>，ry 觉得挺不错，于是就接纳了意见。</p><p>但是，这个设计并不是刻意为之，而 deno 的设计则可以为之，通过与浏览器 API 保持一致，来减少大家的认知。</p><p><strong>怎么兼容浏览器 API</strong></p><blockquote><p>概念上兼容</p></blockquote><ul><li><p>模块系统，从上面介绍看出 deno 是完全遵循浏览器实现的；</p></li><li><p>默认安全，当然也不是自己创造的概念，w3c 早已做出浏览器权限的规定，我们在做小程序的时候尤为明显，需要获取各种权限；</p></li><li><p>对于异步操作返回 Promise；</p></li><li><p>使用 <code>ArrayBuffer</code> 处理二进制；</p></li></ul><blockquote><p>存在 window 全局变量</p></blockquote><p><code>console.log(window === this, window === self, window === globalThis);</code></p><blockquote><p>实现了 WindowOrWorkerGlobalScope 的全部方法</p></blockquote><p>具体方法列表，我们可以参考：<code>lib.deno.shared_globals.d.ts</code> 和 <code>lib.deno.window.d.ts</code></p><pre><code class="js">// 请求方法fetch(&quot;https://baidu.com&quot;);// base64 转化let encodedData = btoa(&quot;Hello, world&quot;); // 编码let decodedData = atob(encodedData); // 解码// 微任务queueMicrotask(() =&gt; &#123;  console.log(123);&#125;);</code></pre><blockquote><p>大趋势</p></blockquote><p>总体而言，如果服务端和浏览器端存在相同概念，deno 就不会创造新的概念。这一点其实 node 也在做，新的 node 14.0 CHANGELOG 就也提及要实现 Universal JavaScript 和 Spec compliance and Web Compatibility的思想，所以这点大家应该都会接受吧，毕竟大势所趋趋势。</p><h2 id="5-支持-Typescript"><a href="#5-支持-Typescript" class="headerlink" title="5.支持 Typescript"></a>5.支持 Typescript</h2><p>不管你喜欢与否，2020 年了，必须学习 TS 了（起码在面试的时候是亮点）。学完之后你才会明白王境泽定律真的无处不在。</p><pre><code class="js">// index.tslet str: string = &quot;王境泽定律&quot;;str = 132;&gt; deno run index.tserror TS2322: Type &#39;123&#39; is not assignable to type &#39;string&#39;.► file:///Users/zhangchaojie/Desktop/index.ts:2:12 str = 123  ~~~</code></pre><h2 id="6-去-node-modules"><a href="#6-去-node-modules" class="headerlink" title="6.去 node_modules"></a>6.去 node_modules</h2><p>deno 没有 <code>node_modules</code>，那么它是怎么进行包管理的呢？我们先看下面的例子</p><pre><code class="js">// index.jsimport &#123; white, bgRed &#125; from &quot;https://deno.land/std/fmt/colors.ts&quot;;console.log(bgRed(white(&quot;hello world!&quot;)));&gt; deno run index.jsDownload https://deno.land/std/fmt/colors.tsCompile https://deno.land/std/fmt/colors.tshello world!</code></pre><p>我们看到其有 Download 和 Compile 两个步骤，我们会产生几个疑问：</p><blockquote><p>1、每次执行都要下载吗？</p></blockquote><p>解：我们只需要再执行一次就能明白，不需要每次下载。</p><pre><code class="js">&gt; deno run index.jshello world!</code></pre><blockquote><p>2、Download 和 Compile 的文件在哪里呢？</p></blockquote><p>解：我们会发现，当前执行的目录，并没有 Download 和 Compile 文件，那文件放在哪里呢，我们首先来看一下 deno –help 命令：</p><pre><code class="js">&gt; deno --helpSUBCOMMANDS:# ...info           Show info about cache or info related to source file# ...ENVIRONMENT VARIABLES:    DENO_DIR   Set deno&#39;s base directory (defaults to $HOME/.deno)</code></pre><p>deno info 命令展示了依赖关系，类似 package.json。</p><pre><code class="js">&gt; deno info index.jslocal: /Users/zhangchaojie/Desktop/index.jstype: JavaScriptdeps:file:///Users/zhangchaojie/Desktop/index.js  └── https://deno.land/std/fmt/colors.ts</code></pre><p>DENO_DIR 则为实际的安装和编译目录，相当于 node_modules，默认为 $HOME/.deno（命令提示是这样的，但实际需要指定一下环境变量 <code>export DENO_DIR=$HOME/.deno）</code>，我们看一下：</p><pre><code class="js">&gt; tree $HOME/.deno/Users/zhangchaojie/.deno├── deps│   └── https│       └── deno.land│           ├── 3574883d8acbaf00e28990ec8e83d71084c4c668c1dc7794be25208c60cfc935│           └── 3574883d8acbaf00e28990ec8e83d71084c4c668c1dc7794be25208c60cfc935.metadata.json└── gen    └── https        └── deno.land            └── std                └── fmt                    ├── colors.ts.js                    ├── colors.ts.js.map                    └── colors.ts.meta8 directories, 5 files</code></pre><blockquote><p>3、没网络了怎么办？</p></blockquote><p>我们有些场景是将本地写好的代码部署到没有网络的服务器，那么当执行 deno run xxx 时，就是提示 error sending request。</p><p>解：将上面的缓存目录内容，直接拷贝到服务器并指定环境变量到其目录即可。</p><blockquote><p>4、依赖代码更新了怎么办？</p></blockquote><p>解：当依赖模块更新时，我们可以通过 –reload 进行更新缓存，例如：</p><p><code>&gt; deno run --reload index.js</code><br>我们还可以通过白名单的方式，只更新部分依赖。例如：</p><p><code>&gt; deno run --reload=https://deno.land index.js</code></p><blockquote><p>5、仅缓存依赖，不执行代码有办法吗？</p></blockquote><p>解：有的，我们可以通过 deno cache index.js 进行依赖缓存。</p><blockquote><p>6、多版本怎么处理？</p></blockquote><p>解：暂时没有好的解决方案，只能通过 git tag 的方式区分版本。</p><h2 id="7-标准模块-与-node-API-兼容"><a href="#7-标准模块-与-node-API-兼容" class="headerlink" title="7.标准模块 与 node API 兼容"></a>7.标准模块 与 node API 兼容</h2><p>我们通过第 1 点可以看到，其实 deno 的 API 相对于 node 其实是少一些的，通过其文件大小也能看出来：</p><pre><code class="js">&gt; ll /usr/local/bin/node /Users/zhangchaojie/.local/bin/deno-rwxr-xr-x  1   42M   /Users/zhangchaojie/.local/bin/deno-rwxr-xr-x  1   70M   /usr/local/bin/node</code></pre><p>那这些少的 API 只能自己写或者求助于社区吗？</p><p>deno 对于自身相对于 node 少的和社区中常用的功能，提供了标准模块，其特点是不依赖非标准模块的内容，达到社区内的模块引用最后都收敛于标准模块的效果。例如：</p><pre><code class="js">// 类似 node 中 chalk 包import &#123; bgRed, white &#125; from &quot;https://deno.land/std/fmt/colors.ts&quot;;// 类似 node 中的 uuid 包import &#123; v4 &#125; from &quot;https://deno.land/std/uuid/mod.ts&quot;;</code></pre><p>同时为了对 node 用户友好，提供了 node API 的兼容</p><pre><code class="js">import * as path from &quot;https://deno.land/std/node/path.ts&quot;;import * as fs from &quot;https://deno.land/std/node/fs.ts&quot;;console.log(path.resolve(&#39;./&#39;, &#39;./test&#39;))</code></pre><p>所以，大家在为 deno 社区做贡献的时候，首先要看一下标准模块有没有提供类似的功能，如果已经提供了可以进行引用。</p><h2 id="8-异步操作"><a href="#8-异步操作" class="headerlink" title="8.异步操作"></a>8.异步操作</h2><blockquote><p>根据 ry 自己是说法，在设计 node 是有人提议 Promise 处理回调，但是他没听，用他自己的话说就是愚蠢的拒绝了。</p></blockquote><p><strong>node 用回调的方式处理异步操作、deno 则选择用 Promise</strong></p><pre><code class="js">// node 方式const fs = require(&quot;fs&quot;);fs.readFile(&quot;./data.txt&quot;, (err, data) =&gt; &#123;  if (err) throw err;  console.log(data);&#125;);</code></pre><p>另外 deno 支持 top-level-await，所以以上读取文件的代码可以为：</p><pre><code class="js">// deno 方式const data = await Deno.readFile(&quot;./data.txt&quot;);console.log(data);</code></pre><p>node 关于这方面也在一直改进，例如社区上很多 <code>promisify</code> 解决方案，通过包裹一层函数，实现目的。例如：</p><pre><code class="js">// node API promisifyconst &#123; promisify &#125; = require(&quot;es6-promisify&quot;);const fs = require(&quot;fs&quot;);// 没有 top-level-await，只能包一层async function main() &#123;  const readFile = promisify(fs.readFile);  const data = await readFile(&quot;./data.txt&quot;);  console.log(data);&#125;main();</code></pre><h2 id="9-单文件分发"><a href="#9-单文件分发" class="headerlink" title="9.单文件分发"></a>9.单文件分发</h2><p>我们知道 npm 包必须有 <code>package.json</code> 文件，里面不仅需要指明 main 或 module 或 browser 等字段来标明入口文件，还需要指明 <code>name 、license 、description</code> 等字段来说明这个包。</p><p>ry 觉得这些字段扰乱了开发者的视听，所以在 deno 中，其模块不需要任何配置文件，直接是 import url 的形式。</p><h2 id="10-去中心化仓库"><a href="#10-去中心化仓库" class="headerlink" title="10.去中心化仓库"></a>10.去中心化仓库</h2><p>对于 <code>www.npmjs.com</code> 我们肯定都不陌生，它是推动 node 蓬勃发展的重要支点。但作者认为它是中心化仓库，违背了互联网去中心化原则。</p><p>所以 deno 并没有一个像 npmjs.com 的仓库，通过 import url 的方式将互联网任何一处的代码都可以引用。</p><p>PS：deno 其实是有个基于 <code>GitHub</code> 的第三方模块集合。</p><h2 id="11-去开发依赖"><a href="#11-去开发依赖" class="headerlink" title="11.去开发依赖"></a>11.去开发依赖</h2><p>我们在写一个 node 库或者工具时，开发依赖是少不了的，例如 babel 做转化和打包、jest 做测试、prettier 做代码格式化、eslint 做代码格式校检、gulp 或者 webpack 做构建等等，让我们在开发前就搞得筋疲力尽。</p><blockquote><p>deno 通过内置了一些工具，解决上述问题。</p></blockquote><ul><li><p><code>deno bundle</code>：打包命令，用来替换 babel、gulp 一类工具: 例如：deno bundle ./mod.ts；</p></li><li><p><code>deno fmt</code>：格式化命令，用来替换 prettier 一类工具，例如：deno fmt ./mod.ts；</p></li><li><p><code>deno test</code>：运行测试代码，用来替换 jest 一类工具，例如 deno test ./test.ts；</p></li><li><p><code>deno lint</code>：代码校检（暂未实现），用来替换 eslint 一类工具，例如：deno lint ./mod.ts。</p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>就像小时候一直幻想的炸弹始终没能炸了学校，技（轮）术（子）的进（制）步（造）一直也未停止过。不论我们学的动或者学不动，技术就在那里，不以人的意志为转移。</p><p>至于 deno 能不能火，我个人觉得起码一两年内不会有太大反响，之后和 node 的关系有可能像 Vue 和 react，有人喜欢用 deno，觉得比 node 好一万倍，有人则喜欢 node ，觉得 node 还能再战 500 年。至于最终学不学还看自己。</p><p><a href="https://juejin.im/post/5ebcabb2e51d454da74185a9">20 分钟入门 deno</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Deno-VS-Node&quot;&gt;&lt;a href=&quot;#Deno-VS-Node&quot; class=&quot;headerlink&quot; title=&quot;Deno VS Node&quot;&gt;&lt;/a&gt;Deno VS Node&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;不同点&lt;/th&gt;</summary>
      
    
    
    
    <category term="Deno" scheme="https://shinichikudo-fe.github.io/categories/Deno/"/>
    
    
    <category term="Deno" scheme="https://shinichikudo-fe.github.io/tags/Deno/"/>
    
  </entry>
  
  <entry>
    <title>javascript设计模式Es6代码实现</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/12/Js/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FEs6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/12/Js/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FEs6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-12T05:20:35.000Z</published>
    <updated>2020-05-17T13:26:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e021eb96fb9a01628014095">原文地址</a></p><h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p><code>设计模式</code>代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。<code>设计模式</code>是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p><code>设计模式</code>是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用<code>设计模式</code>是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，<code>设计模式</code>于己于他人于系统都是多赢的，<code>设计模式</code>使代码编制真正工程化，<code>设计模式</code>是软件工程的基石，如同大厦的一块块砖石一样。</p><h2 id="设计模式规则（SOLID）"><a href="#设计模式规则（SOLID）" class="headerlink" title="设计模式规则（SOLID）"></a>设计模式规则（SOLID）</h2><p><strong>S – Single Responsibility Principle 单一职责原则</strong></p><ul><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ul><p><strong>O – OpenClosed Principle 开放/封闭原则</strong></p><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li></ul><p><strong>L – Liskov Substitution Principle 里氏替换原则</strong></p><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li></ul><p><strong>I – Interface Segregation Principle 接口隔离原则</strong></p><ul><li>保持接口的单一独立</li><li>类似单一职责原则，这里更关注接口</li></ul><p><strong>D – Dependency Inversion Principle 依赖倒转原则</strong></p><ul><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现</li></ul><p>再举个栗子：<a href="https://juejin.im/post/5adc8e18518825672b0352a8#comment">此例来源-守候-改善代码的各方面问题</a></p><pre><code class="js">//checkType(&#39;165226226326&#39;,&#39;mobile&#39;)//result：falselet checkType=function(str, type) &#123;    switch (type) &#123;        case &#39;email&#39;:            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str)        case &#39;mobile&#39;:            return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str);        case &#39;tel&#39;:            return /^(0\d&#123;2,3&#125;-\d&#123;7,8&#125;)(-\d&#123;1,4&#125;)?$/.test(str);        default:            return true;    &#125;&#125;</code></pre><p>有以下两个问题：</p><ol><li>如果想添加其他规则就得在函数里面增加 case 。添加一个规则就修改一次！这样违反了开放-封闭原则（对扩展开放，对修改关闭）。而且这样也会导致整个 API 变得臃肿，难维护。</li><li>比如A页面需要添加一个金额的校验，B页面需要一个日期的校验，但是金额的校验只在A页面需要，日期的校验只在B页面需要。如果一直添加 case 。就是导致A页面把只在B页面需要的校验规则也添加进去，造成不必要的开销。B页面也同理。</li></ol><p>建议的方式是给这个 API 增加一个扩展的接口:</p><pre><code class="js">let checkType=(function()&#123;    let rules=&#123;        email(str)&#123;            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);        &#125;,        mobile(str)&#123;            return /^1[3|4|5|7|8][0-9]&#123;9&#125;$/.test(str);        &#125;    &#125;;    //暴露接口    return &#123;        //校验        check(type,str)&#123;            return rules[type]?rules[type](str):false;        &#125;,        //添加规则        addRule(type,fn)&#123;            rules[type]=fn;        &#125;    &#125;&#125;)();//调用方式//使用mobile校验规则console.log(checkType.check(&#39;mobile&#39;,&#39;188170239&#39;));//添加金额校验规则checkType.addRule(&#39;money&#39;,function (str) &#123;    return /^[0-9]+(.[0-9]&#123;2&#125;)?$/.test(str)&#125;);//使用金额校验规则console.log(checkType.check(&#39;18.36&#39;,&#39;money&#39;));</code></pre><p>此例更详细内容请查看-&gt; <a href="https://juejin.im/post/5adc8e18518825672b0352a8#comment">守候i-重构-改善代码的各方面问题</a></p><h1 id="设计模式分类（23种）"><a href="#设计模式分类（23种）" class="headerlink" title="设计模式分类（23种）"></a>设计模式分类（23种）</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote><p>创建型</p></blockquote><ul><li>单例模式</li><li>原型模式</li><li>工厂模式</li><li>抽象工厂模式</li><li>建造者模式</li></ul><blockquote><p>结构型</p></blockquote><ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul><blockquote><p>行为型</p></blockquote><ul><li>观察者模式</li><li>迭代器模式</li><li>策略模式</li><li>模板方法模式</li><li>职责链接模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>工厂模式定义到一个用于创建对象的接口，这个接口由子类决定实例化哪一类。该模式使一个类的实例化延迟到了子类,而子类可以重写接口方法以便创建的时候指定自己的对象类型</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="js">class Product&#123;  constructor(name)&#123;    this.name = name  &#125;  init()&#123;    console.log(&#39;init&#39;,this.name)  &#125;&#125;class Factory &#123;  create(name)&#123;    return new Product(name)  &#125;&#125;let factory = new Factory()let p = factory.create(&#39;hello world&#39;)p.init()</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li><li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li><li>构造函数和创建者分离, 符合“开闭原则”</li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul><h3 id="什么时候不用"><a href="#什么时候不用" class="headerlink" title="什么时候不用"></a>什么时候不用</h3><p>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。</p><p>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>曾经我们熟悉的JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象</li></ul><pre><code class="js">class jQuery &#123;    constructor(selector) &#123;        super(selector)    &#125;    add() &#123;            &#125;  // 此处省略若干API&#125;window.$ = function(selector) &#123;    return new jQuery(selector)&#125;</code></pre><ul><li>vue 的异步组件<br>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</li></ul><pre><code class="js">Vue.component(&#39;async-component&#39;,function(resolve,reject)&#123;  setTimeout(funciton()&#123;    resolve(&#123;      templete: &#39;&lt;div&gt;I am async&lt;/div&gt;&#39;    &#125;)  &#125;,1000)&#125;)</code></pre><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一个类只有一个实例，比提供一个访问它的全局访问点</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><pre><code class="js"> class LoginForm &#123;    constructor() &#123;        this.state = &#39;hide&#39;    &#125;    show() &#123;        if (this.state === &#39;show&#39;) &#123;            alert(&#39;已经显示&#39;)            return        &#125;        this.state = &#39;show&#39;        console.log(&#39;登录框显示成功&#39;)    &#125;    hide() &#123;        if (this.state === &#39;hide&#39;) &#123;            alert(&#39;已经隐藏&#39;)            return        &#125;        this.state = &#39;hide&#39;        console.log(&#39;登录框隐藏成功&#39;)    &#125; &#125; LoginForm.getInstance = (function () &#123;     let instance     return function () &#123;        if (!instance) &#123;            instance = new LoginForm()        &#125;        return instance     &#125; &#125;)()let obj1 = LoginForm.getInstance()obj1.show()let obj2 = LoginForm.getInstance()obj2.hide()console.log(obj1 === obj2)</code></pre><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。</li><li>无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li></ul><h3 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h3><p>定义命名空间和实现分支型方法<br>登录框<br>vuex 和 redux中的store</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将一个类接口转化为另一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><pre><code class="js">class Plug &#123;  getName() &#123;    return &#39;iphone充电头&#39;;  &#125;&#125;class Target &#123;  constructor() &#123;    this.plug = new Plug();  &#125;  getName() &#123;    return this.plug.getName() + &#39; 适配器Type-c充电头&#39;;  &#125;&#125;let target = new Target();target.getName(); // iphone充电头 适配器转Type-c充电头</code></pre><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>可以让两个没有关系的类连接起来一起运行</li><li>提高了类的复用</li><li>适配对象，适配库，适配数据</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>整合第三方SDK</li><li>封装旧接口</li></ul><pre><code class="js">// 自己封装的ajax， 使用方式如下ajax(&#123;    url: &#39;/getData&#39;,    type: &#39;Post&#39;,    dataType: &#39;json&#39;,    data: &#123;        test: 111    &#125;&#125;).done(function() &#123;&#125;)// 因为历史原因，代码中全都是：// $.ajax(&#123;....&#125;)// 做一层适配器var $ = &#123;    ajax: function (options) &#123;        return ajax(options)    &#125;&#125;</code></pre><ul><li>vue的computed</li></ul><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;example&quot;&gt;        &lt;p&gt;Original message: &quot;&#123;&#123; message &#125;&#125;&quot;&lt;/p&gt;  &lt;!-- Hello --&gt;        &lt;p&gt;Computed reversed message: &quot;&#123;&#123; reversedMessage &#125;&#125;&quot;&lt;/p&gt;  &lt;!-- olleH --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script type=&#39;text/javascript&#39;&gt;    export default &#123;        name: &#39;demo&#39;,        data() &#123;            return &#123;                message: &#39;Hello&#39;            &#125;        &#125;,        computed: &#123;            reversedMessage: function() &#123;                return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)            &#125;        &#125;    &#125;&lt;/script&gt;</code></pre><p><strong>原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式</strong></p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>适配器模式与代理模式很相似</p><ul><li>适配器模式：提供一个不同的接口（如不同版本的插头）</li><li>代理模式：提供一个一模一样的接口</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案<br>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><pre><code class="js">class Cellphone &#123;    create() &#123;        console.log(&#39;生成一个手机&#39;)    &#125;&#125;class Decorator &#123;    constructor(cellphone) &#123;        this.cellphone = cellphone    &#125;    create() &#123;        this.cellphone.create()        this.createShell(cellphone)    &#125;    createShell() &#123;        console.log(&#39;生成手机壳&#39;)    &#125;&#125;// 测试代码let cellphone = new Cellphone()cellphone.create()console.log(&#39;------------&#39;)let dec = new Decorator(cellphone)dec.create()</code></pre><h3 id="场景例子-1"><a href="#场景例子-1" class="headerlink" title="场景例子"></a>场景例子</h3><ul><li>比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3 种配件。如果使用继承的方式来给每种自行车创建子类，则需要 4×3 = 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3个类</li><li>ES6 <a href="http://es6.ruanyifeng.com/#docs/decorator">Decorator</a> 阮一峰</li><li>core-decorators</li></ul><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><blockquote><p>假设当A 在心情好的时候收到花，小明表白成功的几率有60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。<br>小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。<br>但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选择A 心情好的时候把花转交给A，代码如下：</p></blockquote><pre><code class="js">let Flower = function()&#123;&#125;let xiaoming = &#123;  sendFlower: function(target)&#123;    let flower = new Flower()    target.receviceFlower()  &#125;&#125;let B = &#123;  receviceFlower:function(flower)&#123;    A.listenGoodMood(function()&#123;      A.receviceFlower(flower)    &#125;)  &#125;&#125;let A = &#123;  receviceFlower:function(flower)&#123;    console.log(&#39;收到花&#39;+ flower)  &#125;  listenGoodMood:function(fn)&#123;    setTimeout(function()&#123;      fn()    &#125;,1000)  &#125;&#125;xiaoming.sendFlower(B)</code></pre><h3 id="场景例子-2"><a href="#场景例子-2" class="headerlink" title="场景例子"></a>场景例子</h3><ul><li>HTML元 素事件代理</li></ul><pre><code class="html">&lt;ul id=&quot;ul&quot;&gt;  &lt;li&gt;1&lt;/li&gt;  &lt;li&gt;2&lt;/li&gt;  &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  let ul = document.querySelector(&#39;#ul&#39;);  ul.addEventListener(&#39;click&#39;, event =&gt; &#123;    console.log(event.target);  &#125;);&lt;/script&gt;</code></pre><ul><li>ES6 的 proxy 阮一峰Proxy</li><li>jQuery.proxy()方法</li></ul><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul><h3 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h3><blockquote><p>装饰者模式实现上和代理模式类似<br>装饰者模式： 扩展功能，原有功能不变且可直接使用<br>代理模式： 显示原有功能，但是经过限制之后的</p></blockquote><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><ol><li>兼容浏览器事件绑定</li></ol><pre><code class="js">let addMyEvent = function (el, ev, fn) &#123;    if (el.addEventListener) &#123;        el.addEventListener(ev, fn, false)    &#125; else if (el.attachEvent) &#123;        el.attachEvent(&#39;on&#39; + ev, fn)    &#125; else &#123;        el[&#39;on&#39; + ev] = fn    &#125;&#125;; </code></pre><ol start="2"><li>封装接口</li></ol><pre><code class="js">let myEvent = &#123;    // ...    stop: e =&gt; &#123;        e.stopPropagation();        e.preventDefault();    &#125;&#125;;</code></pre><p>斜挎单肩包，透气跑鞋，运动袜，T恤，运动短裤</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade</li><li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。</li><li>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。</li></ul><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul><li>减少系统的相互依赖</li><li>提高了灵活性</li><li>提高了安全性</li></ul><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p><ul><li>发布 &amp; 订阅</li><li>一对多</li></ul><h3 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h3><pre><code class="js">// 主题 保存状态，状态变化之后触发所有观察者对象class Subject &#123;  constructor() &#123;    this.state = 0    this.observers = []  &#125;  getState() &#123;    return this.state  &#125;  setState(state) &#123;    this.state = state    this.notifyAllObservers()  &#125;  notifyAllObservers() &#123;    this.observers.forEach(observer =&gt; &#123;      observer.update()    &#125;)  &#125;  attach(observer) &#123;    this.observers.push(observer)  &#125;&#125;// 观察者class Observer &#123;  constructor(name, subject) &#123;    this.name = name    this.subject = subject    this.subject.attach(this)  &#125;  update() &#123;    console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`)  &#125;&#125;// 测试let s = new Subject()let o1 = new Observer(&#39;o1&#39;, s)let o2 = new Observer(&#39;02&#39;, s)s.setState(12)</code></pre><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul><li>DOM事件</li></ul><pre><code class="js">document.body.addEventListener(&#39;click&#39;, function() &#123;    console.log(&#39;hello world!&#39;);&#125;);document.body.click()</code></pre><ul><li>Vue响应式</li></ul><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p><h3 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h3><pre><code class="js">class State &#123;  constructor(state)&#123;    this.state = state  &#125;  handle(context)&#123;    console.log(`this is $&#123;context&#125; light`)  &#125;&#125;class Context&#123;  constructor()&#123;    this.state = null  &#125;  getState()&#123;    return this.state  &#125;  setState(state)&#123;    this.state = state  &#125;&#125;let context = new Context()let weak = new State(&#39;Weak&#39;)let strong = new State(&#39;Strong&#39;)let off = new State(&#39;off&#39;)// 弱光weak.handle(context)console.log(context.getState())// 强光strong.handle(context)console.log(context.getState())// 关闭off.handle(context)console.log(context.getState())</code></pre><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li><li>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</li></ul><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul><li>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便</li><li>状态与状态间，行为与行为间彼此独立互不干扰</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li></ul><h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会在系统中定义许多状态类</li><li>逻辑分散</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e021eb96fb9a01628014095&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介</summary>
      
    
    
    
    <category term="Js" scheme="https://shinichikudo-fe.github.io/categories/Js/"/>
    
    
    <category term="ES6" scheme="https://shinichikudo-fe.github.io/tags/ES6/"/>
    
    <category term="设计模式" scheme="https://shinichikudo-fe.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发实践(下)</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/10/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%8B/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/10/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%8B/</id>
    <published>2020-05-10T09:30:23.000Z</published>
    <updated>2020-05-10T15:06:54.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e1eb1dff265da3e354ea2d0">原文地址</a>   </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面两篇文章总结了 Vue 开发的大部分技巧和内容，最后一篇文章来对它进行一个收尾<br>这篇文章我们来谈谈一些 Vue 理解和实践要求高一点的问题</p><p>首先是生命周期这一块内容，随着实践越多它的意义越大，理解也越深刻</p><p>mixin 功能强大，对代码复用组织都有很高的要求，算是 Vue 后期发力的高级技巧</p><p>服务端渲染可能是学习 Vue 最后一块阵地了，对于 SPA 框架的一个里程碑</p><p>最后，总结一下我在使用 Vue 中使用的技巧和经验</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c19f1dd22b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="概览"></p><h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><h2 id="什么是-Vue-生命周期？"><a href="#什么是-Vue-生命周期？" class="headerlink" title="什么是 Vue 生命周期？"></a>什么是 Vue 生命周期？</h2><p>Vue 生命周期大概就是：一个从 Vue 实例的创建到组件销毁的一个的过程。</p><p>具体情况下，我们分为几个核心的阶段，并且每个阶段都有一套钩子函数来执行我们需要的代码。</p><h3 id="生命周期阶段与钩子"><a href="#生命周期阶段与钩子" class="headerlink" title="生命周期阶段与钩子"></a>生命周期阶段与钩子</h3><p>我们整理分类一下这些生命周期钩子，为了记忆方便分为 4 大核心阶段：</p><p>方便读者记忆，这里尽量使用图示：<br><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c27264b6562?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图示"></p><p>可以看到每一个阶段中的钩子命名都很好记忆，阶段开始前使用 <code>beforeXxx</code>，阶段后结束后使用<code>xxxed</code></p><p>除这 8 个核心钩子，另外还有 3 个新增功能型钩子，目前总共是 11 个钩子 顺带提一下这 3 个钩子的功能</p><ol><li>组件缓存，<code>activated</code> 与 <code>deactivated</code>，这两个钩子也是一对的，分别表示被 keep-alive 缓存的组件激活和停用时调用。</li><li>组件错误捕获，<code>errorCaptured</code>，对组件中出现对异常错误进行处理，使用较少。</li></ol><h3 id="Vue-源码基本流程"><a href="#Vue-源码基本流程" class="headerlink" title="Vue 源码基本流程"></a>Vue 源码基本流程</h3><p>对于上面那张图的理解，我们需要对 Vue 源码进行梳理，才能真正的理解。大概根据现有的源码，我梳理了一下大致的流程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c2cc22b99c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="源码"></p><p>我们可以清楚的看到，从 Vue 实例创建、组件挂载、渲染的一些过程中，有着明显的周期节点。</p><h3 id="简化文字图解"><a href="#简化文字图解" class="headerlink" title="简化文字图解"></a>简化文字图解</h3><p>对于上面那张图的理解，我们需要对 Vue 源码进行梳理，才能真正的理解。大概根据现有的源码，我梳理了一下大致的流程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c2cc22b99c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图解"></p><h2 id="实践验证一下生命周期"><a href="#实践验证一下生命周期" class="headerlink" title="实践验证一下生命周期"></a>实践验证一下生命周期</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>下面我们提出一些问题：</p><ol><li>什么时期创建 el ？</li><li>什么时期挂载 data ？</li><li>什么时期可以访问 dom ？</li><li>什么情况下组件会更新？更新是同步更新还是异步更新？</li><li>什么情况下组件会被销毁？</li><li>销毁组件后，还可以访问哪些内容？</li></ol><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ol><li>首先写一个小 demo，打印关键组件信息</li></ol><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;message&quot;&gt;      &#123;&#123;message&#125;&#125;    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123;      data() &#123;            return &#123;                  message: &#39;1&#39;            &#125;    &#125;,      methods: &#123;            printComponentInfo(lifeName) &#123;                  console.log(lifeName)                  console.log(&#39;el&#39;, this.$el)                  console.log(&#39;data&#39;, this.$data)                  console.log(&#39;watch&#39;, this.$watch)            &#125;      &#125;&#125;&lt;/script&gt;</code></pre><ol start="2"><li>增加核心的 8 个生命周期钩子，分别调用打印方法</li></ol><pre><code class="js">  // ...    beforeCreate() &#123;    this.printComponentInfo(&#39;beforeCreate&#39;)  &#125;,    created() &#123;    this.printComponentInfo(&#39;created&#39;)  &#125;,    beforeMount() &#123;    this.printComponentInfo(&#39;beforeMount&#39;)  &#125;,    mounted() &#123;    this.printComponentInfo(&#39;mounted&#39;)  &#125;,    beforeUpdate() &#123;    this.printComponentInfo(&#39;beforeUpdate&#39;)  &#125;,    updated() &#123;    this.printComponentInfo(&#39;updated&#39;)  &#125;,    beforeDestroy() &#123;    this.printComponentInfo(&#39;beforeDestroy&#39;)  &#125;,    destroyed() &#123;    this.printComponentInfo(&#39;destroyed&#39;)  &#125;,    // ...</code></pre><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c25e769e9f94e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="创建"></p><p>beforeCreate 中methods中方法直接报错无法访问，直接访问 el 和 data 后</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c26347c3622f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="创建"></p><p>发现只能访问到 watch， el 和 data 均不能访问到</p><p>created 时期 el 无法访问到，但是可以访问到 data 了</p><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c2679f7e956d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="挂载"></p><p><code>beforeMount</code> 中可以访问 data 但是仍然访问不到 el</p><p><code>mounted</code> 中可以访问到 el 了</p><blockquote><p>首次加载页面，更新阶段和销毁阶段到钩子都未触发</p></blockquote><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><pre><code class="js">this.message = this.message + 1</code></pre><p>如果增加在 created 阶段，发现 update钩子仍然未触发，但是 el 和 data 的值都变成了 2</p><p>如果增加在 mounted 阶段，发现 update钩子此时触发了</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c2727250a6c8c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="更新"></p><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p>怎样触发销毁的钩子呢？ 大概有这几种方法</p><ul><li>手动调用 $destory</li><li>v-if 与 v-for 指令，（v-show 不行）</li><li>路由切换和关闭或刷新浏览器</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c2ef6a6785ddc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="路由切换"></p><h2 id="生命周期钩子常见使用的场景"><a href="#生命周期钩子常见使用的场景" class="headerlink" title="生命周期钩子常见使用的场景"></a>生命周期钩子常见使用的场景</h2><h3 id="beforeCreate-谨慎操作-this"><a href="#beforeCreate-谨慎操作-this" class="headerlink" title="beforeCreate 谨慎操作 this"></a>beforeCreate 谨慎操作 this</h3><p><code>beforeCreate</code> 无法访问到 this 中的 <code>data、method</code></p><h3 id="请求应放在-created-钩子中"><a href="#请求应放在-created-钩子中" class="headerlink" title="请求应放在 created 钩子中"></a>请求应放在 created 钩子中</h3><p>created 可以访问 this，但无法访问 dom，dom 未挂载</p><h3 id="操作-DOM-代码应放在-mounted-钩子中"><a href="#操作-DOM-代码应放在-mounted-钩子中" class="headerlink" title="操作 DOM 代码应放在 mounted 钩子中"></a>操作 DOM 代码应放在 mounted 钩子中</h3><p>mounted 已经挂载 dom，可以访问 this</p><blockquote><p>生命周期相关demo 代码见[github-lifecycle-demo](生命周期相关demo 代码见github-lifecycle-demo)</p></blockquote><h1 id="理解并合理使用-mixin"><a href="#理解并合理使用-mixin" class="headerlink" title="理解并合理使用 mixin"></a>理解并合理使用 mixin</h1><h2 id="什么是-mixin（混入）"><a href="#什么是-mixin（混入）" class="headerlink" title="什么是 mixin（混入）"></a>什么是 mixin（混入）</h2><blockquote><p>当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项 大致原理就是将外来的组件、方法以某种方式进行合并。合并的规则有点像继承和扩展。</p></blockquote><p>当组件和混入对象含有<strong>同名选项</strong>时，这些选项将以恰当的方式进行“合并”</p><p>我们看一下一个组件里面有哪些东西是可以合并的</p><p><code>data、methods、computed、directives、components</code> 生命周期钩子</p><p>没错这些都可以混入</p><pre><code class="js">import demoMixin form &#39;@/mixins/demo&#39;export default &#123;        mixins: [demoMixin]&#125;</code></pre><p>这样看来，很多页面重复的代码我们都可以直接抽取出来<br>或者是封装成一个公共的 <code>mixin</code><br>比如我们做 H5 页面，里面很多短信验证的逻辑固有逻辑，但是需要访问到 this。使用工具函数肯定不行。<br>这时候就可以考虑使用 <code>mixin</code>，封装成一个具有响应式的模块。供需要的地方进行引入。</p><h2 id="mixin-规则"><a href="#mixin-规则" class="headerlink" title="mixin 规则"></a>mixin 规则</h2><p>首先是<strong>优先级</strong>的问题，当重名选项时选择哪一个为最后的结果</p><p>默认规则我这里分为 3 类</p><ul><li><ol><li>data 混入: 以当前组件值为最后的值</li></ol></li><li><ol start="2"><li>生命周期钩子: 保留所有钩子，先执行 mixins 的，后执行当前组件的</li></ol></li><li><ol start="3"><li>methods、computed、directives、components 这种健值对形式，同名key，统统以当前组件为准</li></ol></li></ul><p>当然如果想改变规则，也可以通过配置来改变规则</p><pre><code class="js">Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) &#123;    // 返回合并后的值&#125;</code></pre><h2 id="mixin-的好处"><a href="#mixin-的好处" class="headerlink" title="mixin 的好处"></a>mixin 的好处</h2><p>我们知道 <code>Vue</code> 最能复用代码的就是组件。一般情况，我们通过 <code>props</code> 来控制组件的，将原有组件封装成 <code>HOC</code> 高阶组件。而控制 <code>props</code> 的生成不一样的功能的代码还是写在基础组件里。</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  div.dib    van-button.btn(          @click=&quot;$emit(&#39;click&#39;)&quot;          :class=&quot;getClass&quot; v-bind=&quot;$attrs&quot;          :style=&quot;&#123;&#39;width&#39;: size === &#39;large&#39; ? &#39;345px&#39;: &#39;&#39;,     &#39;backgroundColor&#39;: getBgColor,     borderColor: getBgColor, color: getBgColor&#125;&quot;)      slot&lt;/template&gt;&lt;script&gt;import &#123; Button &#125; from &#39;vant&#39;import Vue from &#39;vue&#39;import &#123; getColor &#125; from &#39;@/utils&#39;Vue.use(Button)export default &#123;      name: &#39;app-button&#39;,      props: &#123;            type: &#123;                  type: String,                  default: &#39;primary&#39;            &#125;,            theme: &#123;                  type: String,                  default: &#39;blue&#39;            &#125;,            size: &#123;                  type: String,                  default: &#39;&#39;           &#125;      &#125;&#125;</code></pre><p>以这个组件为例，我们还是<strong>通过公共组件内部的逻辑，来改变组件的行为</strong>。</p><p>但是，使用 mixin 提供了另一个思路。我们写好公共的 mixin，每一个需要使用 mixin 的地方。我们进行扩展合并，不同与公共 mixin 的选项我们在当前组件中进行自定义，也就是扩展。<strong>我们新的逻辑是写在当前组件里面的，而非公共 mixins 里</strong>。</p><p>画个图理解一下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c3937144fd11f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="画个图"></p><h2 id="最后总结一下-mixin-的优点及缺点"><a href="#最后总结一下-mixin-的优点及缺点" class="headerlink" title="最后总结一下 mixin 的优点及缺点"></a>最后总结一下 mixin 的优点及缺点</h2><p><strong>优点</strong></p><ul><li>复用代码，公共逻辑抽离</li><li>可以访问 this, 可以操作响应式代码</li><li>mixins 相对与组件来说，更像扩展</li></ul><p><strong>缺点</strong></p><ul><li>千万不能滥用全局 mixins 因为会影响所有多子组件</li><li>由于 mixins 的合并策略固有影响，可能在一些极端情况达不到你想要的效果。</li></ul><p>比如：我已经存在一个 <code>mixins</code>，我的页面里面也有一些方法，我要引入<code>mixins</code> 就要做很多改动，来保证我的代码按我的需要运行。</p><p>页面 data 有一个 <code>message</code> 值，<code>mixins</code> 里面同样有一个。</p><p>按照默认规则，<code>mixins</code> 里面的 <code>message</code> 会被页面里面 <code>message</code> 覆盖。但是这两个 <code>message</code> 可能代表的意义不一样，都需要存在。那么我就需要改掉其中的一个，如果业务太深的话，可能这个 <code>message</code> 没那么好改。</p><p>有时候需要考虑这些问题，导致使用 <code>mixins</code> 都会增加一些开发负担。当然也是这些问题可以使用规范来规避。</p><h1 id="理解并使用-SSR"><a href="#理解并使用-SSR" class="headerlink" title="理解并使用 SSR"></a>理解并使用 SSR</h1><blockquote><p>SSR 是 Serve Side Render 的缩写，翻译过来就是我们常说的服务端渲染</p></blockquote><h2 id="简单归纳-SSR-存在的原因"><a href="#简单归纳-SSR-存在的原因" class="headerlink" title="简单归纳 SSR 存在的原因"></a>简单归纳 SSR 存在的原因</h2><ol><li>SPA 框架 SEO 的解决方案</li><li>提升首屏加载速度</li></ol><p>但是它还存在以下问题</p><ul><li>有些生命周期钩子无法使用（之前提到的 activated 和 deactivated 等等）</li><li>额外很多的配置</li><li>服务器资源的需求</li></ul><p>总得来说，SSR 是必要的但不是充分的，SPA 的 SEO 现在没有更好的方案，有这方面强烈需求的网站来说，SSR 确实很有必要</p><h2 id="SSR-原理"><a href="#SSR-原理" class="headerlink" title="SSR 原理"></a>SSR 原理</h2><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c3ed6607a605c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SSR 原理"></p><p>通过上面图我们可以得大致几点内容</p><ul><li>通用业务代码只写一套。</li><li>通过暴露客户端和服务端两个入口，对 Vue 实例进行访问。</li><li>通过构建工具打成两个包，服务端包通过 node 服务器渲染给浏览器访问。客户端和原来一样通过访问资源获取。</li></ul><h2 id="实现SSR-有-3-种方式"><a href="#实现SSR-有-3-种方式" class="headerlink" title="实现SSR 有 3 种方式"></a>实现SSR 有 3 种方式</h2><ol><li>根据官网教程搭建，一步一步搭建SSR， 这里有具体教程，略微有点麻烦，但是能够体验搭建的过程，更加深入细节。使用于练习，和现有项目的改造</li><li>使用demo改造，开源 demo，方便省时，适用代码参考学习 <a href="https://github.com/vuejs/vue-hackernews-2.0">vue-ssr-demo</a></li><li>使用nuxt，预设了 SSR 和预渲染，适用于需要 SSR 的新项目。</li></ol><p><strong>分别尝试用这 3 种方式搭建 SSR</strong></p><h2 id="五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）"><a href="#五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）" class="headerlink" title="五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）"></a>五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）</h2><p><em>这里主要加深理解，vue-cli3+ 实现基本 SSR</em></p><h3 id="第一步：安装依赖"><a href="#第一步：安装依赖" class="headerlink" title="第一步：安装依赖"></a>第一步：安装依赖</h3><ul><li>vue-server-renderer （核心依赖，版本必须与 vue 版本一致）</li><li>webpack-merge（用于webpack配置合并）</li><li>webpack-node-externals （用于webpack配置更改）</li><li>express (用于服务端渲染)</li></ul><h3 id="第二步：建立入口，并改造改造"><a href="#第二步：建立入口，并改造改造" class="headerlink" title="第二步：建立入口，并改造改造"></a>第二步：建立入口，并改造改造</h3><p>分为 2 个入口，将 <code>main.js</code> 定为通用入口， 并额外增加<code>entry-client.js</code> 和 <code>entry-serve.js</code> 两个</p><p>1.改造主要入口，创建工厂函数</p><pre><code class="js">// main.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import &#123; createRouter &#125; from &quot;./router&quot;// app、routerexport function createApp () &#123;      const router = createRouter()      const app = new Vue(&#123;            router,            render: h =&gt; h(App)      &#125;)      return &#123;         app, router     &#125;&#125;</code></pre><p>2.客户端入口</p><pre><code class="js">// client.jsimport &#123; createApp &#125; from &#39;./main&#39;// 客户端特定引导逻辑const &#123; app &#125; = createApp()app.$mount(&#39;#app&#39;)</code></pre><p>3.服务端入口</p><pre><code class="js">// serve.jsimport &#123; createApp &#125; from &quot;./main&quot;;export default context =&gt; &#123;      // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise      return new Promise((resolve, reject) =&gt; &#123;            const &#123; app, router &#125; = createApp();            // 设置服务器端 router 的位置            router.push(context.url);            // 等到 router 将可能的异步组件和钩子函数解析完            router.onReady(() =&gt; &#123;                  const matchedComponents = router.getMatchedComponents();                  // 匹配不到的路由，执行 reject 函数                  if (!matchedComponents.length) &#123;                        return reject(&#123;                              code: 404                        &#125;);                  &#125;                  // Promise 应该 resolve 应用程序实例，以便它可以渲染                  resolve(app);                       &#125;, reject);      &#125;);&#125;;</code></pre><h3 id="第三步：改造-vue-config-配置"><a href="#第三步：改造-vue-config-配置" class="headerlink" title="第三步：改造 vue.config 配置"></a>第三步：改造 vue.config 配置</h3><pre><code class="js">const VueSSRServerPlugin = require(&quot;vue-server-renderer/server-plugin&quot;);const VueSSRClientPlugin = require(&quot;vue-server-renderer/client-plugin&quot;);const nodeExternals = require(&quot;webpack-node-externals&quot;);const merge = require(&quot;webpack-merge&quot;);const TARGET_NODE = process.env.WEBPACK_TARGET === &quot;node&quot;;const target = TARGET_NODE ? &quot;server&quot; : &quot;client&quot;;module.exports = &#123;      configureWebpack: () =&gt; (&#123;            entry: `./src/entry-$&#123;target&#125;.js`,            devtool: &#39;source-map&#39;,            target: TARGET_NODE ? &quot;node&quot; : &quot;web&quot;,            node: TARGET_NODE ? undefined : false,            output: &#123;                  libraryTarget: TARGET_NODE ? &quot;commonjs2&quot; : undefined            &#125;,            externals: TARGET_NODE              ? nodeExternals(&#123;                      whitelist: [/\.css$/]                &#125;): undefined,            optimization: &#123;                      splitChunks: undefined            &#125;,            plugins: [            TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()]          &#125;),                  //...&#125;;</code></pre><h3 id="第四步：对路由-router-改造"><a href="#第四步：对路由-router-改造" class="headerlink" title="第四步：对路由 router 改造"></a>第四步：对路由 router 改造</h3><pre><code class="js">export function createRouter()&#123;      return new Router(&#123;            mode: &#39;history&#39;,            routes: [                //...            ]      &#125;)&#125;</code></pre><h3 id="第五步：使用-express-运行服务端代码"><a href="#第五步：使用-express-运行服务端代码" class="headerlink" title="第五步：使用 express 运行服务端代码"></a>第五步：使用 express 运行服务端代码</h3><p>这一步主要是让 node 服务端响应 HTML 给浏览器访问</p><pre><code class="js">const Vue = require(&#39;vue&#39;)const server = require(&#39;express&#39;)()const renderer = require(&#39;vue-server-renderer&#39;).createRenderer()server.get(&#39;*&#39;, (req, res) =&gt; &#123;      const app = new Vue(&#123;            data: &#123;                  url: req.url            &#125;,            template: `&lt;div&gt;访问的 URL 是： &#123;&#123; url &#125;&#125;&lt;/div&gt;`      &#125;)      renderer.renderToString(app, (err, html) =&gt; &#123;            if (err) &#123;                  res.status(500).end(&#39;Internal Server Error&#39;)                  return            &#125;            res.end(`                  &lt;!DOCTYPE html&gt;                  &lt;html lang=&quot;en&quot;&gt;                   &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;                    &lt;body&gt;$&#123;html&#125;&lt;/body&gt;                  &lt;/html&gt;`)      &#125;)&#125;)server.listen(8080)</code></pre><h2 id="nuxt-体验"><a href="#nuxt-体验" class="headerlink" title="nuxt 体验"></a>nuxt 体验</h2><p>简单几步体验下 nuxt</p><p>安装后</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c7cbe963be44c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="nuxt"></p><p>简单看了一下源码，nuxt 把我们之前提到的重要的改造，全部封装到 .nuxt 文件夹里面了\</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c7cc50e09b590?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="启动"></p><p>跑一下 dev 发现有两个端，一个 clinet 端，一个 server 端</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c7cc93fe6230b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>最后查看一下效果，整个过程挺丝滑的。目录结构也比较符合我的风格，新项目需要 SSR 会考虑使用 nuxt</p><h2 id="使用-webpack-插件预渲染"><a href="#使用-webpack-插件预渲染" class="headerlink" title="使用 webpack 插件预渲染"></a>使用 webpack 插件预渲染</h2><p>解决 SEO 问题是不是只有 SSR 呢？其实预渲染也能做到，首先</p><h3 id="区别使用-SSR-和预渲染"><a href="#区别使用-SSR-和预渲染" class="headerlink" title="区别使用 SSR 和预渲染"></a>区别使用 SSR 和预渲染</h3><ul><li>服务端渲染解决的问题，不仅只是把 HTML 页面给浏览器，更重要的是处理动态逻辑和 JS 代码后，将渲染后完整的 HTML 给浏览器，渲染的过程在服务端。</li><li>预渲染，是利用构建工具在 webpack 中生成静态的 HTML，直接给浏览器，渲染的过程在本地。</li><li>预渲染插件里面提到两种不能使用：大量路由、动态内容</li></ul><h3 id="使用-prerender-spa-plugin-插件进行简单预渲染"><a href="#使用-prerender-spa-plugin-插件进行简单预渲染" class="headerlink" title="使用 prerender-spa-plugin 插件进行简单预渲染"></a>使用 prerender-spa-plugin 插件进行简单预渲染</h3><ol><li>安装 prerender-spa-plugin</li></ol><pre><code class="js">yarn prerender-spa-plugin</code></pre><ol start="2"><li>修改 webpack 配置，比较简单就能完成配置</li></ol><pre><code class="js">const path = require(&#39;path&#39;)const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;)const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = &#123;      plugins: [            //...            new PrerenderSPAPlugin(&#123;                  staticDir: path.join(__dirname, &#39;dist&#39;),                  outputDir: path.join(__dirname, &#39;prerendered&#39;),                  indexPath: path.join(__dirname, &#39;dist&#39;, &#39;index.html&#39;),                  routes: [ &#39;/&#39;, &#39;/about&#39;, &#39;/some/deep/nested/route&#39; ],                  postProcess (renderedRoute) &#123;                        renderedRoute.route = renderedRoute.originalPath                        renderedRoute.html = renderedRoute.html.split(/&gt;[\s]+&lt;/gmi).join(&#39;&gt;&lt;&#39;)                        if (renderedRoute.route.endsWith(&#39;.html&#39;)) &#123;                              renderedRoute.outputPath = path.join(__dirname, &#39;dist&#39;, renderedRoute.route)                        &#125;                        return renderedRoute                  &#125;,                  minify: &#123;                        collapseBooleanAttributes: true,                        collapseWhitespace: true,                        decodeEntities: true,                        keepClosingSlash: true,                        sortAttributes: true                  &#125;,                  renderer: new Renderer(&#123;                        inject: &#123;                              foo: &#39;bar&#39;                        &#125;,                    maxConcurrentRoutes: 4          ]&#125;</code></pre><h1 id="Vue-开发技巧总结"><a href="#Vue-开发技巧总结" class="headerlink" title="Vue 开发技巧总结"></a>Vue 开发技巧总结</h1><blockquote><p>从 5 个大的角度来提升开发效率和体验，代码美观和代码质量，用户体验</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c3a14c4cf39?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="技巧"></p><h2 id="5-大角度提升"><a href="#5-大角度提升" class="headerlink" title="5 大角度提升"></a>5 大角度提升</h2><h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><ul><li>组件化开发，代码效率 * n</li><li>使用 mixins 抽离公共逻辑，代码效率 * n</li><li>工具化函数、使用 filter 编码效率+</li><li>sass 复用 css，编码体验、效率+</li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul><li>代码静态检查 eslint + prettier，代码风格+、基础语法错误-</li><li>数据类型控制 typescript，代码质量+</li><li>前端测试 test，代码质量+</li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li>合理使用 vue，渲染性能+</li><li>合理使用 vuex 减少请求，使用图片懒加载，加载性能+</li><li>合理使用函数组件，组件性能+</li><li>合理骨架屏、路由过渡，用户体验+</li></ul><h3 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h3><ul><li>使用更新的脚手架 vue-cli4，webpack 配置效率+</li><li>使用配置好的脚手架模版 vue-h5-template，vue 配置效率+</li><li>使用更简洁的模版 pug，HTML 编写效率+</li><li>使用更强大的 css 编写 sass，CSS 编写效率+</li><li>使用模拟数据 mock，脱离后端开发效率+</li><li>开源组件封装 HOC，组件开发，页面编写效率+</li></ul><h3 id="瓶颈解决"><a href="#瓶颈解决" class="headerlink" title="瓶颈解决"></a>瓶颈解决</h3><ul><li>路由history使用，服务端配置相关，URL美观+</li><li>解决SEO与首屏加载、服务端渲染 SSR 基本解决</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e1eb1dff265da3e354ea2d0&quot;&gt;原文地址&lt;/a&gt;   &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>吃透Vue项目开发实践(中)</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/09/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%AD/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/09/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%AD/</id>
    <published>2020-05-09T02:03:02.000Z</published>
    <updated>2020-05-09T15:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e15932ee51d4540f02fae27">原文地址</a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f5676f7940d72a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="概览"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p>本节内容主要围绕下列问题展开：</p></blockquote><ul><li>如何编写原生组件，以及组件编写的思考与原则？</li><li>组件怎么通信？有哪些方式？</li><li>如何使用vuex 以及它的应用场景和原理</li><li>如何使用过滤器，编写自己的过滤器</li><li>如何使用 Jest 测试你的代码？TDD 与 BDD 的比较</li></ul><h2 id="如何编写原生组件"><a href="#如何编写原生组件" class="headerlink" title="如何编写原生组件"></a>如何编写原生组件</h2><h3 id="组件编写原理"><a href="#组件编写原理" class="headerlink" title="组件编写原理"></a>组件编写原理</h3><p>vue 编写组件有两种方式，一种是单文件组件，另外一种函数组件。根据组件引入和创建还可以分为动态组件和异步组件。</p><p>动态组件<code>keep-alive</code>使之缓存。异步组件原理和异步路由一样，使用<code>import()</code>实现异步加载也就是按需加载。</p><p>所谓 vue 单文件组件，就是我们最常见的这种形式：</p><pre><code class="js">&lt;template lang=&quot;pug&quot;&gt;    .demo      h1 hello&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;demo&#39;,  data() &#123;    return &#123;&#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.demo &#123;  h1 &#123;    color: #f00;  &#125;&#125;&lt;/style&gt;</code></pre><p>这里的template 也可以使用 <code>render</code> 函数来编写</p><pre><code class="js">Vue.component(&#39;demo&#39;, &#123;    render: function (createElement) &#123;      return createElement(        &#39;h1&#39;,      &#39;hello&#39;,         // ...          )      &#125;&#125;)</code></pre><p>我们可以发现<code>render</code>函数写模版让我们更有编程的感觉。<br>对模版也可以编程，在vue 里面我们可以很容易联想到，很多地方都有两种写法，一种是 <code>template</code> ， 一种是<code>js</code>。<br>比如：对于路由，我们既可以使用<code>:to=&quot;&quot;</code>，又可以使用<code>$router.push</code>，这也许是 vue 用起来比较爽的原因。</p><h4 id="函数式组件是什么呢？"><a href="#函数式组件是什么呢？" class="headerlink" title="函数式组件是什么呢？"></a>函数式组件是什么呢？</h4><p><code>functional</code>，这意味它<strong>无状态 (没有响应式数据)**，也没有</strong>实例** (没有 this 上下文)</p><ul><li>单文件形式 2.5.0+</li></ul><pre><code class="html">&lt;template functional&gt;&lt;/template&gt;</code></pre><ul><li>Render 函数形式</li></ul><pre><code class="js">Vue.component(&#39;my-component&#39;, &#123;  functional: true,  render function (createElement, context) &#123;    return createElement(&#39;div&#39;)      &#125;&#125;</code></pre><h4 id="为什么要使用函数组件呢？"><a href="#为什么要使用函数组件呢？" class="headerlink" title="为什么要使用函数组件呢？"></a>为什么要使用函数组件呢？</h4><p>最重要的原因就是<strong>函数组件开销低</strong>，也就是对性能有好处，在不需要响应式和this的情况下，写成函数式组件算是一种优化方案。</p><p>组件写好了，需要将组件注册才能使用</p><h3 id="组件注册的两种方式"><a href="#组件注册的两种方式" class="headerlink" title="组件注册的两种方式"></a>组件注册的两种方式</h3><p>组件注册分为两种，一种是全局注册，一种是局部注册</p><p><code>局部注册</code>就是我们常用的 <code>Vue.component(&#39;s-button&#39;, &#123; /* ... */ &#125;)</code>，比较简单不详细论述</p><p><code>全局注册</code>上节已经提到，在<code>new Vue</code> 之前在 <code>mian.js </code>注册，这里还提到一种自动全局注册的方法 <code>**require.text**</code></p><pre><code class="js">import Vue from &#39;vue&#39;import upperFirst from &#39;lodash/upperFirst&#39;import camelCase from &#39;lodash/camelCase&#39;const requireComponent = require.context(  &#39;./components&#39;,  // 是否查询其子目录  false,  /Base[A-Z]\w+\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; &#123;    // 获取组件配置     const componentConfig = requireComponent(fileName)    const componentName = upperFirst(          camelCase(                 // 获取和目录深度无关的文件名            fileName.split(&#39;/&#39;).pop().replace(/\.\w+$/, &#39;&#39;)          )    )      // 全局注册组件    Vue.component(      componentName,      componentConfig.default || componentConfig      )&#125;)</code></pre><p>基本原理和全局注册一样，就是将 <code>components</code> 中的组件文件名，<code>appButton </code>变成 <code>AppButton</code> 作为注册的组件名。<br>把原来需要手动复制的，变成之间使用 <code>keys</code> 方法批量注册。</p><h3 id="实践开发一个-button-组件"><a href="#实践开发一个-button-组件" class="headerlink" title="实践开发一个 button 组件"></a>实践开发一个 button 组件</h3><p>现在，我们以写一个简单的原生 <code>button</code>组件为例，探讨一下组件开发的一些关键点。 写之前，我们需要抓住 4 个核心的要点：</p><ul><li><strong>用哪个标签作为组件主体， <code>button</code> 还是 <code>div</code> 标签</strong></li><li><strong>如何根据属性控制 <code>button</code> 组件的颜色 <code>color</code> 、形状 <code>type</code> 、大小 <code>size</code></strong></li><li><strong>如何处理 <code>button</code> 组件的点击事件</strong></li><li>*<em>如何去扩展 <code>button</code> 组件的内容</em></li></ul><blockquote><p>这些思考点在其他原生组件开发和高阶组件封装里面也需要考虑到</p></blockquote><p>首先看第一个问题，大部分原生组件第一考虑的地方，就是主要标签用原生 <code>&lt;button&gt;&lt;/button&gt;</code>标签还是用 去模拟。</p><blockquote><p>为什么不考虑 <code>&lt;input&gt;</code>呢，因为 <code>&lt;button&gt;&lt;/button&gt;</code> 元素比 <code>&lt;input&gt;</code> 元素更容易添加内部元素。你可以在元素内添加HTML内容（像 、 甚至 <code>&lt;img&gt;</code>），以及 <code>::after</code> 和 <code>::before</code> 伪元素来实现复杂的效果，而 <code>&lt;input&gt;</code> 只支持文本内容。</p></blockquote><p>下面分析这两种写法的优劣</p><p><strong>使用原生 <code>button</code> 标签的优势：</strong></p><ol><li> 更好的标签语义化</li><li> 原生标签自带的 <code>buff</code> ，一些自带的键盘事件行为等</li></ol><blockquote><p>为什么说更好的语义化呢？有人可能会说，可以使用 <code>role</code> 来增强 <code>div</code> 的语义化。确实可以，但是可能存在问题——有些爬虫并不会根据 <code>role</code> 来确定这个标签的含义。</p></blockquote><blockquote><p>另外一点，对开发者来说， <code>&lt;button&gt;&lt;/button&gt;</code> 比 阅读起来更好。</p></blockquote><p><strong>使用 <code>div</code> 模拟的优势：</strong></p><ol><li> 不需要关心 <code>button</code> 原生样式带来的一些干扰，少写一些覆盖原生 <code>css</code> 的代码，更干净纯粹。</li><li> 全部用 <code>div</code> ，不需要再去找原生标签、深入了解原生标签的一些兼容相关的诡异问题。</li><li> 可塑性更强，也就是拓展性和兼容性更好。这也是大多数组件都会选择使用 <code>div</code> 作为组件主体的原因。</li></ol><blockquote><p>貌似 div 除了语义不是很好以外，其他方面都还行，但是具体用哪一种其实都可以，只要代码写的健壮适配性强，基本都没啥大问题。</p></blockquote><p>我们这里使用原生 <code>&lt;button&gt;&lt;/button&gt;</code>作为主要标签，使用 <code>s-xx</code>作为 <code>class</code>前缀</p><blockquote><p>为什么需要使用前缀，因为在有些时候，比如使用第三方组件，多个组件之间的 class 可能会产生冲突，前缀用来充当组件 css 的一个命名空间，不同组件之间不会干扰。</p></blockquote><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;   button.s-button(:class=&quot;xxx&quot; :style=&quot;xxx&quot; )     slot&lt;/template&gt;</code></pre><p>然后，我们看第二个问题：</p><p><strong>如何根据属性来控制 <code>button</code> 的样式</strong> 其实这个很简单，基本原理就是：</p><ol><li>使用 <code>props</code> 获取父组件传过来的属性。</li><li>根据相关属性，生成不同的 <code>class</code>，使用 <code>:class=&quot;&#123;xxx: true, xxx: &#39;s-button--&#39; + size&#125;&quot;</code> 这种形式，在 <code>style</code> 里面对不同的 <code>s-button--xxx</code> 做出不同的处理。</li></ol><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  button.s-button(:class=&quot;&quot; :style=&quot;&quot; )    slot&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;s-button&#39;    data: return &#123;&#125;    props: &#123;        theme: &#123;&#125;,        size: &#123;&#125;,        type: &#123;&#125;    &#125;&#125;&lt;/script&gt;  </code></pre><p><strong>如何使用事件以及如何扩展组件</strong></p><p>扩展组件的原理，主要就是使用 <code>props</code> 控制组件属性，模版中使用 <code>v-if/v-show</code> 增加组件功，比如增加内部 ICON，使用 <code>:style class</code>控制组件样式。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9d9414f682625?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="type"> </p><p>还要注意的是我们还要控制原生 <code>type</code> 类型，原生默认是 <code>submit</code>，这里我们默认设置为 <code>button</code></p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt; button.s-button(:class=&quot;&quot; :style=&quot;&quot; :type=&quot;nativeType&quot;)   slot   s-icon(v-if=&quot;icon &amp;&amp; $slots.icon&quot; name=&quot;loading&quot;)&lt;/template&gt;&lt;script&gt;export default &#123;    name: &#39;s-button&#39;    data: return &#123;&#125;    props: &#123;        nativeType: &#123;            type: String,            default: &#39;button&#39;        &#125;,        theme: &#123;&#125;,        size: &#123;&#125;,        type: &#123;&#125;    &#125;&#125;&lt;/script&gt;</code></pre><p>控制事件，直接使用 <code>@click=&quot;&quot;</code> + <code>emit</code></p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  button.s-button(@click=&quot;handleClick&quot;)&lt;/template&gt;&lt;script&gt;export default &#123;    methods: &#123;        handleClick (evt) &#123;            this.$emit(&#39;click&#39;, evt)          &#125;      &#125;&#125;&lt;/script&gt;</code></pre><h4 id="最后总结下："><a href="#最后总结下：" class="headerlink" title="最后总结下："></a>最后总结下：</h4><blockquote><p>一般就直接使用 <code>template</code>单文件编写组件，需要增强 js编写能力可以使用 <code>render()</code><br>常规编写组件需要考虑：1. 使用什么标签 2. 如何控制各种属性的表现 3. 如何增强组件扩展性 4. 如何处理组件事件</p></blockquote><blockquote><p>对响应式 <code>this</code>要求不高，使用函数 <code>functional</code>组件优化性能。</p></blockquote><blockquote><p>基础组件通常全局注册，业务组件通常局部注册</p></blockquote><blockquote><p>使用 <code>keys()</code>遍历文件来实现自动批量全局注册</p></blockquote><blockquote><p>使用 <code>import()</code> 异步加载组件提升减少首次加载开销，使用 <code>keep-alive + is</code>缓存组件减少二次加载开销</p></blockquote><h2 id="如何使用-vuex-以及它的应用"><a href="#如何使用-vuex-以及它的应用" class="headerlink" title="如何使用 vuex 以及它的应用"></a>如何使用 vuex 以及它的应用</h2><h3 id="由来以及原理"><a href="#由来以及原理" class="headerlink" title="由来以及原理"></a>由来以及原理</h3><p>我们知道组件中通信有以下几种方式：</p><h4 id="1-父组件通过-props-传递给子组件，不详细论述"><a href="#1-父组件通过-props-传递给子组件，不详细论述" class="headerlink" title="1. 父组件通过 props 传递给子组件，不详细论述"></a>1. 父组件通过 <code>props</code> 传递给子组件，不详细论述</h4><h4 id="2-子组件通过-emit-事件传递数据给父组件-父组件通过-on-监听，也就是一个典型的-订阅-发布模型"><a href="#2-子组件通过-emit-事件传递数据给父组件-父组件通过-on-监听，也就是一个典型的-订阅-发布模型" class="headerlink" title="2. 子组件通过 emit 事件传递数据给父组件,父组件通过 on 监听，也就是一个典型的 订阅-发布模型"></a>2. 子组件通过 <code>emit</code> 事件传递数据给父组件,父组件通过 <code>on</code> 监听，也就是一个典型的 <strong>订阅-发布</strong>模型</h4><blockquote><p><code>@</code> 为 <code>v-on:</code> 的简写</p></blockquote><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;&lt;!--子组件--&gt;    div.component-1&lt;template&gt;&lt;script&gt;export default &#123;    mounted() &#123;        this.$emit(&#39;eventName&#39;, params)      &#125;&#125;&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 父组件--&gt;&lt;template lang=&quot;pug&quot;&gt;    Component-1(@eventName=&quot;handleEventName&quot;)&lt;template&gt;&lt;script&gt;export default &#123;    methods: &#123;        handleEventName (params) &#123;            console.log(params)        &#125;  &#125;&lt;/script&gt;</code></pre><h4 id="3-集中式通信事件，主要用于简单的非父子组件通信"><a href="#3-集中式通信事件，主要用于简单的非父子组件通信" class="headerlink" title="3. 集中式通信事件，主要用于简单的非父子组件通信"></a>3. 集中式通信事件，主要用于简单的非父子组件通信</h4><p>原理很简单其实就是在 <code>emit</code> 与 <code>on</code> 的基础上加了一个事件中转站 “bus”。我觉得更像是现实生活中的集线器。</p><p>普遍的实现原理大概是这样的 “bus” 为 <code>vue</code> 的一个实例，实例里面可以调用 <code>emit</code>, <code>off</code>, <code>on</code> 这些方法。</p><pre><code class="js">var eventHub = new Vue()// 发布eventHub.$emit(&#39;add&#39;, params)// 订阅/响应eventHub.$on(&#39;add&#39;, params)// 销毁eventHub.$off(&#39;add&#39;, params)</code></pre><p>但是稍微复杂点的情况，使用这种方式就太繁锁了。还是使用 vuex 比较好。</p><p>从某种意义而言，我觉得 vuex 不仅仅是它的一种进化版。</p><ol><li> 使用 <code>store</code> 作为 <strong>状态管理</strong> 的仓库，并且引入了 <strong>状态</strong> 这个概念</li><li> 它的模型完全不一样了， <code>bus</code> 模型感觉像一个电话中转站<br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9ddf76fc5b0fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="中转站"></li></ol><p>而 vuex 的模型更像是集中式的代码仓库。</p><blockquote><p>与 <code>git</code> 类似，它不能直接修改代码，需要参与者提交 <code>commit</code>，提交完的 <code>commit</code>修改仓库，仓库更新，参与者 <code>fetch</code> 代码更新自己的代码。不同的是代码仓库需要合并，而 <code>vuex</code> 是直接覆盖之前的状态。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ede3d74ab245?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="state"></p><h3 id="管理-vuex"><a href="#管理-vuex" class="headerlink" title="管理 vuex"></a>管理 vuex</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (<code>state</code>)。Vuex 和单纯的全局对象有以下两点不同</p></blockquote><ul><li><strong>响应式</strong> （改变属性后，触发组件中的状态改变，触发 <code>dom</code> ）</li><li><strong>不能直接改变状态</strong> （唯一途径是提交 <code>mutation</code> )</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9deb7be3845f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="store"></p><p><strong>基本用法</strong>：就是在 <code>state</code> 里面定义各种属性，页面或组件组件中，直接使用 <code>$store.state</code>或者 <code>$store.getters</code>来使用。如果想要改变状态 <code>state</code>呢，就 <code>commit</code> 一个 <code>mutation</code></p><p>但是假如我想提交一连串动作呢？可以定义一个 <code>action</code>，然后使用 <code>$store.dispatch</code> 执行这个 <code>action</code></p><p>使用 <code>action</code> 不仅能省略不少代码，而且关键是 <code>action</code> 中可以使用异步相关函数，还可以直接返回一个 <code>promise</code></p><p>而为什么不直接到 <code>mutation</code>中写异步呢？ 因为 <code>mutation</code> 一定是个同步，它是唯一能改变 state 的，一旦提交了 <code>mutation</code>， <code>mutation</code> 必须给定一个明确结果。否则会阻塞状态的变化。</p><p>下面给出常用 vuex 的使用方式</p><h4 id="新建-Store"><a href="#新建-Store" class="headerlink" title="新建 Store"></a>新建 Store</h4><p>新建一个 <code>store</code>并将其他各个功能化分文件管理</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state from &#39;./states&#39;import getters from &#39;./getters&#39;import mutations from &#39;./mutations&#39;import actions from &#39;./actions&#39;import user from &#39;./modules/user&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;      //在非生产环境下，使用严格模式      strict: process.env.NODE_ENV !== &#39;production&#39;,       state,      getters,      mutations,      actions,      modules: &#123;            user      &#125;&#125;)</code></pre><p><strong>操作状态两种方式</strong></p><ol><li> 获取状态</li></ol><pre><code class="js">console.log(store.state.count)</code></pre><ol start="2"><li> 改变状态</li></ol><pre><code class="js">store.commit(&#39;xxx&#39;)</code></pre><h4 id="管理状态-states"><a href="#管理状态-states" class="headerlink" title="管理状态 states"></a>管理状态 states</h4><blockquote><p>单一状态树, 这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p></blockquote><pre><code class="js">// states 文件export default &#123;      count: 0&#125;</code></pre><p>计算属性中返回，每当 <code>state</code> 中属性变化的时候, 其他组件都会重新求取计算属性，并且触发更新相关联的 DOM</p><pre><code class="js">const Counter = &#123;      template: &#39;&lt;div&gt;&#123;&#123;count&#125;&#125;&lt;div&gt;&#39;,      computed: &#123;            count() &#123;                  return store.state.count            &#125;      &#125;&#125;</code></pre><h4 id="管理取值器-getters"><a href="#管理取值器-getters" class="headerlink" title="管理取值器 getters"></a>管理取值器 getters</h4><blockquote><p><code>getters</code> 相当于 <code>store</code> 的计算属性。不需要每次都要在计算属性中过滤一下，也是一种代码复用。 我们在 <code>getters</code>文件中管理</p></blockquote><pre><code class="js">export default &#123;      count: (state) =&gt; Math.floor(state.count)&#125;</code></pre><h4 id="管理-mutations"><a href="#管理-mutations" class="headerlink" title="管理 mutations"></a>管理 mutations</h4><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方</p></blockquote><p>使用 types 大写用于调试，在 <code>mutationTypes</code> 文件中 <code>export const ROUTE_ADD = &#39;ROUTE_ADD&#39;</code></p><p>然后在 <code>mutations</code> 文件中管理</p><pre><code class="js">import * as MutationTypes from &#39;./mutationTypes&#39;export default &#123;      [MutationTypes.ADDONE]: function(state) &#123;    state.count = state.count + 1      &#125;,      //...&#125;</code></pre><pre><code class="js">this.$store.commit(MutationTypes.ADDONE)</code></pre><h4 id="管理-actions"><a href="#管理-actions" class="headerlink" title="管理 actions"></a>管理 actions</h4><p>和 <code>mutations</code> 类似， <code>actions</code> 对应的是 <code>dispatch</code>，不同的是 <code>action</code>可以使用异步函数，有种更高一级的封装。</p><pre><code class="js">// 简化actions: &#123;    increment (&#123; commit &#125;) &#123;        setTimeout(() =&gt; &#123;              commit(MutationTypes.ADDONE)    &#125;    , 1000)    &#125;&#125;// 触发store.dispatch(&#39;increment&#39;)</code></pre><blockquote><p>上述用法都可以使用 <strong>载荷</strong>的形式，引入也可以使用 <code>mapXxxx</code> 进行批量引入，这里不详细论述，有兴趣可以查看官网。</p></blockquote><h4 id="分模块管理状态"><a href="#分模块管理状态" class="headerlink" title="分模块管理状态"></a>分模块管理状态</h4><p>状态太多太杂，分模块管理是一个良好的代码组织方式。</p><pre><code class="js">import count from &#39;./modules/count&#39;export default new Vuex.Store(&#123;      modules: &#123;            count      &#125;&#125;)</code></pre><p>每一个模块都可以有独立的相关属性</p><pre><code class="js">import * as ActionTypes from &#39;./../actionTypes&#39;export default &#123;      state: &#123;            count: 0      &#125;,      mutations: &#123;            ADD_ONE: function(state) &#123;                   state.count = state.count + 1              &#125;      &#125;,      actions: &#123;            [ActionTypes.INIT_INTENT_ORDER]: function(&#123; commit &#125;) &#123;                  commit(&#39;ADD_ONE&#39;)            &#125;      &#125;,      getters: &#123;            pageBackToLoan: (state) =&gt; Math.floor(state.count)      &#125;&#125;</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9e11d627d9b4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>vuex</code> 主要有几个应用场景，一个是用于 <strong>组件通信</strong>和 <strong>状态共享</strong>，一个是用于 <strong>数据缓存</strong>，还有就是用于 <strong>减少请求</strong>。这些场景归根节点都是对于 <strong>缓存</strong>和 <strong>共享</strong>来说的。</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><p>首先，状态统一管理在仓库，就实现了组件通信的可能性。</p><p>当一个组件通过 <code>commit</code> 提交 <code>mutation</code> 就改了 <code>state</code>，其他组件就可以通过 <code>store.state</code>获取最新的 <code>state</code>，这样一来就相当于 <strong>更新的值通过 <code>store</code> 传递给了其他组件</strong>，不仅实现了一对一的通信，还实现了一对多的通信。</p><h4 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h4><p>我们经常使用的一个场景就是 <strong>权限管理</strong>。</p><p>写权限管理时候，首次进入页面就要将权限全部拿到，然后需要分发给各个页面使用，来控制各个路由、按钮的权限。</p><pre><code class="js">/** *  * 判断用户有没有权限访问页面  */function hasPermission(routeItem, menus) &#123;    return menus.some(menuItem =&gt; &#123;        return menuItem.name === routeItem.name    &#125;)&#125;/** *  * 递归过滤异步路由表，返回符合用户角色权限的路由表 *  * @param &#123;*&#125; routes 路由表 *  * @param &#123;*&#125; menus 菜单信息  * */function filterRoutes(routes, menus) &#123;    return routes.filter(routeItem =&gt; &#123;        if (routeItem.hidden) &#123;            return true        &#125; else if (hasPermission(routeItem, menus)) &#123;            const menuItem = menus.find(item =&gt; item.name === routeItem.name)            if (menuItem &amp;&amp; menuItem.children &amp;&amp; menuItem.children.length &gt; 0) &#123;                routeItem.children = filterRoutes(routeItem.children, menuItem.children)                if (!routeItem.children.length) return false              &#125;              return true            &#125; else &#123;                return false              &#125;        &#125;)  &#125;  const permission = &#123;      state: &#123;          routers: constantRouterMap,          addRouters: [],          roles: [],          user_name: &#39;&#39;,          avatar_url: &#39;&#39;,          onlyEditor: false,          menus: null,          personal: true,          teamList: []      &#125;,      mutations: &#123;&#125;  &#125;  export default permission</code></pre><p>而且权限还可以被更改，更改后的权限直接分发到其他页面组件中。这个场景要是不使用 <code>vuex</code> ，代码将会比较复杂。</p><h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><p><code>store</code> 是一个仓库，它从创建开始就一直存在，只有页面 <code>Vuex.store</code> 实例被销毁，state 才会被清空。具体表现就是刷新页面。</p><p>这个数据缓存适用于：页面加载后缓存数据，刷新页面请求数据的场景。在一般 <code>Hybrid</code>中，一般不存在刷新页面这个按钮，所以使用 vuex 缓存数据可以应对大多数场景。</p><pre><code class="js">export default &#123;      state: &#123;            // 缓存修改手机号需要的信息            changePhoneInfo: &#123;                  nameUser: &#39;&#39;,                  email: &#39;&#39;,                  phone: &#39;&#39;            &#125;,      &#125;&#125;</code></pre><p>如果需要持久化缓存，结合浏览器或 APP 缓存更佳。</p><pre><code class="js">export default &#123;      // 登陆成功后，vuex 写入token，并写入app缓存，存储持久化      [ActionTypes.LOGIN_SUCCESS]: function(store, token) &#123;            store.commit(MutationTypes.SET_TOKEN, token)            setStorage(&#39;token&#39;, token)            router.replace(&#123; name: &#39;Home&#39;, params: &#123; source: &#39;login&#39; &#125; &#125;)      &#125;&#125;</code></pre><h4 id="减少请求-数据缓存的变种"><a href="#减少请求-数据缓存的变种" class="headerlink" title="减少请求(数据缓存的变种)"></a>减少请求(数据缓存的变种)</h4><p>在写后台管理平台时候，经常会有 <code>list</code> 选型组件，里面数据从服务端拿的数据。如果我们把这个 <code>list</code> 数据存储起来，下次再次使用，直接从 <code>store</code> 里面拿，这样我们就不用再去请求数据了。相当于减少了一次请求。</p><h2 id="如何使用过滤器，编写自己的过滤器"><a href="#如何使用过滤器，编写自己的过滤器" class="headerlink" title="如何使用过滤器，编写自己的过滤器"></a>如何使用过滤器，编写自己的过滤器</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>假设我现在有个需求，需要将性别0、1、2，分别转换成男、女、不确定这三个汉字展示。页面中多处地方需要使用。</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  .user-info    .gender        label(for=&quot;性别&quot;) 性别        span &#123;&#123;gender&#125;&#125;&lt;/template&gt;</code></pre><p>完成这个需求，我们知道有 <strong>4</strong> 种方式：</p><ol><li> 使用 computed 方法</li><li> 使用 methods 方法</li><li> 使用 utils 工具类</li><li> 使用 filters</li></ol><p><strong>应该选择哪种方式呢？</strong></p><p>我从下面三个方面来论述这个问题</p><p><strong>1. 可实现性</strong></p><ul><li> 使用 <code>computed</code> 实现成功，我们知道 <code>computed</code> 不是一个函数是无法传参的，这里有个技巧， <code>return</code> 一个函数接受传过来的参数</li></ul><pre><code class="js">    // ...      computed: &#123;          convertIdToName() &#123;              return function(value) &#123;                  const item = list.find(function(item) &#123;                        return item.id === value                    &#125;)                    return item.name                &#125;            &#125;      &#125;</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9eb7a20ecdcdf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"></p><ul><li> 使用 <code>methods</code> 实现成功，这里直接可以传参数，一种常规的写法。</li></ul><blockquote><p>注意 <code>methods</code>、 <code>computed</code>和 <code>data</code> 相互之前是不能同名的</p></blockquote><pre><code class="js">  // ...    methods: &#123;        convertIdToName(value) &#123;            const item = list.find(function(item) &#123;                return item.id === value            &#125;)            return item.name        &#125;    &#125;</code></pre><ul><li> 使用 <code>utils</code> 和 <code>methods</code> 差不多基本上也可以实现</li><li> 使用 <code>filter</code> 也是实现的，有个可以和 <code>methods</code> 、 <code>computed</code> 同名哦</li></ul><pre><code class="js">    filters: &#123;          console.log(this.render)          convertIdToName(value) &#123;              const item = list.find(function(item) &#123;                  return item.id === value              &#125;)              return item.name          &#125;      &#125;,</code></pre><p><strong>总的来说他们全部都可以实现这个需求</strong></p><p><strong>2. 局限性</strong></p><ul><li><code>computed</code> 、 <code>methods</code> 和 <code>data</code> 三者互不同名，他们没办法被其他组件使用，除非通过 <code>mixins</code></li><li><code>filters</code> 与 <code>utils</code> 无法访问 <code>this</code> ，也就是于响应式绝缘。但是通过定义全局 <code>filters</code> ，可以其他地方使用，另外还可以直接加载第三方 <code>filter</code> 和 <code>utils</code></li></ul><p><strong>3. 总结比较</strong></p><p><code>filters</code> 与 <code>utils</code> 归属一对，他们既是脱离了 <code>this</code>，获得了自由，又是被 <code>this</code> 弃之门外。相反 <code>methods</code> 与 <code>computed</code> 与 <code>this</code> 紧紧站在一起，但又是无法获得自由。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="编写一个简单的千分位过滤器"><a href="#编写一个简单的千分位过滤器" class="headerlink" title="编写一个简单的千分位过滤器"></a>编写一个简单的千分位过滤器</h4><pre><code class="js">export const thousandBitSeparator = (value) =&gt; &#123;    return   value &amp;&amp; (value.toString().indexOf(&#39;.&#39;) !== -1 ? value.toString().replace(/(\d)(?=(\d&#123;3&#125;)+\.)/g, function($0, $1) &#123;          return $1 + &#39;,&#39;;      &#125;) :   value.toString().replace(/(\d)(?=(\d&#123;3&#125;)+$)/g, function($0, $1) &#123;          return $1 + &#39;,&#39;;      &#125;)  );&#125;</code></pre><h4 id="使用-vue-filter-插件"><a href="#使用-vue-filter-插件" class="headerlink" title="使用 vue-filter 插件"></a>使用 vue-filter 插件</h4><p>两款插件</p><p><a href="https://www.npmjs.com/package/vue-filter">vue-filter</a> 使用 <code>use</code> 引入</p><p><a href="https://www.npmjs.com/package/vue-filters">vue2-filters</a> 使用 <code>mixins</code> 引入</p><blockquote><p>有需要的话，我一般就用第二个了，大多数都是自己写一下小过滤器</p></blockquote><p>自定义过滤器之后，直接全局自动注册，其他地方都可以使用</p><h4 id="注册全局过滤器"><a href="#注册全局过滤器" class="headerlink" title="注册全局过滤器"></a>注册全局过滤器</h4><p>遍历过滤属性值，一次性全部注册</p><pre><code class="js">for (const key in filters) &#123;      Vue.filter(key, filters[key])&#125;</code></pre><h2 id="如何使用-Jest-测试你的代码"><a href="#如何使用-Jest-测试你的代码" class="headerlink" title="如何使用 Jest 测试你的代码"></a>如何使用 Jest 测试你的代码</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>我们思考一下测试 js 代码需要哪些东西</p><ol><li> 浏览器运行环境</li><li> 断言库</li></ol><p>如果是测试 vue 代码呢？ 那得再加一个 vue 测试容器</p><h3 id="Jest-Vue"><a href="#Jest-Vue" class="headerlink" title="Jest + Vue"></a>Jest + Vue</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre><code class="json">&#123;      &quot;@vue/cli-plugin-unit-jest&quot;: &quot;^4.0.5&quot;,      &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;,      &quot;jest&quot;: &quot;^24.9.0&quot;,      // ...&#125;</code></pre><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><pre><code class="js">// For a detailed explanation regarding each configuration property, visit:// https://jestjs.io/docs/en/configuration.htmlmodule.exports = &#123;    preset: &#39;@vue/cli-plugin-unit-jest&#39;,    automock: false, &quot;/private/var/folders/10/bb2hb93j34999j9cqr587ts80000gn/T/jest_dx&quot;,    clearMocks: true,    // collectCoverageFrom: null,    coverageDirectory: &#39;tests/coverage&#39;    //...&#125;</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="测试-utils-工具类"><a href="#测试-utils-工具类" class="headerlink" title="测试 utils 工具类"></a>测试 utils 工具类</h4><blockquote><p>对我们之前写的一个性别名称转换工具进行测试</p></blockquote><pre><code class="js">import &#123; convertIdToName &#125; from &#39;./convertIdToName&#39;describe(&#39;测试convertIdToName方法&#39;, () =&gt; &#123;    const list = [        &#123; id: 0, name: &#39;男&#39; &#125;,        &#123; id: 1, name: &#39;女&#39; &#125;,        &#123; id: 2, name: &#39;未知&#39; &#125;    ]    it(&#39;测试正常输入&#39;, () =&gt; &#123;        const usage = list        usage.forEach((item) =&gt; &#123;            expect(convertIdToName(item.id, list)).toBe(item.name)        &#125;)  &#125;)    it(&#39;测试非正常输入&#39;, () =&gt; &#123;        const usage = [&#39;a&#39;, null, undefined, NaN]        usage.forEach((item) =&gt; &#123;            expect(convertIdToName(item, list)).toBe(&#39;&#39;)        &#125;)    &#125;)&#125;)</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9eda87016bfe2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"><br>这样一测试，发现原来我们之前写的工具有这么多漏洞 测试正常输入全部通过了，非正常输入失败了，根据测试用例改进我们的代码</p><pre><code class="js">export const convertIdToName = (value, list) =&gt; &#123;    if (value !== 0 &amp;&amp; value !== 1 &amp;&amp; value !== 2) return &#39;&#39;    const item = list.find(function(item) &#123;        return item.id === value    &#125;)   return item.name&#125;</code></pre><p>现在测试都通过了呢</p><h4 id="测试-components-单文件组件"><a href="#测试-components-单文件组件" class="headerlink" title="测试 components 单文件组件"></a>测试 components 单文件组件</h4><blockquote><p>对我们最简单的 <code>hello world</code> 进行测试</p></blockquote><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  .hello    h1 &#123;&#123; msg &#125;&#125;&lt;/template&gt;&lt;script&gt;export default &#123;    props: &#123;        msg: String    &#125;&#125;&lt;/script&gt;</code></pre><pre><code class="js">import &#123; shallowMount &#125; from &#39;@vue/test-utils&#39;import HelloWorld from &#39;@/components/HelloWorld.vue&#39;describe(&#39;HelloWorld.vue&#39;, () =&gt; &#123;    it(&#39;renders props.msg when passed&#39;, () =&gt; &#123;        const msg = &#39;new message&#39;        const wrapper = shallowMount(HelloWorld, &#123;            propsData: &#123; msg &#125;        &#125;)        expect(wrapper.text()).toMatch(msg)    &#125;)&#125;)</code></pre><h4 id="测试-api-请求"><a href="#测试-api-请求" class="headerlink" title="测试 api 请求"></a>测试 api 请求</h4><p>异步测试有几种常见写法</p><ul><li><code>async</code> 与 <code>await</code></li><li><code>done()</code></li></ul><blockquote><p>简单的异步测试，测试一个简单的登陆请求</p></blockquote><pre><code class="js">export const login = (data) =&gt; post(&#39;/user/login&#39;, data)</code></pre><p>测试代码</p><pre><code class="js">import &#123; login &#125; from &#39;@/api/index&#39;describe(&#39;login api&#39;, () =&gt; &#123;    const response = &#123;        code: &#39;1000&#39;,        data: &#123;&#125;    &#125;    const errorResponse = &#123;        code: &#39;5000&#39;,        data: &#123;&#125;,       message: &#39;用户名或密码错误&#39;    &#125;    it(&#39;测试正常登陆&#39;, async () =&gt; &#123;        const params = &#123;            user: &#39;admin&#39;,            password: &#39;123456&#39;        &#125;        expect(await login(params)).toEqual(response)    &#125;)    it(&#39;测试异常登陆&#39;, async () =&gt; &#123;        const params = &#123;            user: &#39;admin&#39;,           password: &#39;123123&#39;        &#125;        expect(await login(params)).toEqual(errorResponse)    &#125;)&#125;)</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9efc734a64747?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"></p><h3 id="功能模块测试"><a href="#功能模块测试" class="headerlink" title="功能模块测试"></a>功能模块测试</h3><p>组件， <code>api</code>，工具这些零零碎碎都测试了，而且这些都是比较通用、和业务关系不大的代码，它们改动较少，测试到这里其实已经足够了，已经达到了 <code>20%</code> 的测试工作量了很大一部分代码的目的。</p><blockquote><p>为什么我说只有 20% 的工作量呢？因为这些都是不怎么变化的逻辑，是一劳永逸的事情。长远来说占用的工作量确实很少。</p></blockquote><p>但是有些情况业务还是必须得测，也就是必须要功能模块集成测试。</p><p>经常得回归的业务，那种迭代对原有的系统比较大，避免改动之后使旧的代码各种新的问题。这种经常回归测试，采用 <code>BDD</code> + 集成测试，比不停改 <code>bug</code> 要轻松的多。</p><h3 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h3><p>像版本一样，每次测试之后生成一个版本，比较与上一个版本的区别。 这是一种粒度及其小的测试，可以测试到每一个符号。</p><h4 id="比如我用它来测试一个配置文件的变动"><a href="#比如我用它来测试一个配置文件的变动" class="headerlink" title="比如我用它来测试一个配置文件的变动"></a>比如我用它来测试一个配置文件的变动</h4><p>这是我们一个配置文件</p><pre><code class="js">export const api = &#123;    develop: &#39;http://xxxx:8080&#39;,    mock: &#39;http://xxxx&#39;,    feature: &#39;http://xxxx&#39;,    test: &#39;http://xxxx&#39;,    production: &#39;http://xxxx&#39;&#125;export default api[process.env.NODE_ENV || &#39;dev&#39;]</code></pre><p>使用快照测试</p><pre><code class="js">import &#123; api &#125; from &#39;./config&#39;describe(&#39;配置文件测试&#39;, () =&gt; &#123;    it(&#39;测试配置文件是否变动&#39;, () =&gt; &#123;        expect(api).toMatchSnapshot(&#123;            develop: &#39;http://xxxx:8080&#39;,            mock: &#39;http://xxxx&#39;,             feature: &#39;http://xxxx&#39;,             test: &#39;http://xxxx&#39;,             production: &#39;http://xxxx&#39;          &#125;)    &#125;)&#125;)</code></pre><p>使用快照第一次测试后，通过测试，代码被写入快照<br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9f1b5e3b2e64f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快照测试1"><br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9f1d9415200e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快照测试2"><br>改动配置再次测试，未通过测试 这时如果要改变配置怎么办呢？ 只需同时改一下用例就好了。快照将再次写入快照生成版本2，这样配置改动也有根据了<br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9f1eeb7396fdc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快照测试3"></p><h3 id="TDD-与-BDD"><a href="#TDD-与-BDD" class="headerlink" title="TDD 与 BDD"></a>TDD 与 BDD</h3><p>最近讨论比较多的算是 <strong>测试驱动开发</strong>和 <strong>行为驱动开发</strong>，其实总得来说是 4 种</p><ol><li> 不写测试。好处是省时间，坏处当然就 <code>bug</code> 多，代码质量低。</li><li> 先写测试和测试用例，再写代码，也就是测试驱动开发。这样好处是代码比较健全，考虑的因素比较多。固定模块健壮性高，bug少。</li><li> 先写代码，再通过模拟用户的行为写测试。好处是思路清晰，如果测试用例够全面，基本上线基本没太大问题，回归测试也很好做。</li><li> 写代码之前写测试和用例，写完代码之后再写用户行为测试。这种代码质量就太高了，当然缺点就是费时间。</li></ol><blockquote><p>那么你是哪一种？ 反正我比较佛系哈，有的不写测试，也有的写满测试。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e15932ee51d4540f02fae27&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h1</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>吃透Vue项目开发实践(上)</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/06/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%8A/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/06/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%8A/</id>
    <published>2020-05-06T09:37:11.000Z</published>
    <updated>2020-05-09T15:17:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e0202fc6fb9a0165721e39a">原文地址</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f5676f7940d72a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="概览"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>我将从 16 个方面来论述 vue 开发过程中的一些技巧和原理。当然由于篇幅有限，先论述前 8 个问题，下节将完成全系列内容。</p></blockquote><p>本篇文章将围绕下列问题进行论述：</p><ul><li><strong>如何规范你的 git 提交，并自动生成并提交日志？</strong></li><li><strong>如何配置和使用 Sass 和 PUG 提升你的编码效率？</strong></li><li><strong>如何处理你的代码风格问题，以及如何使用 perttier 与 eslint 解决效率风格两难问题？</strong></li><li><strong>如何管理页面的路由，如何编写异步路由？</strong></li><li><strong>如何编写组件，引入组件库？</strong></li><li><strong>如何管理你的资源，如何引入图标，样式？</strong></li><li><strong>如何封装你的 axios，管理你的api？</strong></li><li><strong>如何使用 mock 模拟你的数据，实现真正意义的前后端分离？</strong></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>实践之前：我希望你有如下准备，或者知识储备。</p><ul><li>了解 <code>npm/yarn/git/sass/pug/vue/vuex/vue-router/axios/mock/ssr/jest</code><br>的使用和原理。</li><li>当然上面知识不了解也没关系哈哈哈，文章中会提到大致用法和作用。</li></ul></blockquote><h3 id="如何规范-git-提交"><a href="#如何规范-git-提交" class="headerlink" title="如何规范 git 提交"></a>如何规范 git 提交</h3><blockquote><p>代码提交记录是一个很好的代码修改日志。规范的代码提交记录，不管在平时代码开发维护过程中，还是在定位 bug 或者回退版本来说都是极为重要。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>两种做法：</p><ul><li>自己手动规范 git 的提交原则或者团队统一制定。这个靠自觉，好习惯养成之后就没问题来</li><li>使用插件规范，比如下面这种</li></ul><p>为了规范提交，我使用了如下插件：</p><ul><li>commitizen</li><li>conventional-changelog</li><li>cz-conventional-changelog</li><li>conventional-changelog-cli<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="安装系列插件依赖"><a href="#安装系列插件依赖" class="headerlink" title="安装系列插件依赖"></a>安装系列插件依赖</h5><pre><code class="sh">yarn add -D commitizen conventional-changelog cz-conventional-changelog</code></pre><blockquote><p>安装依赖时，要注意是否是生产环境需要的。显然 <code>commitizen</code> 只在开发环境中使用。<code>-D</code> 只在 <code>dev</code> 环境使用</p></blockquote><h5 id="配置依赖路径"><a href="#配置依赖路径" class="headerlink" title="配置依赖路径"></a>配置依赖路径</h5>在 <code>package.json</code> 中添加配置<pre><code class="js">&#123;  //...  &quot;config&quot;: &#123;      &quot;commitizen&quot;: &#123;        &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;      &#125;  &#125;&#125;</code></pre>在命令行中输入<pre><code class="sh">git add -Agit-cz</code></pre>出现了交互输入方式，规范你的 <code>commit</code> 输入格式<br><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f554235055e8f3?w=2194&h=620&f=jpeg&s=226477" alt="commit"></li></ul><h5 id="生成-CHANGELOG"><a href="#生成-CHANGELOG" class="headerlink" title="生成 CHANGELOG"></a>生成 CHANGELOG</h5><pre><code class="sh">npm i -g conventional-changelog-cli</code></pre><p>增加一个npm 命令，快速生成日志</p><pre><code class="js">&quot;genlog&quot;: &quot;conventional-changelog -p angular -i .github/CHANGELOG.md -s&quot;</code></pre><p>使用<code>yarn</code>命令生成日志</p><pre><code class="sh">yarn genlog</code></pre><p>自动生成的log</p><h5 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h5><ul><li><strong>git:</strong> 增加commitizen工具规范提交 (<a href="https://github.com/suoyuesmile/suo-design-pro/commit/58e39370aa838fd99312f73b37d092ffadc85990">58e3937</a>)</li></ul><h3 id="如何管理代码风格"><a href="#如何管理代码风格" class="headerlink" title="如何管理代码风格"></a>如何管理代码风格</h3><blockquote><p>较统一的代码风格利于阅读，也利于协作。</p></blockquote><h4 id="原理与解决方案"><a href="#原理与解决方案" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>使用 eslint 约束基本风格和语法，使用 prettier 自动格式化你的代码。</p><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><h5 id="安装-eslint-依赖"><a href="#安装-eslint-依赖" class="headerlink" title="安装 eslint 依赖"></a>安装 eslint 依赖</h5><pre><code class="json">&#123;    &quot;eslint&quot;: &quot;^5.16.0&quot;,    &quot;eslint-config-standard&quot;: &quot;^6.2.1&quot;,    &quot;eslint-friendly-formatter&quot;: &quot;^2.0.7&quot;,    &quot;eslint-loader&quot;: &quot;^2.1.2&quot;,    &quot;eslint-plugin-html&quot;: &quot;^2.0.1&quot;,    &quot;eslint-plugin-promise&quot;: &quot;^3.5.0&quot;,    &quot;eslint-plugin-standard&quot;: &quot;^2.3.1&quot;,    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;&#125;</code></pre><p>使用两个插件，一个 <code>plugin:vue/essential</code>，一个是 <code>standard</code>。<br><code>vue/essential</code> 为了在 vue 里面也可以生效。另一个是 <code>standard</code>。<br><a href="https://github.com/standard/standard/blob/master/docs/RULES-zhcn.md#javascript-standard-style">standard 标准文档</a></p><blockquote><p>使用 recommend 也可以，采用推荐 lint，更加轻量化</p></blockquote><pre><code class="js">module.exports = &#123;  root: true,  env: &#123;    node: true  &#125;,  extends: [&#39;plugin:vue/essential&#39;, &#39;standard&#39;],  rules: &#123;    quotes: [&#39;error&#39;, &#39;single&#39;],    indent: [&#39;error&#39;, 2, &#123; MemberExpression: &#39;off&#39; &#125;],    &#39;arrow-parens&#39;: 0,    &#39;no-loop-func&#39;: 2,    &#39;space-before-function-paren&#39;: [&#39;error&#39;, &#39;never&#39;],    indent: [&#39;error&#39;, 2, &#123; SwitchCase: 1 &#125;]  &#125;,  parserOptions: &#123;    parser: require.resolve(&#39;babel-eslint&#39;),    ecmaVersion: 2018,    sourceType: &#39;module&#39;  &#125;&#125;</code></pre><h5 id="可以自定义-rules-的规则"><a href="#可以自定义-rules-的规则" class="headerlink" title="可以自定义 rules 的规则"></a>可以自定义 rules 的规则</h5><blockquote><p>rules 的规则 { 规则名：[是否关闭/规则等级，配置的值，只对部分配置] }<br><code>indent: [&#39;error&#39;, 2, &#123; SwitchCase: 1 &#125;]</code> 兼容 prettier，prettier 会将代码格式化成 eslint 报错的情况。<br>规则等级：0 关闭 1 警告 2 报错</p></blockquote><h5 id="使用-prettier"><a href="#使用-prettier" class="headerlink" title="使用 prettier"></a>使用 prettier</h5><h6 id="配置-prettier-文件"><a href="#配置-prettier-文件" class="headerlink" title="配置 prettier 文件"></a>配置 prettier 文件</h6><pre><code class="js">&#123;  &quot;printWidth&quot;: 150,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;semi&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;useTabs&quot;: false,  &quot;bracketSpacing&quot;: true,  &quot;jsxBracketSameLine&quot;: false,  &quot;arrowParens&quot;: &quot;always&quot;,  &quot;proseWrap&quot;: &quot;preserve&quot;,  &quot;overrides&quot;: [    &#123;        &quot;files&quot;: [&quot;*.json&quot;, &quot;.eslintrc&quot;, &quot;.tslintrc&quot;, &quot;.prettierrc&quot;, &quot;.tern-project&quot;],        &quot;options&quot;: &#123;            &quot;parser&quot;: &quot;json&quot;,            &quot;tabWidth&quot;: 2        &#125;    &#125;,    &#123;        &quot;files&quot;: &quot;*.&#123;css,sass,scss,less&#125;&quot;,        &quot;options&quot;: &#123;            &quot;parser&quot;: &quot;css&quot;,            &quot;tabWidth&quot;: 2        &#125;    &#125;,    &#123;        &quot;files&quot;: &quot;*.ts&quot;,        &quot;options&quot;: &#123;            &quot;parser&quot;: &quot;typescript&quot;        &#125;    &#125;,    &#123;        &quot;files&quot;: &quot;*.vue&quot;,        &quot;options&quot;: &#123;            &quot;parser&quot;: &quot;vue&quot;        &#125;    &#125;,    &#123;        &quot;files&quot;: &quot;*.md&quot;,        &quot;options&quot;: &#123;            &quot;parser&quot;: &quot;markdown&quot;        &#125;    &#125;  ]&#125;</code></pre><h5 id="开启-vscode-自动格式化"><a href="#开启-vscode-自动格式化" class="headerlink" title="开启 vscode 自动格式化"></a>开启 vscode 自动格式化</h5><pre><code class="json">&#123;  // prettier  &quot;prettier.singleQuote&quot;: true,  &quot;prettier.semi&quot;: false,  &quot;prettier.tabWidth&quot;: 2,  &quot;[javascript]&quot;: &#123;    &quot;editor.formatOnSave&quot;: true,    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  &#125;&#125;</code></pre><h3 id="如何提升编码效率"><a href="#如何提升编码效率" class="headerlink" title="如何提升编码效率"></a>如何提升编码效率</h3><h4 id="原理与解决方案-1"><a href="#原理与解决方案-1" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>我主要从 3 个方面来做一些编码效率上的改进</p><ul><li>升级你的 vue-cli 减少 webpack 配置的成本</li><li>使用 sass，利用里面函数、mixins、变量提升 css 文件的复用</li><li>使用 pug，减少 html 的代码编写量</li></ul><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><blockquote><p><code>vue-cli3+、vue-cli4+</code> 相比于 <code>vue-cli2+</code> 最大的改变就是将约定俗称的配置，全部公共化了，也就是做了一次二次封装。这样的好处在于，我们不必要在繁多的配置代码中寻找需要的配置。</p></blockquote><p>简单新建一个配置入口就能操作我们大多数想要的功能。在 <code>root</code> 目录下新建一个 <code>vue.config.js</code> 文件，作为我们 <code>webpack</code> 的配置文件。</p><p><strong>初始化 vue 配置</strong></p><pre><code class="js">const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = &#123;  publicPath: process.env === &#39;production&#39; ? &#39;&#39; : &#39;/&#39;,  outputDir: &#39;dist&#39;,  assetsDir: &#39;static&#39;,  filenameHashing: true,  lintOnSave: true,  runtimeCompiler: false,  transpileDependencies: [/\/node_modules\/vue-echarts\//, /\/node_modules\/resize-detector\//],  productionSourceMap: false&#125;</code></pre><p>简单的配置完成后，我们引入一个 <code>sass</code> 工具用于编写 <code>sass</code>文件</p><blockquote><p>用法见 sass <a href="https://www.sass.hk/docs/">参考资料</a>！</p></blockquote><h5 id="使用-Sass"><a href="#使用-Sass" class="headerlink" title="使用 Sass"></a>使用 Sass</h5><h6 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h6><pre><code class="sh">yarn add -D sass sass-loader</code></pre><h6 id="如何处理样式"><a href="#如何处理样式" class="headerlink" title="如何处理样式"></a>如何处理样式</h6><p>在 <code>assets</code> 目录中建立一个 styles 文件专门来存放样式文件，新增入口<code>index.scss</code>文件，便于 JavaScript 引入，增加 utils.scss、reset.scss、varibles 文件。</p><blockquote><p>这些样式工具都是为了提升我们 <code>scss</code> 开发效率，具有畅快的开发体验！</p></blockquote><h6 id="使用-varibles-变量文件"><a href="#使用-varibles-变量文件" class="headerlink" title="使用 varibles 变量文件"></a>使用 varibles 变量文件</h6><p>为了提升我们代码的可读性，复用性。使用 <code>sass</code> 变量必不可少。</p><p>还有一点就是利于全局修改样式，如果需要更换皮肤这个功能，我们只需要更改全局的主题色，即可更换主题，那样更加方便。</p><pre><code class="scss">// 主题色$color-red: #ff3333;$color-purple: #ff33a9;$color-orange: #ff8833;$color-blue: #3377ff;// 文字色$color-black: #000;$color-dark: #333;$color-deep: #555;$color-pl: #999999;$color-weak: #B3B3B3;$color-white: #fff;// 背景色$bg-bar: #F9F9F9;$bg-page: #F3F3F3;$bg-page-light: #F9F9F9;</code></pre><p>使用变量之后，sass 文件不会直接生效，至少在 vue 文件 里面是访问不到的。<br>需要在 <code>vue.config.js</code> 里面增加如下配置。</p><pre><code class="js">module.exports = &#123;    // ...    css: &#123;        sourceMap: true,        loaderOptions: &#123;            sass: &#123;                prependData: `        @import &quot;@/assets/styles/variable.scss&quot;;        `            &#125;        &#125;    &#125;&#125;</code></pre><h6 id="覆盖默认样式"><a href="#覆盖默认样式" class="headerlink" title="覆盖默认样式"></a>覆盖默认样式</h6><p>常规操作, 引入 reset.scss 将默认样式覆盖掉</p><pre><code class="scss">/* http://meyerweb.com/eric/tools/css/reset/   v2.0 | 20110126   License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header, hgroup,menu, nav, output, ruby, section, summary,time, mark, audio, video &#123;    margin: 0;    padding: 0;    border: 0;    font-size: 100%;    font: inherit;    vertical-align: baseline;&#125;/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section &#123;    display: block;&#125;body &#123;    line-height: 1;&#125;ol, ul &#123;    list-style: none;&#125;blockquote, q &#123;    quotes: none;&#125;blockquote:before, blockquote:after,q:before, q:after &#123;    content: &#39;&#39;;    content: none;&#125;table &#123;    border-collapse: collapse;    border-spacing: 0;&#125;html, body &#123;  width: 100%;  height: 100%;  overflow: auto;  margin: 0;  scroll-behavior: smooth;  -webkit-overflow-scrolling: touch;&#125;</code></pre><h6 id="使用样式工具集"><a href="#使用样式工具集" class="headerlink" title="使用样式工具集"></a>使用样式工具集</h6><p>有时候我们发现，光是引入变量还不够，变量工具只能允许我们在 css 类文件中使用。假如我想着模版中直接使用样式，有没有更快的方案呢？<br>当然有的，我们可以自定义一个常用的样式工具集。设置一些背景颜色、字体颜色、盒子模型中的常规操作。</p><blockquote><p>要是有设计规范更好哦，我也是常常向设计师提出要求，一定要制定出一套产品的设计规范。</p></blockquote><pre><code class="scss">/* // utils 工具// 颜色 */.bg-red &#123;background-color: $color-red!important;&#125;.bg-purple &#123;background-color: $color-purple!important;&#125;.bg-orange &#123;background-color: $color-orange!important;&#125;.bg-blue &#123;background-color: $color-blue!important;&#125;.color-red &#123;color: $color-red!important;&#125;.color-purple &#123;color: $color-purple!important;&#125;.color-orange &#123;color: $color-orange!important;&#125;.color-blue &#123;color: $color-blue!important;&#125;.text-black &#123;color: #000;&#125;.text-dark &#123;color: #333;&#125;.text-deep &#123;color: #555;&#125;.text-weak &#123;color: #B3B3B3;&#125;.text-white &#123;color: #fff;&#125;/* // 字体 */.f10 &#123;font-size: 10px;&#125;.f12 &#123;font-size: 12px;&#125;.f14 &#123;font-size: 14px;&#125;.f15 &#123;font-size: 15px;&#125;.f17 &#123;font-size: 17px;&#125;.f20 &#123;font-size: 20px;&#125;.f24 &#123;font-size: 24px;&#125;/* // 文字对齐 */.tl &#123;text-align: left;&#125;.tc &#123;text-align: center;&#125;.tr &#123;text-align: right;&#125;/* // 浮动与清除浮动 */.fl &#123;float: left;&#125;.fr &#123;float: right;&#125;.fix &#123;*zoom: 1;&#125;.fix:after&#123;display:table; content:&#39;&#39;; clear:both;&#125;/* // 显示 */.dn&#123;display:none;&#125;.di&#123;display:inline;&#125;.db&#123;display:block;&#125;.dib&#123;display:inline-block;&#125;.dt&#123;display:table;&#125;div.dib&#123;*display:inline; *zoom:1;&#125;.vm &#123;vertical-align: middle;&#125;.vib &#123;display:inline-block; vertical-align: middle;&#125;/* // 定位 */.pr &#123;position: relative;&#125;.pa &#123;position: absolute;&#125;.pf &#123;position: fixed;&#125;/* // 盒子模型 */.ml4 &#123;margin-left: 4px;&#125;.mr4 &#123;margin-right: 4px;&#125;.mt4 &#123;margin-top: 4px;&#125;.mb4 &#123;margin-bottom: 4px;&#125;.ml8 &#123;margin-left: 8px;&#125;.mr8 &#123;margin-right: 8px;&#125;.mt8 &#123;margin-top: 8px;&#125;.mb8 &#123;margin-bottom: 8px;&#125;.ml12 &#123;margin-left: 12px;&#125;.mr12 &#123;margin-right: 12px;&#125;.mt12 &#123;margin-top: 12px;&#125;.mb12 &#123;margin-bottom: 12px;&#125;.ml16 &#123;margin-left: 16px;&#125;.mr16 &#123;margin-right: 16px;&#125;.mt16 &#123;margin-top: 16px;&#125;.mb16 &#123;margin-bottom: 16px;&#125;.ml20 &#123;margin-left: 20px;&#125;.mr20 &#123;margin-right: 20px;&#125;.mt20 &#123;margin-top: 20px;&#125;.mb20 &#123;margin-bottom: 20px;&#125;.ml24 &#123;margin-left: 24px;&#125;.mr24 &#123;margin-right: 24px;&#125;.mt24 &#123;margin-top: 24px;&#125;.mb24 &#123;margin-bottom: 24px;&#125;.ml10 &#123;margin-left: 10px;&#125;.mr10 &#123;margin-right: 10px;&#125;.mt10 &#123;margin-top: 10px;&#125;.mb10 &#123;margin-bottom: 10px;&#125;.ml15 &#123;margin-left: 15px;&#125;.mr15 &#123;margin-right: 15px;&#125;.mt15 &#123;margin-top: 15px;&#125;.mb15 &#123;margin-bottom: 15px;&#125;/* // 按钮禁用 */.disabled&#123;outline:0 none; cursor:default!important; opacity:.4; filter:alpha(opacity=40); -ms-pointer-events:none; pointer-events:none;&#125;</code></pre><h6 id="增加样式入口文件"><a href="#增加样式入口文件" class="headerlink" title="增加样式入口文件"></a>增加样式入口文件</h6><p>最后一步，新建一个入口文件，将样式工具类全部导入进来，供主程序引入。</p><pre><code class="scss">// index.scss 文件import &#39;./reset.scss&#39;;import &#39;./varibles.scss&#39;;improt &#39;./utils/scss&#39;;</code></pre><p>在 <code>main.js</code> 中直接引入 <code>index.scss</code></p><pre><code class="js">import &#39;@/assets/styles/index.scss&#39;</code></pre><h3 id="vue-中写样式要注意哪些方面，有哪些技巧呢？"><a href="#vue-中写样式要注意哪些方面，有哪些技巧呢？" class="headerlink" title="vue 中写样式要注意哪些方面，有哪些技巧呢？"></a>vue 中写样式要注意哪些方面，有哪些技巧呢？</h3><h4 id="避免全局污染"><a href="#避免全局污染" class="headerlink" title="避免全局污染"></a>避免全局污染</h4><p>在页面中写 <code>css/scss</code> 加上 <code>scoped</code>，<code>scoped</code> 的功能就是使页面的样式是局部的，不让影响其他页面的样式。</p><h4 id="bem-规范"><a href="#bem-规范" class="headerlink" title="bem 规范"></a>bem 规范</h4><p>我们大多数人时候会遇到问题，<strong>样式嵌套太多了怎么命名</strong></p><blockquote><p>BEM是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。</p></blockquote><p>名字太长易读性太差</p><pre><code class="scss">.cardbox &#123;    .cardbox-card &#123;        .cardbox-card-wrapper            .cardbox-card-wrapper-header &#123;                .cardbox-card-wrapper-header-title &#123;                    // ...                &#125;            &#125;            .cardbox-card-wrapper-body&#123;                .cardbox-card-item &#123;                    .cardbox-card-item-title &#123;                        // ...                    &#125;                &#125;          &#125;        &#125;    &#125;&#125;</code></pre><h4 id="bem-使用方式"><a href="#bem-使用方式" class="headerlink" title="bem 使用方式"></a>bem 使用方式</h4><p><code>block-name__element-name--color</code></p><ul><li>区分块，子元素，修饰元素</li><li>块，页面中独立的单元</li><li>子元素，块里面的儿子 <code>card__item</code> 使用 <code>__</code> 连接</li><li>子元素长命名使用 - 连接</li><li>修饰（易变的）<code>card__item--warning</code> 使用 <code>--</code></li></ul><p>我们使用 bem 改造样式</p><pre><code class="scss">.cardbox &#123;    &amp;__header &#123;        &amp;__title &#123;            //...        &#125;    &#125;    &amp;__body &#123;        &amp;__item &#123;            &amp;__title &#123;                //...            &#125;        &#125;    &#125;&#125;</code></pre><blockquote><p>bem 一般推荐子元素嵌套尽量在2-3层以内</p></blockquote><p>但是我们发现样式子元素嵌套有点多，使用了两重子元素嵌套。</p><p>大致原理是<strong>尝试分离父子元素的关系，把卡片本身当作一个块看待。</strong></p><p>下面来试着去减少嵌套：</p><pre><code class="scss">.cardbox &#123;    &amp;__header &#123;        &amp;__title &#123;            //...        &#125;    &#125;    &amp;__body &#123;        .card &#123;            &amp;__title &#123;                //...            &#125;        &#125;    &#125;&#125;</code></pre><p>现在编写样式效率提高也更加规范了，那么编写 HTML 也是有很多累赘的代码。</p><p>比如大多数标签都是前开后闭的。通过 pug 我们可以省略很多字符的敲打，下面我们谈谈如何使用 pug 编写模版。</p><blockquote><p>当然喜欢哪种 HTML 编写风格见人见智啦，我自己更加倾向 pug，那种缩进和简洁的表达，有种在写 scss 的感觉。</p></blockquote><h3 id="如何使用-pug"><a href="#如何使用-pug" class="headerlink" title="如何使用 pug"></a>如何使用 pug</h3><h4 id="实践：类似-sass，首先安装-pug-和-pug-的-loader"><a href="#实践：类似-sass，首先安装-pug-和-pug-的-loader" class="headerlink" title="实践：类似 sass，首先安装 pug 和 pug 的 loader"></a>实践：类似 sass，首先安装 pug 和 pug 的 loader</h4><pre><code>yarn add -D pug pug-html-loader pug-plain-loader</code></pre><h4 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h4><pre><code class="js">module.exports = &#123;  // ...  chainWebpack: (config) =&gt; &#123;    config.module      .rule(&#39;pug&#39;)      .test(/\.pug$/)      .use(&#39;pug-html-loader&#39;)      .loader(&#39;pug-html-loader&#39;)      .end()  &#125;&#125;</code></pre><h4 id="编写-pug-代码"><a href="#编写-pug-代码" class="headerlink" title="编写 pug 代码"></a>编写 pug 代码</h4><p>使用 scss 工具与 pug 完美搭配，少写很多代码</p><pre><code class="html">// 登陆&lt;template lang=&quot;pug&quot;&gt;  .login    h1.login__title.ml15 注册/登陆    .login__form.mt15.ml15      van-field.login__form__input(placeholder=&quot;输入手机号&quot; v-model=&quot;phone&quot;)      .login__form__protocol.mt15        .login__form__protocol__tips.dib.text-weak 注册或登录即表示同意        .login__form__protocol__name.dib.color-orange 《用户协议》      app-button.mt15(size=&quot;large&quot;        theme=&quot;orange&quot;        :disabled=&quot;phone.length !== 11&quot;        @click=&quot;handleSubmit&quot;      ) 下一步&lt;/template&gt;</code></pre><p>我们已经引入了样式，接下来我将谈谈其他资源的引入</p><h3 id="如何管理你的资源"><a href="#如何管理你的资源" class="headerlink" title="如何管理你的资源"></a>如何管理你的资源</h3><h4 id="原理与解决方案-2"><a href="#原理与解决方案-2" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>我暂时把资源分为下面几种</p><ul><li>字体</li><li>ICON</li><li>图片</li><li>样式<br><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f55578916de772?imageslim" alt="资源"><br>把他们各自新建一个目录，都放在 assets 目录下面分门别类，供其他地方调用。<br>使用 alias 更好重命名，使之更便捷的访问到。</li></ul><p>增加 <code>vue.config.js</code> 配置 ,设置<code>assets</code>别名</p><pre><code class="js">const path = require(&#39;path&#39;)function resolve(dir) &#123;  return path.join(__dirname, dir)&#125;module.exports = &#123;  //...  chainWebpack: (config) =&gt; &#123;    config.resolve.alias.set(&#39;@&#39;, resolve(&#39;src&#39;)).set(&#39;@assets&#39;, resolve(&#39;src/assets&#39;))  &#125;&#125;</code></pre><h5 id="ICON"><a href="#ICON" class="headerlink" title="ICON"></a>ICON</h5><h6 id="引入-iconfont"><a href="#引入-iconfont" class="headerlink" title="引入 iconfont"></a>引入 iconfont</h6><ul><li>(1) <a href="https://www.iconfont.cn/manage/index">iconfont</a> 阿里图标项目中下载，将整个项目图标包一起下载下来</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f462a5119bdcdf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ICON"></p><ul><li>(2) 引入 iconfont 样式<br>需要下面四个文件</li></ul><ul><li><code>iconfont.eot</code></li><li><code>iconfont.ttf</code></li><li><code>iconfont.woff</code></li><li><code>iconfont.woff2</code></li></ul><ul><li>(3)  项目中引入 iconfont</li></ul><p>让 <code>icon</code> 组件化</p><pre><code class="html">&lt;template&gt;  &lt;i class=&quot;iconfont&quot; v-on=&quot;$listeners&quot; :class=&quot;name&quot;&gt;&lt;/i&gt;&lt;/template&gt;&lt;script&gt;export default &#123;  props: &#123;    name: String  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.iconfont &#123;  font-size: 16px;  color: $color-icon;&#125;&lt;/style&gt;</code></pre><h6 id="引入图片作为-ICON"><a href="#引入图片作为-ICON" class="headerlink" title="引入图片作为 ICON"></a>引入图片作为 ICON</h6><p>让图片组件化，我们再来写一个 img 组件</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  img(    :src=&quot;require(`@/assets/images/$&#123;name&#125;.png`)&quot;    v-bind=&quot;$attrs&quot;    v-on=&quot;$listeners&quot;    :style=&quot;&#123;&#39;width&#39;: width ? width + &#39;px&#39; : size + &#39;px&#39;, &#39;height&#39;: height ? height + &#39;px&#39; : size + &#39;px&#39; &#125;&quot;)&lt;/template&gt;&lt;script&gt;export default &#123;  name: &#39;app-img&#39;,  props: &#123;    name: &#123;      type: String,      default: &#39;&#39;    &#125;,    size: &#123;      type: Number,      default: 16    &#125;,    width: &#123;      type: Number,      default: 0    &#125;,    height: &#123;      type: Number,      default: 0    &#125;  &#125;&#125;&lt;/script&gt;</code></pre><h3 id="如何管理你的路由"><a href="#如何管理你的路由" class="headerlink" title="如何管理你的路由"></a>如何管理你的路由</h3><h4 id="原理与解决方案-3"><a href="#原理与解决方案-3" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>使用 vue-router，使用<code>import()</code> 生成异步路由，只有在访问时候才会加载模块。</p><p>为什么使用 <code>import()</code> 会异步加载模块？</p><blockquote><p>MDN：在您希望按照一定的条件或者按需加载模块的时候，动态import() 是非常有用的。而静态型的 import 是初始化加载依赖项的最优选择，使用静态 import 更容易从代码静态分析工具和 tree shaking 中受益。</p></blockquote><p>说白了就是起到一个<strong>按需加载</strong>的目的。现在大多数实现的按需加载，基本都是依赖 <code>import()</code> 这个方法。</p><h5 id="安装-vue-router"><a href="#安装-vue-router" class="headerlink" title="安装 vue-router"></a>安装 vue-router</h5><pre><code class="sh">yarn add vue-router</code></pre><p>安装完 <code>router</code>，在编写 <code>router</code> 先创建页面</p><h5 id="新建一个空页面"><a href="#新建一个空页面" class="headerlink" title="新建一个空页面"></a>新建一个空页面</h5><p>src 目录下新增 views 目录存放页面文件。创建 index 目录和 home 页面</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  .home 首页&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h5 id="编写路由"><a href="#编写路由" class="headerlink" title="编写路由"></a>编写路由</h5><pre><code class="js">const routes = [    &#123;        // 首页        path: &#39;/&#39;,        name: &#39;index&#39;,        redirect: &#39;/home&#39;,        component: App,        children: [            &#123;                // 首页                path: &#39;home&#39;,                name: &#39;home&#39;,                // 路由懒加载                component: () =&gt;                    import(                        /* webpackChunkName: &quot;index&quot; */ &#39;../views/index/home.vue&#39;                    )            &#125;        ]    &#125;]Vue.use(VueRouter)const router = new VueRouter(&#123;    mode: &#39;history&#39;,    routes: routes,    base: process.env.BASE_URL,    props: true&#125;)export default router</code></pre><h5 id="为了消除-显得路径更加好看简洁，我们采用-history-模式，但是-history-模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到"><a href="#为了消除-显得路径更加好看简洁，我们采用-history-模式，但是-history-模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到" class="headerlink" title="为了消除 # 显得路径更加好看简洁，我们采用 history 模式，但是 history 模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到"></a>为了消除 # 显得路径更加好看简洁，我们采用 history 模式，但是 history 模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到</h5><p>在 vue.config.js 中增加配置，开发环境可以访问到，恢复正常</p><pre><code class="js">module.exports = &#123;  // ...  devServer: &#123;    historyApiFallback: true  &#125;&#125;</code></pre><blockquote><p>关于路由还有很多可以研究到地方，可以自行研究哦！</p></blockquote><h3 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h3><h4 id="原理与解决方案-4"><a href="#原理与解决方案-4" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>一般来说，我们根据组件的复用度，分给基础（公共）组件和业务组件。</p><p>为了节省时间，快速开发，这里基础组件大部分引用开源组件。当然不能直接就用哦。</p><p>一般要进行二次封装，也就是高阶组件开发。</p><ol><li>通过修改和覆盖当前组件的样式来达到修改样式的作用。</li><li>通过拦截事件来更改js的逻辑。</li></ol><p>下面我们先引入 <code>vant</code> 组件</p><h4 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a>实践</h4><h5 id="引入-vant"><a href="#引入-vant" class="headerlink" title="引入 vant"></a>引入 vant</h5><pre><code class="sh">yarn add vant</code></pre><h4 id="对基础组件进行二次封装和改造"><a href="#对基础组件进行二次封装和改造" class="headerlink" title="对基础组件进行二次封装和改造"></a>对基础组件进行二次封装和改造</h4><p>下面 7 步来写好一个公共组件</p><ul><li>(1) 新建一个 <code>components</code> 目录来存放基础组件</li><li>(2) 基础组件命名为 <code>app-xxx</code> 或 <code>appXxx</code>，新建一个 <code>app-button</code> 目录，新建 <code>index.vue</code></li><li>(3) 根据设计稿设计和编写组件<blockquote><p>编写组件之前首先要设计组件，根据组件的不变性和可变性原则编写。不变性是组件的核心，可变性根据参数对组件对相关部分进行调节，实现可选择的功能。</p></blockquote></li><li>(4) 实现组件</li></ul><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  div.dib    van-button.btn(      @click=&quot;$emit(&#39;click&#39;)&quot;      :class=&quot;getClass&quot; v-bind=&quot;$attrs&quot;      :style=&quot;&#123;&#39;width&#39;: size === &#39;large&#39; ? &#39;345px&#39;: &#39;&#39;, &#39;backgroundColor&#39;: getBgColor, borderColor: getBgColor, color: getBgColor&#125;&quot;)      slot&lt;/template&gt;&lt;script&gt;import &#123; Button &#125; from &#39;vant&#39;import Vue from &#39;vue&#39;import &#123; getColor &#125; from &#39;@/utils&#39;Vue.use(Button)export default &#123;  name: &#39;app-button&#39;,  props: &#123;    type: &#123;      type: String,      default: &#39;primary&#39;    &#125;,    theme: &#123;      type: String,      default: &#39;blue&#39;    &#125;,    size: &#123;      type: String,      default: &#39;&#39;    &#125;  &#125;,  computed: &#123;    getClass() &#123;      if (!this.type) &#123;        return &#39;&#39;      &#125;      return `app-btn--$&#123;this.type&#125;`    &#125;,    getBgColor() &#123;      if (!this.theme) &#123;        return &#39;&#39;      &#125;      return getColor(this.theme)    &#125;  &#125;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.app-btn  &#123;  ::v-deep &amp;--primary &#123;    padding: 8px 30px;    height: 40px;    border-radius: 4px;    font-size: 15px;    font-weight: 400;    line-height: 19px;    color: white!important;  &#125;  ::v-deep &amp;--minor &#123;    padding: 5px 10px;    height: 26px;    border-radius: 14px;    font-size: 12px;    font-weight: 400;    line-height: 16px;    background-color: #fff!important;  &#125;  ::v-deep &amp;--rect &#123;    padding: 5px px;    height: 49px;    font-size: 14px;    color: white!important;  &#125;&#125;&lt;/style&gt;</code></pre><blockquote><p>::v-deep  样式深覆盖，scoped 情况下覆盖组件样式，不改变其样式</p></blockquote><ul><li>(5) 写好基础组件 README，为什么要写文档呢？如果多人开发同一个项目，基础组件会被其他人引用。方便其他人使用，所以要写文档。</li></ul><blockquote><p>一句话言：只要可能被其他人用的公共方法和组件，注释或文档是很重要的，对自己的代码负责哈。</p></blockquote><p>其他用法参照 vant</p><ul><li>(6) 全局引用，基础组件许多页面都会用到，将其设置成全局组件，其他地方就不必再引用了哦。</li></ul><p>新建一个文件 <code>global</code> 存放全局组件注册，在 <code>main.js</code> 引入</p><pre><code class="javascript">import Vue from &#39;vue&#39;import appButton from &#39;@/components/app-button&#39;Vue.component(&#39;app-button&#39;, appButton)</code></pre><ul><li>(7) 写好 <code>demo</code>，即使暂时不写单元测试，也要写好一个 <code>demo</code>，使之能正常的运行</li></ul><p>添加 demo 页面和路由</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  div(class=&quot;base&quot;)    // 按钮组件    app-button.mt4(theme=&quot;blue&quot;) 确认支付    app-button(theme=&quot;orange&quot;) 确认支付    app-button(theme=&quot;purple&quot;) 确认支付    app-button.mt4(theme=&quot;red&quot;) 确认支付    app-button(theme=&quot;grey&quot;) 确认支付    app-button.mt4(theme=&quot;blue&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;orange&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;purple&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;red&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;grey&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;blue&quot; type=&quot;minor&quot;) 确认收货    app-button(theme=&quot;orange&quot; type=&quot;minor&quot;) 确认收货    app-button(theme=&quot;purple&quot; type=&quot;minor&quot;) 确认收货    app-button(theme=&quot;red&quot; type=&quot;minor&quot;) 修改地址    app-button(theme=&quot;grey&quot; type=&quot;minor&quot;) 修改地址    app-button.mt4(theme=&quot;blue&quot; type=&quot;rect&quot;) 确认收货    app-button(theme=&quot;orange&quot; type=&quot;rect&quot;) 确认收货    app-button(theme=&quot;purple&quot; type=&quot;rect&quot;) 确认收货    app-button(theme=&quot;red&quot; type=&quot;rect&quot;) 修改地址    app-button(theme=&quot;grey&quot; type=&quot;rect&quot;) 修改地址&lt;/template&gt;&lt;script&gt;export default &#123;&#125;&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;</code></pre><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f55700de463c65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h3 id="如何封装请求"><a href="#如何封装请求" class="headerlink" title="如何封装请求"></a>如何封装请求</h3><h4 id="原理与解决方案-5"><a href="#原理与解决方案-5" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>基本上就是对 axios 的封装，封装主要有两个目的。</p><ul><li>修改一些基础的配置：请求地址，超时，其他的杂七杂八的</li><li>统一操作：统一处理错误，统一处理请求参数和格式，响应参数和格式。统一处理 message，统一拦截挂载等等。</li></ul><p>网上已经有很多类似的文章了， 我这里给出我常用的封装方案。</p><h4 id="实践-4"><a href="#实践-4" class="headerlink" title="实践"></a>实践</h4><h5 id="根据不同环境设置请求地址"><a href="#根据不同环境设置请求地址" class="headerlink" title="根据不同环境设置请求地址"></a>根据不同环境设置请求地址</h5><pre><code class="js">// .env-default.js 文件// 不同环境访问不同的路径const api = &#123;  develop: &#39;http://xxxx:8080&#39;,  mock: &#39;http://xxxx&#39;,  feature: &#39;http://xxxx&#39;,  test: &#39;http://xxxx&#39;,  production: &#39;http://xxxx&#39;&#125;export const baseURL = api[process.env.NODE_ENV || &#39;dev&#39;]</code></pre><blockquote><p>因为每个人开发环境，mock环境不一定相同，这个文件建议 gitignore忽略掉。模版可以写在 readme 文档中，启动项目时加入文件。</p></blockquote><h5 id="新建一个-utils-工具"><a href="#新建一个-utils-工具" class="headerlink" title="新建一个 utils 工具"></a>新建一个 <code>utils</code> 工具</h5><p>我们现在将 axios 封装成我们自己需要的配置，然后定义四个常用的请求方法供调用</p><pre><code class="js">// utils/http.js 文件import axios from &#39;axios&#39;import &#123; baseURL &#125; from &#39;../../.env-defalut.js&#39;// axios 配置const defaultBaseUrl = &#39;http://localhost:8080/&#39;// 默认超时时间axios.defaults.timeout = 15000// 数据接口域名统一配置.envaxios.defaults.baseURL = baseURL || defaultBaseUrl // http request 拦截器axios.interceptors.request.use(  (config) =&gt; &#123;    config.headers = &#123;    &#125;    return config  &#125;,  (err) =&gt; &#123;    return Promise.reject(err)  &#125;)// http response 拦截器axios.interceptors.response.use(  (response) =&gt; &#123;    return response  &#125;,  (error) =&gt; &#123;    const data = error.response.data    return Promise.reject(data || error)  &#125;)export default axios/** * fetch 请求方法 * @param &#123;*&#125; url * @param &#123;*&#125; params */export function fetch(url, params = &#123;&#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios      .get(url, &#123;        params: params      &#125;)      .then((response) =&gt; &#123;        resolve(response.data)      &#125;)      .catch((err) =&gt; &#123;        reject(err)      &#125;)  &#125;)&#125;/** * post 请求方法，发送数据格式 json * @param &#123;*&#125; url * @param &#123;*&#125; data */export function post(  url,  data = &#123;&#125;,  config = &#123;    transformRequest: [      function(fData, headers) &#123;        headers[&#39;Content-Type&#39;] = &#39;application/json&#39;        return JSON.stringify(fData)      &#125;    ]  &#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.post(url, data, config).then(      (response) =&gt; &#123;        resolve(response.data)      &#125;,      (err) =&gt; &#123;        reject(err)      &#125;    )  &#125;)&#125;/** * patch 请求方法，发送数据格式 json * @param &#123;*&#125; url * @param &#123;*&#125; data */export function patch(url, data = &#123;&#125;) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios      .patch(url, data, &#123;        transformRequest: [          function(fData, headers) &#123;            headers[&#39;Content-Type&#39;] = &#39;application/json&#39;            return JSON.stringify(fData)          &#125;        ]      &#125;)      .then(        (response) =&gt; &#123;          resolve(response.data)        &#125;,        (err) =&gt; &#123;          reject(err)        &#125;      )  &#125;)&#125;export function del(url, data) &#123;  return new Promise((resolve, reject) =&gt; &#123;    axios.delete(url, &#123; data &#125;).then(      (response) =&gt; &#123;        resolve(response.data)      &#125;,      (err) =&gt; &#123;        reject(err)      &#125;    )  &#125;)&#125;</code></pre><h3 id="如何管理-api"><a href="#如何管理-api" class="headerlink" title="如何管理 api"></a>如何管理 api</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>首先要制定一个 api 的原则<br>我的原则一般是这些：</p><ul><li>干净纯粹</li><li>尽量不要处理数据</li><li>独立单一不要互相依赖</li></ul><p>好处在于：不在 api 里面处理数据，api里面的接口和接口文档上一样。避免别人引用我的api，还要去看代码，只需要看文档就好了。</p><blockquote><p>例子：想象这样一种情况，别人引用了我的 api，突然发现响应数据不对。首先它排查到页面数据没更改。看了api文档，数据也没问题，最后发现我在写 api 的时候进行了处理，这个 api 呢又不能改动，改了影响我自己的模块。只能它在重新写一个api，这样显得很繁杂了，不够干净优雅。</p></blockquote><pre><code class="js">import &#123; fetch, post &#125; from &#39;@/utils/http&#39;// 用户登陆export const login = data =&gt; post(&#39;/user/login&#39;, data)// 获取用户信息export const getUserInfo = (data) =&gt; fetch(&#39;/api/user/info&#39;, data)</code></pre><p>如果需要处理数据，要么使用一个中间工具处理，要么在页面里面处理。当然还是实际问题实际分析。</p><h3 id="如何使用mock模拟数据"><a href="#如何使用mock模拟数据" class="headerlink" title="如何使用mock模拟数据"></a>如何使用<code>mock</code>模拟数据</h3><h4 id="原理与解决方案-6"><a href="#原理与解决方案-6" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>一般就是两种方案，一是模拟后端，使用远程在线 JSON 服务器。另外一种搭建本地 JSON 或者 使用现成的 Node 服务器拦截请求。</p><blockquote><p>这两种方式各有千秋，没有优劣之分，适合就是最好的。</p></blockquote><h4 id="远程在线mock"><a href="#远程在线mock" class="headerlink" title="远程在线mock"></a>远程在线<code>mock</code></h4><p>我用过的远程在线<code>mock</code></p><ul><li>apizza：好用，功能齐全，喜欢他的文件展开目录<code>api</code>，免费版只支持 2 个人共同编辑</li><li>swagger：开源免费，<code>api</code>管理太凌乱，</li><li>rap/rap2：开源免费，可以搭建本地<code>api</code>，需要自己搭建</li></ul><p>使用远程<code>mock</code>的优点：</p><ul><li>不需要在项目内部增加<code>mock</code></li><li>功能更加全面完善</li><li>可以在接口文档基础上<code>mock</code>，与接口文档放在一起查看更加方便。</li></ul><p>缺点：需要自己另外搭建服务器，只支持静态的<code>mock</code>，不能与单元测试结合使用</p><h4 id="本地JSON-mock"><a href="#本地JSON-mock" class="headerlink" title="本地JSON mock"></a>本地JSON mock</h4><ul><li>使用 <code>webpack</code> 内部 mock 配置</li></ul><pre><code class="js">devServer: &#123;    // 接口未实现情况下，使用mock    before: require(&#39;./mock&#39;)&#125;</code></pre><p>基本原理：主要是使用 node 读取文件，转换成 JSON 格式，使用<code>mock.js</code> 模拟数据，最后 webpack 拦截请求生成<code>json</code>响应数据</p><pre><code class="js">const Mock = require(&#39;mockjs&#39;)module.exports = (app) =&gt; &#123;    function getJsonFile (filePath) &#123;        var json = fs.readFileSync(path.resolve(__dirname, filePath), &#39;utf-8&#39;)        return JSON.parse(json)    &#125;,    const returnMock = (datafile, res, req) =&gt; &#123;        setTimeout(() =&gt; &#123;            var json            if (/\.json$/.test(datafile)) &#123;                // json文件暴露的是mock的模板                json = getJsonFile(datafile)            &#125; else if (/\.js$/.test(datafile)) &#123;                json = require(datafile)(req.query)            &#125;            res.json(Mock.mock(json))        &#125;, 500)    &#125;&#125;</code></pre><ul><li>使用 <code>json-server</code> 搭建<br>主要分为下面几步</li></ul><ol><li><code>npm</code> 安装 <code>json-server</code></li><li>编写 <code>npm</code> 脚本命令，引入 <code>mock</code> 配置文件</li><li>编写 <code>mock</code> 路由匹配规则<blockquote><p>比较简单这里不详细描述了！</p></blockquote></li></ol><p>本地的缺点在于需要</p><ul><li>前端需要根据<code>api</code>文档写<code>mock</code>数据格式</li><li>功能没有远程<code>mock</code>那么完善，支持<code>restful</code>需要去研究下</li><li>也是需要配置相关<code>mock</code>工具</li></ul><p>优点在于</p><ul><li>不用查看编辑<code>api</code>文档</li><li>在代码中就可以更改和查看<code>mock</code>数据</li><li>支持使用<code>JavaScipt</code>动态处<code> mock</code>，可以与单元测试结合使用</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/commitizen/cz-cli">commitizen</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import">MDN import()</a></li><li><a href="https://youzan.github.io/vant/#/zh-CN/intro">vant 文档</a></li><li><a href="https://eslint.org/">eslint 文档</a></li><li><a href="https://router.vuejs.org/zh/">vue-router 文档</a></li><li><a href="https://www.sasscss.com/getting-started/">sass 文档</a></li><li><a href="https://github.com/axios/axios">axios 文档</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e0202fc6fb9a0165721e39a&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2</summary>
      
    
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/categories/Vue/"/>
    
    
    <category term="Vue" scheme="https://shinichikudo-fe.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>12个前端必会 H5 问题及解决方法</title>
    <link href="https://shinichikudo-fe.github.io/2020/05/05/HTML5/12%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A-H5-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://shinichikudo-fe.github.io/2020/05/05/HTML5/12%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A-H5-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</id>
    <published>2020-05-05T13:14:45.000Z</published>
    <updated>2020-05-05T15:03:46.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/suoyuesmile/suo-blog/blob/master/articals/h5/0003.md">原文地址</a></p><h1 id="移动端-H5-相关问题汇总："><a href="#移动端-H5-相关问题汇总：" class="headerlink" title="移动端 H5 相关问题汇总："></a>移动端 H5 相关问题汇总：</h1><ul><li>1px 问题</li><li>响应式布局</li><li>iOS 滑动不流畅</li><li>iOS 上拉边界下拉出现白色空白</li><li>页面件放大或缩小不确定性行为</li><li>click 点击穿透与延迟</li><li>软键盘弹出将页面顶起来、收起未回落问题</li><li>iPhone X 底部栏适配问题</li><li>保存页面为图片和二维码问题和解决方案</li><li>微信公众号 H5 分享问题</li><li>H5 调用 SDK 相关问题及解决方案</li><li>H5 调试相关方案与策略</li></ul><h1 id="移动端-H5-相关基础技术概览"><a href="#移动端-H5-相关基础技术概览" class="headerlink" title="移动端 H5 相关基础技术概览"></a>移动端 H5 相关基础技术概览</h1><p><img src="https://camo.githubusercontent.com/fd55251b2784c435753d675301fb4bfa7aef733b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32342f313666333638373230643365623432313f773d3232303626683d3131343026663d6a70656726733d323437373332" alt="H5"></p><p><a href="https://juejin.im/post/5df3053ce51d45583d425ada">1px问题</a><br><a href="https://juejin.im/post/5df59139518825123e7af459">响应式布局</a></p><h2 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h2><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p><strong>为什么 iOS 的 webview 中 滑动不流畅，它是如何定义的</strong></p><p>最终我在 <code>safari</code> 文档里面寻找到了答案（文档链接在参考资料项）。</p><p><img src="https://camo.githubusercontent.com/dae1dc14e59ea49999123abbf133f60bd8f5fa2a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316461616237633431653034343f773d3134323026683d3131303426663d6a70656726733d313635343933" alt="safari文档"></p><p>原来在 <code>iOS 5.0</code> 以及之后的版本，滑动有定义有两个值 <code>auto</code> 和 <code>touch</code>，默认值为 <code>auto</code>。</p><pre><code class="css">-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1.在滚动容器上增加滚动 touch 方法</p><p>将<code>-webkit-overflow-scrolling</code> 值设置为 <code>touch</code></p><pre><code class="css">.wrapper &#123;    -webkit-overflow-scrolling: touch;&#125;</code></pre><p>设置滚动条隐藏： </p><pre><code class="css">.container ::-webkit-scrollbar &#123;display: none;&#125;</code></pre><p>可能会导致使用<code>position:fixed;</code> 固定定位的元素，随着页面一起滚动</p><p>2.设置 overflow</p><p>设置外部 <code>overflow</code> 为 <code>hidden</code>,设置内容元素 <code>overflow</code> 为 <code>auto</code>。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p><pre><code class="css">body &#123;    overflow-y: hidden;&#125;.wrapper &#123;    overflow-y: auto;&#125;</code></pre><p><strong>两者结合使用更佳！</strong></p><h2 id="iOS-上拉边界下拉出现白色空白"><a href="#iOS-上拉边界下拉出现白色空白" class="headerlink" title="iOS 上拉边界下拉出现白色空白"></a>iOS 上拉边界下拉出现白色空白</h2><h3 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h3><p>手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。</p><h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>在 iOS 中，手指按住屏幕上下拖动，会触发 <code>touchmove</code> 事件。这个事件触发的对象是整个 <code>webview</code> 容器，容器自然会被拖动，剩下的部分会成空白。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>监听事件禁止滑动<br>移动端触摸事件有三个，分别定义为</li></ol><ul><li><ol><li>touchstart ：手指放在一个DOM元素上。</li></ol></li><li><ol start="2"><li>touchmove ：手指拖曳一个DOM元素。</li></ol></li><li><ol start="3"><li>touchend ：手指从一个DOM元素上移开。<br>显然我们需要控制的是 <code>touchmove</code> 事件，由此我在 W3C 文档中找到了这样一段话</li></ol></li></ul><p><code>Note that the rate at which the user agent sends touchmove events is implementation-defined, and may depend on hardware capabilities and other implementation details</code></p><p><code>If the preventDefault method is called on the first touchmove event of an active touch point, it should prevent any default action caused by any touchmove event associated with the same active touch point, such as scrolling.</code></p><p><code>touchmove</code> 事件的速度是可以实现定义的，取决于硬件性能和其他实现细节</p><p><code>preventDefault</code> 方法，阻止同一触点上所有默认行为，比如滚动。</p><p>由此我们找到解决方案，通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动。</p><p>值得注意的是我们要过滤掉具有滚动容器的元素。</p><p>实现如下：</p><pre><code class="js">document.body.addEventListener(&#39;touchmove&#39;, function(e) &#123;    if(e._isScroller) return;    // 阻止默认事件    e.preventDefault();&#125;, &#123;    passive: false&#125;);</code></pre><span id="more"></span><ol start="2"><li>滚动妥协填充空白，装饰成其他功能<br>在很多时候，我们可以不去解决这个问题，换一直思路。根据场景，我们可以将下拉作为一个功能性的操作。</li></ol><p>比如： 下拉后刷新页面</p><p><img src="https://camo.githubusercontent.com/c3c6e29337d2f01a03f3fde0edde261edaa636aa/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32302f313666323139643137613666643434383f773d37353426683d3133323626663d6a70656726733d313833353730" alt="刷新页面"></p><h2 id="页面放大或缩小不确定性行为"><a href="#页面放大或缩小不确定性行为" class="headerlink" title="页面放大或缩小不确定性行为"></a>页面放大或缩小不确定性行为</h2><h3 id="表现-2"><a href="#表现-2" class="headerlink" title="表现"></a>表现</h3><p>双击或者双指张开手指页面元素，页面会放大或缩小。</p><h3 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h3><p>HTML 本身会产生放大或缩小的行为，比如在 PC 浏览器上，可以自由控制页面的放大缩小。但是在移动端，我们是不需要这个行为的。所以，我们需要禁止该不确定性行为，来提升用户体验。</p><h3 id="原理与解决方案"><a href="#原理与解决方案" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h3><p>HTML <code>meta</code> 元标签标准中有个 中 <code>viewport</code> 属性，用来控制页面的缩放，一般用于移动端。如下图 <code>MDN</code> 中介绍</p><p><img src="https://camo.githubusercontent.com/3c5a1f8607485339b7e2d3676d8a93c02fd3bff4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316366353238653738373439383f773d3132393426683d3132303226663d6a70656726733d333235303130" alt="viewport"></p><p>移动端常规写法</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p><p>因此我们可以设置 <code>maximum-scale、minimum-scale 与 user-scalable=no</code> 用来避免这个问题</p><p><code>&lt;meta name=viewport content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no&quot;&gt;</code></p><h2 id="click-点击事件延时与穿透"><a href="#click-点击事件延时与穿透" class="headerlink" title="click 点击事件延时与穿透"></a>click 点击事件延时与穿透</h2><h3 id="表现-3"><a href="#表现-3" class="headerlink" title="表现"></a>表现</h3><p>监听元素 click 事件，点击元素触发时间延迟约 300ms。</p><p>点击蒙层，蒙层消失后，下层元素点击触发。</p><h3 id="产生原因-3"><a href="#产生原因-3" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li><p>为什么会产生 <code>click</code> 延时？<br>iOS 中的 safari，为了实现双击缩放操作，在单击 300ms 之后，如果未进行第二次点击，则执行 <code>click</code> 单击操作。也就是说来判断用户行为是否为双击产生的。但是，在 App 中，无论是否需要双击缩放这种行为，<code>click</code> 单击都会产生 300ms 延迟。</p></li><li><p>为什么会产生 <code>click</code> 点击穿透？<br>双层元素叠加时，在上层元素上绑定 touch 事件，下层元素绑定 <code>click</code> 事件。由于 <code>click</code> 发生在 touch 之后，点击上层元素，元素消失，下层元素会触发 <code>click</code> 事件，由此产生了点击穿透的效果。</p></li></ul><h3 id="原理与解决方案-1"><a href="#原理与解决方案-1" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h3><p>解决方案一：使用 <code>touchstart</code> 替换 <code>click</code><br>前面已经介绍了，移动设备不仅支持点击，还支持几个触摸事件。 那么我们现在基本思路就是用 touch 事件代替<code>click</code> 事件。</p><p>将 <code>click</code> 替换成 <code>touchstart</code> 不仅解决了 <code>click</code> 事件都延时问题，还解决了穿透问题。因为穿透问题是在 touch 和 <code>click</code> 混用时产生。</p><p>在原生中使用</p><pre><code class="js">el.addEventListener(&quot;touchstart&quot;, () =&gt; &#123; console.log(&quot;ok&quot;); &#125;, false);</code></pre><p>在 vue 中使用</p><pre><code class="html">&lt;button @touchstart=&quot;handleTouchstart()&quot;&gt;点击&lt;/button&gt;</code></pre><p>开源解决方案中，也是既提供了 <code>click</code> 事件，又提供了<code>touchstart</code> 事件。如 <code>vant</code> 中的 button 组件</p><p><img src="https://camo.githubusercontent.com/30a48da02fce60e7dccd243bbbce4bb7325b069c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316431333330303332313635353f773d3135313226683d33363826663d6a70656726733d3539373630" alt="vant button"></p><p><strong>那么，是否可以将 click 事件全部替换成 touchstart 呢？为什么开源框架还会给出 click 事件呢？</strong></p><p>我们想象一种情景，同时需要点击和滑动的场景下。如果将 <code>click</code> 替换成 <code>touchstart</code> 会怎样？</p><ul><li>事件触发顺序: <code>touchstart, touchmove, touchend, click</code>。</li></ul><p>很容易想象，在我需要<code>touchmove</code>滑动时候，优先触发了<code>touchstart</code>的点击事件，是不是已经产生了冲突呢？</p><p>所以呢，在具有滚动的情况下，还是建议使用 click 处理。</p><p>在接下来的<code>fastclick</code>开源库中也做了如下处理。 针对 <code>touchstart</code> 和 <code>touchend</code>，截取了部分源码。</p><pre><code class="js">// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:// 1) the user does a fling scroll on the scrollable layer// 2) the user stops the fling scroll with another tap// then the event.target of the last &#39;touchend&#39; event will be the element that was under the user&#39;s finger// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).this.updateScrollParent(targetElement);// Don&#39;t send a synthetic click event if the target element is contained within a parent layer that was scrolled// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).scrollParent = targetElement.fastClickScrollParent;if (scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) &#123;    return true;&#125;</code></pre><p>主要目的就是，在使用 <code>touchstart</code> 合成 <code>click</code> 事件时，保证其不在滚动的父元素之下。</p><p><strong>解决方案二： 使用 <code>fastclick</code> 库</strong></p><p>使用 <code>npm/yarn</code> 安装后使用</p><pre><code class="js">import FastClick from &#39;fastclick&#39;;FastClick.attach(document.body, options);</code></pre><p>同样，使用<code>fastclick</code>库后，click 延时和穿透问题都没了</p><p>按照我的惯例，只要涉及开源库，那么我们一定要去了解它实现的原理。主要是将现有的原生事件集合封装合成一个兼容性较强的事件集合。</p><p><a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js">fastclick源码</a> 核心代码不长， 1000 行不到。有兴趣可以了解一下!</p><h2 id="软键盘将页面顶起来、收起未回落问题"><a href="#软键盘将页面顶起来、收起未回落问题" class="headerlink" title="软键盘将页面顶起来、收起未回落问题"></a>软键盘将页面顶起来、收起未回落问题</h2><h2 id="表现-4"><a href="#表现-4" class="headerlink" title="表现"></a>表现</h2><p>Android 手机中，点击 <code>input</code> 框时，键盘弹出，将页面顶起来，导致页面样式错乱。</p><p>移开焦点时，键盘收起，键盘区域空白，未回落。</p><h2 id="产生原因-4"><a href="#产生原因-4" class="headerlink" title="产生原因"></a>产生原因</h2><p>我们在app 布局中会有个固定的底部。安卓一些版本中，输入弹窗出来，会将解压 <code>absolute</code> 和 <code>fixed</code> 定位的元素。导致可视区域变小，布局错乱。</p><h2 id="原理与解决方案-2"><a href="#原理与解决方案-2" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h2><p>软键盘将页面顶起来的解决方案，主要是<strong>通过监听页面高度变化，强制恢复成弹出前的高度</strong>。</p><pre><code class="js">// 记录原有的视口高度const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;window.onresize = function()&#123;  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;  if(resizeHeight &lt; originalHeight )&#123;    // 恢复内容区域高度    // const container = document.getElementById(&quot;container&quot;)    // 例如 container.style.height = originalHeight;  &#125;&#125;</code></pre><p>键盘不能回落问题出现在 <code>iOS 12+</code> 和<code> wechat 6.7.4+</code> 中，而在微信 H5 开发中是比较常见的 Bug。</p><p>兼容原理，<strong>1.判断版本类型 2.更改滚动的可视区域</strong></p><pre><code class="js">const isWechat = window.navigator.userAgent.match(/MicroMessenger\/([\d\.]+)/i);if (!isWechat) return;const wechatVersion = wechatInfo[1];const version = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/);  // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口if (+wechatVersion.replace(/\./g, &#39;&#39;) &gt;= 674 &amp;&amp; +version[1] &gt;= 12) &#123;  window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));&#125;</code></pre><h2 id="iPhone-X系列安全区域适配问题"><a href="#iPhone-X系列安全区域适配问题" class="headerlink" title="iPhone X系列安全区域适配问题"></a>iPhone X系列安全区域适配问题</h2><h3 id="表现-5"><a href="#表现-5" class="headerlink" title="表现"></a>表现</h3><p>头部刘海两侧区域或者底部区域，出现刘海遮挡文字，或者呈现黑底或白底空白区域。</p><h3 id="产生原因-5"><a href="#产生原因-5" class="headerlink" title="产生原因"></a>产生原因</h3><p>iPhone X 以及它以上的系列，都采用刘海屏设计和全面屏手势。头部、底部、侧边都需要做特殊处理。才能适配 iPhone X 的特殊情况。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>设置安全区域，填充危险区域，危险区域不做操作和内容展示。</p><blockquote><p>危险区域指头部不规则区域，底部横条区域，左右触发区域。</p></blockquote><p><img src="https://camo.githubusercontent.com/e3113d3bf82f463084d4e51e4ee5dd804d7aa77f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316433313135306537396362393f773d3131313826683d35393426663d6a70656726733d3439313234" alt="危险区域"></p><p>具体操作为：<code>viewport-fit</code> meta 标签设置为 <code>cover</code>，获取所有区域填充。 判断设备是否属于 <code>iPhone X</code>，给头部底部增加适配层</p><blockquote><p>viewport-fit 有 3 个值分别为：</p></blockquote><ul><li>auto：此值不影响初始布局视图端口，并且整个web页面都是可查看的。</li><li>contain： 视图端口按比例缩放，以适合显示内嵌的最大矩形。</li><li>cover：视图端口被缩放以填充设备显示。强烈建议使用 safe area inset 变量，以确保重要内容不会出现在显示之外。</li></ul><p><strong>设置 viewport-fit 为 cover</strong></p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover&quot;&gt;</code></p><p><strong>增加适配层</strong></p><p>使用 <code>safe area inset</code> 变量</p><pre><code class="css">/* 适配 iPhone X 顶部填充*/@supports (top: env(safe-area-inset-top))&#123;  body,  .header&#123;      padding-top: constant(safe-area-inset-top, 40px);      padding-top: env(safe-area-inset-top, 40px);      padding-top: var(safe-area-inset-top, 40px);  &#125;&#125;/* 判断iPhoneX 将 footer 的 padding-bottom 填充到最底部 */@supports (bottom: env(safe-area-inset-bottom))&#123;    body,    .footer&#123;        padding-bottom: constant(safe-area-inset-bottom, 20px);        padding-bottom: env(safe-area-inset-bottom, 20px);        padding-top: var(safe-area-inset-bottom, 20px);    &#125;&#125;</code></pre><blockquote><p><code>safe-area-inset-top</code>, <code>safe-area-inset-right</code>, <code>safe-area-inset-bottom</code>, <code>safe-area-inset-left</code> <code>safe-area-inset-*</code>由四个定义了视口边缘内矩形的 top, right, bottom 和 left 的环境变量组成，这样可以安全地放入内容，而不会有被非矩形的显示切断的风险。对于矩形视口，例如普通的笔记本电脑显示器，其值等于零。 对于非矩形显示器（如圆形表盘，iPhoneX 屏幕），在用户代理设置的四个值形成的矩形内，所有内容均可见。</p></blockquote><p>其中 env() 用法为 <code>env( &lt;custom-ident&gt; , &lt;declaration-value&gt;? )</code>，第一个参数为自定义的区域，第二个为备用值。</p><p>其中 var() 用法为 <code>var( &lt;custom-property-name&gt; , &lt;declaration-value&gt;? )</code>，作用是在 env() 不生效的情况下，给出一个备用值。</p><p><code>constant（）</code> 被 css 2017-2018 年为草稿阶段，是否已被标准化未知。而其他iOS 浏览器版本中是否有此函数未知，作为兼容处理而添加进去。</p><p>详情请查看文章末尾的参考资料。</p><p><strong>兼容性</strong></p><p><img src="https://camo.githubusercontent.com/c2eaef48e9887a3709118acbcd181adf338e1b97/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32302f313666323132666639393865316563313f773d3230323426683d35363826663d6a70656726733d313432363938" alt="兼容性"></p><h2 id="页面生成为图片和二维码问题"><a href="#页面生成为图片和二维码问题" class="headerlink" title="页面生成为图片和二维码问题"></a>页面生成为图片和二维码问题</h2><h3 id="表现-6"><a href="#表现-6" class="headerlink" title="表现"></a>表现</h3><p>在工作中有需要将页面生成图片或者二维码的需求。可能我们第一想到的，交给后端来生成更简单。但是这样我们需要把页面代码全部传给后端，网络性能消耗太大。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h4><p>使用 <code>QRCode</code> 生成二维码</p><pre><code class="js">import QRCode from &#39;qrcode&#39;;// 使用 async 生成图片const options = &#123;&#125;;const url = window.location.href;async url =&gt; &#123;  try &#123;    console.log(await QRCode.toDataURL(url, options))  &#125; catch (err) &#123;    console.error(err);  &#125;&#125;</code></pre><p>将 <code>await QRCode.toDataURL(url, options)</code> 赋值给 图片 url 即可</p><h4 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h4><p>主要是使用 <code>htmlToCanvas</code> 生成 <code>canvas</code> 画布</p><pre><code class="js">import html2canvas from &#39;html2canvas&#39;;html2canvas(document.body).then(function(canvas) &#123;    document.body.appendChild(canvas);&#125;);</code></pre><p>但是不单单在此处就完了，由于是 canvas 的原因。移动端生成出来的图片比较模糊。</p><p>我们使用一个新的 canvas 方法多倍生成，放入一倍容器里面，达到更加清晰的效果，<strong>通过超链接下载图片 下载文件简单实现，更完整的实现方式之后更新</strong></p><pre><code class="js">const scaleSize = 2;const newCanvas = document.createElement(&quot;canvas&quot;);const target = document.querySelector(&#39;div&#39;);const width = parseInt(window.getComputedStyle(target).width);const height = parseInt(window.getComputedStyle(target).height);newCanvas.width = width * scaleSize;newCanvas.height = widthh * scaleSize;newCanvas.style.width = width + &quot;px&quot;;newCanvas.style.height =width + &quot;px&quot;;const context = newCanvas.getContext(&quot;2d&quot;);context.scale(scaleSize, scaleSize);html2canvas(document.querySelector(&#39;.demo&#39;), &#123; canvas: newCanvas &#125;).then(function(canvas) &#123;  // 简单的通过超链接设置下载功能  document.querySelector(&quot;.btn&quot;).setAttribute(&#39;href&#39;, canvas.toDataURL());&#125;</code></pre><p>根据需要设置 <code>scaleSize</code> 大小</p><h2 id="微信公众号分享问题"><a href="#微信公众号分享问题" class="headerlink" title="微信公众号分享问题"></a>微信公众号分享问题</h2><h3 id="表现-7"><a href="#表现-7" class="headerlink" title="表现"></a>表现</h3><p>在微信公众号 H5 开发中，页面内部点击分享按钮调用 SDK，方法不生效。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方法：<strong>添加一层蒙层，做分享引导</strong>。<br>因为页面内部点击分享按钮无法直接调用，而分享功能需要点击右上角更多来操作。</p><p>然后用户可能不知道通过右上角小标里面的功能分享。又想引导用户分享，这时应该怎么做呢？</p><p>技术无法实现的，从产品出发。</p><p><img src="https://camo.githubusercontent.com/f37734d29e8e4cb0df21bdd06be8aefc796b0094/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32302f313666316566613633323037313939623f773d33323826683d35373426663d6a70656726733d3535323135" alt="share"></p><p><strong>如果技术上实现复杂，或者直接不能实现。不要强行钻牛角尖哦，学会怼产品，也是程序员必备的能力之一。</strong></p><h2 id="H5-调用-SDK-相关解决方案"><a href="#H5-调用-SDK-相关解决方案" class="headerlink" title="H5 调用 SDK 相关解决方案"></a>H5 调用 SDK 相关解决方案</h2><h3 id="产生原因-6"><a href="#产生原因-6" class="headerlink" title="产生原因"></a>产生原因</h3><p>在 Hybrid App 中使用 H5 是最常见的不过了，刚接触的，肯定会很生疏模糊。不知道 H5 和 Hybrid 是怎么交互的。怎样同时支持 iOS 和 Android 呢？现在来谈谈 Hybrid 技术要点，原生与 H5 的通信。</p><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>DSBridge</code> 同时支持 iOS 与 Android</p><p>SDK小组 提供方法<br>注册方法 <code>bridge.register</code></p><pre><code class="js">bridge.register(&#39;enterApp&#39;, function() &#123;  broadcast.emit(&#39;ENTER_APP&#39;)&#125;)</code></pre><p>回调方法 <code>bridge.call</code></p><pre><code class="js">export const getSDKVersion = () =&gt; bridge.call(&#39;BLT.getSDKVersion&#39;)</code></pre><p>事件监听与触发法</p><pre><code class="js">const broadcast = &#123;  on: function(name, fn, pluralable) &#123;    this._on(name, fn, pluralable, false)  &#125;,  once: function(name, fn, pluralable) &#123;    this._on(name, fn, pluralable, true)  &#125;,  _on: function(name, fn, pluralable, once) &#123;    let eventData = broadcast.data    let fnObj = &#123; fn: fn, once: once &#125;    if (pluralable &amp;&amp; Object.prototype.hasOwnProperty.call(eventData, &#39;name&#39;)) &#123;      eventData[name].push(fnObj)    &#125; else &#123;      eventData[name] = [fnObj]    &#125;    return this  &#125;,  emit: function(name, data, thisArg) &#123;    let fn, fnList, i, len    thisArg = thisArg || null    fnList = broadcast.data[name] || []    for (i = 0, len = fnList.length; i &lt; len; i++) &#123;      fn = fnList[i].fn      fn.apply(thisArg, [data, name])      if (fnList[i].once) &#123;        fnList.splice(i, 1)        i--        len--      &#125;    &#125;    return this  &#125;,  data: &#123;&#125;&#125;export default broadcast</code></pre><p>踩坑注意</p><p>方法调用前，一定要判断 SDK 是否提供该方法 如果 Android 提供该方法，iOS 上调用就会出现一个方法调用失败等弹窗。 怎么解决呢？</p><p><strong>提供一个判断是否 Android、iOS。根据设备进行判断</strong></p><pre><code class="js">export const hasNativeMethod = (name) =&gt;  return bridge.hasNativeMethod(&#39;BYJ.&#39; + name)&#125;export const getSDKVersion = function() &#123;  if (hasNativeMethod(&#39;getSDKVersion&#39;)) &#123;    bridge.call(&#39;BYJ.getSDKVersion&#39;)  &#125;&#125;</code></pre><blockquote><p>同一功能需要iOS，Android方法名相同，这样更好处理哦</p></blockquote><h2 id="H5-调试相关方案策略"><a href="#H5-调试相关方案策略" class="headerlink" title="H5 调试相关方案策略"></a>H5 调试相关方案策略</h2><h3 id="表现-8"><a href="#表现-8" class="headerlink" title="表现"></a>表现</h3><p>调试代码一般就是为了<strong>查看数据和定位 bug</strong>。分为两种场景，一种是开发和测试时调试，一种是生产环境上调试。</p><p>为什么有生产环境上调试呢？有些时候测试环境上没法复现这个 bug，测试环境和生产环境不一致，此时就需要紧急生产调试。</p><p>在 PC 端开发时，我们可以直接掉出控制台，使用浏览器提供的工具操作devtools或者查看日志。但是在 App 内部我们怎么做呢？</p><h3 id="原理与解决方案-3"><a href="#原理与解决方案-3" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h3><ol><li>vconsole 控制台插件</li></ol><p>使用方法也很简单</p><pre><code class="js">import Vconsole from &#39;vconsole&#39;new Vconsole()</code></pre><p>有兴趣看看它实现的基本原理，我们关注的点应该在 <code>vsconsole</code> 如何打印出我们所有 <code>log</code> 的 腾讯开源<a href="https://github.com/Tencent/vConsole/blob/dev/src/core/core.js">vconsole</a></p><p>上述方法仅用于开发和测试。生产环境中不允许出现，所以，<strong>使用时需要对环境进行判断</strong>。</p><pre><code class="js">import Vconsole from &#39;vconsole&#39;if (process.env.NODE_ENV !== &#39;production&#39;) &#123;    new Vconsole()&#125;</code></pre><ol start="2"><li>代理 + spy-debugger</li></ol><p>操作稍微有点麻烦，不过我会详细写出，大致分为 4 个步骤</p><ul><li>安装插件(全局安装)<br>sudo npm install spy-debugger -g</li><li>手机与电脑置于同一 wifi 下，手机设置代理<br>设置手机的 HTTP 代理，代理 IP 地址设置为 PC 的 IP 地址，端口为spy-debugger的启动端口</li></ul><p><code>spy-debugger</code> 默认端口：<code>9888</code></p><p>Android ：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</p><p>IOS ：设置 - Wi-Fi - 选中网络, 点击感叹号, HTTP 代理手动</p><ul><li>手机打开浏览器或者 app 中 H5 页面</li><li>打开桌面日志网站进行调试，点击 npm 控制台监听地址。查看抓包和 H5 页面结构</li></ul><p>这种方式可以调试生成环境的页面，不需要修改代码，可以应付大多数调试需求</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/css/property/-webkit-overflow-scrolling">Safari CSS Reference</a><br><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/css/property/-webkit-overflow-scrolling">MDN touch 事件</a><br><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/css/property/-webkit-overflow-scrolling">MDN css var()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/env">MDN css env()</a><br><a href="https://drafts.csswg.org/css-env-1/">csswg env() drafts</a><br><a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js">fastclick 源码</a><br><a href="https://github.com/wendux/DSBridge-Android">DSBridge-Android</a> &amp; <a href="https://github.com/wendux/DSBridge-IOS">DSBridge-iOS</a><br><a href="https://github.com/davidshimjs/qrcodejs">qrcodejs 源码</a><br><a href="https://github.com/niklasvh/html2canvas">html2canvas 源码</a><br><a href="https://www.cnblogs.com/lolDragon/p/7795174.html">关于H5页面在iPhoneX适配</a><br><a href="https://youzan.github.io/vant/#/zh-CN/button">vant 相关文档</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://github.com/suoyuesmile/suo-blog/blob/master/articals/h5/0003.md&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;移动端-H5-相关问题汇总：&quot;&gt;&lt;a href=&quot;#移动端-H5-相关问题汇总：&quot; class=&quot;headerlink&quot; title=&quot;移动端 H5 相关问题汇总：&quot;&gt;&lt;/a&gt;移动端 H5 相关问题汇总：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1px 问题&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;li&gt;iOS 滑动不流畅&lt;/li&gt;
&lt;li&gt;iOS 上拉边界下拉出现白色空白&lt;/li&gt;
&lt;li&gt;页面件放大或缩小不确定性行为&lt;/li&gt;
&lt;li&gt;click 点击穿透与延迟&lt;/li&gt;
&lt;li&gt;软键盘弹出将页面顶起来、收起未回落问题&lt;/li&gt;
&lt;li&gt;iPhone X 底部栏适配问题&lt;/li&gt;
&lt;li&gt;保存页面为图片和二维码问题和解决方案&lt;/li&gt;
&lt;li&gt;微信公众号 H5 分享问题&lt;/li&gt;
&lt;li&gt;H5 调用 SDK 相关问题及解决方案&lt;/li&gt;
&lt;li&gt;H5 调试相关方案与策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;移动端-H5-相关基础技术概览&quot;&gt;&lt;a href=&quot;#移动端-H5-相关基础技术概览&quot; class=&quot;headerlink&quot; title=&quot;移动端 H5 相关基础技术概览&quot;&gt;&lt;/a&gt;移动端 H5 相关基础技术概览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/fd55251b2784c435753d675301fb4bfa7aef733b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32342f313666333638373230643365623432313f773d3232303626683d3131343026663d6a70656726733d323437373332&quot; alt=&quot;H5&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5df3053ce51d45583d425ada&quot;&gt;1px问题&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5df59139518825123e7af459&quot;&gt;响应式布局&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-滑动不流畅&quot;&gt;&lt;a href=&quot;#iOS-滑动不流畅&quot; class=&quot;headerlink&quot; title=&quot;iOS 滑动不流畅&quot;&gt;&lt;/a&gt;iOS 滑动不流畅&lt;/h2&gt;&lt;h3 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h3&gt;&lt;p&gt;上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。&lt;/p&gt;
&lt;h3 id=&quot;产生原因&quot;&gt;&lt;a href=&quot;#产生原因&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;为什么 iOS 的 webview 中 滑动不流畅，它是如何定义的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终我在 &lt;code&gt;safari&lt;/code&gt; 文档里面寻找到了答案（文档链接在参考资料项）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/dae1dc14e59ea49999123abbf133f60bd8f5fa2a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316461616237633431653034343f773d3134323026683d3131303426663d6a70656726733d313635343933&quot; alt=&quot;safari文档&quot;&gt;&lt;/p&gt;
&lt;p&gt;原来在 &lt;code&gt;iOS 5.0&lt;/code&gt; 以及之后的版本，滑动有定义有两个值 &lt;code&gt;auto&lt;/code&gt; 和 &lt;code&gt;touch&lt;/code&gt;，默认值为 &lt;code&gt;auto&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */

-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;p&gt;1.在滚动容器上增加滚动 touch 方法&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;-webkit-overflow-scrolling&lt;/code&gt; 值设置为 &lt;code&gt;touch&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.wrapper &amp;#123;
    -webkit-overflow-scrolling: touch;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置滚动条隐藏： &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.container ::-webkit-scrollbar &amp;#123;display: none;&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能会导致使用&lt;code&gt;position:fixed;&lt;/code&gt; 固定定位的元素，随着页面一起滚动&lt;/p&gt;
&lt;p&gt;2.设置 overflow&lt;/p&gt;
&lt;p&gt;设置外部 &lt;code&gt;overflow&lt;/code&gt; 为 &lt;code&gt;hidden&lt;/code&gt;,设置内容元素 &lt;code&gt;overflow&lt;/code&gt; 为 &lt;code&gt;auto&lt;/code&gt;。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;body &amp;#123;
    overflow-y: hidden;
&amp;#125;
.wrapper &amp;#123;
    overflow-y: auto;
&amp;#125;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;两者结合使用更佳！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-上拉边界下拉出现白色空白&quot;&gt;&lt;a href=&quot;#iOS-上拉边界下拉出现白色空白&quot; class=&quot;headerlink&quot; title=&quot;iOS 上拉边界下拉出现白色空白&quot;&gt;&lt;/a&gt;iOS 上拉边界下拉出现白色空白&lt;/h2&gt;&lt;h3 id=&quot;表现-1&quot;&gt;&lt;a href=&quot;#表现-1&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h3&gt;&lt;p&gt;手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。&lt;/p&gt;
&lt;h3 id=&quot;产生原因-1&quot;&gt;&lt;a href=&quot;#产生原因-1&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h3&gt;&lt;p&gt;在 iOS 中，手指按住屏幕上下拖动，会触发 &lt;code&gt;touchmove&lt;/code&gt; 事件。这个事件触发的对象是整个 &lt;code&gt;webview&lt;/code&gt; 容器，容器自然会被拖动，剩下的部分会成空白。&lt;/p&gt;
&lt;h3 id=&quot;解决方案-1&quot;&gt;&lt;a href=&quot;#解决方案-1&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;监听事件禁止滑动&lt;br&gt;移动端触摸事件有三个，分别定义为&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;touchstart ：手指放在一个DOM元素上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;touchmove ：手指拖曳一个DOM元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;touchend ：手指从一个DOM元素上移开。&lt;br&gt;显然我们需要控制的是 &lt;code&gt;touchmove&lt;/code&gt; 事件，由此我在 W3C 文档中找到了这样一段话&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Note that the rate at which the user agent sends touchmove events is implementation-defined, and may depend on hardware capabilities and other implementation details&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;If the preventDefault method is called on the first touchmove event of an active touch point, it should prevent any default action caused by any touchmove event associated with the same active touch point, such as scrolling.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;touchmove&lt;/code&gt; 事件的速度是可以实现定义的，取决于硬件性能和其他实现细节&lt;/p&gt;
&lt;p&gt;&lt;code&gt;preventDefault&lt;/code&gt; 方法，阻止同一触点上所有默认行为，比如滚动。&lt;/p&gt;
&lt;p&gt;由此我们找到解决方案，通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动。&lt;/p&gt;
&lt;p&gt;值得注意的是我们要过滤掉具有滚动容器的元素。&lt;/p&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;document.body.addEventListener(&amp;#39;touchmove&amp;#39;, function(e) &amp;#123;
    if(e._isScroller) return;
    // 阻止默认事件
    e.preventDefault();
&amp;#125;, &amp;#123;
    passive: false
&amp;#125;);
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="HTML5" scheme="https://shinichikudo-fe.github.io/categories/HTML5/"/>
    
    
    <category term="HTML5" scheme="https://shinichikudo-fe.github.io/tags/HTML5/"/>
    
  </entry>
  
</feed>
