<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>默默默默燃</title>
  
  <subtitle>路漫漫其修远兮，吾将上下而求索</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://zhanghao-web.github.io/"/>
  <updated>2020-04-22T14:40:47.596Z</updated>
  <id>https://zhanghao-web.github.io/</id>
  
  <author>
    <name>张白告丶</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>尤雨溪在Vue3.0 Beta直播里聊到了这些…</title>
    <link href="https://zhanghao-web.github.io/2020/04/22/Vue/%E5%B0%A4%E9%9B%A8%E6%BA%AA%E5%9C%A8Vue3-0-Beta%E7%9B%B4%E6%92%AD%E9%87%8C%E8%81%8A%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%E2%80%A6/"/>
    <id>https://zhanghao-web.github.io/2020/04/22/Vue/尤雨溪在Vue3-0-Beta直播里聊到了这些…/</id>
    <published>2020-04-22T14:07:49.000Z</published>
    <updated>2020-04-22T14:40:47.596Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15" target="_blank" rel="noopener">原文地址(https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15)</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>4月21日晚，Vue作者尤雨溪在哔哩哔哩直播分享了Vue.js 3.0 Beta最新进展。 以下是直播内容整理</p><h2 id="全新文档RFCs"><a href="#全新文档RFCs" class="headerlink" title="全新文档RFCs"></a>全新文档RFCs</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719da838e76e8c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="全新文档RFCs"></p><p><code>Vue.js 3.0 Beta</code>发布后的工作重点是保证稳定性和推进各类库集成</p><p>所有的进度和文档都将在全新<code>RFCs</code>文档可以看到。</p><h2 id="六大亮点"><a href="#六大亮点" class="headerlink" title="六大亮点"></a>六大亮点</h2><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719daca80f3b7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="六大亮点"></p><blockquote><ul><li>Performance：性能更比Vue 2.0强。</li><li>Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。</li><li>Composition API：组合API</li><li>Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”</li><li>Better TypeScript support：更优秀的Ts支持</li><li>Custom Renderer API：暴露了自定义渲染API</li></ul></blockquote><h3 id="Performance"><a href="#Performance" class="headerlink" title="Performance"></a>Performance</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/21/1719d6747e723d03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Performance"></p><ul><li><ol><li>重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。</li></ol></li><li><ol start="2"><li>编译模板的优化。</li></ol></li><li><ol start="3"><li>更高效的组件初始化。</li></ol></li><li><ol start="4"><li>update性能提高1.3~2倍。</li></ol></li><li><ol start="5"><li>SSR速度提高了2~3倍。</li></ol></li></ul><p>下面是各项性能对比</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719db04999e3890?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="性能对比"></p><h4 id="要点1：编译模板的优化"><a href="#要点1：编译模板的优化" class="headerlink" title="要点1：编译模板的优化"></a>要点1：编译模板的优化</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e59cd0f2b668?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="编译模板的优化"></p><p>假设要编译以下代码</p><pre><code class="js">&lt;div&gt;  &lt;span/&gt;  &lt;span&gt;{{ msg }}&lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="js">import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, null, &quot;static&quot;),    _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)  ]))}// Check the console for the AST</code></pre><p>注意看第二个<code>_createVNode</code>结尾的“1”：</p><p>Vue在运行时会生成number（大于0）值的<code>PatchFlag</code>，用作标记。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e69419edbc4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="标记"></p><p>仅带有<code>PatchFlag</code>标记的节点会被真正追踪，且无论层级嵌套多深，它的动态节点都直接与<code>Block</code>根节点绑定，无需再去遍历静态节点</p><p>再看以下例子：</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e6d7d3efe7f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="例子2"></p><pre><code class="js">&lt;div&gt;  &lt;span&gt;static&lt;/span&gt;  &lt;span :id=&quot;hello&quot; class=&quot;bar&quot;&gt;{{ msg }}   &lt;/span&gt;&lt;/div&gt;</code></pre><pre><code class="js">import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, null, &quot;static&quot;),    _createVNode(&quot;span&quot;, {      id: _ctx.hello,      class: &quot;bar&quot;    }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;id&quot;])  ]))}</code></pre><a id="more"></a><p><code>PatchFlag</code> 变成了<code>9 /* TEXT, PROPS */, [&quot;id&quot;]</code><br>它会告知我们不光有TEXT变化，还有PROPS变化（id）<br>这样既跳出了<code>virtual dom</code>性能的瓶颈，又保留了可以手写<code>render</code>的灵活性。<br>等于是：既有react的灵活性，又有基于模板的性能保证。</p><h4 id="要点2-事件监听缓存：cacheHandlers"><a href="#要点2-事件监听缓存：cacheHandlers" class="headerlink" title="要点2: 事件监听缓存：cacheHandlers"></a>要点2: 事件监听缓存：cacheHandlers</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e775146d5a84?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cacheHandlers"></p><p>假设我们要绑定一个事件：</p><pre><code class="html">&lt;div&gt;  &lt;span @click=&quot;onClick&quot;&gt;    {{msg}}  &lt;/span&gt;&lt;/div&gt;</code></pre><p>关闭<code>cacheHandlers</code>后：</p><pre><code class="js">import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, { onClick: _ctx.onClick }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;onClick&quot;])  ]))}</code></pre><p><code>onClick</code>会被视为<code>PROPS</code>动态绑定，后续替换点击事件时需要进行更新。</p><p>开启<code>cacheHandlers</code>后：</p><pre><code class="js">import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot;export function render(_ctx, _cache) {  return (_openBlock(), _createBlock(&quot;div&quot;, null, [    _createVNode(&quot;span&quot;, {      onClick: _cache[1] || (_cache[1] = $event =&gt; (_ctx.onClick($event)))    }, _toDisplayString(_ctx.msg), 1 /* TEXT */)  ]))}</code></pre><p><code>cache[1]</code>，会自动生成并缓存一个内联函数，“神奇”的变为一个静态节点。 Ps：相当于<code>React中useCallback</code>自动化。</p><p>并且支持手写内联函数：</p><pre><code class="html">&lt;div&gt;  &lt;span @click=&quot;()=&gt;foo()&quot;&gt;    {{msg}}  &lt;/span&gt;&lt;/div&gt;</code></pre><p>补充：<code>PatchFlags</code>枚举定义</p><p>而通过查询Ts枚举定义，我们可以看到分别定义了以下的追踪标记：</p><pre><code class="js">export const enum PatchFlags {  TEXT = 1,// 表示具有动态textContent的元素  CLASS = 1 &lt;&lt; 1,  // 表示有动态Class的元素  STYLE = 1 &lt;&lt; 2,  // 表示动态样式（静态如style=&quot;color: red&quot;，也会提升至动态）  PROPS = 1 &lt;&lt; 3,  // 表示具有非类/样式动态道具的元素。  FULL_PROPS = 1 &lt;&lt; 4,  // 表示带有动态键的道具的元素，与上面三种相斥  HYDRATE_EVENTS = 1 &lt;&lt; 5,  // 表示带有事件监听器的元素  STABLE_FRAGMENT = 1 &lt;&lt; 6,   // 表示其子顺序不变的片段（没懂）。   KEYED_FRAGMENT = 1 &lt;&lt; 7, // 表示带有键控或部分键控子元素的片段。  UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 表示带有无key绑定的片段  NEED_PATCH = 1 &lt;&lt; 9,   // 表示只需要非属性补丁的元素，例如ref或hooks  DYNAMIC_SLOTS = 1 &lt;&lt; 10,  // 表示具有动态插槽的元素  // 特殊 FLAGS -------------------------------------------------------------  HOISTED = -1,  // 特殊标志是负整数表示永远不会用作diff,只需检查 patchFlag === FLAG.  BAIL = -2 // 一个特殊的标志，指代差异算法（没懂）}</code></pre><p>感兴趣的可以看源码：<code>packages/shared/src/patchFlags.ts</code></p><h3 id="Tree-shaking-support"><a href="#Tree-shaking-support" class="headerlink" title="Tree shaking support"></a>Tree shaking support</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719db10e9e06382?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Tree shaking support"></p><ul><li>可以将无用模块“剪辑”，仅打包需要的（比如<code>v-model</code>,<code>&lt;transition&gt;</code>，用不到就不会打包）。</li><li>一个简单“HelloWorld”大小仅为：13.5kb11.75kb，仅Composition API。</li><li>包含运行时完整功能：22.5kb,拥有更多的功能，却比Vue 2更迷你。</li></ul><p>很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入。</p><h3 id="Composition-API"><a href="#Composition-API" class="headerlink" title="Composition API"></a>Composition API</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dc2469bd375c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Composition API"></p><p>与React Hooks 类似的东西，实现方式不同。</p><ul><li>可与现有的 Options API一起使用</li><li>灵活的逻辑组合与复用</li><li>vue 3的响应式模块可以和其他框架搭配使用</li></ul><p>混入<code>(mixin)</code> 将不再作为推荐使用， <code>Composition API</code>可以实现更灵活且无副作用的复用代码。</p><p>感兴趣的可以查看：<a href="https://composition-api.vuejs.org/#summary" target="_blank" rel="noopener">composition-api.vuejs.org/#summary</a></p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dc20717835c1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="omposition-api.vuejs.org"></p><p>Composition API包含了六个主要API</p><p><a href="https://composition-api.vuejs.org/api.html#setup" target="_blank" rel="noopener">composition-api.vuejs.org/api.html#setup</a></p><p>Ps：其它的均为常见的工具函数，可先忽略不看。</p><h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dcd5c5f2b631?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Fragment"></p><p>Fragment翻译为：“碎片”</p><ul><li>不再限于模板中的单个根节点</li><li>render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。</li><li>‘Just works’</li></ul><h4 id=""><a href="#" class="headerlink" title=""></a><Teleport></h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dd2d18fe0d55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Teleport"></p><ul><li>以前称为<code>&lt;Portal&gt;</code>，译作传送门。</li><li>更多细节将由@<code>Linusborg</code> 分享</li></ul><p><code>&lt;Teleport&gt;</code>原先是对标 <code>React Portal</code>（增加多个新功能，更强）</p><p>但因为Chrome有个提案，会增加一个名为<code>Portal</code>的原生<code>element</code>，为避免命名冲突，改为<code>Teleport</code></p><h4 id="-1"><a href="#-1" class="headerlink" title=""></a><Suspense></h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719ddbaf6d0f226?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Suspense"></p><p>Suspense翻译为：“悬念”</p><ul><li>可在嵌套层级中等待嵌套的异步依赖项</li><li>支持async setup()</li><li>支持异步组件</li></ul><p>虽然React 16引入了<code>Suspense</code>，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。<br>Vue 3 的<code>&lt;Suspense&gt;</code>更加轻量：<br><strong>仅5%应用能感知运行时的调度差异，综合考虑下，Vue3 的<code>&lt;Suspense&gt;</code> 没和React一样做运行调度处理</strong></p><h3 id="更好的TypeScript支持"><a href="#更好的TypeScript支持" class="headerlink" title="更好的TypeScript支持"></a>更好的TypeScript支持</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719de6ad581aa38?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="TypeScript"></p><ul><li>Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示</li><li>JavaScript和TypeScript中的API是相同的。事实上，代码也基本相同</li><li>支持TSX,class组件还会继续支持，但是需要引入<code>vue-class-component@next</code>，该模块目前还处在 alpha 阶段。</li></ul><p>还有<code>Vue 3 + TypeScript</code> 插件正在开发，有类型检查，自动补全等功能。目前进展可喜。</p><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719deb6563506b7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Vue 3 + TypeScript"></p><h3 id="Custom-Renderer-API：自定义渲染器API"><a href="#Custom-Renderer-API：自定义渲染器API" class="headerlink" title="Custom Renderer API：自定义渲染器API"></a>Custom Renderer API：自定义渲染器API</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719df0e878dbeb3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Custom Renderer API"></p><ul><li>正在进行NativeScript Vue集成</li><li>用户可以尝试WebGL自定义渲染器，与普通Vue应用程序一起使用（Vugel）。</li></ul><p>意味着以后可以通过 <code>vue</code>， <code>Dom</code> 编程的方式来进行 <code>webgl</code> 编程 。感兴趣可以看这里：<a href="https://vugel.planning.nl/#application" target="_blank" rel="noopener">Getting started vugel</a></p><h3 id="剩余工作"><a href="#剩余工作" class="headerlink" title="剩余工作"></a>剩余工作</h3><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719df667b34919f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="剩余工作"></p><h4 id="Docs-amp-Migration-Guides"><a href="#Docs-amp-Migration-Guides" class="headerlink" title="Docs &amp; Migration Guides"></a>Docs &amp; Migration Guides</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719df8c7c95f9b9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Docs &amp; Migration Guides"></p><ul><li>新的文档编写交由<code>@NataliaTepluhina, @sdras, @bencodezen &amp; @phanan</code> 负责</li><li><code>@sdras</code> 正在做自动升级迁移工具</li><li><code>@sodatea</code> 已经开始研究<code>CodeMods</code></li></ul><h4 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dfcab0e73db6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Router"></p><ul><li>下一代 Router：<code>vue-router@next</code>已在alpha阶段，感谢<code>@posva</code></li></ul><p>有部分的<code>API</code>变动，可到<code>RFC</code>上看。</p><h4 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719dfed3afd961b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Vuex"></p><ul><li>下一代Vuex：，<code>vuex@next</code>（与Vue 3 compat相同的API），已在alpha阶段，感谢<code>@KiaKing</code>。</li><li>团队正在为下一次迭代试验Vuex API的简化</li></ul><p>目前以兼容Vue 3为主，基本上没有API变动，莫慌。</p><h4 id="CLI"><a href="#CLI" class="headerlink" title="CLI"></a>CLI</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e043616c018f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="CLI"></p><ul><li>CLI插件：<code>vue-cli-plugin-vue-next</code> by <code>@sodatea</code></li><li>（wip）CodeMods支持升级Vue 2应用</li></ul><h4 id="新工具：vite（法语-“快”）"><a href="#新工具：vite（法语-“快”）" class="headerlink" title="新工具：vite（法语 “快”）"></a>新工具：vite（法语 “快”）</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e0c133c3367f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="vite"></p><p>地址：<a href="https://github.com/vuejs/vite" target="_blank" rel="noopener">github.com/vuejs/vite</a></p><p>一个简易的http服务器，无需<code>webpack</code>编译打包，根据请求的Vue文件，直接发回渲染，且支持热更新（非常快）</p><h4 id="vue-test-utils"><a href="#vue-test-utils" class="headerlink" title="vue-test-utils"></a>vue-test-utils</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e0d602d57dc6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="vue-test-utils"></p><h4 id="DevTools"><a href="#DevTools" class="headerlink" title="DevTools"></a>DevTools</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e0d0e479ec8b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="devtools"></p><h4 id="IDE-Support-Vetur"><a href="#IDE-Support-Vetur" class="headerlink" title="IDE Support (Vetur)"></a>IDE Support (Vetur)</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e12c5bfa38e3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="IDE"></p><h4 id="Nuxt"><a href="#Nuxt" class="headerlink" title="Nuxt"></a>Nuxt</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e15306126103?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Nuxt"></p><h4 id="Vue-2-x还有2-7版本"><a href="#Vue-2-x还有2-7版本" class="headerlink" title="Vue 2.x还有2.7版本"></a>Vue 2.x还有2.7版本</h4><p><img src="https://user-gold-cdn.xitu.io/2020/4/22/1719e16b0eaabdd2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="Vue 2.x还有2.7版本"></p><ul><li>将有最后一个小版本（2.7）</li><li>从Vue 3向后移植兼容的改进(不损坏兼容性前提下)</li><li>加上在Vue 3中删除的功能的弃用警告</li><li>LTS1 18个月。</li></ul><p><strong>最后建议：Vue 3虽好，如果你的项目很稳定，且对新功能无过多的要求或者迁移成本过高，则不建议升级。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址(https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;4月21日晚，Vue作者尤雨溪在哔哩哔哩直播分享了Vue.js 3.0 Beta最新进展。 以下是直播内容整理&lt;/p&gt;
&lt;h2 id=&quot;全新文档RFCs&quot;&gt;&lt;a href=&quot;#全新文档RFCs&quot; class=&quot;headerlink&quot; title=&quot;全新文档RFCs&quot;&gt;&lt;/a&gt;全新文档RFCs&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719da838e76e8c7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;全新文档RFCs&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Vue.js 3.0 Beta&lt;/code&gt;发布后的工作重点是保证稳定性和推进各类库集成&lt;/p&gt;
&lt;p&gt;所有的进度和文档都将在全新&lt;code&gt;RFCs&lt;/code&gt;文档可以看到。&lt;/p&gt;
&lt;h2 id=&quot;六大亮点&quot;&gt;&lt;a href=&quot;#六大亮点&quot; class=&quot;headerlink&quot; title=&quot;六大亮点&quot;&gt;&lt;/a&gt;六大亮点&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719daca80f3b7c2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;六大亮点&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;Performance：性能更比Vue 2.0强。&lt;/li&gt;
&lt;li&gt;Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。&lt;/li&gt;
&lt;li&gt;Composition API：组合API&lt;/li&gt;
&lt;li&gt;Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念”&lt;/li&gt;
&lt;li&gt;Better TypeScript support：更优秀的Ts支持&lt;/li&gt;
&lt;li&gt;Custom Renderer API：暴露了自定义渲染API&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Performance&quot;&gt;&lt;a href=&quot;#Performance&quot; class=&quot;headerlink&quot; title=&quot;Performance&quot;&gt;&lt;/a&gt;Performance&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/21/1719d6747e723d03?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;Performance&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;编译模板的优化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;更高效的组件初始化。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;4&quot;&gt;
&lt;li&gt;update性能提高1.3~2倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;5&quot;&gt;
&lt;li&gt;SSR速度提高了2~3倍。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面是各项性能对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719db04999e3890?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;性能对比&quot;&gt;&lt;/p&gt;
&lt;h4 id=&quot;要点1：编译模板的优化&quot;&gt;&lt;a href=&quot;#要点1：编译模板的优化&quot; class=&quot;headerlink&quot; title=&quot;要点1：编译模板的优化&quot;&gt;&lt;/a&gt;要点1：编译模板的优化&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719e59cd0f2b668?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;编译模板的优化&quot;&gt;&lt;/p&gt;
&lt;p&gt;假设要编译以下代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;span/&amp;gt;
  &amp;lt;span&amp;gt;{{ msg }}&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &amp;quot;vue&amp;quot;

export function render(_ctx, _cache) {
  return (_openBlock(), _createBlock(&amp;quot;div&amp;quot;, null, [
    _createVNode(&amp;quot;span&amp;quot;, null, &amp;quot;static&amp;quot;),
    _createVNode(&amp;quot;span&amp;quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */)
  ]))
}

// Check the console for the AST
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意看第二个&lt;code&gt;_createVNode&lt;/code&gt;结尾的“1”：&lt;/p&gt;
&lt;p&gt;Vue在运行时会生成number（大于0）值的&lt;code&gt;PatchFlag&lt;/code&gt;，用作标记。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719e69419edbc4d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;标记&quot;&gt;&lt;/p&gt;
&lt;p&gt;仅带有&lt;code&gt;PatchFlag&lt;/code&gt;标记的节点会被真正追踪，且无论层级嵌套多深，它的动态节点都直接与&lt;code&gt;Block&lt;/code&gt;根节点绑定，无需再去遍历静态节点&lt;/p&gt;
&lt;p&gt;再看以下例子：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/4/22/1719e6d7d3efe7f1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;例子2&quot;&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;div&amp;gt;
  &amp;lt;span&amp;gt;static&amp;lt;/span&amp;gt;
  &amp;lt;span :id=&amp;quot;hello&amp;quot; class=&amp;quot;bar&amp;quot;&amp;gt;{{ msg }}   &amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &amp;quot;vue&amp;quot;

export function render(_ctx, _cache) {
  return (_openBlock(), _createBlock(&amp;quot;div&amp;quot;, null, [
    _createVNode(&amp;quot;span&amp;quot;, null, &amp;quot;static&amp;quot;),
    _createVNode(&amp;quot;span&amp;quot;, {
      id: _ctx.hello,
      class: &amp;quot;bar&amp;quot;
    }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&amp;quot;id&amp;quot;])
  ]))
}
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue3.x" scheme="https://zhanghao-web.github.io/tags/Vue3-x/"/>
    
  </entry>
  
  <entry>
    <title>关于SaaS产品的一些思考和总结</title>
    <link href="https://zhanghao-web.github.io/2020/04/20/%E6%9D%82%E6%96%87/%E5%85%B3%E4%BA%8ESaaS%E4%BA%A7%E5%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>https://zhanghao-web.github.io/2020/04/20/杂文/关于SaaS产品的一些思考和总结/</id>
    <published>2020-04-20T09:38:27.000Z</published>
    <updated>2020-04-20T12:30:10.931Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SaaS的收费模式"><a href="#SaaS的收费模式" class="headerlink" title="SaaS的收费模式"></a>SaaS的收费模式</h1><p>首年收取的是开户费(软件系统费和账号费等)，从第二年开始收取年费，Sass要提供持续的运营服务才能够持续收费</p><h1 id="SaaS的运营框架"><a href="#SaaS的运营框架" class="headerlink" title="SaaS的运营框架"></a>SaaS的运营框架</h1><h2 id="基础工作"><a href="#基础工作" class="headerlink" title="基础工作"></a>基础工作</h2><h3 id="弄懂产品"><a href="#弄懂产品" class="headerlink" title="弄懂产品"></a>弄懂产品</h3><p>了解产品，可不是注册一个账号，随便玩玩，然后提几个优化建议就完事了，这是敷衍。真正弄懂产品，可以从这4方面入手。</p><p>第一、了解产品相关的行业背景，如行业历史、现状、最新动态。了解产品涉及的基础知识，如技术原理，在行业的优势。</p><p>第二、阅读产品相关的材料，包括内部的文档、介绍、白皮书，外部的报道、技术分析等。</p><p>第三、经常和技术、产品、客服同学交流，了解内部人对产品的切身感受和想法。</p><p>第四、自己深度体验产品，多问几个为什么。为什么这个功能是这样设计的，在什么场景下为谁解决了什么问题？</p><h3 id="弄懂业务"><a href="#弄懂业务" class="headerlink" title="弄懂业务"></a>弄懂业务</h3><p>首先，要弄懂自己内部的业务。要把同事变成自己的助手，而不是阻力。一定要熟悉各部门的办事流程、各部门能支持的资源、老板能支持的资源，洞悉和掌握这些信息，有利于你开展工作，快速推进。</p><p>其次，要了解客户的业务。他们的业务是怎么运作的，每个人是如何分工配合的，遇到的问题是什么。弄懂客户的业务，才能更好的匹配客户需求，不然永远是门外汉。</p><h3 id="弄懂用户路径"><a href="#弄懂用户路径" class="headerlink" title="弄懂用户路径"></a>弄懂用户路径</h3><p>用户是怎么认识你，为什么选择了你，最后又是怎么流失的？如果你能弄懂用户路径，那么就知道每个环节应该做什么，张弛有度，整体的运营工作开展就会很顺利。这一点非常重要，很多人就是没搞懂用户路径，不知道工作从哪着手，想到一点就做一点，完全没有章法，工作自然难出成绩。</p><h1 id="SaaS的核心组件"><a href="#SaaS的核心组件" class="headerlink" title="SaaS的核心组件"></a>SaaS的核心组件</h1><h2 id="安全组件（保护用户数据）"><a href="#安全组件（保护用户数据）" class="headerlink" title="安全组件（保护用户数据）"></a>安全组件（保护用户数据）</h2><h2 id="数据隔离组件"><a href="#数据隔离组件" class="headerlink" title="数据隔离组件"></a>数据隔离组件</h2><h2 id="可配置组件"><a href="#可配置组件" class="headerlink" title="可配置组件"></a>可配置组件</h2><h2 id="可扩展组件"><a href="#可扩展组件" class="headerlink" title="可扩展组件"></a>可扩展组件</h2><h2 id="0停机时间升级维护产品"><a href="#0停机时间升级维护产品" class="headerlink" title="0停机时间升级维护产品"></a>0停机时间升级维护产品</h2><h2 id="多租户组件"><a href="#多租户组件" class="headerlink" title="多租户组件"></a>多租户组件</h2><h1 id="SaaS多租户下的数据模型分析"><a href="#SaaS多租户下的数据模型分析" class="headerlink" title="SaaS多租户下的数据模型分析"></a>SaaS多租户下的数据模型分析</h1><h2 id="数据存储架构"><a href="#数据存储架构" class="headerlink" title="数据存储架构"></a>数据存储架构</h2><p>现有的多租户用户数据存储主要分为三种方式：</p><ul><li>独立数据库</li><li>共享数据库但隔离数据</li><li>共享数据库且共享数据</li></ul><h2 id="总体业务架构"><a href="#总体业务架构" class="headerlink" title="总体业务架构"></a>总体业务架构</h2><p>SaaS平台的用户管理系统主要是统一管理用户信息，用户通过SaaS平台统一注册、登录后，能够试用、采购各企业应用，实现各个第三方企业应用的集成</p><p>从功能结构上大致可以分成4个业务域：租户域、租户管理域、用户域、用户权限域等；</p><ul><li>租户域：主要描述租户的基本信息，以及租户的组织结构、租户的用户成员（成员职位）等信息；</li><li>租户管理域：主要描述租户多级管理员详情，以及管理员对应管理的企业应用权限、数据范围权限；</li><li>用户域：主要描述用户基本信息，用户登录账号、实名认证、登录的第三方账号绑定等信息；</li><li>用户权限域：主要描述用户能够使用的企业应用以及数据范围的权限信息；</li></ul><p><img src="https://img-blog.csdn.net/20180622144116115?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2hvdF9zdW1tZXJ5/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="多租户模型图"><br><img src="https://img-blog.csdnimg.cn/20200404205531179.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hvdGljZTg4OA==,size_16,color_FFFFFF,t_70" alt="分析介绍"></p><h1 id="成熟SaaS产品的4个标志"><a href="#成熟SaaS产品的4个标志" class="headerlink" title="成熟SaaS产品的4个标志"></a>成熟SaaS产品的4个标志</h1><p>成熟可用是企业选择SaaS产品的最重要标准，这也是为什么我们行业为什么要坚持潜行相当长时间的原因。企业境况说是靠时间熬出来的，更准确地说是靠产品的成熟化熬出来的。成熟的SaaS果实一如褚橙般甜蜜。</p><p>那么如何判断一个产品是已经成熟的？</p><h2 id="稳定的商业模式，组分市场和顾客分层"><a href="#稳定的商业模式，组分市场和顾客分层" class="headerlink" title="稳定的商业模式，组分市场和顾客分层"></a>稳定的商业模式，组分市场和顾客分层</h2><p>当一个商业模式和对应的价格水平能够稳定一到两年，感觉已经没有大幅修订的必要时，SaaS产品在商业模式上才算稳定下来，它是对产品成熟度的第一大贡献。</p><h2 id="产品投射了专业和行业的最佳实践"><a href="#产品投射了专业和行业的最佳实践" class="headerlink" title="产品投射了专业和行业的最佳实践"></a>产品投射了专业和行业的最佳实践</h2><p>一个成熟的CRM应用必然需要将销售管理方法、流程和工具内置在产品中，它不仅需要提供一个程序，还需要提供一个使用程序的程序。</p><h2 id="健全的用户入场协助"><a href="#健全的用户入场协助" class="headerlink" title="健全的用户入场协助"></a>健全的用户入场协助</h2><p>为了做到这一点，SaaS产品需要首先拥有完善的团队账户架构，能够支持每个个体用户使用实名账户，被初始管理员授予合适的权限，如果有多个团队，还可能需要团队管理员这个角色来减轻大管家的压力。为了加入新成员，调整成员和分组的过程必须足够清晰和简单，让客户有动力来维持这个用户系统。相反，如果我们在这个问题上忽视，胡乱地分配一些001，002工号出去，甚至允许用户合用账号，那客户总是会走到混乱失序的那一天，距离客户流失也就不远了。</p><p>仅仅有了科学完善的账户结构体系还不够，我们还要帮助企业穿针引线，让多成员进入这个系统非常简单和轻松。比如一个BI应用，在配置外部数据源的时候，需要用户添加Google Analytics的Profile，问题是掌握这个信息的人可能不是管理员本人，他可能需要同事的帮忙才能完成这个配置，这时候软件可能需要直接将邀请成员完成一个配置作为一个用例来对待，设计出专门的交互界面。</p><p>有一次在机场顿悟，昂贵的机场设施和几乎所有的机场地勤人员其实只为一个事情，让乘客登上飞机。而我们去机场，其实是为了坐飞机旅行，我们不一定意识到onboarding的过程这么重要和昂贵。</p><p>当一个SaaS产品意识到这一点，把帮助用户上船，上飞机作为一个大型项目来看待，它距离成熟就不远了。</p><h2 id="支持外部数据整合的开放性"><a href="#支持外部数据整合的开放性" class="headerlink" title="支持外部数据整合的开放性"></a>支持外部数据整合的开放性</h2><p>最后一点，成熟的SaaS产品必然考虑开放性，如果没有API，几乎就不可能成为一个长期存在的SaaS产品</p><p>一个标准化的SaaS软件可能增强到特性丰富，组织有序的良好状态，但是它绝无可能提供用户所要的所有功能，企业用户结合使用多个产品工具解决业务问题是一个常态。有了丰富的编程接口，至少让用户有机会能够通过变通的办法来实现他之所想。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SaaS的收费模式&quot;&gt;&lt;a href=&quot;#SaaS的收费模式&quot; class=&quot;headerlink&quot; title=&quot;SaaS的收费模式&quot;&gt;&lt;/a&gt;SaaS的收费模式&lt;/h1&gt;&lt;p&gt;首年收取的是开户费(软件系统费和账号费等)，从第二年开始收取年费，Sass要提供持续
      
    
    </summary>
    
      <category term="杂文" scheme="https://zhanghao-web.github.io/categories/%E6%9D%82%E6%96%87/"/>
    
    
      <category term="杂文" scheme="https://zhanghao-web.github.io/tags/%E6%9D%82%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>&lt;深入理解TypeScript读书笔记&gt;（一）</title>
    <link href="https://zhanghao-web.github.io/2020/04/19/Ts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://zhanghao-web.github.io/2020/04/19/Ts/深入理解TypeScript读书笔记（二）/</id>
    <published>2020-04-19T08:18:50.000Z</published>
    <updated>2020-04-19T08:18:50.609Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TypeScript类型系统"><a href="#TypeScript类型系统" class="headerlink" title="TypeScript类型系统"></a>TypeScript类型系统</h1><h2 id="types"><a href="#types" class="headerlink" title="@types"></a>@types</h2><h3 id="全局-types"><a href="#全局-types" class="headerlink" title="全局@types"></a>全局@types</h3><p>@types 支持全局和模块类型定义</p><pre><code class="js">npm install @type/jquery --save-dev</code></pre><p>默认情况下，TypeScript 会自动包含支持全局使用的任何声明定义</p><h3 id="局部-types"><a href="#局部-types" class="headerlink" title="局部@types"></a>局部@types</h3><p>安装完成后不需要做特别配置，只要想使用模块一样使用它一样</p><pre><code class="js">import * as $ from &#39;jquery&#39;</code></pre><p>可以在<code>typeconfig.json</code>中可以配置有意义的类型</p><pre><code class="js">{    compilerOptions{        &quot;type&quot; :[            &quot;jquery&quot;        ]    }}</code></pre><h2 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h2><p>可以使用<code>declear</code>关键字来告诉typescript，你试图表诉一个其他地方已经存在的代码</p><pre><code class="ts">foo = 123declear var foo:anyfoo = 123</code></pre><p>在实际项目可以新建一个<code>global.d.ts</code>文件来把这些声明放到里面</p><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>接口运行时的影响为0.有多种方式可以声明变量的结构</p><pre><code class="js">//等效声明//内联注解declear const myPoint = {x:number,y:number}//接口实现  interface myPoint{    x: number,    y: number}</code></pre><h3 id="类来实现接口"><a href="#类来实现接口" class="headerlink" title="类来实现接口"></a>类来实现接口</h3><pre><code class="js">interface myPoint{    x: string,    y: string}class point implements myPoint{    x: string,    y: string}</code></pre><p><strong>注意：并非每个接口都容易实现</strong></p><pre><code class="js">interface Crazy{    new() {        value: number    }}class CrazyClass implements Crazy{    constructor(){        return {            value: 123        }    }}const crazy = new CrazyClass()</code></pre><h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><p>枚举是收集有关连变量的一种方式, 作用就是管理常量，让常量更规范统一</p><h3 id="数字枚举"><a href="#数字枚举" class="headerlink" title="数字枚举"></a>数字枚举</h3><pre><code class="js">enum CradSuit{    Clubs,    Diamonds,    Hearts,    Spades}let clubs = CradSuot.Clubs</code></pre><h3 id="字符串枚举"><a href="#字符串枚举" class="headerlink" title="字符串枚举"></a>字符串枚举</h3><pre><code class="js">enum CradSuit{    Clubs,    Diamonds,    Hearts,    Spades}console.log(CardSuit.Clubs[0]) // &#39;Clubs&#39;console.log(CardSuit.[&#39;Diamonds&#39;]) // 0</code></pre><p>改变与枚举关联的数字</p><pre><code class="js">enum CradSuit{    Clubs , // 0    Diamonds, // 1    Hearts, // 2    Spades // 3}enum CradSuit{    Clubs  = 3, // 3    Diamonds, // 4    Hearts, // 5    Spades // 6</code></pre><h3 id="常量枚举"><a href="#常量枚举" class="headerlink" title="常量枚举"></a>常量枚举</h3><pre><code class="js">enum Fruit {    Apple,    banner,    orange}console.log(Fruit.orange) // 2</code></pre><h4 id="静态方法的枚举"><a href="#静态方法的枚举" class="headerlink" title="静态方法的枚举"></a>静态方法的枚举</h4><pre><code class="js">enum Weekday{    Monday,    Tuesday,    Wednesday,    Thursday,    Friday,    Saturday    Sunday}namesapce Weekday{    export function isBusinessDay(weekday: Weekday){        switch(weekday){            case Weekday.Saturday:        case Weekday.Sunday:            return false;        default:            return true;        }    }}const mon = Weekday.Monday;const sun = Weekday.Sunday;console.log(Weekday.isBusinessDay(mon)); // trueconsole.log(Weekday.isBusinessDay(sun));</code></pre><h2 id="lib-d-ts"><a href="#lib-d-ts" class="headerlink" title="lib.d.ts"></a>lib.d.ts</h2><p>安装typescript的时候会有附带一个<code>lib.d.ts</code>的文件，里面的内容定义了(window,document,math，data,string)的变量声明</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>可组合系统的核心构建块</p><h3 id="返回函数类型注解"><a href="#返回函数类型注解" class="headerlink" title="返回函数类型注解"></a>返回函数类型注解</h3><pre><code class="js">interface Foo {    foo: string}function foo(sameple: foo) :foo{    console.log(foo)}</code></pre><h3 id="可选参数及默认参数值属性"><a href="#可选参数及默认参数值属性" class="headerlink" title="可选参数及默认参数值属性"></a>可选参数及默认参数值属性</h3><pre><code class="js">function person(speak:string =&quot;hello world&quot;,age?:number){    console.log(speak,age)}person(&#39;你好&#39;)person(...12)</code></pre><h3 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h3><pre><code class="js">function addOne(a:number,y?:number,z?:number,x?:number){    if(x === undefined &amp;&amp; y === undefined &amp;&amp; z === undefined){        x = y = z = a    }else if( y === undefined &amp;&amp; z === undefined ){        z = a         x = y    }    return {        top: a,        left: x,        right: y,        bottom: z    }}addOne(1)addOne(1,1,1,1)</code></pre><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><pre><code class="js">type londHand = {    (a:number) : number}type ShortHand = (a:number) =&gt;{number}</code></pre><h2 id="可调用的"><a href="#可调用的" class="headerlink" title="可调用的"></a>可调用的</h2><pre><code class="js">interface Complex {    (foo:string,age?:number,...other,boolean[]):number}</code></pre><h2 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h2><p>TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」</p><p><code>as foo 与 &lt;foo&gt;</code></p><p><code>&lt;foo&gt;</code>可能会与jsx中冲突，推荐使用<code>as foo</code></p><h3 id="双重断言"><a href="#双重断言" class="headerlink" title="双重断言"></a>双重断言</h3><pre><code class="js">function handle(event:Event){    console.log(element = (event as any) as HTMLElement)}</code></pre><h2 id="Freshness"><a href="#Freshness" class="headerlink" title="Freshness"></a>Freshness</h2><p>为了能让检查对象字面量类型更容易，提供Freshness更严格的类型检查</p><h2 id="类型保护"><a href="#类型保护" class="headerlink" title="类型保护"></a>类型保护</h2><p>你可以使用更小范围的对象类型</p><p><code>typeof</code> <code>instanceof</code></p><h2 id="字面量类型"><a href="#字面量类型" class="headerlink" title="字面量类型"></a>字面量类型</h2><p>你可以使用一个准备的类型来定义一个对象</p><h2 id="readOnly"><a href="#readOnly" class="headerlink" title="readOnly"></a>readOnly</h2><p>如字面意思一样，是只读的，不能随便更改的，是一种更安全的方式</p><pre><code class="js">type Foo = {  readonly bar: number;  readonly bas: number;};// 初始化const foo: Foo = { bar: 123, bas: 456 };// 不能被改变foo.bar = 456; // Error: foo.bar 为仅读属性</code></pre><h3 id="与const不同"><a href="#与const不同" class="headerlink" title="与const不同"></a>与const不同</h3><ul><li>const 用于变量，变量不能重新赋给其他任何事物</li><li>readOnly 用于属性，用于别名可以修改属性</li></ul><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>他的用途就是在你不确定要穿的值的属性时，那么就可以使用泛型去确定<br>在成员之间提供有意义的约束，这些成员可以是：</p><ul><li>类的实例成员</li><li>类的方法</li><li>函数参数</li><li>函数返回值</li></ul><pre><code class="js">class Queue&lt;T&gt;{    private data: T[] = []    push = (item:&lt;T&gt;) =&gt; {this.data.push(item)}    pop = ():T | undefiend =&gt; {this.data.shift()}}const queue = new Queue&lt;number&gt;()queue.push(1)queue.shift(&#39;1&#39;) //  error &#39;1&#39; is string</code></pre><p>你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 T、U、V 表示</p><h2 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h2><p>TypeScript 能根据一些简单的规则推断（检查）变量的类型，你可以通过实践，很快的了解它们。</p><p>定义变量，函数返回类型，赋值，解构，结构化等都可以推断出类型</p><h2 id="类型兼容性"><a href="#类型兼容性" class="headerlink" title="类型兼容性"></a>类型兼容性</h2><p>用于确定一个类型是否能赋值给其他类型</p><p>协变<br>逆变，<br>双向协变，<br>不变</p><h2 id="never"><a href="#never" class="headerlink" title="never"></a>never</h2><p><code>never</code> 类型是 TypeScript 中的底层类型。它自然被分配的一些例子：</p><p>一个从来不会有返回值的函数（如：如果函数内含有 <code>while(true) {}</code>）；<br>一个总是会抛出错误的函数（如：<code>function foo() { throw new Error(&#39;Not Implemented&#39;)</code> }，foo 的返回类型是 never）；</p><p>但是，never 类型仅能被赋值给另外一个 never</p><h3 id="用例：详细的检查"><a href="#用例：详细的检查" class="headerlink" title="用例：详细的检查"></a>用例：详细的检查</h3><pre><code class="js">function foo(x:string | number):boolean {    if (typeof x === &#39;string&#39;) {        return true;    } else if (typeof x === &#39;number&#39;) {        return false;    }    // 如果不是一个 never 类型，这会报错：    // - 不是所有条件都有返回值 （严格模式下）    // - 或者检查到无法访问的代码    // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型    // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。    return fail(&#39;Unexhaustive&#39;);} function fail(message: string): never {  throw new Error(message);}</code></pre><h3 id="never与void的区别"><a href="#never与void的区别" class="headerlink" title="never与void的区别"></a>never与void的区别</h3><p>void 表示没有任何类型，never 表示永远不存在的值的类型。</p><h2 id="辨析联合类型"><a href="#辨析联合类型" class="headerlink" title="辨析联合类型"></a>辨析联合类型</h2><p>当类中含有字面量成员时，我们可以用该类的属性来辨析联合类型。</p><pre><code class="js">interface Square {  kind: &#39;square&#39;;  size: number;}interface Rectangle {  kind: &#39;rectangle&#39;;  width: number;  height: number;}type Shape = Square | Rectangle;</code></pre><h2 id="流动的类型"><a href="#流动的类型" class="headerlink" title="流动的类型"></a>流动的类型</h2><p>TypeScript 类型系统非常强大，它支持其他任何单一语言无法实现的类型流动和类型片段。<br>关键的动机：当你改变了其中一个时，其他相关的会自动更新，并且当有事情变糟糕时，你会得到一个友好的提示，就好像一个被精心设计过的约束系统。</p><h3 id="复制类型和值"><a href="#复制类型和值" class="headerlink" title="复制类型和值"></a>复制类型和值</h3><p>如果你想移动一个类，你可能会想要做以下事情：</p><pre><code class="js">class Foo {}const Bar = Foo;let bar: Bar; // Error: 不能找到名称 &#39;Bar&#39;//这会得到一个错误，因为 const 仅仅是复制了 Foo 到一个变量声明空间，因此你无法把 Bar 当作一个类型声明使用。正确的方式是使用 import 关键字，请注意，如果你在使用 namespace 或者 modules，使用 import 是你唯一能用的方式：namespace importing {  export class Foo {}}import Bar = importing.Foo;let bar: Bar; // ok//这个 import 技巧，仅适合于类型和变量。</code></pre><h3 id="捕获变量的类型"><a href="#捕获变量的类型" class="headerlink" title="捕获变量的类型"></a>捕获变量的类型</h3><p>你可以通过 typeof 操作符在类型注解中使用变量    </p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>JavaScript 有一个 Error 类，用于处理异常。你可以通过 throw 关键字来抛出一个错误。然后通过 try/catch 块来捕获此错误：</p><pre><code class="js">try{    throw new Error(&#39;Something bad happened&#39;);}catch(e){    console.log(e)}</code></pre><p>除内置的 Error 类外，还有一些额外的内置错误，它们继承自 Error 类：<code>RangeError,ReferenceError,SyntaxError,TypeError,URIError</code></p><h2 id="混合"><a href="#混合" class="headerlink" title="混合"></a>混合</h2><p>TypeScript (和 JavaScript) 类只能严格的单继承，因此你不能做：</p><pre><code class="js">class User extends Tagged, Timestamped { // ERROR : 不能多重继承  // ..}</code></pre><p>从可重用组件构建类的另一种方式是通过基类来构建它们，这种方式称为混合。</p><h2 id="常见的typescript错误"><a href="#常见的typescript错误" class="headerlink" title="常见的typescript错误"></a>常见的typescript错误</h2><p><a href="https://jkchao.github.io/typescript-book-chinese/error/common.html#ts2304" target="_blank" rel="noopener">常见的typescript错误</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TypeScript类型系统&quot;&gt;&lt;a href=&quot;#TypeScript类型系统&quot; class=&quot;headerlink&quot; title=&quot;TypeScript类型系统&quot;&gt;&lt;/a&gt;TypeScript类型系统&lt;/h1&gt;&lt;h2 id=&quot;types&quot;&gt;&lt;a href=&quot;#
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>什么是laaS,PaaS,SaaS?</title>
    <link href="https://zhanghao-web.github.io/2020/04/16/%E6%9C%8D%E5%8A%A1/%E4%BB%80%E4%B9%88%E6%98%AFlaaS-PaaS-SaaS/"/>
    <id>https://zhanghao-web.github.io/2020/04/16/服务/什么是laaS-PaaS-SaaS/</id>
    <published>2020-04-16T01:54:46.000Z</published>
    <updated>2020-04-16T14:19:39.756Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>首先云服务器可以分为</p><ul><li>IaaS：基础设施即服务，<code>Infrastructure-as-a-service</code></li><li>PaaS：平台即服务，<code>Platform-as-a-service</code></li><li>SaaS：软件即服务，<code>Software-as-a-service</code></li><li>数据即服务：如阿里云对象存储，七牛云存储等</li><li>其他软件服务：机器学习、人工智能等</li></ul></blockquote><p>公司要开发一个<code>SaaS云服务器</code>的软件，借此来加深下lasS,PaaS,SaaS的概念及区别</p><h2 id="比喻lasS-PaaS-SaaS"><a href="#比喻lasS-PaaS-SaaS" class="headerlink" title="比喻lasS,PaaS,SaaS"></a>比喻lasS,PaaS,SaaS</h2><p><a href="http://www.ruanyifeng.com/blog/2017/07/iaas-paas-saas.html" target="_blank" rel="noopener">比喻来自阮一峰的网站</a></p><p>请设想你是一个餐饮业者，打算做披萨生意。</p><p>你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。</p><p>（1）方案一：IaaS</p><p>他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。</p><p>（2）方案二：PaaS</p><p>除了基础设施，他人还提供披萨饼皮。<br>你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。</p><p>（3）方案三：SaaS</p><p>他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017072306.png" alt="披萨"></p><p>从左到右，自己承担的工作量（上图蓝色部分）越来越少，IaaS &gt; PaaS &gt; SaaS。</p><p>对应软件开发，则是下面这张图。</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2017/bg2017072307.jpg" alt="开发流程"></p><p>SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS，下面是一些例子。</p><blockquote><ul><li>客户管理服务 Salesforce</li><li>团队协同服务 Google Apps</li><li>储存服务 Box</li><li>储存服务 Dropbox</li><li>社交服务 Facebook / Twitter / Instagram</li></ul></blockquote><p>PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。</p><blockquote><ul><li>Heroku</li><li>Google App Engine</li><li>OpenShift</li></ul></blockquote><p>IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。</p><blockquote><ul><li>Amazon EC2</li><li>Digital Ocean</li><li>RackSpace Cloud</li></ul></blockquote><h2 id="SaaS详细介绍"><a href="#SaaS详细介绍" class="headerlink" title="SaaS详细介绍"></a>SaaS详细介绍</h2><p>我们将着重介绍SaaS架构设计,并围绕WHAT（是什么？）、WHY（为什么？）、WHERE（在哪里？）和HOW（怎么样？）这四个问题</p><h3 id="什么是SaaS？"><a href="#什么是SaaS？" class="headerlink" title="什么是SaaS？"></a>什么是SaaS？</h3><p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1a96e7d4e0ce5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="SaaS"></p><p>从宏观的角度来看，SaaS是一种软件应用程序交付方式，软件提供商集中化托管一个或多个软件应用程序，并通过互联网向租户体用这些软件应用程序;从分类上讲SaaS也是云计算的一部分</p><p>SaaS应用程序的任何更新或者修复漏洞操作都是由软件提供商负责实施和处理的，由于租户是通过互联网获取软件服务，所以租户端无需下载任何的升级包或者修复补丁，是一种开箱即获取最新软件产品的服务方式。</p><h3 id="为什么选择SaaS？"><a href="#为什么选择SaaS？" class="headerlink" title="为什么选择SaaS？"></a>为什么选择SaaS？</h3><h4 id="1-消费者角度"><a href="#1-消费者角度" class="headerlink" title="1.消费者角度"></a>1.消费者角度</h4><p>获取软件服务的方式足够简单，SaaS也许是迄今为止使用软件最简单的方式之一，租户只需要动动鼠标和键盘，即可在几小时甚至几分钟内获得一个大型的软件服务。相比于传统使用软件的方式，租户省去了研发、部署、运维等一系列繁复的过程，且获得软件的时间和费用成本都大幅度降低</p><h4 id="2-商业角度"><a href="#2-商业角度" class="headerlink" title="2.商业角度"></a>2.商业角度</h4><p>SaaS可以体用跨地域、跨平台的软件服务。与此同时，软件服务商可以统一对软件进行版本管理，这将带来以下几点好处（包括但不限于）：</p><p>1、缩短产品上线时间：多端适配，统一版本，统一更新<br>2、降低维护成本：不需要同时维护多个版本的软件实例，运维压力减小<br>3、容易升级：由于版本得到有效控制，一次升级，即可覆盖所有租户端</p><h3 id="SaaS的特性及优势是什么"><a href="#SaaS的特性及优势是什么" class="headerlink" title="SaaS的特性及优势是什么?"></a>SaaS的特性及优势是什么?</h3><p>1.简单<br>2.经济实惠<br>3.安全<br>4.兼任性</p><h3 id="SaaS软件的适用范围"><a href="#SaaS软件的适用范围" class="headerlink" title="SaaS软件的适用范围"></a>SaaS软件的适用范围</h3><p>从理论上讲，SaaS可以将任何的软件SaaS，下面列举一些通用的分类供大家参考：</p><p>1、Office在线办公类SaaS产品<br>2、电子邮件和即时消息类SaaS产品<br>3、社交媒体类SaaS产品<br>4、第三方API类SaaS产品<br>5、安全和访问控制类SaaS产品<br>6、机器学习类SaaS产品<br>7、人工智能类SaaS产品<br>8、地理位置服务类SaaS产品<br>9、数据流和数据检索类SaaS产品</p><h3 id="SaaS产品的缺陷"><a href="#SaaS产品的缺陷" class="headerlink" title="SaaS产品的缺陷"></a>SaaS产品的缺陷</h3><h4 id="1-软件控制权"><a href="#1-软件控制权" class="headerlink" title="1.软件控制权"></a>1.软件控制权</h4><p>与企业内部部署的软件不同，由于SaaS软件被击中托管在服务提供商的Web服务器中，所以租户无法控制所有的软件应用程序，SaaS化的软件比企业自行部署的软件获得的控制权更少，租户可操作的自定义控制权极度有限。</p><h4 id="2-消费者基数小"><a href="#2-消费者基数小" class="headerlink" title="2.消费者基数小"></a>2.消费者基数小</h4><p>由于SaaS软件是将一套应用程序共享给一个或者多个租户共同使用，这种共享的消费方式还未被大多数的消费者所接受。同时，受制于市场环境的影响，目前还有大多数的软件还未SaaS化</p><h4 id="3-性能瓶颈"><a href="#3-性能瓶颈" class="headerlink" title="3.性能瓶颈"></a>3.性能瓶颈</h4><p>共享应用程序必然会带来服务器性能的下降、如计算速度、网络资源、I/O读写等都将面临严峻的考验。在性能方面，企业内部部署的“独享模式”的应用程序比SaaS软件的“共享模式”略胜一筹。</p><h4 id="4-安全问题"><a href="#4-安全问题" class="headerlink" title="4.安全问题"></a>4.安全问题</h4><p>当租户在选择一款SaaS产品时，产品的安全性将会被放置在第一位进行考虑。如数据的隔离、敏感数据的加密、数据访问权限控制、个人隐私等问题。</p><h3 id="SaaS产品的核心组件"><a href="#SaaS产品的核心组件" class="headerlink" title="SaaS产品的核心组件"></a>SaaS产品的核心组件</h3><p>不同类型的SaaS产品，由于要面对不同的用户愿景，可能在功能和业务上会有所不同，但任何一个SaaS产品，都具备以下几个共同的核心组件。</p><p><img src="https://user-gold-cdn.xitu.io/2019/6/3/16b1a96e7628ebeb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="核心组件"></p><h4 id="安全组件"><a href="#安全组件" class="headerlink" title="安全组件"></a>安全组件</h4><p>在SaaS产品中，系统安全永远是第一位需要考虑的事情，如何保障租户数据的安全，是你首要的事情。这如同银行首选需要保障储户资金安全一样。安全组件就是统一的对SaaS产品进行安全防护，保障系统数据安全。</p><h4 id="数据隔离组件"><a href="#数据隔离组件" class="headerlink" title="数据隔离组件"></a>数据隔离组件</h4><p>安全组件解决了用户数据安全可靠的问题，但数据往往还需要解决隐私问题，各企业之间的数据必须相互不可见，即相互隔离。在SaaS产品中，如何识别、区分、隔离个租户的数据时你在实施SaaS软件架构设计时需要考虑的第二个问题。</p><h4 id="可配置组件"><a href="#可配置组件" class="headerlink" title="可配置组件"></a>可配置组件</h4><p>尽管SaaS产品在设计之初就考虑了大多数通用的功能，让租户开箱即用，但任然有为数不少的租户需要定制服务自身业务需求的配置项，如UI布局、主题、标识（Logo）等信息。正因为无法抽象出一个完全通用的应用程序，所以在SaaS产品中，你需要提供一个可用于自定义配置的组件。</p><h4 id="可扩展组件"><a href="#可扩展组件" class="headerlink" title="可扩展组件"></a>可扩展组件</h4><p>随着SaaS产品业务和租户数量的增长，原有的服务器配置将无法继续满足新的需求，系统性能将会与业务量和用户量成反比。此时，SaaS产品应该具备水平扩展的能力。如通过网络负载均衡其和容器技术，在多个服务器上部署多个软件运行示例并提供相同的软件服务，以此实现水平扩展SaaS产品的整体服务性能。为了实现可扩展能力，就需要SaaS展示层的代码与业务逻辑部分的代码进行分离，两者独立部署。例如<strong>使用VUE+微服务构建前后端分离且可水平进行扩展的分布式SaaS应用产品</strong>。对于可扩展，还有另外一种方式，即<strong>垂直扩展</strong>，其做法比较简单，也比较粗暴：通过增加单台服务器的配置，如购买性能更好的CUP、存储更大的内存条、增大带宽等措施，让服务器能够处理更多的用户请求。但此做法对于提升产品性能没有质的改变，且成本很高。</p><h4 id="0停机时间升级产品"><a href="#0停机时间升级产品" class="headerlink" title="0停机时间升级产品"></a>0停机时间升级产品</h4><p>以往的软件在升级或者修复Bug时，都需要将运行的程序脱机一段时间，等待升级或修复工作完成后，再重新启动应用程序。而SaaS产品则需要全天候保障服务的可用性。这就需要你考虑如何实现在不重启原有应用程序的情况下，完成应用程序的升级修复工作。</p><h4 id="多租户组件"><a href="#多租户组件" class="headerlink" title="多租户组件"></a>多租户组件</h4><p>要将原有产品SaaS化，就必须提供多租户组件，多租户组件是衡量一个应用程序是否具备SaaS服务能力的重要指标之一。SaaS产品需要同时容纳多个租户的数据，同时还需要保证各租户之间的数据不会相互干扰，保证租户中的用户能够按期望索引到正确的数据，多租户组件是你必须要解决的一个问题。其余的组件都将围绕此组件展开各自的业务。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;首先云服务器可以分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IaaS：基础设施即服务，&lt;code&gt;Infrastructure
      
    
    </summary>
    
      <category term="Serve" scheme="https://zhanghao-web.github.io/categories/Serve/"/>
    
    
      <category term="服务端" scheme="https://zhanghao-web.github.io/tags/%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>vue.config.js基本配置</title>
    <link href="https://zhanghao-web.github.io/2020/04/01/Vue/vue-config-js%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE/"/>
    <id>https://zhanghao-web.github.io/2020/04/01/Vue/vue-config-js基本配置/</id>
    <published>2020-04-01T08:06:12.000Z</published>
    <updated>2020-04-01T08:07:02.716Z</updated>
    
    <content type="html"><![CDATA[<pre><code class="js">// vue.config.js 基本配置方法module.exports = {  // 项目部署的基础路径  // 我们默认假设你的应用将会部署在域名的根部，  // 比如 https://www.my-app.com/  // 如果你的应用时部署在一个子路径下，那么你需要在这里  // 指定子路径。比如，如果你的应用部署在  // https://www.foobar.com/my-app/  // 那么将这个值改为 `/my-app/`  // 基本路径 baseURL已经过时  publicPath: &#39;./&#39;,    // 打包项目时构建的文件目录，用法与webpack本身的output.path一致  outputDir: &#39;dist&#39;,   // 静态资源目录 (js, css, img, fonts)  assetsDir: &#39;assets&#39;,  // eslint-loader 是否在保存的时候检查，编译不规范时，设为true在命令行中警告，若设为error则不仅警告，并且编译失败  lintOnSave: true,  // 调整内部的 webpack 配置。查阅 https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli/webpack.md  chainWebpack: () =&gt; {},  configureWebpack: () =&gt; {},  // vue-loader 配置项 https://vue-loader.vuejs.org/en/options.html   vueLoader: {},  // 生产环境是否生成 sourceMap 文件，默认true，若不需要生产环境的sourceMap，可以设置为false，加速生产环境的构建  productionSourceMap: true,  // css相关配置  css: {   // 是否使用css分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用&lt;style&gt;方式内联至html文件中   extract: true,   // 是否在构建样式地图，false将提高构建速度   sourceMap: false,   // css预设器配置项   loaderOptions: {},   // 启用 CSS modules for all css / pre-processor files.   // 这个选项不会影响 `*.vue` 文件   modules: false  },  // 在生产环境下为 Babel 和 TypeScript 使用 `thread-loader`  // 在多核机器下会默认开启。  parallel: require(&#39;os&#39;).cpus().length &gt; 1,  // 是否启用dll See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#dll-mode  dll: false,  // PWA 插件相关配置 see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa  pwa: {},  // webpack-dev-server 相关配置  devServer: {   open: process.platform === &#39;darwin&#39;,   host: &#39;0.0.0.0&#39;,//如果是真机测试，就使用这个IP   port: 1234,   https: false,   hotOnly: false,   proxy: null, // 设置代理   // proxy: {   //     &#39;/api&#39;: {   //         target: &#39;&lt;url&gt;&#39;,   //         ws: true,   //         changOrigin: true   //     }   // },   before: app =&gt; {}  },  // 第三方插件配置  pluginOptions: {   // ...  } }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// vue.config.js 基本配置方法
module.exports = {
  // 项目部署的基础路径
  // 我们默认假设你的应用将会部署在域名的根部，
  // 比如 https://www.my-app.com/
 
      
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>&lt;深入理解TypeScript读书笔记&gt;（一）</title>
    <link href="https://zhanghao-web.github.io/2020/03/25/Ts/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://zhanghao-web.github.io/2020/03/25/Ts/深入理解TypeScript读书笔记-（一）/</id>
    <published>2020-03-25T13:07:50.000Z</published>
    <updated>2020-03-25T14:41:03.128Z</updated>
    
    <content type="html"><![CDATA[<h1 id="书本地址"><a href="#书本地址" class="headerlink" title="书本地址"></a>书本地址</h1><p><a href="https://jkchao.github.io/typescript-book-chinese/#why" target="_blank" rel="noopener">https://jkchao.github.io/typescript-book-chinese/#why</a></p><h2 id="什么是TypeScript-为什么要使用TypeScript"><a href="#什么是TypeScript-为什么要使用TypeScript" class="headerlink" title="什么是TypeScript,为什么要使用TypeScript?"></a>什么是TypeScript,为什么要使用TypeScript?</h2><p>根据TypeScript官网中的介绍，TypeScript - JavaScript the scales (属于Js的超集)，Ts发展至今已经是很多大型项目的标配，它提供的静态类型检查，大大的提高了代码的可维护性及可读性；同时提供最新和不断发展的Javascript特性，让我们能建立更加强壮的组件。</p><h2 id="从tsconfig-json配置看ts整体"><a href="#从tsconfig-json配置看ts整体" class="headerlink" title="从tsconfig.json配置看ts整体"></a>从tsconfig.json配置看ts整体</h2><h3 id="创建tsconfig-json文件，配置信息"><a href="#创建tsconfig-json文件，配置信息" class="headerlink" title="创建tsconfig.json文件，配置信息"></a>创建tsconfig.json文件，配置信息</h3><p>通过compilerOption来定制你的编译选项</p><pre><code class="json">{  &quot;compilerOptions&quot;: {    /* 基本选项 */    &quot;target&quot;: &quot;es5&quot;,                       // 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39;    &quot;module&quot;: &quot;commonjs&quot;,                  // 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39;    &quot;lib&quot;: [],                             // 指定要包含在编译中的库文件    &quot;allowJs&quot;: true,                       // 允许编译 javascript 文件    &quot;checkJs&quot;: true,                       // 报告 javascript 文件中的错误    &quot;jsx&quot;: &quot;preserve&quot;,                     // 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39;    &quot;declaration&quot;: true,                   // 生成相应的 &#39;.d.ts&#39; 文件    &quot;sourceMap&quot;: true,                     // 生成相应的 &#39;.map&#39; 文件    &quot;outFile&quot;: &quot;./&quot;,                       // 将输出文件合并为一个文件    &quot;outDir&quot;: &quot;./&quot;,                        // 指定输出目录    &quot;rootDir&quot;: &quot;./&quot;,                       // 用来控制输出目录结构 --outDir.    &quot;removeComments&quot;: true,                // 删除编译后的所有的注释    &quot;noEmit&quot;: true,                        // 不生成输出文件    &quot;importHelpers&quot;: true,                 // 从 tslib 导入辅助工具函数    &quot;isolatedModules&quot;: true,               // 将每个文件做为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）.    /* 严格的类型检查选项 */    &quot;strict&quot;: true,                        // 启用所有严格类型检查选项    &quot;noImplicitAny&quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错    &quot;strictNullChecks&quot;: true,              // 启用严格的 null 检查    &quot;noImplicitThis&quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误    &quot;alwaysStrict&quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39;    /* 额外的检查 */    &quot;noUnusedLocals&quot;: true,                // 有未使用的变量时，抛出错误    &quot;noUnusedParameters&quot;: true,            // 有未使用的参数时，抛出错误    &quot;noImplicitReturns&quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误    &quot;noFallthroughCasesInSwitch&quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）    /* 模块解析选项 */    &quot;moduleResolution&quot;: &quot;node&quot;,            // 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6)    &quot;baseUrl&quot;: &quot;./&quot;,                       // 用于解析非相对模块名称的基目录    &quot;paths&quot;: {},                           // 模块名到基于 baseUrl 的路径映射的列表    &quot;rootDirs&quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容    &quot;typeRoots&quot;: [],                       // 包含类型声明的文件列表    &quot;types&quot;: [],                           // 需要包含的类型声明文件名列表    &quot;allowSyntheticDefaultImports&quot;: true,  // 允许从没有设置默认导出的模块中默认导入。    /* Source Map Options */    &quot;sourceRoot&quot;: &quot;./&quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置    &quot;mapRoot&quot;: &quot;./&quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置    &quot;inlineSourceMap&quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件    &quot;inlineSources&quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性    /* 其他选项 */    &quot;experimentalDecorators&quot;: true,        // 启用装饰器    &quot;emitDecoratorMetadata&quot;: true          // 为装饰器提供元数据的支持  }}</code></pre><h3 id="Ts编译生成Js文件"><a href="#Ts编译生成Js文件" class="headerlink" title="Ts编译生成Js文件"></a>Ts编译生成Js文件</h3><p>在目录下运行 <code>tsc</code>命令，会在当前目录或者父级目录下找<code>tsconfig.json</code>文件<br>运行 <code>tsc -p ./path-to-project-directory</code> 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。<br>使用 <code>tsc -w</code> 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。</p><h3 id="显示的指定编译文件"><a href="#显示的指定编译文件" class="headerlink" title="显示的指定编译文件"></a>显示的指定编译文件</h3><pre><code class="js">{  &quot;files&quot;: [    &quot;./some/file.ts&quot;  ]}</code></pre><h2 id="声明空间"><a href="#声明空间" class="headerlink" title="声明空间"></a>声明空间</h2><h3 id="类型声明空间（class-interface-type）"><a href="#类型声明空间（class-interface-type）" class="headerlink" title="类型声明空间（class interface type）"></a>类型声明空间（class interface type）</h3><pre><code class="js">class Foo{}interface Bar{}type Bas{}</code></pre><p><strong>注意：</strong>尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。</p><h3 id="变量声明空间"><a href="#变量声明空间" class="headerlink" title="变量声明空间"></a>变量声明空间</h3><pre><code class="js">class Foo {}const someOne = Fooconst someOneVar = 123</code></pre><p><strong>注意</strong> 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解。</p><a id="more"></a><h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h3 id="全局模块"><a href="#全局模块" class="headerlink" title="全局模块"></a>全局模块</h3><p>类似js的中全局对象，是一种不安全的方式，可使用文件模块代替</p><pre><code class="js">const Foo = 123const Bar = Foo</code></pre><h3 id="文件模块"><a href="#文件模块" class="headerlink" title="文件模块"></a>文件模块</h3><p>文件模块也可以叫做外部模块，通过import,export导入导出，从而才能使用</p><pre><code class="js">//foo.jsexport const foo = 123//bar.jsimport {foo} from &#39;./foo.js&#39;const bar = foo</code></pre><h4 id="文件模块详情"><a href="#文件模块详情" class="headerlink" title="文件模块详情"></a>文件模块详情</h4><h5 id="ES模块语法"><a href="#ES模块语法" class="headerlink" title="ES模块语法"></a>ES模块语法</h5><p>导出</p><pre><code class="js">//使用 export 关键字导出一个变量或类型export const someVar = 123;export type someType = {  foo: string;};// export 的写法除了上面这种，还有另外一种：const someVar = 123;type someType = {  type: string;};export { someVar, someType };// 可以用重命名变量的方式导出：const someVar = 123;export { someVar as aDifferentName };</code></pre><p>导入</p><pre><code class="js">//使用 import 关键字导入一个变量或者是一个类型：import { someVar, someType } from &#39;./foo&#39;;//通过重命名的方式导入变量或者类型：import { someVar as aDifferentName } from &#39;./foo&#39;//可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面：// 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型import * as foo from &#39;./foo&#39;;//只导入模块：import &#39;core-js&#39;; // 一个普通的 polyfill 库//从其他模块导入后整体导出：export * from &#39;./foo&#39;;//从其他模块导入后，部分导出：export { someVar } from &#39;./foo&#39;;//通过重命名，部分导出从另一个模块导入的项目：export { someVar as aDifferentName } from &#39;./foo&#39;;//默认导入／导出,使用 export default// some varexport default (someVar = 123);//导入使用 import someName from &#39;someModule&#39; 语法（你可以根据需要为导入命名）：import someLocalNameForThisFile from &#39;./foo&#39;;</code></pre><h5 id="模块路径"><a href="#模块路径" class="headerlink" title="模块路径"></a>模块路径</h5><p>这里存在两种截然不同的模块：</p><blockquote><p>相对模块路径（路径以 . 开头，例如：./someFile 或者 ../../someFolder/someFile 等）；<br>其他动态查找模块（如：core-js，typestyle，react 或者甚至是 react/core 等）。</p></blockquote><h5 id="什么是-place"><a href="#什么是-place" class="headerlink" title="什么是 place"></a>什么是 place</h5><p>这个点指的应该是一个模块查找的过程</p><h5 id="重写类型的动态查找"><a href="#重写类型的动态查找" class="headerlink" title="重写类型的动态查找"></a>重写类型的动态查找</h5><p>在项目里，可以通过<code>declare module &#39;somePath&#39;</code> 声明一个全局模块的方式，来解决查找模块路径的问题。</p><h5 id="import-require-仅仅是导入类型"><a href="#import-require-仅仅是导入类型" class="headerlink" title="import/require 仅仅是导入类型"></a>import/require 仅仅是导入类型</h5><p>它实际上只做了两件事：</p><ul><li>导入 foo 模块的所有类型信息；</li><li>确定 foo 模块运行时的依赖关系。</li></ul><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>在 JavaScript 可以使用匿名函数创建一个命名空间</p><pre><code class="js">(function(something) {  something.foo = 123;})(something || (something = {}));</code></pre><p>TypeScript 提供了 namespace 关键字来描述这种分组</p><pre><code class="js">namespace Utility {  export function log(msg) {    console.log(msg);  }  export function error(msg) {    console.log(msg);  }}// usageUtility.log(&#39;Call me&#39;);Utility.error(&#39;maybe&#39;);</code></pre><h2 id="动态导入表达式"><a href="#动态导入表达式" class="headerlink" title="动态导入表达式"></a>动态导入表达式</h2><p>动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块  </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;书本地址&quot;&gt;&lt;a href=&quot;#书本地址&quot; class=&quot;headerlink&quot; title=&quot;书本地址&quot;&gt;&lt;/a&gt;书本地址&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://jkchao.github.io/typescript-book-chinese/#why&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://jkchao.github.io/typescript-book-chinese/#why&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;什么是TypeScript-为什么要使用TypeScript&quot;&gt;&lt;a href=&quot;#什么是TypeScript-为什么要使用TypeScript&quot; class=&quot;headerlink&quot; title=&quot;什么是TypeScript,为什么要使用TypeScript?&quot;&gt;&lt;/a&gt;什么是TypeScript,为什么要使用TypeScript?&lt;/h2&gt;&lt;p&gt;根据TypeScript官网中的介绍，TypeScript - JavaScript the scales (属于Js的超集)，Ts发展至今已经是很多大型项目的标配，它提供的静态类型检查，大大的提高了代码的可维护性及可读性；同时提供最新和不断发展的Javascript特性，让我们能建立更加强壮的组件。&lt;/p&gt;
&lt;h2 id=&quot;从tsconfig-json配置看ts整体&quot;&gt;&lt;a href=&quot;#从tsconfig-json配置看ts整体&quot; class=&quot;headerlink&quot; title=&quot;从tsconfig.json配置看ts整体&quot;&gt;&lt;/a&gt;从tsconfig.json配置看ts整体&lt;/h2&gt;&lt;h3 id=&quot;创建tsconfig-json文件，配置信息&quot;&gt;&lt;a href=&quot;#创建tsconfig-json文件，配置信息&quot; class=&quot;headerlink&quot; title=&quot;创建tsconfig.json文件，配置信息&quot;&gt;&lt;/a&gt;创建tsconfig.json文件，配置信息&lt;/h3&gt;&lt;p&gt;通过compilerOption来定制你的编译选项&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
  &amp;quot;compilerOptions&amp;quot;: {

    /* 基本选项 */
    &amp;quot;target&amp;quot;: &amp;quot;es5&amp;quot;,                       // 指定 ECMAScript 目标版本: &amp;#39;ES3&amp;#39; (default), &amp;#39;ES5&amp;#39;, &amp;#39;ES2015&amp;#39;, &amp;#39;ES2016&amp;#39;, &amp;#39;ES2017&amp;#39;, or &amp;#39;ESNEXT&amp;#39;
    &amp;quot;module&amp;quot;: &amp;quot;commonjs&amp;quot;,                  // 指定使用模块: &amp;#39;commonjs&amp;#39;, &amp;#39;amd&amp;#39;, &amp;#39;system&amp;#39;, &amp;#39;umd&amp;#39; or &amp;#39;es2015&amp;#39;
    &amp;quot;lib&amp;quot;: [],                             // 指定要包含在编译中的库文件
    &amp;quot;allowJs&amp;quot;: true,                       // 允许编译 javascript 文件
    &amp;quot;checkJs&amp;quot;: true,                       // 报告 javascript 文件中的错误
    &amp;quot;jsx&amp;quot;: &amp;quot;preserve&amp;quot;,                     // 指定 jsx 代码的生成: &amp;#39;preserve&amp;#39;, &amp;#39;react-native&amp;#39;, or &amp;#39;react&amp;#39;
    &amp;quot;declaration&amp;quot;: true,                   // 生成相应的 &amp;#39;.d.ts&amp;#39; 文件
    &amp;quot;sourceMap&amp;quot;: true,                     // 生成相应的 &amp;#39;.map&amp;#39; 文件
    &amp;quot;outFile&amp;quot;: &amp;quot;./&amp;quot;,                       // 将输出文件合并为一个文件
    &amp;quot;outDir&amp;quot;: &amp;quot;./&amp;quot;,                        // 指定输出目录
    &amp;quot;rootDir&amp;quot;: &amp;quot;./&amp;quot;,                       // 用来控制输出目录结构 --outDir.
    &amp;quot;removeComments&amp;quot;: true,                // 删除编译后的所有的注释
    &amp;quot;noEmit&amp;quot;: true,                        // 不生成输出文件
    &amp;quot;importHelpers&amp;quot;: true,                 // 从 tslib 导入辅助工具函数
    &amp;quot;isolatedModules&amp;quot;: true,               // 将每个文件做为单独的模块 （与 &amp;#39;ts.transpileModule&amp;#39; 类似）.

    /* 严格的类型检查选项 */
    &amp;quot;strict&amp;quot;: true,                        // 启用所有严格类型检查选项
    &amp;quot;noImplicitAny&amp;quot;: true,                 // 在表达式和声明上有隐含的 any类型时报错
    &amp;quot;strictNullChecks&amp;quot;: true,              // 启用严格的 null 检查
    &amp;quot;noImplicitThis&amp;quot;: true,                // 当 this 表达式值为 any 类型的时候，生成一个错误
    &amp;quot;alwaysStrict&amp;quot;: true,                  // 以严格模式检查每个模块，并在每个文件里加入 &amp;#39;use strict&amp;#39;

    /* 额外的检查 */
    &amp;quot;noUnusedLocals&amp;quot;: true,                // 有未使用的变量时，抛出错误
    &amp;quot;noUnusedParameters&amp;quot;: true,            // 有未使用的参数时，抛出错误
    &amp;quot;noImplicitReturns&amp;quot;: true,             // 并不是所有函数里的代码都有返回值时，抛出错误
    &amp;quot;noFallthroughCasesInSwitch&amp;quot;: true,    // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿）

    /* 模块解析选项 */
    &amp;quot;moduleResolution&amp;quot;: &amp;quot;node&amp;quot;,            // 选择模块解析策略： &amp;#39;node&amp;#39; (Node.js) or &amp;#39;classic&amp;#39; (TypeScript pre-1.6)
    &amp;quot;baseUrl&amp;quot;: &amp;quot;./&amp;quot;,                       // 用于解析非相对模块名称的基目录
    &amp;quot;paths&amp;quot;: {},                           // 模块名到基于 baseUrl 的路径映射的列表
    &amp;quot;rootDirs&amp;quot;: [],                        // 根文件夹列表，其组合内容表示项目运行时的结构内容
    &amp;quot;typeRoots&amp;quot;: [],                       // 包含类型声明的文件列表
    &amp;quot;types&amp;quot;: [],                           // 需要包含的类型声明文件名列表
    &amp;quot;allowSyntheticDefaultImports&amp;quot;: true,  // 允许从没有设置默认导出的模块中默认导入。

    /* Source Map Options */
    &amp;quot;sourceRoot&amp;quot;: &amp;quot;./&amp;quot;,                    // 指定调试器应该找到 TypeScript 文件而不是源文件的位置
    &amp;quot;mapRoot&amp;quot;: &amp;quot;./&amp;quot;,                       // 指定调试器应该找到映射文件而不是生成文件的位置
    &amp;quot;inlineSourceMap&amp;quot;: true,               // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件
    &amp;quot;inlineSources&amp;quot;: true,                 // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性

    /* 其他选项 */
    &amp;quot;experimentalDecorators&amp;quot;: true,        // 启用装饰器
    &amp;quot;emitDecoratorMetadata&amp;quot;: true          // 为装饰器提供元数据的支持
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;Ts编译生成Js文件&quot;&gt;&lt;a href=&quot;#Ts编译生成Js文件&quot; class=&quot;headerlink&quot; title=&quot;Ts编译生成Js文件&quot;&gt;&lt;/a&gt;Ts编译生成Js文件&lt;/h3&gt;&lt;p&gt;在目录下运行 &lt;code&gt;tsc&lt;/code&gt;命令，会在当前目录或者父级目录下找&lt;code&gt;tsconfig.json&lt;/code&gt;文件&lt;br&gt;运行 &lt;code&gt;tsc -p ./path-to-project-directory&lt;/code&gt; 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。&lt;br&gt;使用 &lt;code&gt;tsc -w&lt;/code&gt; 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。&lt;/p&gt;
&lt;h3 id=&quot;显示的指定编译文件&quot;&gt;&lt;a href=&quot;#显示的指定编译文件&quot; class=&quot;headerlink&quot; title=&quot;显示的指定编译文件&quot;&gt;&lt;/a&gt;显示的指定编译文件&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;{
  &amp;quot;files&amp;quot;: [
    &amp;quot;./some/file.ts&amp;quot;
  ]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;声明空间&quot;&gt;&lt;a href=&quot;#声明空间&quot; class=&quot;headerlink&quot; title=&quot;声明空间&quot;&gt;&lt;/a&gt;声明空间&lt;/h2&gt;&lt;h3 id=&quot;类型声明空间（class-interface-type）&quot;&gt;&lt;a href=&quot;#类型声明空间（class-interface-type）&quot; class=&quot;headerlink&quot; title=&quot;类型声明空间（class interface type）&quot;&gt;&lt;/a&gt;类型声明空间（class interface type）&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;class Foo{}
interface Bar{}
type Bas{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。&lt;/p&gt;
&lt;h3 id=&quot;变量声明空间&quot;&gt;&lt;a href=&quot;#变量声明空间&quot; class=&quot;headerlink&quot; title=&quot;变量声明空间&quot;&gt;&lt;/a&gt;变量声明空间&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;class Foo {}
const someOne = Foo
const someOneVar = 123
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解。&lt;/p&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的箭头函数</title>
    <link href="https://zhanghao-web.github.io/2020/03/15/Js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
    <id>https://zhanghao-web.github.io/2020/03/15/Js/你不知道的箭头函数/</id>
    <published>2020-03-15T10:31:16.000Z</published>
    <updated>2020-03-18T13:59:45.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简言"><a href="#简言" class="headerlink" title="简言"></a>简言</h1><p>ES6的箭头函数，我们会在工作中经常知道，但是你知道什么时候使用箭头函数，什么时候不能使用箭头函数吗？</p><h2 id="什么时候使用箭头函数？"><a href="#什么时候使用箭头函数？" class="headerlink" title="什么时候使用箭头函数？"></a>什么时候使用箭头函数？</h2><blockquote><p>为啥大多数情况都使用箭头函数？</p></blockquote><p>作用域安全性:当箭头函数被一致使用时，所有东西都保证使用与根对象相同的this。如果一个标准函数回调与一堆箭头函数混合在一起，那么作用域就有可能变得混乱。</p><p>紧凑性:箭头函数更容易读写。</p><p>清晰度:使用箭头函数可明确知道当前 this 指向</p><p>其它情况使用箭头函数。</p><h2 id="什么时候不能使用箭头函数？"><a href="#什么时候不能使用箭头函数？" class="headerlink" title="什么时候不能使用箭头函数？"></a>什么时候不能使用箭头函数？</h2><h3 id="定义对象方法"><a href="#定义对象方法" class="headerlink" title="定义对象方法"></a>定义对象方法</h3><h4 id="定义字面量的方法"><a href="#定义字面量的方法" class="headerlink" title="定义字面量的方法"></a>定义字面量的方法</h4><pre><code class="js">const calculator = {    array: [1, 2, 3],    sum: () =&gt; {        console.log(this === window); // =&gt; true        return this.array.reduce((result, item) =&gt; result + item);    }};console.log(this === window); // =&gt; true// Throws &quot;TypeError: Cannot read property &#39;reduce&#39; of undefined&quot;calculator.sum();</code></pre><p>calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。</p><p><strong>解决的办法</strong>是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的，</p><pre><code class="js">const calculator = {    array: [1, 2, 3],    sum() {        console.log(this === calculator); // =&gt; true        return this.array.reduce((result, item) =&gt; result + item);    }};calculator.sum(); // =&gt; 6</code></pre><h4 id="定义原型方法"><a href="#定义原型方法" class="headerlink" title="定义原型方法"></a>定义原型方法</h4><p>同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误</p><pre><code class="js">function Cat(name) {    this.name = name;}Cat.prototype.sayCatName = () =&gt; {    console.log(this === window); // =&gt; true    return this.name;};const cat = new Cat(&#39;Mew&#39;);cat.sayCatName(); // =&gt; undefined</code></pre><p><strong>解决方法</strong>:使用传统的函数表达式就能解决问题</p><h3 id="定义事件回调函数"><a href="#定义事件回调函数" class="headerlink" title="定义事件回调函数"></a>定义事件回调函数</h3><pre><code class="js">const button = document.getElementById(&#39;myButton&#39;);button.addEventListener(&#39;click&#39;, () =&gt; {    console.log(this === window); // =&gt; true    this.innerHTML = &#39;Clicked button&#39;;});</code></pre><p>在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。</p><p><strong>解决方法</strong>:使用传统的函数表达式就能解决问题</p><h3 id="定义构造函数"><a href="#定义构造函数" class="headerlink" title="定义构造函数"></a>定义构造函数</h3><p>构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。</p><pre><code class="js">const Message = (text) =&gt; {    this.text = text;};// Throws &quot;TypeError: Message is not a constructor&quot;const helloMessage = new Message(&#39;Hello World!&#39;);</code></pre><h3 id="追求过短的代码"><a href="#追求过短的代码" class="headerlink" title="追求过短的代码"></a>追求过短的代码</h3><p>在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观，</p><pre><code class="js">const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b;const double = multiply(2);double(3);      // =&gt; 6multiply(2, 3); // =&gt; 6</code></pre><p>multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者</p><pre><code class="js">function multiply(a, b) {    if (b === undefined) {        return function (b) {            return a * b;        }    }    return a * b;}const double = multiply(2);double(3); // =&gt; 6multiply(2, 3); // =&gt; 6</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;简言&quot;&gt;&lt;a href=&quot;#简言&quot; class=&quot;headerlink&quot; title=&quot;简言&quot;&gt;&lt;/a&gt;简言&lt;/h1&gt;&lt;p&gt;ES6的箭头函数，我们会在工作中经常知道，但是你知道什么时候使用箭头函数，什么时候不能使用箭头函数吗？&lt;/p&gt;
&lt;h2 id=&quot;什么时候使用
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="ES6" scheme="https://zhanghao-web.github.io/tags/ES6/"/>
    
  </entry>
  
  <entry>
    <title>你不知道的 JSON.stringify() 的威力</title>
    <link href="https://zhanghao-web.github.io/2019/12/12/Js/%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JSON-stringify-%E7%9A%84%E5%A8%81%E5%8A%9B/"/>
    <id>https://zhanghao-web.github.io/2019/12/12/Js/你不知道的-JSON-stringify-的威力/</id>
    <published>2019-12-12T08:17:03.000Z</published>
    <updated>2020-01-28T10:04:15.036Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5decf09de51d45584d238319#heading-4" target="_blank" rel="noopener">原文地址</a></p><h2 id="通过需求学习JSON-stringify"><a href="#通过需求学习JSON-stringify" class="headerlink" title="通过需求学习JSON.stringify()"></a>通过需求学习JSON.stringify()</h2><p>首先我们在开发的过程当中遇到这样一个处理数据的需求</p><pre><code class="js">const todayILearn = {  _id: 1,  content: &#39;今天学习 JSON.stringify()，我很开心！&#39;,  created_at: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;,  updated_at: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39;}</code></pre><p>我们需要将上面这个对象处理成下面这个对象</p><pre><code class="js">const todayILearn = {  id: 1,  content: &#39;今天学习 JSON.stringify()，我很开心！&#39;,  createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;,  updatedAt: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39;}</code></pre><p>也就是在不改变属性的值的前提下，将对象属性修改一下。 把_id  改成 id，把 updated_at 改成 updatedAt，把 created_at 改成 createdAt。我们现在通过这个小小的需求来见识一下 JSON.stringify() 的强大吧。</p><p>首先要解决这个问题我们有很多种解决方式，我们先提供两种不优雅的解决方案：</p><p><strong>方案一：一次遍历+多声明一个变量</strong></p><pre><code class="js">// 多一个变量存储const todayILearnTemp = {};for (const [key, value] of Object.entries(todayILearn)) {  if (key === &quot;_id&quot;) todayILearnTemp[&quot;id&quot;] = value;  else if (key === &quot;created_at&quot;) todayILearnTemp[&quot;createdAt&quot;] = value;  else if (key === &quot;updatedAt&quot;) todayILearnTemp[&quot;updatedAt&quot;] = value;  else todayILearnTemp[key] = value;}console.log(todayILearnTemp);// 结果：// { id: 1,//  content: &#39;今天学习 JSON.stringify()，我很开心！&#39;,//  createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;,//  updated_at: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; // }</code></pre><p>方案一完全没有问题，可以实现。但是多声明了一个变量又加上一层循环并且还有很多的 if else 语句，怎么都显得不太优雅。</p><p><strong>方案二：暴力 delete 属性和增加属性</strong></p><pre><code class="js">// 极致的暴力美学todayILearn.id = todayILearn._id;todayILearn.createdAt = todayILearn.created_at;todayILearn.updatedAt = todayILearn.updated_at;delete todayILearn._id;delete todayILearn.created_at;delete todayILearn.updated_at;console.log(todayILearn);//     太暴力😢//{ //  content: &#39;今天学习 JSON.stringify()，我很开心！&#39;,//  id: 1,//  createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;,//  updatedAt: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; //}</code></pre><p>直接 delete 暴力解决太粗鲁了，而且有一个缺点，属性的顺序变了。</p><p><strong>方案三：序列化+ replace 美学典范</strong></p><pre><code class="js">const mapObj = {  _id: &quot;id&quot;,  created_at: &quot;createdAt&quot;,  updated_at: &quot;updatedAt&quot;};JSON.parse(  JSON.stringify(todayILearn).replace(    /_id|created_at|updated_at/gi,    matched =&gt; mapObj[matched])    )// { // id: 1,//  content: &#39;今天学习 JSON.stringify()，我很开心！&#39;,//  createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;,//  updatedAt: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; // }</code></pre><p><img src="https://user-gold-cdn.xitu.io/2019/12/8/16ee5ace18ca5dbb?imageslim" alt="Json.Stringify"></p><a id="more"></a><h2 id="JSON-stringify-九大特性"><a href="#JSON-stringify-九大特性" class="headerlink" title="JSON.stringify() 九大特性"></a>JSON.stringify() 九大特性</h2><h3 id="JSON-stringify-第一大特性"><a href="#JSON-stringify-第一大特性" class="headerlink" title="JSON.stringify()第一大特性"></a>JSON.stringify()第一大特性</h3><p><strong>对于 undefined、任意的函数以及 symbol 三个特殊的值分别作为对象属性的值、数组元素、单独的值时 JSON.stringify()将返回不同的结果</strong>。</p><p>首先，我们来复习一下知识点，看一道非常简单的面试题目：请问下面代码会输出什么？</p><pre><code class="js">const data = {  a: &quot;aaa&quot;,  b: undefined,  c: Symbol(&quot;dd&quot;),  fn: function() {    return true;  }};JSON.stringify(data); // 输出：？// &quot;{&quot;a&quot;:&quot;aaa&quot;}&quot;</code></pre><p>很简单这道题目面试官主要考察的知识点是：</p><ul><li>undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 将跳过（忽略）对它们进行序列化</li></ul><p>面试官追问：假设 undefined、任意的函数以及 symbol 值作为数组元素会是怎样呢？</p><pre><code class="js">JSON.stringify([&quot;aaa&quot;, undefined, function aa() {    return true  }, Symbol(&#39;dd&#39;)])  // 输出：？// &quot;[&quot;aaa&quot;,null,null,null]&quot;</code></pre><p>知识点是：</p><ul><li>undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 会将它们序列化为 null</li></ul><p>我们稍微再动下脑筋，如果单独序列化这些值会是什么样的结果呢？</p><pre><code class="js">JSON.stringify(function a (){console.log(&#39;a&#39;)})// undefinedJSON.stringify(undefined)// undefinedJSON.stringify(Symbol(&#39;dd&#39;))// undefined</code></pre><p>单独转换的结果就是：</p><p>undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时都会返回 undefined</p><blockquote><p>JSON.stringify() 第一大特性总结<br>undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 对跳过（忽略）它们进行序列化<br>undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 将会将它们序列化为 null<br>undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时，都会返回 undefined</p></blockquote><h3 id="JSON-stringify-第二大特性"><a href="#JSON-stringify-第二大特性" class="headerlink" title="JSON.stringify() 第二大特性"></a>JSON.stringify() 第二大特性</h3><p><strong>非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。</strong></p><pre><code class="js">const data = {  a: &quot;aaa&quot;,  b: undefined,  c: Symbol(&quot;dd&quot;),  fn: function() {    return true;  },  d: &quot;ddd&quot;};JSON.stringify(data); // 输出：？// &quot;{&quot;a&quot;:&quot;aaa&quot;,&quot;d&quot;:&quot;ddd&quot;}&quot;JSON.stringify([&quot;aaa&quot;, undefined, function aa() {    return true  }, Symbol(&#39;dd&#39;),&quot;eee&quot;])  // 输出：？// &quot;[&quot;aaa&quot;,null,null,null,&quot;eee&quot;]&quot;</code></pre><p>正如我们在第一特性所说，JSON.stringify() 序列化时<strong>会忽略一些特殊的值</strong>，所以不能保证序列化后的字符串还是以特定的顺序出现（数组除外）。</p><h3 id="JSON-stringify-第三大特性"><a href="#JSON-stringify-第三大特性" class="headerlink" title="JSON.stringify() 第三大特性"></a>JSON.stringify() 第三大特性</h3><ul><li>转换值如果<strong>有 toJSON() 函数，该函数返回什么值，序列化结果就是什么值，并且忽略其他属性的值</strong>。</li></ul><pre><code class="js">JSON.stringify({    say: &quot;hello JSON.stringify&quot;,    toJSON: function() {      return &quot;today i learn&quot;;    }  })// &quot;today i learn&quot;</code></pre><h3 id="JSON-stringify-第四大特性"><a href="#JSON-stringify-第四大特性" class="headerlink" title="JSON.stringify()第四大特性"></a>JSON.stringify()第四大特性</h3><p>JSON.stringify() 将会<strong>正常序列化 Date</strong> 的值。</p><pre><code class="js">JSON.stringify({ now: new Date() });// &quot;{&quot;now&quot;:&quot;2019-12-08T07:42:11.973Z&quot;}&quot;</code></pre><p>实际上 Date 对象自己部署了 toJSON() 方法（同Date.toISOString()），因此 Date 对象会被当做字符串处理。</p><h3 id="JSON-stringify-第五大特性"><a href="#JSON-stringify-第五大特性" class="headerlink" title="JSON.stringify() 第五大特性"></a>JSON.stringify() 第五大特性</h3><p><strong>NaN 和 Infinity 格式的数值及 null 都会被当做 null。</strong></p><pre><code class="js">JSON.stringify(NaN)// &quot;null&quot;JSON.stringify(null)// &quot;null&quot;JSON.stringify(Infinity)// &quot;null&quot;</code></pre><h3 id="JSON-stringify-第六大特性"><a href="#JSON-stringify-第六大特性" class="headerlink" title="JSON.stringify() 第六大特性"></a>JSON.stringify() 第六大特性</h3><p><strong>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。</strong></p><pre><code class="js">JSON.stringify([new Number(1), new String(&quot;false&quot;), new Boolean(false)]);// &quot;[1,&quot;false&quot;,false]&quot;</code></pre><h3 id="JSON-stringify-第七大特性"><a href="#JSON-stringify-第七大特性" class="headerlink" title="JSON.stringify() 第七大特性"></a>JSON.stringify() 第七大特性</h3><p>关于对象属性的是否可枚举：</p><p><strong>其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。</strong></p><pre><code class="js">// 不可枚举的属性默认会被忽略：JSON.stringify(     Object.create(        null,         {             x: { value: &#39;json&#39;, enumerable: false },             y: { value: &#39;stringify&#39;, enumerable: true }         }    ));// &quot;{&quot;y&quot;:&quot;stringify&quot;}&quot;</code></pre><h3 id="JSON-stringify-第八大特性"><a href="#JSON-stringify-第八大特性" class="headerlink" title="JSON.stringify() 第八大特性"></a>JSON.stringify() 第八大特性</h3><p>我们都知道实现深拷贝最简单粗暴的方式就是序列化：<code>JSON.parse(JSON.stringify())</code>，这个方式实现深拷贝会因为序列化的诸多特性从而导致诸多的坑点：比如现在我们要说的循环引用问题。</p><pre><code class="js">// 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 const obj = {  name: &quot;loopObj&quot;};const loopObj = {  obj};// 对象之间形成循环引用，形成闭环obj.loopObj = loopObj;// 封装一个深拷贝的函数function deepClone(obj) {  return JSON.parse(JSON.stringify(obj));}// 执行深拷贝，抛出错误deepClone(obj)/** VM44:9 Uncaught TypeError: Converting circular structure to JSON    --&gt; starting at object with constructor &#39;Object&#39;    |     property &#39;loopObj&#39; -&gt; object with constructor &#39;Object&#39;    --- property &#39;obj&#39; closes the circle    at JSON.stringify (&lt;anonymous&gt;)    at deepClone (&lt;anonymous&gt;:9:26)    at &lt;anonymous&gt;:11:13 */</code></pre><ul><li>对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。</li></ul><p>这也就是为什么用序列化去实现深拷贝时，遇到循环引用的对象会抛出错误的原因</p><h3 id="JSON-stringify-第九大特性"><a href="#JSON-stringify-第九大特性" class="headerlink" title="JSON.stringify() 第九大特性"></a>JSON.stringify() 第九大特性</h3><p><strong>所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。</strong></p><pre><code class="js">JSON.stringify({ [Symbol.for(&quot;json&quot;)]: &quot;stringify&quot; }, function(k, v) {    if (typeof k === &quot;symbol&quot;) {      return v;    }  })// undefined</code></pre><p><code>replacer</code> 是 <code>JSON.stringify()</code> 的第二个参数，我们比较少用到，所以很多时候我们会忘记 <code>JSON.stringify()</code> 第二个、第三个参数，场景不多，但是用的好的话会非常方便，关于 <code>JSON.stringify()</code> 第九大特性的例子中对 replacer 参数不明白的同学先别急，其实很简单，我们马上就会在下面的学习中弄懂。</p><h2 id="第二个参数和第三个参数"><a href="#第二个参数和第三个参数" class="headerlink" title="第二个参数和第三个参数"></a>第二个参数和第三个参数</h2><p>JSON.stringify() 第二个参数和第三个参数</p><h3 id="强大的第二个参数："><a href="#强大的第二个参数：" class="headerlink" title="强大的第二个参数："></a>强大的第二个参数：</h3><p>作为函数时，它有两个参数，键（key）和值（value），函数类似就是数组方法 map、filter 等方法的回调函数，对每一个属性值都会执行一次该函数（期间我们还简单实现过一个 map 函数）。<br>如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名。</p><h3 id="华丽的第三个参数："><a href="#华丽的第三个参数：" class="headerlink" title="华丽的第三个参数："></a>华丽的第三个参数：</h3><p>如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个空格）；</p><p>如果是一个字符串，则每一级别会比上一级别多缩进该字符串（或该字符串的前10个字符）。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5decf09de51d45584d238319#heading-4&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;通过需求学习JSON-stringify&quot;&gt;&lt;a href=&quot;#通过需求学习JSON-stringify&quot; class=&quot;headerlink&quot; title=&quot;通过需求学习JSON.stringify()&quot;&gt;&lt;/a&gt;通过需求学习JSON.stringify()&lt;/h2&gt;&lt;p&gt;首先我们在开发的过程当中遇到这样一个处理数据的需求&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const todayILearn = {
  _id: 1,
  content: &amp;#39;今天学习 JSON.stringify()，我很开心！&amp;#39;,
  created_at: &amp;#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&amp;#39;,
  updated_at: &amp;#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们需要将上面这个对象处理成下面这个对象&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const todayILearn = {
  id: 1,
  content: &amp;#39;今天学习 JSON.stringify()，我很开心！&amp;#39;,
  createdAt: &amp;#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&amp;#39;,
  updatedAt: &amp;#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&amp;#39;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;也就是在不改变属性的值的前提下，将对象属性修改一下。 把_id  改成 id，把 updated_at 改成 updatedAt，把 created_at 改成 createdAt。我们现在通过这个小小的需求来见识一下 JSON.stringify() 的强大吧。&lt;/p&gt;
&lt;p&gt;首先要解决这个问题我们有很多种解决方式，我们先提供两种不优雅的解决方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案一：一次遍历+多声明一个变量&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// 多一个变量存储
const todayILearnTemp = {};
for (const [key, value] of Object.entries(todayILearn)) {
  if (key === &amp;quot;_id&amp;quot;) todayILearnTemp[&amp;quot;id&amp;quot;] = value;
  else if (key === &amp;quot;created_at&amp;quot;) todayILearnTemp[&amp;quot;createdAt&amp;quot;] = value;
  else if (key === &amp;quot;updatedAt&amp;quot;) todayILearnTemp[&amp;quot;updatedAt&amp;quot;] = value;
  else todayILearnTemp[key] = value;
}
console.log(todayILearnTemp);
// 结果：
// { id: 1,
//  content: &amp;#39;今天学习 JSON.stringify()，我很开心！&amp;#39;,
//  createdAt: &amp;#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&amp;#39;,
//  updated_at: &amp;#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&amp;#39; 
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;方案一完全没有问题，可以实现。但是多声明了一个变量又加上一层循环并且还有很多的 if else 语句，怎么都显得不太优雅。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案二：暴力 delete 属性和增加属性&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// 极致的暴力美学
todayILearn.id = todayILearn._id;
todayILearn.createdAt = todayILearn.created_at;
todayILearn.updatedAt = todayILearn.updated_at;
delete todayILearn._id;
delete todayILearn.created_at;
delete todayILearn.updated_at;
console.log(todayILearn);
//     太暴力😢
//{ 
//  content: &amp;#39;今天学习 JSON.stringify()，我很开心！&amp;#39;,
//  id: 1,
//  createdAt: &amp;#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&amp;#39;,
//  updatedAt: &amp;#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&amp;#39; 
//}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接 delete 暴力解决太粗鲁了，而且有一个缺点，属性的顺序变了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方案三：序列化+ replace 美学典范&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const mapObj = {
  _id: &amp;quot;id&amp;quot;,
  created_at: &amp;quot;createdAt&amp;quot;,
  updated_at: &amp;quot;updatedAt&amp;quot;
};
JSON.parse(
  JSON.stringify(todayILearn).replace(
    /_id|created_at|updated_at/gi,
    matched =&amp;gt; mapObj[matched])
    )

// { 
// id: 1,
//  content: &amp;#39;今天学习 JSON.stringify()，我很开心！&amp;#39;,
//  createdAt: &amp;#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&amp;#39;,
//  updatedAt: &amp;#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&amp;#39; 
// }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/12/8/16ee5ace18ca5dbb?imageslim&quot; alt=&quot;Json.Stringify&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Js" scheme="https://zhanghao-web.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>使用vue高阶组件</title>
    <link href="https://zhanghao-web.github.io/2019/11/25/Vue/%E4%BD%BF%E7%94%A8vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6/"/>
    <id>https://zhanghao-web.github.io/2019/11/25/Vue/使用vue高阶组件/</id>
    <published>2019-11-25T02:48:54.000Z</published>
    <updated>2020-01-28T10:04:15.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前文"><a href="#前文" class="headerlink" title="前文"></a>前文</h1><p><code>高阶组件(HOC)</code>是一种架构模式，在 React 中非常常见，但也可以在 Vue 中使用。它可以被描述为一种<strong>在组件之间共享公共功能而不需要重复代码</strong>的方法。HOC 的目的是增强组件的功能。它允许在项目中实现可重用性和可维护性。</p><ul><li>只要你向一个方法传入组件，然后返回一个新的组件，这就是一个 HOC。</li></ul><blockquote><p>高阶组件在以下方面非常有用: 1.操作属性。 2.操作数据和数据抽象。 3.代码重用</p></blockquote><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p>在我们开始教程之前，需要了解以下几点：</p><p>使用 Vue 框架的经验。<br>知道如何使用 vue-cli 设置应用程序。<br>JavaScript 和 Vue 的基本知识<br>Node (8)<br>npm (5.2.0)</p><h2 id="Vue-中的高阶组件模式"><a href="#Vue-中的高阶组件模式" class="headerlink" title="Vue 中的高阶组件模式"></a>Vue 中的高阶组件模式</h2><p>虽然高阶组件通常与 React 相关联，但是为 Vue 组件创建高阶组件是很有可能的。在 Vue 中创建高阶组件的模式如下所示。</p><pre><code class="js">// hoccomponent.jsimport Vue from &quot;vue&quot;import ComponentExample from &#39;@/components/ComponentExample.vue&#39;const HoComponent = (component) =&gt; {    return Vue.component(&#39;withSubscription&#39;, {        render(createElement) {            return createElement(component)        }    }}const HoComponentEnhanced = HoComponent(ComponentExample);</code></pre><p>如上面的代码块所示，<code>HoComponent</code> 函数接受一个组件作为参数，并创建一个新组件来渲染传进来的组件。</p><h2 id="一个简单的-HOC-示例"><a href="#一个简单的-HOC-示例" class="headerlink" title="一个简单的 HOC 示例"></a>一个简单的 HOC 示例</h2><p>在本教程中，我们将介绍一个使用高阶组件的示例。在介绍高阶组件之前，我们将了解在没有高阶组件的情况下，当前的代码库是如何工作的，然后了解如何进行抽象。</p><p><a href="https://codesandbox.io/embed/llvq04nx4l" target="_blank" rel="noopener">https://codesandbox.io/embed/llvq04nx4l</a></p><p>正如上面的 CodeSandbox 所示，该应用程序会显示一个纸业公司及其净资产的列表，以及《办公室》(美国)中的人物及其获奖情况。</p><p>我们获得应用程序所需的所有数据来源只有一个，那就是<code>mockData.js</code>文件。</p><a id="more"></a><pre><code class="js">// src/components/mockData.jsconst staff = [  {    name: &quot;Michael Scott&quot;,    id: 0,    awards: 2  },  {    name: &quot;Toby Flenderson&quot;,    id: 1,    awards: 0  },  {    name: &quot;Dwight K. Schrute&quot;,    id: 2,    awards: 10  },  {    name: &quot;Jim Halpert&quot;,    id: 3,    awards: 1  },  {    name: &quot;Andy Bernard&quot;,    id: 4,    awards: 0  },  {    name: &quot;Phyllis Vance&quot;,    id: 5,    awards: 0  },  {    name: &quot;Stanley Hudson&quot;,    id: 6,    awards: 0  }];const paperCompanies = [  {    id: 0,    name: &quot;Staples&quot;,    net: 10000000  },  {    id: 1,    name: &quot;Dundler Mufflin&quot;,    net: 5000000  },  {    id: 2,    name: &quot;Michael Scott Paper Company&quot;,    net: 300000  },  {    id: 3,    name: &quot;Prince Family Paper&quot;,    net: 30000  }];export default {  getStaff() {    return staff;  },  getCompanies() {    return paperCompanies;  },  increaseAward(id) {    staff[id].awards++;  },  decreaseAward(id) {    staff[id].awards--;  },  setNetWorth(id) {    paperCompanies[id].net = Math.random() * (5000000 - 50000) + 50000;  }};</code></pre><p>在上面的代码片段中，有几个 const 变量保存了公司和员工列表的信息。我们也导出了一些函数，</p><blockquote><p>实现以下功能：<br>返回员工列表<br>返回公司列表<br>增加和减少对特定员工的奖励，最后<br>最后，设定公司的净值</p></blockquote><p>接下来，我们看看 <code>Staff.vue</code> 和 <code>Companies.vue</code> 组件。</p><pre><code class="html">// src/components/Staff.vue&lt;template&gt;  &lt;main&gt;    &lt;h3&gt;Staff List&lt;/h3&gt;    &lt;div v-for=&quot;(staff, i) in staffList&quot; :key=&quot;i&quot;&gt;      {{ staff.name }}: {{ staff.awards }} Salesman of the year Award 🎉      &lt;button @click=&quot;increaseAwards(staff.id);&quot;&gt;+&lt;/button&gt;      &lt;button @click=&quot;decreaseAwards(staff.id);&quot;&gt;-&lt;/button&gt;    &lt;/div&gt;  &lt;/main&gt;&lt;/template&gt;&lt;script&gt;  import mockData from &quot;./mockData.js&quot;;  export default {    data() {      return {        staffList: mockData.getStaff()      };    },    methods: {      increaseAwards(id) {        mockData.increaseAward(id);        this.staffList = mockData.getStaff();      },      decreaseAwards(id) {        mockData.decreaseAward(id);        this.staffList = mockData.getStaff();      }    }  };&lt;/script&gt;</code></pre><p>在上面的代码块中，数据实例变量staffList被赋值为函数mockData.getStaff()返回的内容。我们也有increaseAwards和decreaseAwards函数，分别调用mockData.increaseAward 和 mockData.decreaseAward。传递给这些函数的id 是从渲染的模板中获得的。</p><pre><code class="html">    // src/components/Companies.vue    &lt;template&gt;      &lt;main&gt;        &lt;h3&gt;Paper Companies&lt;/h3&gt;        &lt;div v-for=&quot;(companies, i) in companies&quot; :key=&quot;i&quot;&gt;          {{ companies.name }} - ${{ companies.net          }}&lt;button @click=&quot;setWorth(companies.id);&quot;&gt;Set Company Value&lt;/button&gt;        &lt;/div&gt;      &lt;/main&gt;    &lt;/template&gt;    &lt;script&gt;      import mockData from &quot;./mockData.js&quot;;        export default {        data() {          return {            companies: mockData.getCompanies()          };        },        methods: {          setWorth(id) {            mockData.setNetWorth(id);            this.companies = mockData.getCompanies();          }        }      };    &lt;/script&gt;</code></pre><p>在上面的代码块中，数据实例变量companies 被赋值为函数mockData.getCompanies()的返回内容。我们还有setWorth函数，它通过将公司的 id 传递给mockData.setNetWorth来设置一个随机值作为净值。传递给函数的id是从渲染的模板中获得的。</p><p>现在我们已经看到了这两个组件是如何工作的，我们可以</p><blockquote><p>找出它们之间的共同点，并将其抽象如下：</p></blockquote><p>从数据源获取数据 (mockData.js)<br>onClick 函数</p><p>我们来看看如何将上面的操作放到高阶组件中，以避免代码重复并确保可重用性。</p><p>HoComponent 函数接受两个参数，一个组件和fetchData。fetchData方法用于确定要在表示组件中显示什么。这意味着无论在哪里使用高阶组件，作为fetchData 传递的函数都将被用来从mockData 中获取数据。</p><p>然后将数据实例returnedData 设置为fetchData的内容，然后作为props 传递给在高阶组件中创建的新组件。</p><p>让我们看看新创建的高阶组件如何在应用程序中使用。我们需要编辑Staff.vue 和Companies.vue。</p><pre><code class="html">    // src/components/Staff.vue    &lt;template&gt;      &lt;main&gt;        &lt;h3&gt;Staff List&lt;/h3&gt;        &lt;div v-for=&quot;(staff, i) in returnedData&quot; :key=&quot;i&quot;&gt;          {{ staff.name }}: {{ staff.awards }} Salesman of the year Award 🎉          &lt;button @click=&quot;increaseAwards(staff.id);&quot;&gt;+&lt;/button&gt;          &lt;button @click=&quot;decreaseAwards(staff.id);&quot;&gt;-&lt;/button&gt;        &lt;/div&gt;      &lt;/main&gt;    &lt;/template&gt;    &lt;script&gt;      export default {        props: [&quot;returnedData&quot;]      };    &lt;/script&gt;</code></pre><pre><code class="html">    // src/components/Companies.vue    &lt;template&gt;      &lt;main&gt;        &lt;h3&gt;Paper Companies&lt;/h3&gt;        &lt;div v-for=&quot;(companies, i) in returnedData&quot; :key=&quot;i&quot;&gt;          {{ companies.name }} - ${{ companies.net          }}&lt;button @click=&quot;setWorth(companies.id);&quot;&gt;Set Company Value&lt;/button&gt;        &lt;/div&gt;      &lt;/main&gt;    &lt;/template&gt;    &lt;script&gt;      export default {        props: [&quot;returnedData&quot;]      };    &lt;/script&gt;</code></pre><p>正如你在上面的代码块中看到的，对于这两个组件，我们去掉了函数和数据实例变量，显示内容所需的所有数据现在都将从这些props中获得。对于删掉的函数，我们将很快会讲到。</p><p>在 App.vue 组件中，用以下代码编辑script 标签中的现有内容：</p><pre><code class="html">    // src/App.vue    &lt;script&gt;      // import the Companies component      import Companies from &quot;./components/Companies&quot;;      // import the Staff component      import Staff from &quot;./components/Staff&quot;;      // import the higher order component      import HoComponent from &quot;./components/HoComponent.js&quot;;      // Create a const variable which contains the Companies component wrapped in the higher order component      const CompaniesComponent = HoComponent(Companies, mockData =&gt; mockData.getCompanies()      );      // Create a const variable which contains the Staff component wrapped in the higher order component      const StaffComponent = HoComponent(Staff, mockData =&gt; mockData.getStaff());      export default {        name: &quot;App&quot;,        components: {          CompaniesComponent,          StaffComponent        }      };    &lt;/script&gt;</code></pre><p>在上面的代码块中，HoComponent用于包装 Staff 和 Companies 组件。</p><p>每个组件作为HoComponent 的第一个参数传入，第二个参数是一个函数，它返回另一个函数，指定应该从mockData获取什么数据。这是我们之前创建的高阶组件(HoComponent.js)中的fetchData 函数。</p><p>如果你现在刷新应用程序，你应该仍然可以看到来自mockData 文件的数据像往常一样呈现。唯一的区别是，这些按钮无法工作，因为它们还没有绑定到任何函数。让我们解决这个问题。</p><pre><code class="html">    // src/App.vue    &lt;template&gt;      &lt;div id=&quot;app&quot;&gt;        &lt;CompaniesComponent @click=&quot;onEventHappen&quot; /&gt;        &lt;StaffComponent @click=&quot;onEventHappen&quot; /&gt;      &lt;/div&gt;    &lt;/template&gt;    &lt;script&gt;      // import the Companies component      import Companies from &quot;./components/Companies&quot;;      // import the Staff component      import Staff from &quot;./components/Staff&quot;;      // import the higher order component      import HoComponent from &quot;./components/HoComponent.js&quot;;      // import the source data from mockData only to be used for event handlers      import sourceData from &quot;./components/mockData.js&quot;;      // Create a const variable which contains the Companies component wrapped in the higher order component      const CompaniesComponent = HoComponent(Companies, mockData =&gt;      mockData.getCompanies()      );      // Create a const variable which contains the Staff component wrapped in the higher order component      const StaffComponent = HoComponent(Staff, mockData =&gt; mockData.getStaff());      export default {        name: &quot;App&quot;,        components: {          CompaniesComponent,          StaffComponent          },        methods: {          onEventHappen(value) {            // set the variable setFunction to the name of the function that was passed iin the value emitted from child component i.e. if value.name is &#39;increaseAward&#39;, setFunction is set to increaseAward()            let setFunction = sourceData[value.name];            // call the corresponding function with the id passed as an argument.            setFunction(value.id);          }        }      };    &lt;/script&gt;    &lt;style&gt;    #app {      font-family: &quot;Avenir&quot;, Helvetica, Arial, sans-serif;      -webkit-font-smoothing: antialiased;      -moz-osx-font-smoothing: grayscale;      text-align: center;      color: #2c3e50;      margin-top: 60px;    }    &lt;/style&gt;</code></pre><p>在上面的代码块中，我们在App.vue组件中添加了一个事件监听器。</p><p>vue的组件。每当Staff.vue 或Companies.vue 组件被点击时，onEventHappen 方法将会被调用。</p><p>在onEventHappen方法中，我们将变量setFunction 设置为从子组件发出的值中传递的函数名，也就是说，如果value.name是’increaseAward’，那么setFunction设置为increaseAward()。setFunction 将以id作为参数执行。</p><p>最后，为了将事件监听器传递给封装在高阶组件中的组件，我们需要在 HoComponent.js文件中添加下面这行代码。</p><pre><code class="js">    props: {    returnedData: this.returnedData    },    on: { ...this.$listeners }</code></pre><h2 id="vue-hoc"><a href="#vue-hoc" class="headerlink" title="vue-hoc"></a>vue-hoc</h2><p>或者，您可以使用<a href="https://github.com/jackmellis/vue-hoc" target="_blank" rel="noopener">vue-hoc</a>库来帮助创建高阶组件。vue-hoc帮助你轻松地创建高阶组件，你要做的就是传递基本组件、应用于HOC的一系列组件选项和在渲染阶段传递给组件的数据属性。<br>vue-hoc 可用如下命令安装：<br>    <code>npm install --save vue-hoc</code></p><p>复制代码vue-hoc插件有一些例子可以让你开始创建更高阶的组件，你可以<a href="https://github.com/jackmellis/vue-hoc/blob/master/packages/vue-hoc/README.md" target="_blank" rel="noopener">查看这里</a>.</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前文&quot;&gt;&lt;a href=&quot;#前文&quot; class=&quot;headerlink&quot; title=&quot;前文&quot;&gt;&lt;/a&gt;前文&lt;/h1&gt;&lt;p&gt;&lt;code&gt;高阶组件(HOC)&lt;/code&gt;是一种架构模式，在 React 中非常常见，但也可以在 Vue 中使用。它可以被描述为一种&lt;strong&gt;在组件之间共享公共功能而不需要重复代码&lt;/strong&gt;的方法。HOC 的目的是增强组件的功能。它允许在项目中实现可重用性和可维护性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只要你向一个方法传入组件，然后返回一个新的组件，这就是一个 HOC。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;高阶组件在以下方面非常有用: 1.操作属性。 2.操作数据和数据抽象。 3.代码重用&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;预备知识&quot;&gt;&lt;a href=&quot;#预备知识&quot; class=&quot;headerlink&quot; title=&quot;预备知识&quot;&gt;&lt;/a&gt;预备知识&lt;/h2&gt;&lt;p&gt;在我们开始教程之前，需要了解以下几点：&lt;/p&gt;
&lt;p&gt;使用 Vue 框架的经验。&lt;br&gt;知道如何使用 vue-cli 设置应用程序。&lt;br&gt;JavaScript 和 Vue 的基本知识&lt;br&gt;Node (8)&lt;br&gt;npm (5.2.0)&lt;/p&gt;
&lt;h2 id=&quot;Vue-中的高阶组件模式&quot;&gt;&lt;a href=&quot;#Vue-中的高阶组件模式&quot; class=&quot;headerlink&quot; title=&quot;Vue 中的高阶组件模式&quot;&gt;&lt;/a&gt;Vue 中的高阶组件模式&lt;/h2&gt;&lt;p&gt;虽然高阶组件通常与 React 相关联，但是为 Vue 组件创建高阶组件是很有可能的。在 Vue 中创建高阶组件的模式如下所示。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// hoccomponent.js

import Vue from &amp;quot;vue&amp;quot;
import ComponentExample from &amp;#39;@/components/ComponentExample.vue&amp;#39;
const HoComponent = (component) =&amp;gt; {
    return Vue.component(&amp;#39;withSubscription&amp;#39;, {
        render(createElement) {
            return createElement(component)
        }
    }
}
const HoComponentEnhanced = HoComponent(ComponentExample);

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如上面的代码块所示，&lt;code&gt;HoComponent&lt;/code&gt; 函数接受一个组件作为参数，并创建一个新组件来渲染传进来的组件。&lt;/p&gt;
&lt;h2 id=&quot;一个简单的-HOC-示例&quot;&gt;&lt;a href=&quot;#一个简单的-HOC-示例&quot; class=&quot;headerlink&quot; title=&quot;一个简单的 HOC 示例&quot;&gt;&lt;/a&gt;一个简单的 HOC 示例&lt;/h2&gt;&lt;p&gt;在本教程中，我们将介绍一个使用高阶组件的示例。在介绍高阶组件之前，我们将了解在没有高阶组件的情况下，当前的代码库是如何工作的，然后了解如何进行抽象。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codesandbox.io/embed/llvq04nx4l&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://codesandbox.io/embed/llvq04nx4l&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;正如上面的 CodeSandbox 所示，该应用程序会显示一个纸业公司及其净资产的列表，以及《办公室》(美国)中的人物及其获奖情况。&lt;/p&gt;
&lt;p&gt;我们获得应用程序所需的所有数据来源只有一个，那就是&lt;code&gt;mockData.js&lt;/code&gt;文件。&lt;/p&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>一张图理清 Vue 3.0 的响应式系统</title>
    <link href="https://zhanghao-web.github.io/2019/10/29/Vue/%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85-Vue-3-0-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>https://zhanghao-web.github.io/2019/10/29/Vue/一张图理清-Vue-3-0-的响应式系统/</id>
    <published>2019-10-29T09:03:11.000Z</published>
    <updated>2020-04-22T14:08:43.412Z</updated>
    
    <content type="html"><![CDATA[<p>转自</p><p>作者：Jrain<br><a href="https://juejin.im/post/5d9da45af265da5b8072de5d" target="_blank" rel="noopener">链接</a></p><p><img src="https://user-gold-cdn.xitu.io/2019/10/9/16dafca37b2e0534?imageslim" alt="vue reactive"></p><h2 id="一个基本的例子"><a href="#一个基本的例子" class="headerlink" title="一个基本的例子"></a>一个基本的例子</h2><p>Vue 3.0 的响应式系统是独立的模块，可以完全脱离 Vue 而使用，所以我们在 clone 了源码下来以后，可以直接在 <code>packages/reactivity</code> 模块下调试。</p><p>1.在项目根目录运行 <code>yarn dev reactivity</code>，然后进入 <code>packages/reactivity</code> 目录找到产出的 <code>dist/reactivity.global.js</code> 文件。<br>2.新建一个 <code>index.html</code>，写入如下代码：</p><pre><code class="html">&lt;script src=&quot;./dist/reactivity.global.js&quot;&gt;&lt;/script&gt;&lt;script&gt;const { reactive, effect } = VueObserverconst origin = {  count: 0}const state = reactive(origin)const fn = () =&gt; {  const count = state.count  console.log(`set count to ${count}`)}effect(fn)&lt;/script&gt;</code></pre><ol start="3"><li>在浏览器打开该文件，于控制台执行 <code>state.count++</code>，便可看到输出 <code>set count to 1</code>。</li></ol><p>在上述的例子中，我们使用 <code>reactive()</code> 函数把 <code>origin</code> 对象转化成了<code>Proxy</code> 对象 <code>state</code>；使用 <code>effect()</code> 函数把 <code>fn()</code> 作为响应式回调。当 <code>state.count</code> 发生变化时，便触发了 <code>fn()</code>。接下来我们将以这个例子结合上文的流程图，来讲解这套响应式系统是怎么运行的。</p><h3 id="初始化阶段"><a href="#初始化阶段" class="headerlink" title="初始化阶段"></a>初始化阶段</h3><blockquote><p>在初始化阶段，主要做了两件事。</p></blockquote><p>1.把 origin 对象转化成响应式的 Proxy 对象 state。<br>2.把函数 fn() 作为一个响应式的 effect 函数。</p><p>大家都知道，Vue 3.0 使用了 <code>Proxy</code> 来代替之前的 <code>Object.defineProperty()</code>，改写了对象的 <code>getter/setter</code>，完成依赖收集和响应触发。但是在这一阶段中，我们暂时先不管它是如何改写对象的 <code>getter/setter</code> 的，这个在后续的”<strong>依赖收集阶段</strong>“会详细说明。为了简单起见，我们可以把这部分的内容浓缩成一个只有两行代码的 <code>reactive()</code> 函数：</p><pre><code class="js">    export default reactive (target){        const observed = new Proxy(target,handler);        return observed;    }</code></pre><p>当一个普通的函数 <code>fn()</code> 被 <code>effect()</code> 包裹之后，就会变成一个响应式的 effect 函数，而 <code>fn()</code> 也会被立即执行一次。</p><p><strong>由于在 fn() 里面有引用到 Proxy 对象的属性，所以这一步会触发对象的 getter，从而启动依赖收集</strong>。</p><p>除此之外，这个 effect 函数也会被压入一个名为”<code>activeReactiveEffectStack</code>“（此处为 <code>effectStack</code>）的栈中，供后续依赖收集的时候使用。</p><pre><code class="js">export function effect (fn) {  // 构造一个 effect  const effect = function effect(...args) {    return run(effect, fn, args)  }  // 立即执行一次  effect()  return effect}export function run(effect, fn, args) {  if (effectStack.indexOf(effect) === -1) {    try {      // 往池子里放入当前 effect      effectStack.push(effect)      // 立即执行一遍 fn()      // fn() 执行过程会完成依赖收集，会用到 effect      return fn(...args)    } finally {      // 完成依赖收集后从池子中扔掉这个 effect      effectStack.pop()    }  }}</code></pre><p>至此，初始化阶段已经完成。接下来就是整个系统最关键的一步——依赖收集阶段。<br><a id="more"></a></p><h3 id="依赖收集阶段"><a href="#依赖收集阶段" class="headerlink" title="依赖收集阶段"></a>依赖收集阶段</h3><p>这个阶段的触发时机，就是在 <code>effect</code> 被立即执行，其内部的 <code>fn()</code> 触发了 <code>Proxy</code> 对象的 <code>getter</code> 的时候。简单来说，只要执行到类似 <code>state.count</code> 的语句，就会触发 <code>state 的 getter</code>。</p><p>依赖收集阶段最重要的目的，就是建立一份”依赖收集表“，也就是图示的”<code>targetMap</code>“。<code>targetMap</code> 是一个 <code>WeakMap</code>，其 key 值是<del>当前的 <code>Prox</code>y 对象 <code>state</code></del>代理前的对象origin，而 value 则是该对象所对应的 <code>depsMap</code>。</p><p><code>depsMap</code> 是一个 Map，key 值为触发 <code>getter</code> 时的属性值（此处为 count），而 value 则是触发过该属性值所对应的各个 effect。</p><p>还是有点绕？那么我们再举个例子。假设有个 Proxy 对象和 effect 如下：</p><pre><code class="js">const state = reactive({  count: 0,  age: 18})const effect1 = effect(() =&gt; {  console.log(&#39;effect1: &#39; + state.count)})const effect2 = effect(() =&gt; {  console.log(&#39;effect2: &#39; + state.age)})const effect3 = effect(() =&gt; {  console.log(&#39;effect3: &#39; + state.count, state.age)})</code></pre><p>这样，<code>{ target -&gt; key -&gt; dep }</code> 的对应关系就建立起来了，依赖收集也就完成了</p><pre><code class="js">export function track (target, operationType, key) {  const effect = effectStack[effectStack.length - 1]  if (effect) {    let depsMap = targetMap.get(target)    if (depsMap === void 0) {      targetMap.set(target, (depsMap = new Map()))    }    let dep = depsMap.get(key)    if (dep === void 0) {      depsMap.set(key, (dep = new Set()))    }    if (!dep.has(effect)) {      dep.add(effect)    }  }}</code></pre><p>弄明白依赖收集表 targetMap 是非常重要的，因为这是整个响应式系统核心中的核心。</p><h3 id="响应阶段"><a href="#响应阶段" class="headerlink" title="响应阶段"></a>响应阶段</h3><p>回顾上一章节的例子，我们得到了一个 <code>{ count: 0, age: 18 }</code> 的 Proxy，并构造了三个 effect。在控制台上看看效果：</p><p><img src="https://user-gold-cdn.xitu.io/2019/10/9/16dafca37dadf75d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="effect"></p><p>当修改对象的某个属性值的时候，会触发对应的 <code>setter</code>。</p><p>setter 里面的 <code>trigger()</code> 函数会从依赖收集表里找到当前属性对应的各个 <code>dep</code>，然后把它们推入到 <code>effects</code> 和 <code>computedEffects</code>（计算属性） 队列中，最后通过 <code>scheduleRun()</code> 挨个执行里面的 effect。</p><p>由于已经建立了依赖收集表，所以要找到属性所对应的 dep 也就轻而易举了</p><pre><code class="js">export function trigger (target, operationType, key) {  // 取得对应的 depsMap  const depsMap = targetMap.get(target)  if (depsMap === void 0) {    return  }  // 取得对应的各个 dep  const effects = new Set()  if (key !== void 0) {    const dep = depsMap.get(key)    dep &amp;&amp; dep.forEach(effect =&gt; {      effects.add(effect)    })  }  // 简化版 scheduleRun，挨个执行 effect  effects.forEach(effect =&gt; {    effect()  })}</code></pre><p>至此，响应式阶段完成。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自&lt;/p&gt;
&lt;p&gt;作者：Jrain&lt;br&gt;&lt;a href=&quot;https://juejin.im/post/5d9da45af265da5b8072de5d&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/10/9/16dafca37b2e0534?imageslim&quot; alt=&quot;vue reactive&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;一个基本的例子&quot;&gt;&lt;a href=&quot;#一个基本的例子&quot; class=&quot;headerlink&quot; title=&quot;一个基本的例子&quot;&gt;&lt;/a&gt;一个基本的例子&lt;/h2&gt;&lt;p&gt;Vue 3.0 的响应式系统是独立的模块，可以完全脱离 Vue 而使用，所以我们在 clone 了源码下来以后，可以直接在 &lt;code&gt;packages/reactivity&lt;/code&gt; 模块下调试。&lt;/p&gt;
&lt;p&gt;1.在项目根目录运行 &lt;code&gt;yarn dev reactivity&lt;/code&gt;，然后进入 &lt;code&gt;packages/reactivity&lt;/code&gt; 目录找到产出的 &lt;code&gt;dist/reactivity.global.js&lt;/code&gt; 文件。&lt;br&gt;2.新建一个 &lt;code&gt;index.html&lt;/code&gt;，写入如下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;script src=&amp;quot;./dist/reactivity.global.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script&amp;gt;
const { reactive, effect } = VueObserver

const origin = {
  count: 0
}
const state = reactive(origin)

const fn = () =&amp;gt; {
  const count = state.count
  console.log(`set count to ${count}`)
}
effect(fn)
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;ol start=&quot;3&quot;&gt;
&lt;li&gt;在浏览器打开该文件，于控制台执行 &lt;code&gt;state.count++&lt;/code&gt;，便可看到输出 &lt;code&gt;set count to 1&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在上述的例子中，我们使用 &lt;code&gt;reactive()&lt;/code&gt; 函数把 &lt;code&gt;origin&lt;/code&gt; 对象转化成了&lt;code&gt;Proxy&lt;/code&gt; 对象 &lt;code&gt;state&lt;/code&gt;；使用 &lt;code&gt;effect()&lt;/code&gt; 函数把 &lt;code&gt;fn()&lt;/code&gt; 作为响应式回调。当 &lt;code&gt;state.count&lt;/code&gt; 发生变化时，便触发了 &lt;code&gt;fn()&lt;/code&gt;。接下来我们将以这个例子结合上文的流程图，来讲解这套响应式系统是怎么运行的。&lt;/p&gt;
&lt;h3 id=&quot;初始化阶段&quot;&gt;&lt;a href=&quot;#初始化阶段&quot; class=&quot;headerlink&quot; title=&quot;初始化阶段&quot;&gt;&lt;/a&gt;初始化阶段&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;在初始化阶段，主要做了两件事。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;1.把 origin 对象转化成响应式的 Proxy 对象 state。&lt;br&gt;2.把函数 fn() 作为一个响应式的 effect 函数。&lt;/p&gt;
&lt;p&gt;大家都知道，Vue 3.0 使用了 &lt;code&gt;Proxy&lt;/code&gt; 来代替之前的 &lt;code&gt;Object.defineProperty()&lt;/code&gt;，改写了对象的 &lt;code&gt;getter/setter&lt;/code&gt;，完成依赖收集和响应触发。但是在这一阶段中，我们暂时先不管它是如何改写对象的 &lt;code&gt;getter/setter&lt;/code&gt; 的，这个在后续的”&lt;strong&gt;依赖收集阶段&lt;/strong&gt;“会详细说明。为了简单起见，我们可以把这部分的内容浓缩成一个只有两行代码的 &lt;code&gt;reactive()&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;    export default reactive (target){
        const observed = new Proxy(target,handler);
        return observed;
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当一个普通的函数 &lt;code&gt;fn()&lt;/code&gt; 被 &lt;code&gt;effect()&lt;/code&gt; 包裹之后，就会变成一个响应式的 effect 函数，而 &lt;code&gt;fn()&lt;/code&gt; 也会被立即执行一次。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于在 fn() 里面有引用到 Proxy 对象的属性，所以这一步会触发对象的 getter，从而启动依赖收集&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;除此之外，这个 effect 函数也会被压入一个名为”&lt;code&gt;activeReactiveEffectStack&lt;/code&gt;“（此处为 &lt;code&gt;effectStack&lt;/code&gt;）的栈中，供后续依赖收集的时候使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;export function effect (fn) {
  // 构造一个 effect
  const effect = function effect(...args) {
    return run(effect, fn, args)
  }
  // 立即执行一次
  effect()
  return effect
}

export function run(effect, fn, args) {
  if (effectStack.indexOf(effect) === -1) {
    try {
      // 往池子里放入当前 effect
      effectStack.push(effect)
      // 立即执行一遍 fn()
      // fn() 执行过程会完成依赖收集，会用到 effect
      return fn(...args)
    } finally {
      // 完成依赖收集后从池子中扔掉这个 effect
      effectStack.pop()
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;至此，初始化阶段已经完成。接下来就是整个系统最关键的一步——依赖收集阶段。&lt;br&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue3.x" scheme="https://zhanghao-web.github.io/tags/Vue3-x/"/>
    
  </entry>
  
  <entry>
    <title>深入理解Node.js中的进程与线程</title>
    <link href="https://zhanghao-web.github.io/2019/09/30/Node/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Node-js%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>https://zhanghao-web.github.io/2019/09/30/Node/深入理解Node-js中的进程与线程/</id>
    <published>2019-09-30T05:30:38.000Z</published>
    <updated>2020-01-28T10:04:15.049Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d43017be51d4561f40adcf9" target="_blank" rel="noopener">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><code>进程</code>与<code>线程</code>是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解<code>进程</code>与<code>线程</code>，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用</p><h2 id="文章导览"><a href="#文章导览" class="headerlink" title="文章导览"></a>文章导览</h2><p><img src="https://user-gold-cdn.xitu.io/2019/8/8/16c6cf612c275894?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="进程与线程"></p><h2 id="面试会问"><a href="#面试会问" class="headerlink" title="面试会问"></a>面试会问</h2><ul><li>Node.js是单线程吗？</li></ul><ul><li>Node.js 做耗时的计算时候，如何避免阻塞？</li></ul><ul><li>Node.js如何实现多进程的开启和关闭？</li></ul><ul><li>Node.js可以创建线程吗？</li></ul><ul><li>你们开发过程中如何实现进程守护的？</li></ul><ul><li>除了使用第三方模块，你们自己是否封装过一个多进程架构?</li></ul><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程<code>Process</code>是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的<strong>每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享</strong>。</p><ul><li>Node.js开启服务进程例子</li></ul><pre><code class="js">const http = require(&#39;http&#39;);const server = http.createServer();server.listen(3000,()=&gt;{    process.title=&#39;程序员成长指北测试进程&#39;;    console.log(&#39;进程id&#39;,process.pid)})</code></pre><p>运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/1/16c4dc0ca13fec40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="进程1"></p><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。<strong>一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的</strong>。</p><h3 id="单线程"><a href="#单线程" class="headerlink" title="单线程"></a>单线程</h3><p><strong>单线程就是一个进程只开一个线程</strong></p><p>Javascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。</p><p><strong>经典计算耗时造成线程阻塞的例子</strong></p><pre><code class="js">const http = require(&#39;http&#39;);const longComputation = () =&gt; {  let sum = 0;  for (let i = 0; i &lt; 1e10; i++) {    sum += i;  };  return sum;};const server = http.createServer();server.on(&#39;request&#39;, (req, res) =&gt; {  if (req.url === &#39;/compute&#39;) {    console.info(&#39;计算开始&#39;,new Date());    const sum = longComputation();    console.info(&#39;计算结束&#39;,new Date());    return res.end(`Sum is ${sum}`);  } else {    res.end(&#39;Ok&#39;)  }});server.listen(3000);//打印结果//计算开始 2019-07-28T07:08:49.849Z//计算结束 2019-07-28T07:09:04.522Z</code></pre><p>查看打印结果，当我们调用<code>127.0.0.1:3000/compute</code><br>的时候，如果想要调用其他的路由地址比如<code>127.0.0.1/</code>大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。<br><a id="more"></a></p><blockquote><p>单线程的一些说明</p><ul><li>Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。</li><li>当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。</li><li>Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。</li><li>单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。</li></ul></blockquote><h2 id="Node-js-中的进程与线程"><a href="#Node-js-中的进程与线程" class="headerlink" title="Node.js 中的进程与线程"></a>Node.js 中的进程与线程</h2><p>Node.js 是 Javascript 在服务端的运行环境，构建在 chrome 的 V8 引擎之上，基于事件驱动、非阻塞I/O模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务</p><blockquote><p>科普：在 Web 服务器方面，著名的 Nginx 也是采用此模式（事件驱动），避免了多线程的线程创建、线程上下文切换的开销，Nginx 采用 C 语言进行编写，主要用来做高性能的 Web 服务器，不适合做业务。</p></blockquote><p>Web业务开发中，如果你有高并发应用场景那么 Node.js 会是你不错的选择。</p><p>在单核 CPU 系统之上我们采用 单进程 + 单线程 的模式来开发。在多核 CPU 系统之上，可以通过 <code>child_process.fork</code> 开启多个进程（Node.js 在 v0.8 版本之后新增了Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。</p><h3 id="Node-js-中的进程"><a href="#Node-js-中的进程" class="headerlink" title="Node.js 中的进程"></a>Node.js 中的进程</h3><h4 id="process-模块"><a href="#process-模块" class="headerlink" title="process 模块"></a>process 模块</h4><p>Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。官方文档提供了详细的说明，感兴趣的可以亲自实践下 Process 文档。</p><ul><li>process.env：环境变量，例如通过  process.env.NODE_ENV 获取不同环境项目配置信息</li><li>process.nextTick：这个在谈及 Event Loop 时经常为会提到</li><li>process.pid：获取当前进程id</li><li>process.ppid：当前进程对应的父进程</li><li>process.cwd()：获取当前进程工作目录，</li><li>process.platform：获取当前进程运行的操作系统平台</li><li>process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值</li><li>进程事件：process.on(‘uncaughtException’, cb) 捕获异常信息、process.on(‘exit’, cb）进程推出监听</li><li>三个标准流：process.stdout 标准输出、process.stdin 标准输入、process.stderr 标准错误输出</li><li>process.title 指定进程名称，有的时候需要给进程指定一个名称</li></ul><p>以上仅列举了部分常用到功能点，除了 Process 之外 Node.js 还提供了 child_process 模块用来对子进程进行操作，在下文 Nodejs进程创建会继续讲述。</p><h3 id="Node-js-进程创建"><a href="#Node-js-进程创建" class="headerlink" title="Node.js 进程创建"></a>Node.js 进程创建</h3><p>进程创建有多种方式，本篇文章以child_process模块和cluster模块进行讲解。</p><h4 id="child-process模块"><a href="#child-process模块" class="headerlink" title="child_process模块"></a>child_process模块</h4><p>child_process 是 Node.js 的内置模块，官网地址：</p><blockquote><p>child_process 官网地址：<a href="https://link.juejin.im/?target=http%3A%2F%2Fnodejs.cn%2Fapi%2Fchild_process.html%23child_process_child_process">nodejs.cn/api/child_p…</a></p></blockquote><p>几个常用函数： 四种方式</p><ul><li><code>child_process.spawn()</code>：适用于返回大量数据，例如图像处理，二进制数据处理。</li><li><code>child_process.exec()</code>：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。</li><li><code>child_process.execFile()</code>：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为</li><li><code>child_process.fork()</code>： 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统<strong> CPU 核心数</strong>设置。</li></ul><blockquote><p>CPU 核心数这里特别说明下，fork 确实可以开启多个进程，但是并不建议衍生出来太多的进程，cpu核心数的获取方式<code>const cpus = require(&#39;os&#39;).cpus()</code>;,这里 cpus 返回一个对象数组，包含所安装的每个 CPU/内核的信息，二者总和的数组哦。假设主机装有两个cpu，每个cpu有4个核，那么总核数就是8。</p></blockquote><p><em>fork开启子进程 Demo</em></p><p>fork开启子进程解决文章起初的计算耗时造成线程阻塞。 在进行 compute 计算时创建子进程，子进程计算完成通过 send 方法将结果发送给主进程，主进程通过 message 监听到信息后处理并退出。</p><blockquote><p>fork_app.js</p></blockquote><pre><code class="js">const http = require(&#39;http&#39;);const fork = require(&#39;child_process&#39;).fork;const server = http.createServer((req, res) =&gt; {    if(req.url == &#39;/compute&#39;){        const compute = fork(&#39;./fork_compute.js&#39;);        compute.send(&#39;开启一个新的子进程&#39;);        // 当一个子进程使用 process.send() 发送消息时会触发 &#39;message&#39; 事件        compute.on(&#39;message&#39;, sum =&gt; {            res.end(`Sum is ${sum}`);            compute.kill();        });        // 子进程监听到一些错误消息退出        compute.on(&#39;close&#39;, (code, signal) =&gt; {            console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`);            compute.kill();        })    }else{        res.end(`ok`);    }});server.listen(3000, 127.0.0.1, () =&gt; {    console.log(`server started at http://${127.0.0.1}:${3000}`);});</code></pre><blockquote><p>fork_compute.js</p></blockquote><p>针对文初需要进行计算的的例子我们创建子进程拆分出来单独进行运算。</p><pre><code class="js">const computation = () =&gt; {    let sum = 0;    console.info(&#39;计算开始&#39;);    console.time(&#39;计算耗时&#39;);    for (let i = 0; i &lt; 1e10; i++) {        sum += i    };    console.info(&#39;计算结束&#39;);    console.timeEnd(&#39;计算耗时&#39;);    return sum;};process.on(&#39;message&#39;, msg =&gt; {    console.log(msg, &#39;process.pid&#39;, process.pid); // 子进程id    const sum = computation();    // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息    process.send(sum);})</code></pre><h4 id="cluster模块"><a href="#cluster模块" class="headerlink" title="cluster模块"></a>cluster模块</h4><p>cluster 开启子进程Demo</p><pre><code class="js">const http = require(&#39;http&#39;);const numCPUs = require(&#39;os&#39;).cpus().length;const cluster = require(&#39;cluster&#39;);if(cluster.isMaster){    console.log(&#39;Master proces id is&#39;,process.pid);    // fork workers    for(let i= 0;i&lt;numCPUs;i++){        cluster.fork();    }    cluster.on(&#39;exit&#39;,function(worker,code,signal){        console.log(&#39;worker process died,id&#39;,worker.process.pid)    })}else{    // Worker可以共享同一个TCP连接    // 这里是一个http服务器    http.createServer(function(req,res){        res.writeHead(200);        res.end(&#39;hello word&#39;);    }).listen(8000);}</code></pre><p>cluster原理分析</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/3/16c5658b2e97e9b2?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cluster原理分析"></p><p>cluster模块调用fork方法来创建子进程，该方法与child_process中的fork是同一个方法。</p><p>cluster模块采用的是经典的主从模型，Cluster会创建一个master，然后根据你指定的数量复制出多个子进程，可以使用cluster.isMaster属性判断当前进程是master还是worker(工作进程)。由master进程来管理所有的子进程，主进程不负责具体的任务处理，主要工作是负责调度和管理。</p><p>cluster模块使用内置的负载均衡来更好地处理线程之间的压力，该负载均衡使用了Round-robin算法（也被称之为循环算法）。当使用Round-robin调度策略时，master accepts()所有传入的连接请求，然后将相应的TCP请求处理发送给选中的工作进程（该方式仍然通过IPC来进行通信）。</p><p>开启多进程时候端口疑问讲解：如果多个Node进程监听同一个端口时会出现 Error:listen EADDRIUNS的错误，而cluster模块为什么可以让多个子进程监听同一个端口呢?原因是master进程内部启动了一个TCP服务器，而真正监听端口的只有这个服务器，当来自前端的请求触发服务器的connection事件后，master会将对应的socket具柄发送给子进程。</p><h4 id="child-process-模块与cluster-模块总结"><a href="#child-process-模块与cluster-模块总结" class="headerlink" title="child_process 模块与cluster 模块总结"></a>child_process 模块与cluster 模块总结</h4><p>无论是 child_process 模块还是 cluster 模块，为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的问题而出现的。核心就是<strong>父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程</strong>。</p><p>cluster模块的一个弊端：</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/3/16c565aaeb065b4a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="cluster弊端"></p><p>cluster内部隐时的构建TCP服务器的方式来说对使用者确实简单和透明了很多，但是这种方式无法像使用child_process那样灵活，因为一直主进程只能管理一组相同的工作进程，而自行通过child_process来创建工作进程，一个主进程可以控制多组进程。原因是child_process操作子进程时，可以隐式的创建多个TCP服务器，对比上面的两幅图应该能理解我说的内容。</p><h4 id="Node-js进程通信原理"><a href="#Node-js进程通信原理" class="headerlink" title="Node.js进程通信原理"></a>Node.js进程通信原理</h4><p>前面讲解的无论是child_process模块，还是cluster模块，都需要主进程和工作进程之间的通信。通过fork()或者其他API，创建了子进程之后，为了实现父子进程之间的通信，父子进程之间才能通过message和send()传递信息。</p><p>IPC这个词我想大家并不陌生，不管那一张开发语言只要提到进程通信，都会提到它。IPC的全称是Inter-Process Communication,即进程间通信。它的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道，匿名管道，socket，信号量，共享内存，消息队列等。Node中实现IPC通道是依赖于libuv。windows下由命名管道(name pipe)实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。</p><p>IPC创建和实现示意图</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/4/16c5b379ad12199e?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="IPC"></p><p>IPC通信管道是如何创建的</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/4/16c5b3812e3bb7d9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="IPC通信"></p><p>父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正的创建出子进程，这个过程中也会通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接</p><h4 id="Node-js句柄传递"><a href="#Node-js句柄传递" class="headerlink" title="Node.js句柄传递"></a>Node.js句柄传递</h4><p>讲句柄之前，先想一个问题，send句柄发送的时候，真的是将服务器对象发送给了子进程？</p><h4 id="子进程对象send-方法可以发送的句柄类型"><a href="#子进程对象send-方法可以发送的句柄类型" class="headerlink" title="子进程对象send()方法可以发送的句柄类型"></a>子进程对象send()方法可以发送的句柄类型</h4><p>net.Socket TCP套接字<br>net.Server TCP服务器，任意建立在TCP服务上的应用层服务都可以享受它带来的好处<br>net.Native C++层面的TCP套接字或IPC管道<br>dgram.Socket UDP套接字<br>dgram.Native C++层面的UDP套接字</p><h4 id="send句柄发送原理分析"><a href="#send句柄发送原理分析" class="headerlink" title="send句柄发送原理分析"></a>send句柄发送原理分析</h4><p>结合句柄的发送与还原示意图更容易理解。</p><p><img src="https://user-gold-cdn.xitu.io/2019/8/4/16c5b52b15d87bbe?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt="send句"></p><p>send()方法在将消息发送到IPC管道前，实际将消息组装成了两个对象，一个参数是hadler，另一个是message。message参数如下所示：</p><pre><code class="js">{    cmd:&#39;NODE_HANDLE&#39;,    type:&#39;net.Server&#39;,    msg:message}</code></pre><p>发送到IPC管道中的实际上是我们要发送的句柄文件描述符。这个message对象在写入到IPC管道时，也会通过<code>JSON.stringfy()</code>进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任何对象。</p><p>连接了IPC通道的子线程可以读取父进程发来的消息，将字符串通过<code>JSON.parse()</code>解析还原为对象后，才触发message事件将消息传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage，如果message.cmd值为NODE_HANDLE,它将取出<code>message.type</code>值和得到的文件描述符一起还原出一个对应的对象。</p><p>以发送的TCP服务器句柄为例，子进程收到消息后的还原过程代码如下:</p><pre><code class="js">function(message,handle,emit){    var self = this;    var server = new net.Server();    server.listen(handler,function(){      emit(server);    });}</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>多进程 vs 多线程</p><p>属性<br>多进程<br>多线程<br>比较</p><p>数据<br>数据共享复杂，需要用IPC；数据是分开的，同步简单<br>因为共享进程数据，数据共享简单，同步复杂<br>各有千秋</p><p>CPU、内存<br>占用内存多，切换复杂，CPU利用率低<br>占用内存少，切换简单，CPU利用率高<br>多线程更好</p><p>销毁、切换<br>创建销毁、切换复杂，速度慢<br>创建销毁、切换简单，速度很快<br>多线程更好</p><p>coding<br>编码简单、调试方便<br>编码、调试复杂<br>编码、调试复杂</p><p>可靠性<br>进程独立运行，不会相互影响<br>线程同呼吸共命运<br>多进程更好</p><p>分布式<br>可用于多机多核分布式，易于扩展<br>只能用于多核分布式<br>多进程更好</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d43017be51d4561f40adcf9&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;code&gt;进程&lt;/code&gt;与&lt;code&gt;线程&lt;/code&gt;是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解&lt;code&gt;进程&lt;/code&gt;与&lt;code&gt;线程&lt;/code&gt;，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用&lt;/p&gt;
&lt;h2 id=&quot;文章导览&quot;&gt;&lt;a href=&quot;#文章导览&quot; class=&quot;headerlink&quot; title=&quot;文章导览&quot;&gt;&lt;/a&gt;文章导览&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/8/16c6cf612c275894?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;进程与线程&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;面试会问&quot;&gt;&lt;a href=&quot;#面试会问&quot; class=&quot;headerlink&quot; title=&quot;面试会问&quot;&gt;&lt;/a&gt;面试会问&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;Node.js是单线程吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Node.js 做耗时的计算时候，如何避免阻塞？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Node.js如何实现多进程的开启和关闭？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;Node.js可以创建线程吗？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;你们开发过程中如何实现进程守护的？&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;除了使用第三方模块，你们自己是否封装过一个多进程架构?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h2&gt;&lt;p&gt;进程&lt;code&gt;Process&lt;/code&gt;是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的&lt;strong&gt;每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Node.js开启服务进程例子&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const http = require(&amp;#39;http&amp;#39;);

const server = http.createServer();
server.listen(3000,()=&amp;gt;{
    process.title=&amp;#39;程序员成长指北测试进程&amp;#39;;
    console.log(&amp;#39;进程id&amp;#39;,process.pid)
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2019/8/1/16c4dc0ca13fec40?imageView2/0/w/1280/h/960/format/webp/ignore-error/1&quot; alt=&quot;进程1&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h2&gt;&lt;p&gt;线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。&lt;strong&gt;一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;单线程&quot;&gt;&lt;a href=&quot;#单线程&quot; class=&quot;headerlink&quot; title=&quot;单线程&quot;&gt;&lt;/a&gt;单线程&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;单线程就是一个进程只开一个线程&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Javascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;经典计算耗时造成线程阻塞的例子&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const http = require(&amp;#39;http&amp;#39;);
const longComputation = () =&amp;gt; {
  let sum = 0;
  for (let i = 0; i &amp;lt; 1e10; i++) {
    sum += i;
  };
  return sum;
};
const server = http.createServer();
server.on(&amp;#39;request&amp;#39;, (req, res) =&amp;gt; {
  if (req.url === &amp;#39;/compute&amp;#39;) {
    console.info(&amp;#39;计算开始&amp;#39;,new Date());
    const sum = longComputation();
    console.info(&amp;#39;计算结束&amp;#39;,new Date());
    return res.end(`Sum is ${sum}`);
  } else {
    res.end(&amp;#39;Ok&amp;#39;)
  }
});

server.listen(3000);
//打印结果
//计算开始 2019-07-28T07:08:49.849Z
//计算结束 2019-07-28T07:09:04.522Z
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;查看打印结果，当我们调用&lt;code&gt;127.0.0.1:3000/compute&lt;/code&gt;&lt;br&gt;的时候，如果想要调用其他的路由地址比如&lt;code&gt;127.0.0.1/&lt;/code&gt;大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。&lt;br&gt;
    
    </summary>
    
      <category term="Node" scheme="https://zhanghao-web.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://zhanghao-web.github.io/tags/Node/"/>
    
  </entry>
  
  <entry>
    <title>在17道题中理解javascript的类型转换</title>
    <link href="https://zhanghao-web.github.io/2019/08/08/Js/%E5%9C%A817%E9%81%93%E9%A2%98%E4%B8%AD%E7%90%86%E8%A7%A3javascript%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/"/>
    <id>https://zhanghao-web.github.io/2019/08/08/Js/在17道题中理解javascript的类型转换/</id>
    <published>2019-08-08T07:50:44.000Z</published>
    <updated>2020-01-28T10:04:15.039Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5d4999fff265da038f47f5c7" target="_blank" rel="noopener">原文地址</a></p><p>类型转换是将值从一种类型转换为另一种类型的过程（比如字符串转数字，对象转布尔值等）。任何类型不论是原始类型还是对象类型都可以进行类型转换，JavaScript 的原始类型有：<code>number, string, boolean, null, undefined, Symbol</code>。</p><pre><code class="js">true + false12 / &quot;6&quot;&quot;number&quot; + 15 + 315 + 3 + &quot;number&quot;[1] &gt; null&quot;foo&quot; + + &quot;bar&quot;&quot;true&quot; == truefalse == &quot;false&quot;null == &quot;&quot;!!&quot;false&quot; == !!&quot;true&quot;[&quot;x&quot;] == &quot;x&quot;[] + null + 1[1,2,3] == [1,2,3]{} + [] + {} + [1]! + [] + [] + ![]new Date(0) - 0new Date(0) + 0</code></pre><p>类似于上面的这些问题大概率也会在 JS 面试中被问到, 所以继续往下读。</p><h2 id="隐式转换VS显示转换"><a href="#隐式转换VS显示转换" class="headerlink" title="隐式转换VS显示转换"></a>隐式转换VS显示转换</h2><p>类型转换可以分为<strong>隐式类型转换</strong>和<strong>显式类型转换</strong>。</p><p>当开发人员通过编写适当的代码(如Number(value))用于在类型之间进行转换时，就称为<code>显式类型强制转换(或强制类型转换)</code>。</p><p>然而 JavaScript 是弱类型语言，在某些操作下，值可以在两种类型之间自动的转换，这叫做<code>隐式类型转换</code>。在对不同类型的值使用运算符时通常会发生隐式类型转换。比如 1 == null, 2 / “5”, null + new Date()。当值被 if 语句包裹时也有可能发生，比如 if(value) {} 会将 value 转换为 boolean类型。</p><p><code>严格相等运算符</code>（===）不会触发类型隐式转换，所以它可以用来比较值和类型是否都相等。</p><p><strong>隐式类型转换是一把双刃剑，使用它虽然可以写更少的代码但有时候会出现难以被发现的bug</strong>。</p><h2 id="三种类型转换"><a href="#三种类型转换" class="headerlink" title="三种类型转换"></a>三种类型转换</h2><p>我们需要知道的第一个规则是：<strong>在 JS 中只有 3 种类型的转换</strong></p><ul><li>to string</li><li>to boolean</li><li>to number</li></ul><p>第二，<strong>类型转换的逻辑在原始类型和对象类型上是不同的，但是他们都只会转换成上面 3 种类型之一</strong>。</p><p>我们首先分析一下原始类型转换。</p><h2 id="String-类型转换"><a href="#String-类型转换" class="headerlink" title="String 类型转换"></a>String 类型转换</h2><p><code>String()</code> 方法可以用来显式将值转为字符串，隐式转换通常在有 <code>+</code> 运算符并且有一个操作数是 <code>string</code> 类型时被触发，如：</p><pre><code class="js">String(123) // 显式类型转换123 + &#39;&#39; // 隐式类型转换</code></pre><p>所有原始类型转 String 类型</p><pre><code class="js">String(123)  // &#39;123&#39;String(-12.3)  // &#39;-12.3&#39;String(null)  // &#39;null&#39;String(undefined)  // &#39;undefined&#39;String(true)  // &#39;true&#39;</code></pre><p>Symbol 类型转 String 类型是比较严格的，它只能被显式的转换</p><pre><code class="js">String(Symbol(&#39;symbol&#39;))  // &#39;Symbol(symbol)&#39;&#39;&#39; + Symbol(&#39;symbol&#39;)  // TypeError is thrown</code></pre><h2 id="Boolean-类型转换"><a href="#Boolean-类型转换" class="headerlink" title="Boolean 类型转换"></a>Boolean 类型转换</h2><p><code>Boolean()</code> 方法可以用来显式将值转换成 boolean 型。</p><p>隐式类型转换通常在逻辑判断或者有逻辑运算符时被触发<code>（|| &amp;&amp; !）</code>。</p><pre><code class="js">Boolean(2)    // 显示类型转换if(2) {}      // 逻辑判断触发隐式类型转换!!2           // 逻辑运算符触发隐式类型转换2 || &#39;hello&#39;  // 逻辑运算符触发隐式类型转换</code></pre><a id="more"></a><p>注意: 逻辑运算符（比如 || 和 &amp;&amp;）是在内部做了 boolean 类型转换，但实际上返回的是<code>原始操作数的值</code>，即使他们都不是 boolean 类型。</p><pre><code class="js">// 返回 number 类型 123，而不是 boolean 型 true// &#39;hello&#39; 和 &#39;123&#39; 仍然在内部会转换成 boolean 型来计算表达式let x = &#39;hello&#39; &amp;&amp; 123  // x === 123</code></pre><p>boolean 类型转换只会有 true 或者 false 两种结果。</p><pre><code class="js">Boolean(&#39;&#39;)           // falseBoolean(0)            // false  Boolean(-0)           // falseBoolean(NaN)          // falseBoolean(null)         // falseBoolean(undefined)     // falseBoolean(false)        // false</code></pre><p><strong>任何不在上面列表中的值都会转换为 true</strong>, 包括 <code>object, function, Array, Date</code> 等，<code>Symbol</code> 类型是真值，空对象和空数组也是真值。</p><pre><code class="js">Boolean({})             // trueBoolean([])             // trueBoolean(Symbol())       // true!!Symbol()              // trueBoolean(function() {})  // true</code></pre><h2 id="Number-类型转换"><a href="#Number-类型转换" class="headerlink" title="Number 类型转换"></a>Number 类型转换</h2><p>和 <code>Boolean()</code>、<code>String()</code> 方法一样， <code>Number()</code> 方法可以用来显式将值转换成 number 类型。<br>number 的隐式类型转换是比较复杂的，因为它可以在下面多种情况下被触发。</p><ul><li>比较操作（&gt;, &lt;, &lt;=, &gt;=）</li><li>按位操作（| &amp; ^ ~）</li><li>算数操作（- + * / %）， 注意，当 + 操作存在任意的操作数是 string 类型时，不会触发 number 类型的隐式转换</li><li>一 元 + 操作</li><li>非严格相等操作（== 或者 != ），注意，== 操作两个操作数都是 string 类型时，不会发生 number 类型的隐式转换</li></ul><pre><code class="js">Number(&#39;123&#39;)    // 显示类型转换+ &#39;123&#39;          //  隐式类型转换123 != &quot;456&quot;    //  隐式类型转换4 &gt; &quot;5&quot;        //  隐式类型转换5 / null      //  隐式类型转换true | 0      //  隐式类型转换</code></pre><p>接下来看一下原始类型显示转换 number 类型会发生什么</p><pre><code class="js">Number(null)                   // 0Number(undefined)              // NaNNumber(true)                   // 1Number(false)                  // 0Number(&quot; 12 &quot;)                 // 12Number(&quot;-12.34&quot;)               // -12.34Number(&quot;\n&quot;)                   // 0Number(&quot; 12s &quot;)                // NaNNumber(123)                    // 123</code></pre><p>当将一个字符串转换为一个数字时，引擎首先删除前尾空格、<code>\n、\t</code> 字符，如果被修剪的字符串不成为一个有效的数字，则返回 NaN。如果字符串为空，则返回 0。</p><p>Number() 方法对于 null 和 undefined 的处理是不同的， null 会转换为 0, undefined 会转换为 NaN</p><p><strong>不管是显式还是隐式转换都不能将 Symbol 类型转为 number 类型，当试图这样操作时，会抛出错误</strong>。</p><pre><code class="js">Number(Symbol(&#39;my symbol&#39;))    // TypeError is thrown+Symbol(&#39;123&#39;)                 // TypeError is thrown</code></pre><p>这里<strong>有 2 个特殊的规则</strong>需要记住：</p><ol><li>当将 == 应用于 null 或 undefined 时，不会发生数值转换。null 只等于 null 或 undefined，不等于其他任何值。<pre><code class="js">null == 0               // false, null is not converted to 0null == null            // trueundefined == undefined  // truenull == undefined       // trueundefined == 0          // false</code></pre></li><li>NaN 不等于任何值，包括它自己</li></ol><pre><code class="js">NaN === NaN  // falseif(value !== value) { console.log(&#39;the value is NaN&#39;) }</code></pre><h2 id="object-类型转换"><a href="#object-类型转换" class="headerlink" title="object 类型转换"></a>object 类型转换</h2><p>到这里我们已经深入了解了原始类型的转换，接下来我们来看一下 object 类型的转换。</p><p>当涉及到对象的操作比如：<code>[1] + [2,3]</code>，引擎首先会尝试将 object 类型转为原始类型，然后在将原始类型转为最终需要的类型，而且仍然只有 3 种类型的转换：<code>number, string, boolean</code></p><p>最简单的情况是 boolean 类型的转换，任何非原始类型总是会转换成 true,无论对象或数组是否为空。</p><p>对象通过内部 <code>[[ToPrimitive]]</code> 方法转换为原始类型，该方法负责数字和字符串转换。</p><p><code>[[ToPrimitive]]</code> 方法接受两个参数一个输入值和一个需要转换的类型<code>（Numer or String）</code><br>number 和 string的转换都使用了对象的两个方法： <code>valueOf</code> 和 <code>toString</code>。这两个方法都在 <code>Object.prototype</code> 上被声明，因此可用于任何派生类，比如 <code>Date, Array</code>等。</p><blockquote><p>通常上 [[ToPrimitive]] 算法如下：</p></blockquote><ul><li>如果输入的值已经是原始类型，直接返回这个值。</li><li>输入的值调用 toString() 方法，如果结果是原始类型，则返回。</li><li>输入的值调用 valueOf() 方法，如果结果是原始类型，则返回。</li><li>如果上面 3 个步骤之后，转换后的值仍然不是原始类型，则抛出 TypeError 错误。</li></ul><p>number 类型的转换首先会调用 <code>valueOf()</code> 方法，如果不是原始值在调用 <code>toString()</code> 方法。 string 类型的转换则相反。</p><p>大多数 JS 内置对象类型的 valueOf() 返回这个对象本身，其结果经常被忽略，因为它不是一个原始类型。所以大多数情况下当 object 需要转换成 number 或 string 类型时最终都调用了 <code>toString()</code> 方法。</p><p>当运算符不同时，<code>[[ToPrimitive]]</code> 方法接受的转换类型参数也不相同。当存在 == 或者 + 运算符时一般会先触发 number 类型的转换再触发 string 类型转换。</p><p>在 JS 中你可以通过重写对象的 <code>toString 和 valueOf</code> 方法来修改对象到原始类型转换的逻辑。</p><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><pre><code class="js">true + false // 1  // &#39;+&#39; 运算符会触发 number 类型转换对于 true 和 false12 / &quot;6&quot; // 2       //算数运算符会把字符串 ‘6’ 转为 number 类型&quot;number&quot; + 15 + 3 // &#39;number153&#39;// &#39;+&#39; 运算符按从左到右的顺序的执行，所以优先执行 “number” + 15, 把 15 转为 string 类型，得到 “number15” 然后同理执行 “number15” + 315 + 3 + &quot;number&quot;  // &quot;18number&quot;// 15 + 3 先执行，运算符两边都是 number 类型 ，不用转换，然后执行 18 + “number” 最终得到 “18number”[1] &gt; null // true// ==&gt; &#39;1&#39; &gt; 0// ==&gt; 1 &gt; 0// ==&gt; true// 比较运算符 &gt; 执行 number 类型隐式转换。&quot;foo&quot; + + &quot;bar&quot; // &quot;fooNaN&quot;// ==&gt; &quot;foo&quot; + (+&quot;bar&quot;)// ==&gt; &quot;foo&quot; + NaN// ==&gt; &quot;fooNaN&quot;// 一元 + 运算符比二元 + 运算符具有更高的优先级。所以 + bar表达式先求值。一元加号执行字符串“bar” 的 number 类型转换。因为字符串不代表一个有效的数字，所以结果是NaN。在第二步中，计算表达式&#39;foo&#39; + NaN。&quot;true&quot; == true // falsefalse == &quot;false&quot; // false// == 运算符执行 number 类型转换，&#39;true&#39; 转换为 NaN， boolean 类型 true 转换为 1null == &quot;&quot; // false// null 不等于任何值除了 null 和 undefined!!&quot;false&quot; == !!&quot;true&quot; // true// !! 运算符将字符串 &#39;true&#39; 和 &#39;false&#39; 转为 boolean 类型 true, 因为不是空字符串，然后两边都是 boolean 型不在执行隐式转换操作。[&quot;x&quot;] == &quot;x&quot; // true// == 运算符对数组类型执行 number 转换，先调用对象的 valueOf() 方法，结果是数组本身，不是原始类型值，所以执行对象的 toString() 方法，得到字符串 &#39;x&#39;[] + null + 1 // &#39;null1&#39;// &#39;+&#39; 运算符执行 number 类型转换，先调用对象的 valueOf() 方法，结果是数组本身，不是原始类型值，所以执行对象的 toString() 方法，得到字符串 &#39;&#39;， 接下来执行表达式 &#39;&#39; + null + 1。[1,2,3] == [1,2,3] // false// 当运算符两边类型相同时，不会执行类型转换，两个数组的内存地址不一样，所以返回 false0 || &quot;0&quot; &amp;&amp; {}  // {}// 逻辑运算符 || 和 &amp;&amp; 将值转为 boolean 型，但是会返回原始值（不是 boolean）。{} + [] + {} + [1] // &#39;0[object Object]1&#39;// 所有的操作数都不是原始类型，所以会按照从左到右的顺序执行 number 类型的隐式转换， object 和 array 类型的 valueOf() 方法返回它们本身，所以直接忽略，执行 toString() 方法。 这里的技巧是，第一个 {} 不被视为 object，而是块声明语句，因此它被忽略。计算从 +[] 表达式开始，该表达式通过toString()方法转换为空字符串，然后转换为0。! + [] + [] + ![] // &#39;truefalse&#39;// 一元运算符优先执行，+[] 转为 number 类型 0，![] 转为 boolean 型 false。new Date(0) - 0 // 0// &#39;-&#39; 运算符执行 number 类型隐式转换对于 Date 型的值，Date.valueOf() 返回到毫秒的时间戳。new Date(0) + 0 //&quot;Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)0&quot;// +&#39; 运算符触发默认转换，因此使用 toString() 方法，而不是 valueOf()。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5d4999fff265da038f47f5c7&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;类型转换是将值从一种类型转换为另一种类型的过程（比如字符串转数字，对象转布尔值等）。任何类型不论是原始类型还是对象类型都可以进行类型转换，JavaScript 的原始类型有：&lt;code&gt;number, string, boolean, null, undefined, Symbol&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;true + false
12 / &amp;quot;6&amp;quot;
&amp;quot;number&amp;quot; + 15 + 3
15 + 3 + &amp;quot;number&amp;quot;
[1] &amp;gt; null
&amp;quot;foo&amp;quot; + + &amp;quot;bar&amp;quot;
&amp;quot;true&amp;quot; == true
false == &amp;quot;false&amp;quot;
null == &amp;quot;&amp;quot;
!!&amp;quot;false&amp;quot; == !!&amp;quot;true&amp;quot;
[&amp;quot;x&amp;quot;] == &amp;quot;x&amp;quot;
[] + null + 1
[1,2,3] == [1,2,3]
{} + [] + {} + [1]
! + [] + [] + ![]
new Date(0) - 0
new Date(0) + 0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类似于上面的这些问题大概率也会在 JS 面试中被问到, 所以继续往下读。&lt;/p&gt;
&lt;h2 id=&quot;隐式转换VS显示转换&quot;&gt;&lt;a href=&quot;#隐式转换VS显示转换&quot; class=&quot;headerlink&quot; title=&quot;隐式转换VS显示转换&quot;&gt;&lt;/a&gt;隐式转换VS显示转换&lt;/h2&gt;&lt;p&gt;类型转换可以分为&lt;strong&gt;隐式类型转换&lt;/strong&gt;和&lt;strong&gt;显式类型转换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当开发人员通过编写适当的代码(如Number(value))用于在类型之间进行转换时，就称为&lt;code&gt;显式类型强制转换(或强制类型转换)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;然而 JavaScript 是弱类型语言，在某些操作下，值可以在两种类型之间自动的转换，这叫做&lt;code&gt;隐式类型转换&lt;/code&gt;。在对不同类型的值使用运算符时通常会发生隐式类型转换。比如 1 == null, 2 / “5”, null + new Date()。当值被 if 语句包裹时也有可能发生，比如 if(value) {} 会将 value 转换为 boolean类型。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;严格相等运算符&lt;/code&gt;（===）不会触发类型隐式转换，所以它可以用来比较值和类型是否都相等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;隐式类型转换是一把双刃剑，使用它虽然可以写更少的代码但有时候会出现难以被发现的bug&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;三种类型转换&quot;&gt;&lt;a href=&quot;#三种类型转换&quot; class=&quot;headerlink&quot; title=&quot;三种类型转换&quot;&gt;&lt;/a&gt;三种类型转换&lt;/h2&gt;&lt;p&gt;我们需要知道的第一个规则是：&lt;strong&gt;在 JS 中只有 3 种类型的转换&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;to string&lt;/li&gt;
&lt;li&gt;to boolean&lt;/li&gt;
&lt;li&gt;to number&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二，&lt;strong&gt;类型转换的逻辑在原始类型和对象类型上是不同的，但是他们都只会转换成上面 3 种类型之一&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;我们首先分析一下原始类型转换。&lt;/p&gt;
&lt;h2 id=&quot;String-类型转换&quot;&gt;&lt;a href=&quot;#String-类型转换&quot; class=&quot;headerlink&quot; title=&quot;String 类型转换&quot;&gt;&lt;/a&gt;String 类型转换&lt;/h2&gt;&lt;p&gt;&lt;code&gt;String()&lt;/code&gt; 方法可以用来显式将值转为字符串，隐式转换通常在有 &lt;code&gt;+&lt;/code&gt; 运算符并且有一个操作数是 &lt;code&gt;string&lt;/code&gt; 类型时被触发，如：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;String(123) // 显式类型转换

123 + &amp;#39;&amp;#39; // 隐式类型转换

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;所有原始类型转 String 类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;String(123)  // &amp;#39;123&amp;#39;
String(-12.3)  // &amp;#39;-12.3&amp;#39;
String(null)  // &amp;#39;null&amp;#39;
String(undefined)  // &amp;#39;undefined&amp;#39;
String(true)  // &amp;#39;true&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Symbol 类型转 String 类型是比较严格的，它只能被显式的转换&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;String(Symbol(&amp;#39;symbol&amp;#39;))  // &amp;#39;Symbol(symbol)&amp;#39;

&amp;#39;&amp;#39; + Symbol(&amp;#39;symbol&amp;#39;)  // TypeError is thrown
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;Boolean-类型转换&quot;&gt;&lt;a href=&quot;#Boolean-类型转换&quot; class=&quot;headerlink&quot; title=&quot;Boolean 类型转换&quot;&gt;&lt;/a&gt;Boolean 类型转换&lt;/h2&gt;&lt;p&gt;&lt;code&gt;Boolean()&lt;/code&gt; 方法可以用来显式将值转换成 boolean 型。&lt;/p&gt;
&lt;p&gt;隐式类型转换通常在逻辑判断或者有逻辑运算符时被触发&lt;code&gt;（|| &amp;amp;&amp;amp; !）&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;Boolean(2)    // 显示类型转换
if(2) {}      // 逻辑判断触发隐式类型转换
!!2           // 逻辑运算符触发隐式类型转换
2 || &amp;#39;hello&amp;#39;  // 逻辑运算符触发隐式类型转换
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Js" scheme="https://zhanghao-web.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript异步编程回调地狱的一些解决方案</title>
    <link href="https://zhanghao-web.github.io/2019/08/01/Js/JavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://zhanghao-web.github.io/2019/08/01/Js/JavaScript异步编程回调地狱的一些解决方案/</id>
    <published>2019-08-01T01:36:56.000Z</published>
    <updated>2020-01-28T10:04:15.032Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.jianshu.com/p/bc7b8d542dcd" target="_blank" rel="noopener">原文地址</a></p><blockquote><p>异步编程在JavaScript中非常重要。过多的异步编程也带了回调嵌套的问题，本文会提供一些解决“回调地狱”的方法。</p></blockquote><pre><code class="js">setTimeout(function(){    console.log(&quot;延时触发&quot;)},2000)fs.readFile(&#39;./samp.txt&#39;,&#39;utf-8&#39;,function(res,error){    console.log(res);})</code></pre><p>上面就是典型的回调函数，不论是在浏览器中，还是在node中，JavaScript本身是单线程，因此，为了应对一些单线程带来的问题，异步编程成为了JavaScript中非常重要的一部分。</p><p>不论是浏览器中最为常见的<strong>ajax、事件监听，还是node中文件读取、网络编程、数据库等操作</strong>，都离不开异步编程。在异步编程中，许多操作都会放<strong>在回调函数（callback）</strong>中。同步与异步的混杂、过多的回调嵌套都会使得代码变得难以理解与维护，这也是常受人诟病的地方。</p><p>先看下面这段代码</p><pre><code class="js">fs.readFile(&#39;./sample.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; {    let keyword = content.substring(0, 5);    db.find(`select * from sample where kw = ${keyword}`, (err, res) =&gt; {        get(`/sampleget?count=${res.length}`, data =&gt; {           console.log(data);        });    });});</code></pre><p>首先我们读取的一个文件中的关键字keyword，然后根据该keyword进行数据库查询，最后依据查询结果请求数据。</p><ul><li>文件读取：fs.readFile</li><li>数据库查询：db.find</li><li>http请求：get</li></ul><p>可以看到，我们没增加一个异步请求，就会多添加一层回调函数的嵌套，这段代码中三个异步函数的嵌套已经开始使一段本可以语言明确的代码编程不易阅读与维护了。</p><p>抽象出来这种代码会变成下面这样：</p><pre><code class="js">asyncFunc1(opt, (...args1) =&gt; {    asyncFunc2(opt, (...args2) =&gt; {        asyncFunc3(opt, (...args3) =&gt; {            asyncFunc4(opt, (...args4) =&gt; {                // some operation            });        });    });});</code></pre><p>左侧明显出现了一个三角形的缩进区域，过多的回调也就让我们陷入<code>“回调地狱”</code>。接下来会介绍一些方法来规避回调地狱。</p><h2 id="一、拆解function"><a href="#一、拆解function" class="headerlink" title="一、拆解function"></a>一、拆解function</h2><p>回调嵌套所带来的一个重要问题就是代码不易阅读与维护。因为普遍来说，过多的缩进（嵌套）会极大的影响代码的可读性。基于这一点，可以进行一个最简单的优化——将各步拆解为单个的<code>function</code></p><pre><code class="js">function getData(count) {    get(`/sampleget?count=${count}`, data =&gt; {        console.log(data);    });}function queryDB(kw) {    db.find(`select * from sample where kw = ${kw}`, (err, res) =&gt; {        getData(res.length);    });}function readFile(filepath) {    fs.readFile(filepath, &#39;utf-8&#39;, (err, content) =&gt; {        let keyword = content.substring(0, 5);        queryDB(keyword);    });}readFile(&#39;./sample.txt&#39;);</code></pre><p>可以看到，通过上面的改写方式，代码清晰了许多。该方法非常简单，具有一定的效果，但是缺少通用性。</p><h2 id="二、事件发布-监听模式"><a href="#二、事件发布-监听模式" class="headerlink" title="二、事件发布/监听模式"></a>二、事件发布/监听模式</h2><p>如果在浏览器中写过事件监听<code>addEventListener</code>，那么你对这种事件发布/监听的模式一定不陌生。</p><p>借鉴这种思想，一方面，我们可以监听某一事件，当事件发生时，进行相应回调操作；另一方面，当某些操作完成后，通过发布事件触发回调。这样就可以将原本捆绑在一起的代码解耦。<br><a id="more"></a></p><pre><code class="js">const events = require(&#39;events&#39;);const eventEmitter = new events.EventEmitter();eventEmitter.on(&#39;db&#39;, (err, kw) =&gt; {    db.find(`select * from sample where kw = ${kw}`, (err, res) =&gt; {        eventEmitter(&#39;get&#39;, res.length);    });});eventEmitter.on(&#39;get&#39;, (err, count) =&gt; {    get(`/sampleget?count=${count}`, data =&gt; {        console.log(data);    });});fs.readFile(&#39;./sample.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; {    let keyword = content.substring(0, 5);    eventEmitter. emit(&#39;db&#39;, keyword);});</code></pre><p>使用这种模式的实现需要一个事件发布/监听的库。上面代码中使用node原生的events模块，当然你可以使用任何你喜欢的库。</p><h2 id="三、Promise"><a href="#三、Promise" class="headerlink" title="三、Promise"></a>三、Promise</h2><p><code>Promise</code>是一种异步解决方案，最早由社区提出并实现，后来写进了es6规范。</p><p>目前一些主流的浏览器已经原生实现了Promise的API，可以在Can I use里查看浏览器的支持情况。当然，如果想要做浏览器的兼容，可以考虑使用一些<code>Promise</code>的实现库，例如bluebird、 Q等。下面以bluebird为例：</p><p>首先，我们需要将异步方法改写为<code>Promise</code>，对于符合node规范的回调函数（第一个参数必须是Error），可以使用<code>bluebird</code>的promisify方法。该方法接收一个标准的异步方法并返回一个<code>Promise</code>对象。</p><pre><code class="js">const bluebird = require(&#39;bluebird&#39;);const fs = require(&quot;fs&quot;);const readFile = bluebird.promisify(fs.readFile);</code></pre><p>这样，readFile就变成了一个Promise对象。</p><p>但是，有的异步方法无法进行转换，或者我们需要使用原生<code>Promise</code>，这就需要我们手动进行一些改造。下面提供一种改造的方法。</p><p>以fs.readFile为例，借助原生<code>Promise</code>来改造该方法：</p><pre><code class="js">const readFile = function (filepath) {    let resolve,        reject;    let promise = new Promise((_resolve, _reject) =&gt; {        resolve = _resolve;        reject = _reject;    });    let deferred = {        resolve,        reject,        promise    };    fs.readFile(filepath, &#39;utf-8&#39;, function (err, ...args) {        if (err) {            deferred.reject(err);        }        else {            deferred.resolve(...args);        }    });    return deferred.promise;}</code></pre><p>我们在方法中创建了一个Promise对象，并在异步回调中根据不同的情况使用reject与resolve来改变Promise对象的状态。该方法返回这个Promise对象。其他的一些异步方法也可以参照这种方式进行改造。</p><p>假设通过改造，readFile、queryDB与getData方法均会返回一个Promise对象。代码就变为了:</p><pre><code class="js">readFile(&#39;./sample.txt&#39;).then(content =&gt; {    let keyword = content.substring(0, 5);    return queryDB(keyword);}).then(res =&gt; {    return getData(res.length);}).then(data =&gt; {    console.log(data);}).catch(err =&gt; {    console.warn(err);});</code></pre><p>可以看到，之前的嵌套操作编程了通过then连接的链式操作。代码的整洁度上有了一个较大的提高。</p><h2 id="四、generator"><a href="#四、generator" class="headerlink" title="四、generator"></a>四、generator</h2><p><code>generator</code>是es6中的一个新的语法。在function关键字后添加*即可将函数变为<code>generator</code>。</p><pre><code class="js">const gen = function* () {    yield 1;    yield 2;    return 3;}</code></pre><p>执行<code>generator</code>将会返回一个遍历器对象，用于遍历<code>generator</code>内部的状态</p><pre><code class="js">let g = gen();g.next(); // { value: 1, done: false }g.next(); // { value: 2, done: false }g.next(); // { value: 3, done: true }g.next(); // { value: undefined, done: true }</code></pre><p>可以看到，<code>generator</code>函数有一个最大的特点，可以在内部执行的过程中交出程序的控制权，<code>yield</code>相当于起到了一个暂停的作用；而当一定情况下，外部又将控制权再移交回来。</p><p>想象一下，我们用<code>generator</code>来封装代码，在异步任务处使用<code>yield</code>关键词，此时<code>generator</code>会将程序执行权交给其他代码，而在异步任务完成后，调用next方法来恢复<code>yield</code>下方代码的执行。以readFile为例，大致流程如下：</p><pre><code class="js">// 我们的主任务——显示关键字// 使用yield暂时中断下方代码执行// yield后面为promise对象const showKeyword = function* (filepath) {    console.log(&#39;开始读取&#39;);    let keyword = yield readFile(filepath);    console.log(`关键字为${filepath}`);}// generator的流程控制let gen = showKeyword();let res = gen.next();res.value.then(res =&gt; gen.next(res));</code></pre><p>在主任务部分，原本<code>readFile</code>异步的部分变成了类似同步的写法，代码变得非常清晰。而在下半部分，则是对于什么时候需要移交回控制权给<code>generator</code>的流程控制。</p><p>然而，我们需要手动控制<code>generator</code>的流程，如果能够自动执行<code>generator</code>——在需要的时候自动移交控制权，那么会更加具有实用性。<br>为此，我们可以使用 co 这个库。它可以是省去我们对于<code>generator</code>流程控制的代码</p><pre><code class="js">const co = reuqire(&#39;co&#39;);// 我们的主任务——显示关键字// 使用yield暂时中断下方代码执行// yield后面为promise对象const showKeyword = function* (filepath) {    console.log(&#39;开始读取&#39;);    let keyword = yield readFile(filepath);    console.log(`关键字为${filepath}`);}// 使用coco(showKeyword);</code></pre><p>其中，yeild关键字后面需要是<code>functio, promise, generator, array或object</code>。可以改写文章一开始的例子：</p><pre><code class="js">const co = reuqire(&#39;co&#39;);const task = function* (filepath) {   let keyword = yield readFile(filepath);   let count = yield queryDB(keyword);   let data = yield getData(res.length);   console.log(data);});co(task, &#39;./sample.txt&#39;);</code></pre><p>五、async/await</p><p>可以看到，上面的方法虽然都在一定程度上解决了异步编程中回调带来的问题。然而</p><ul><li>function拆分的方式其实仅仅只是拆分代码块，时常会不利于后续维护；</li><li>事件发布/监听方式模糊了异步方法之间的流程关系；</li><li>Promise虽然使得多个嵌套的异步调用能够通过链式的API进行操作，但是过多的then也增加了代码的冗余，也对阅读代码中各阶段的异步任务产生了一定干扰；</li><li>通过generator虽然能提供较好的语法结构，但是毕竟generator与yield的语境用在这里多少还有些不太贴切。</li></ul><p>因此，这里再介绍一个方法，它就是es7中的async/await。</p><p>简单介绍一下async/await。基本上，任何一个函数都可以成为async函数，以下都是合法的书写形式：</p><pre><code class="js">async function foo () {};const foo = async function () {};const foo = async () =&gt; {};</code></pre><p>在async函数中可以使用await语句。await后一般是一个Promise对象。</p><pre><code class="js">async function foo () {    console.log(&#39;开始&#39;);    let res = await post(data);    console.log(`post已完成，结果为：${res}`);};</code></pre><p>当上面的函数执行到await时，可以简单理解为，函数挂起，等待<code>await</code>后的<code>Promise</code>返回，再执行下面的语句。</p><p>值得注意的是，这段异步操作的代码，看起来就像是“同步操作”。这就大大方便了异步代码的编写与阅读。下面改写我们的例子。</p><pre><code class="js">const printData = async function (filepath) {   let keyword = await readFile(filepath);   let count = await queryDB(keyword);   let data = await getData(res.length);   console.log(data);});printData(&#39;./sample.txt&#39;);</code></pre><p>可以看到，代码简洁清晰，异步代码也具有了“同步”代码的结构。</p><p>注意，其中<code>readFile、queryDB与getData</code>方法都需要返回一个<code>Promise</code>对象。这可以通过在第三部分Promise里提供的方式进行改写。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>异步编程作为JavaScript中的一部分，具有非常重要的位置，它帮助我们避免同步代码带来的线程阻塞的同时，也为编码与阅读带来了一定的困难。过多的回调嵌套很容易会让我们陷入“回调地狱”中，使代码变成一团乱麻。为了解决“回调地狱”，我们可以使用文中所述的这五种常用方法：</p><ul><li>function拆解</li><li>事件发布/订阅模式</li><li>Promise</li><li>Generator</li><li>async / await</li></ul><p>理解各类方法的原理与实现方式，了解其中利弊，可以帮助我们更好得进行异步编程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.jianshu.com/p/bc7b8d542dcd&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;异步编程在JavaScript中非常重要。过多的异步编程也带了回调嵌套的问题，本文会提供一些解决“回调地狱”的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;setTimeout(function(){
    console.log(&amp;quot;延时触发&amp;quot;)
},2000)
fs.readFile(&amp;#39;./samp.txt&amp;#39;,&amp;#39;utf-8&amp;#39;,function(res,error){
    console.log(res);
})
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上面就是典型的回调函数，不论是在浏览器中，还是在node中，JavaScript本身是单线程，因此，为了应对一些单线程带来的问题，异步编程成为了JavaScript中非常重要的一部分。&lt;/p&gt;
&lt;p&gt;不论是浏览器中最为常见的&lt;strong&gt;ajax、事件监听，还是node中文件读取、网络编程、数据库等操作&lt;/strong&gt;，都离不开异步编程。在异步编程中，许多操作都会放&lt;strong&gt;在回调函数（callback）&lt;/strong&gt;中。同步与异步的混杂、过多的回调嵌套都会使得代码变得难以理解与维护，这也是常受人诟病的地方。&lt;/p&gt;
&lt;p&gt;先看下面这段代码&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;fs.readFile(&amp;#39;./sample.txt&amp;#39;, &amp;#39;utf-8&amp;#39;, (err, content) =&amp;gt; {
    let keyword = content.substring(0, 5);
    db.find(`select * from sample where kw = ${keyword}`, (err, res) =&amp;gt; {
        get(`/sampleget?count=${res.length}`, data =&amp;gt; {
           console.log(data);
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先我们读取的一个文件中的关键字keyword，然后根据该keyword进行数据库查询，最后依据查询结果请求数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;文件读取：fs.readFile&lt;/li&gt;
&lt;li&gt;数据库查询：db.find&lt;/li&gt;
&lt;li&gt;http请求：get&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看到，我们没增加一个异步请求，就会多添加一层回调函数的嵌套，这段代码中三个异步函数的嵌套已经开始使一段本可以语言明确的代码编程不易阅读与维护了。&lt;/p&gt;
&lt;p&gt;抽象出来这种代码会变成下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;asyncFunc1(opt, (...args1) =&amp;gt; {
    asyncFunc2(opt, (...args2) =&amp;gt; {
        asyncFunc3(opt, (...args3) =&amp;gt; {
            asyncFunc4(opt, (...args4) =&amp;gt; {
                // some operation
            });
        });
    });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;左侧明显出现了一个三角形的缩进区域，过多的回调也就让我们陷入&lt;code&gt;“回调地狱”&lt;/code&gt;。接下来会介绍一些方法来规避回调地狱。&lt;/p&gt;
&lt;h2 id=&quot;一、拆解function&quot;&gt;&lt;a href=&quot;#一、拆解function&quot; class=&quot;headerlink&quot; title=&quot;一、拆解function&quot;&gt;&lt;/a&gt;一、拆解function&lt;/h2&gt;&lt;p&gt;回调嵌套所带来的一个重要问题就是代码不易阅读与维护。因为普遍来说，过多的缩进（嵌套）会极大的影响代码的可读性。基于这一点，可以进行一个最简单的优化——将各步拆解为单个的&lt;code&gt;function&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function getData(count) {
    get(`/sampleget?count=${count}`, data =&amp;gt; {
        console.log(data);
    });
}

function queryDB(kw) {
    db.find(`select * from sample where kw = ${kw}`, (err, res) =&amp;gt; {
        getData(res.length);
    });
}

function readFile(filepath) {
    fs.readFile(filepath, &amp;#39;utf-8&amp;#39;, (err, content) =&amp;gt; {
        let keyword = content.substring(0, 5);
        queryDB(keyword);
    });
}

readFile(&amp;#39;./sample.txt&amp;#39;);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以看到，通过上面的改写方式，代码清晰了许多。该方法非常简单，具有一定的效果，但是缺少通用性。&lt;/p&gt;
&lt;h2 id=&quot;二、事件发布-监听模式&quot;&gt;&lt;a href=&quot;#二、事件发布-监听模式&quot; class=&quot;headerlink&quot; title=&quot;二、事件发布/监听模式&quot;&gt;&lt;/a&gt;二、事件发布/监听模式&lt;/h2&gt;&lt;p&gt;如果在浏览器中写过事件监听&lt;code&gt;addEventListener&lt;/code&gt;，那么你对这种事件发布/监听的模式一定不陌生。&lt;/p&gt;
&lt;p&gt;借鉴这种思想，一方面，我们可以监听某一事件，当事件发生时，进行相应回调操作；另一方面，当某些操作完成后，通过发布事件触发回调。这样就可以将原本捆绑在一起的代码解耦。&lt;br&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Js" scheme="https://zhanghao-web.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>Webpack Freestyle 之 Long Term Cache(webpack 实现持久性缓存)</title>
    <link href="https://zhanghao-web.github.io/2019/07/31/Tools/Webpack-Freestyle-%E4%B9%8B-Long-Term-Cache-webpack-%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E6%80%A7%E7%BC%93%E5%AD%98/"/>
    <id>https://zhanghao-web.github.io/2019/07/31/Tools/Webpack-Freestyle-之-Long-Term-Cache-webpack-实现持久性缓存/</id>
    <published>2019-07-31T06:36:29.000Z</published>
    <updated>2020-01-28T10:04:15.063Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/27710902" target="_blank" rel="noopener">原文地址</a></p><h2 id="How-Browser-Cache-Works"><a href="#How-Browser-Cache-Works" class="headerlink" title="How Browser Cache Works"></a>How Browser Cache Works</h2><p>首先，我们要搞清楚浏览器缓存是怎么工作的。 那么，就让我画一张图来告诉大家吧，嘻嘻。</p><p><img src="https://pic2.zhimg.com/80/v2-5babc40038bcc8add9c5f8bcb717c7b5_hd.png" alt="pic"></p><ul><li>浏览器: 我需要 foo.js</li><li>服务器: 让我找找。找到了，给你，缓存有效期为 1 年。</li><li>浏览器: 好，我把他缓存到磁盘里。</li></ul><p>过了 2 天，</p><p><img src="https://pic4.zhimg.com/80/v2-b5e4a95482e0008758b94ec96c0f60a3_hd.png" alt="pic1"></p><p>浏览器: 我需要 foo.js ，在缓存里找到了。缓存还有效，那直接读缓存。<br>用户：哇塞，这网页秒开啊。</p><p>又过了 2 天，foo.js 的代码更新了。（内容从 Hello world 变成了 Goodbye world ）</p><p><img src="https://pic2.zhimg.com/80/v2-680f699d7e09991af4f6bf260559aef1_hd.png" alt="pic2"></p><p>浏览器：我需要 foo.js ，在缓存里找到了。缓存还有效，那直接读缓存。<br>产品经理：？？？这页面怎么跟以前一样啊？</p><p>很尴尬。foo.js 明明更新了，但是浏览器还是读取在缓存中旧的 foo.js ，原因是我们用了缓存，不用缓存就没这事儿了。?</p><p>解决办法嘛，当然有的。比如每次利用缓存之前，<code>先向服务器确认文件是否有更新，有更新则使用新的否则读缓存</code>。还有一种方法是<code>把缓存破坏掉，也就是下面要说的*Cache Busting Technique*</code> </p><h2 id="Cache-Busting-Technique"><a href="#Cache-Busting-Technique" class="headerlink" title="Cache Busting Technique"></a>Cache Busting Technique</h2><p>因为 foo.js 的代码变化了，但是他的缓存还没失效，此时浏览器还是会读取以前的缓存了的 foo.js ，并不会去服务器下载最新的。这显然不是我们想要的，怎么办呢？我们需要破坏缓存（ Cache Busting ）。</p><p>破坏缓存并不是禁止缓存，而是换一种方式让缓存失效。比如：</p><p>1.修改文件的名字：foo.js -&gt; foo.v2.js<br>2.修改文件的路径：/static/foo.js -&gt; /static/v2/foo.js<br>3.加 query string : foo.js -&gt; foo.js?v=qwer</p><p>我们下面将采用第一种方法，也就是修改文件的名字。我们把更新后的 foo.js 的文件名改成 foo.v2.js 。这样，浏览器就不会去读取缓存里的旧的 foo.js ，而是向服务请请求 foo.v2.js ，如下图所示：</p><p><img src="https://pic2.zhimg.com/80/v2-103471cbe5d028bc9e1122db6e4243b9_hd.png" alt="pic4"></p><p>那么，假设我们现在有很多很多的静态文件，然后每次需要更新很多很多的文件，那是不是要手动地一个一个地修改文件的名字呢？我们的理想当然是：哪个文件更新了，就<strong>自动</strong>地生成一个新的文件名。</p><p>另外，如果我们打包出来的静态文件只有一个单独的 JavaScript 文件 app.js ，那么每次改动一点代码，app.js 的文件名肯定都会变。但实际上，我只改动了某个模块的代码（其他模块并没有修改），就破坏了其他模块的缓存，这显然没有充分利用到缓存啊。我们的想法是：哪个模块更新了破坏他的缓存，没更新的模块继续利用缓存。</p><p>这个时候，我们就需要用到 webpack 的 code splitting（如果还不会的话，可以阅读 <a href="https://zhuanlan.zhihu.com/p/26710831?refer=ElemeFE" target="_blank" rel="noopener">Webpack 大法之 Code Splitting</a> ）。把整个 App 分成一个个 chunk ，然后哪个 chunk 发生改变，我就破坏他的缓存；没有更新的 chunk ，则继续利用缓存。这样一来，我们就把缓存的作用发挥到淋漓尽致～</p><p>所以，<code>code splitting</code> 的作用除了”减少文件大小”之外，还能更充分地利用缓存。所以，下面就让我们用 webpack 来实现持久性缓存吧。</p><h2 id="Webpack-amp-Caching"><a href="#Webpack-amp-Caching" class="headerlink" title="Webpack &amp; Caching"></a>Webpack &amp; Caching</h2><p>首先，把我们的 <a href="https://link.zhihu.com/?target=https%3A//github.com/lyyourc/webpack-code-splitting-demo">demo 项目</a>（已经实现了 code splitting ）下载并安装好依赖。</p><p>接着，修改 webpack 配置文件，给我们打包后的静态文件生成随机的唯一的名字。（ changed files ）</p><pre><code class="js">// webpack.config.jsmodule.exports = {  output: {    //...    filename: &#39;[name].[chunkhash:8].js&#39;,    chunkFilename: &#39;[name].[chunkhash:8].chunk.js&#39;,    //...  },}</code></pre><p>我们使用了 <code>[chunkhash]</code> 这个占位符，并且为了更好地分辨和展示 demo ，我们截取了他的前 8 个字符 <code>[chunkhash:8]</code>，但是在实际生产中我们不要那么做！</p><p>好咯，现在来看看我们的打包后的文件：</p><pre><code class="js">                    Asset            Size    Chunk Namescommon-in-lazy.fa79d198.chunk.js    11.6 kB  common-in-lazy    used-twice.c2c4927c.chunk.js    17.1 kB  used-twice        Photos.28d663ec.chunk.js    8.57 kB  Photos         Emoji.d3ea8991.chunk.js    1.15 kB  Emoji                 app.724a238a.js    2.53 kB  app              vendor.05be8f94.js     104 kB  vendor</code></pre><p>那么，现在我们来修改一下 App.vue ，添加个 <code>&lt;footer&gt;</code> 标签（ changed files ） :</p><pre><code class="html">&lt;template&gt;&lt;div id=&quot;app&quot;&gt;  &lt;!-- old codes --&gt;  &lt;footer&gt; A Footer &lt;/footer&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><a id="more"></a><p>此时的打包变成了：</p><pre><code class="js">                        Asset       Size  Chunk Namescommon-in-lazy.fa79d198.chunk.js    11.6 kB  common-in-lazy    used-twice.c2c4927c.chunk.js    17.1 kB  used-twice        Photos.28d663ec.chunk.js    8.57 kB  Photos         Emoji.d3ea8991.chunk.js    1.15 kB  Emoji                 app.fdc2eedb.js    2.57 kB  app              vendor.b611a5da.js     104 kB  vendor</code></pre><p>注意到，我们的 app chunk 的 hash 从 724a238a 变成了 fdc2eedb ，这是我们所希望看到的东西。但是，与此同时 vendor chunk 的 hash 也变了（05be8f94 -&gt; b611a5da）。然而，我们并没有修改 vendor chunk 的代码，为什么他的 hash 也变了呢？?</p><p>原因是 <code>vendor chunk</code> 里面包含了 <code>webpack</code> 的 <code>runtime</code> 代码（用来解析和加载模块之类的运行时代码）：</p><p>解决办法就是把 webpack 的 runtime 代码提取出来（ changed files ）：</p><pre><code class="js">new webpack.optimize.CommonsChunkPlugin({   name: [&#39;manifast&#39;] }),</code></pre><p>把之前 App.vue 更新了的代码暂时去掉，也就是上面添加的 <code>&lt;footer&gt;</code> 标签去掉：</p><p>接着按照之前的，修改 App.vue ，添加 <code></code> 标签（ changed files ）：</p><pre><code class="html">&lt;template&gt;&lt;div id=&quot;app&quot;&gt;  &lt;!-- old codes --&gt;  &lt;footer&gt; A Footer &lt;/footer&gt;&lt;/div&gt;&lt;/template&gt;</code></pre><p>而此时的打包：</p><pre><code class="js">                        Asset       Size  Chunk Namescommon-in-lazy.fa79d198.chunk.js    11.6 kB  common-in-lazy    used-twice.c2c4927c.chunk.js    17.1 kB  used-twice        Photos.28d663ec.chunk.js    8.57 kB  Photos         Emoji.d3ea8991.chunk.js    1.15 kB  Emoji                 app.fdc2eedb.js    2.57 kB  app              vendor.3b70f9d8.js     103 kB  vendor            manifast.1442e3f3.js    1.54 kB  manifast</code></pre><p>很开心，此时只有 <code>app.js</code> 和 <code>manifast.js</code> 这 2 个 chunk 的文件名的 hash 发生了改变，vendor.js chunk 和其他 chunk 都没变，舒服。</p><p>但是，假如我们给 App.vue 随便引入一个模块的话，比如（ changed files ）：</p><pre><code class="js">&lt;script&gt;//...import noop from &#39;./shared/utils.js&#39;&lt;/script&gt;</code></pre><p>而此时的打包：</p><pre><code class="js">                        Asset       Size  Chunk Namescommon-in-lazy.30b1e9b6.chunk.js    11.6 kB  common-in-lazy    used-twice.9eccbe5a.chunk.js    17.1 kB  used-twice        Photos.6096611c.chunk.js    8.57 kB  Photos         Emoji.6208da60.chunk.js    1.15 kB  Emoji                 app.4675a374.js    2.61 kB  app              vendor.8b538297.js     103 kB  vendor            manifast.25580296.js    1.54 kB  manifast</code></pre><p>卧槽居然所有 chunk 的 hash 都发生了改变，这是为什么？</p><p><strong>原因是在 webpack 里每个模块都有一个 module id </strong>，module id 是该模块在<a href="https://link.zhihu.com/?target=https%3A//webpack.js.org/concepts/dependency-graph/">模块依赖关系图</a>里按顺序分配的序号，如果这个 module id 发生了变化，那么他的 chunkhash 也会发生变化。（不确定这里是否正确，希望大佬指出错误）</p><p><img src="https://pic4.zhimg.com/80/v2-5a4b6bef5809e00512873d481a3670e7_hd.png" alt="pic5"></p><p>所以呢，我们需要用一种新的方式来计算 module id 。 <strong>HashedModuleIdsPlugin</strong> 这个插件，他是根据模块所在路径来映射其 module id ，这样就算引入了新的模块，也不会影响 module id 的值，只要模块的路径不改变的话。</p><p>修改我们的 webpack 配置。并且，去掉上面 App.vue 引入的 noop 模块。（ changed files ）</p><pre><code class="js">// webpack.config.jsplugins: [  new webpack.HashedModuleIdsPlugin(),  // ...],</code></pre><p>可以看到，只有 app chunk 和 manifast chunk 的 hash 发生了改变，其他 chunk 不变所以他们的缓存就没被破坏。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>用 webpack 实现 long term cache ：</p><ul><li>生成稳定的 hash 文件名</li><li>提取 webpack 的 runtime 代码</li><li>code splitting</li></ul><p>还有一些东西我们是没讲到的，比如 CSS 的 cache ，内联 manifast chunk 等等，就留给大家去探索咯。</p><p>最后需要注意的是，webpack 是允许其他 plugin 来修改 chunkhash 的，如果他们不能正确地处理的话，那么，假设你更新了代码，但是对应的 chunkhash 没变，并且此时缓存还没失效，就会导致线上的代码还是旧的，用户看到的还是以前的页面。因此，一定要特别注意 chunkhash 到底正不正确！！</p><p>希望本文可以帮助到大家，这样我会很开心的。(<em> </em>)</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/27710902&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;How-Browser-Cache-Works&quot;&gt;&lt;a href=&quot;#How-Browser-Cache-Works&quot; class=&quot;headerlink&quot; title=&quot;How Browser Cache Works&quot;&gt;&lt;/a&gt;How Browser Cache Works&lt;/h2&gt;&lt;p&gt;首先，我们要搞清楚浏览器缓存是怎么工作的。 那么，就让我画一张图来告诉大家吧，嘻嘻。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-5babc40038bcc8add9c5f8bcb717c7b5_hd.png&quot; alt=&quot;pic&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;浏览器: 我需要 foo.js&lt;/li&gt;
&lt;li&gt;服务器: 让我找找。找到了，给你，缓存有效期为 1 年。&lt;/li&gt;
&lt;li&gt;浏览器: 好，我把他缓存到磁盘里。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;过了 2 天，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic4.zhimg.com/80/v2-b5e4a95482e0008758b94ec96c0f60a3_hd.png&quot; alt=&quot;pic1&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器: 我需要 foo.js ，在缓存里找到了。缓存还有效，那直接读缓存。&lt;br&gt;用户：哇塞，这网页秒开啊。&lt;/p&gt;
&lt;p&gt;又过了 2 天，foo.js 的代码更新了。（内容从 Hello world 变成了 Goodbye world ）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-680f699d7e09991af4f6bf260559aef1_hd.png&quot; alt=&quot;pic2&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器：我需要 foo.js ，在缓存里找到了。缓存还有效，那直接读缓存。&lt;br&gt;产品经理：？？？这页面怎么跟以前一样啊？&lt;/p&gt;
&lt;p&gt;很尴尬。foo.js 明明更新了，但是浏览器还是读取在缓存中旧的 foo.js ，原因是我们用了缓存，不用缓存就没这事儿了。?&lt;/p&gt;
&lt;p&gt;解决办法嘛，当然有的。比如每次利用缓存之前，&lt;code&gt;先向服务器确认文件是否有更新，有更新则使用新的否则读缓存&lt;/code&gt;。还有一种方法是&lt;code&gt;把缓存破坏掉，也就是下面要说的*Cache Busting Technique*&lt;/code&gt; &lt;/p&gt;
&lt;h2 id=&quot;Cache-Busting-Technique&quot;&gt;&lt;a href=&quot;#Cache-Busting-Technique&quot; class=&quot;headerlink&quot; title=&quot;Cache Busting Technique&quot;&gt;&lt;/a&gt;Cache Busting Technique&lt;/h2&gt;&lt;p&gt;因为 foo.js 的代码变化了，但是他的缓存还没失效，此时浏览器还是会读取以前的缓存了的 foo.js ，并不会去服务器下载最新的。这显然不是我们想要的，怎么办呢？我们需要破坏缓存（ Cache Busting ）。&lt;/p&gt;
&lt;p&gt;破坏缓存并不是禁止缓存，而是换一种方式让缓存失效。比如：&lt;/p&gt;
&lt;p&gt;1.修改文件的名字：foo.js -&amp;gt; foo.v2.js&lt;br&gt;2.修改文件的路径：/static/foo.js -&amp;gt; /static/v2/foo.js&lt;br&gt;3.加 query string : foo.js -&amp;gt; foo.js?v=qwer&lt;/p&gt;
&lt;p&gt;我们下面将采用第一种方法，也就是修改文件的名字。我们把更新后的 foo.js 的文件名改成 foo.v2.js 。这样，浏览器就不会去读取缓存里的旧的 foo.js ，而是向服务请请求 foo.v2.js ，如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://pic2.zhimg.com/80/v2-103471cbe5d028bc9e1122db6e4243b9_hd.png&quot; alt=&quot;pic4&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么，假设我们现在有很多很多的静态文件，然后每次需要更新很多很多的文件，那是不是要手动地一个一个地修改文件的名字呢？我们的理想当然是：哪个文件更新了，就&lt;strong&gt;自动&lt;/strong&gt;地生成一个新的文件名。&lt;/p&gt;
&lt;p&gt;另外，如果我们打包出来的静态文件只有一个单独的 JavaScript 文件 app.js ，那么每次改动一点代码，app.js 的文件名肯定都会变。但实际上，我只改动了某个模块的代码（其他模块并没有修改），就破坏了其他模块的缓存，这显然没有充分利用到缓存啊。我们的想法是：哪个模块更新了破坏他的缓存，没更新的模块继续利用缓存。&lt;/p&gt;
&lt;p&gt;这个时候，我们就需要用到 webpack 的 code splitting（如果还不会的话，可以阅读 &lt;a href=&quot;https://zhuanlan.zhihu.com/p/26710831?refer=ElemeFE&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Webpack 大法之 Code Splitting&lt;/a&gt; ）。把整个 App 分成一个个 chunk ，然后哪个 chunk 发生改变，我就破坏他的缓存；没有更新的 chunk ，则继续利用缓存。这样一来，我们就把缓存的作用发挥到淋漓尽致～&lt;/p&gt;
&lt;p&gt;所以，&lt;code&gt;code splitting&lt;/code&gt; 的作用除了”减少文件大小”之外，还能更充分地利用缓存。所以，下面就让我们用 webpack 来实现持久性缓存吧。&lt;/p&gt;
&lt;h2 id=&quot;Webpack-amp-Caching&quot;&gt;&lt;a href=&quot;#Webpack-amp-Caching&quot; class=&quot;headerlink&quot; title=&quot;Webpack &amp;amp; Caching&quot;&gt;&lt;/a&gt;Webpack &amp;amp; Caching&lt;/h2&gt;&lt;p&gt;首先，把我们的 &lt;a href=&quot;https://link.zhihu.com/?target=https%3A//github.com/lyyourc/webpack-code-splitting-demo&quot;&gt;demo 项目&lt;/a&gt;（已经实现了 code splitting ）下载并安装好依赖。&lt;/p&gt;
&lt;p&gt;接着，修改 webpack 配置文件，给我们打包后的静态文件生成随机的唯一的名字。（ changed files ）&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// webpack.config.js
module.exports = {
  output: {
    //...
    filename: &amp;#39;[name].[chunkhash:8].js&amp;#39;,
    chunkFilename: &amp;#39;[name].[chunkhash:8].chunk.js&amp;#39;,
    //...
  },
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们使用了 &lt;code&gt;[chunkhash]&lt;/code&gt; 这个占位符，并且为了更好地分辨和展示 demo ，我们截取了他的前 8 个字符 &lt;code&gt;[chunkhash:8]&lt;/code&gt;，但是在实际生产中我们不要那么做！&lt;/p&gt;
&lt;p&gt;好咯，现在来看看我们的打包后的文件：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;                    Asset            Size    Chunk Names
common-in-lazy.fa79d198.chunk.js    11.6 kB  common-in-lazy
    used-twice.c2c4927c.chunk.js    17.1 kB  used-twice
        Photos.28d663ec.chunk.js    8.57 kB  Photos
         Emoji.d3ea8991.chunk.js    1.15 kB  Emoji
                 app.724a238a.js    2.53 kB  app
              vendor.05be8f94.js     104 kB  vendor
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么，现在我们来修改一下 App.vue ，添加个 &lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt; 标签（ changed files ） :&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
&amp;lt;div id=&amp;quot;app&amp;quot;&amp;gt;
  &amp;lt;!-- old codes --&amp;gt;
  &amp;lt;footer&amp;gt; A Footer &amp;lt;/footer&amp;gt;
&amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Tools" scheme="https://zhanghao-web.github.io/categories/Tools/"/>
    
    
      <category term="Webpack" scheme="https://zhanghao-web.github.io/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>通过一个问题学习map,filter,reduce语法</title>
    <link href="https://zhanghao-web.github.io/2019/07/24/Js/%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0map-filter-reduce%E8%AF%AD%E6%B3%95/"/>
    <id>https://zhanghao-web.github.io/2019/07/24/Js/通过一个问题学习map-filter-reduce语法/</id>
    <published>2019-07-24T01:44:52.000Z</published>
    <updated>2020-01-28T10:04:15.040Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？"><a href="#比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？" class="headerlink" title="比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？"></a>比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？</h2><p>这个问题不难，有的少侠可能会使用for循环来过滤出偶数，某些少侠可能会使用while循环，又或是使用数组自带的filter方法。</p><p>这里，我们先不考虑使用for和while这些迭代方法，我们选择使用数组自带的filter方法，如果使用filter方法的话，</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];// 过滤出所有奇数nums.filter(num =&gt; num % 2 !== 0);console.log(nums);</code></pre><p>还是挺简单的对吧？</p><p>相信大部分少侠都能很轻松完成。</p><p>在filter函数内部，我们使用 <code>num % 2 !== 0</code> 来判断 是否是一个奇数，如果是一个奇数，就过滤出来。</p><p>在这里，有的少侠可能就会想到，如果把这个判断过程单独分成一个函数，会方便一些，也方便以后的修改扩展。</p><p>比如单独写一个isOdd函数</p><pre><code class="js">const isOdd = num =&gt; num % 2 !== 0;</code></pre><p>然后在filter里面使用这个函数，是吧？</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;// 过滤出所有奇数const odd = nums.filter(isOdd);console.log(odd);</code></pre><h2 id="如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？"><a href="#如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？" class="headerlink" title="如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？"></a>如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？</h2><p>聪明的少侠这次肯定一下就明白了：</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const double = num =&gt; num *2;const doubleNumbers = nums.map(double);console.log(doubleNumbers);</code></pre><h2 id="从nums里面过滤出所有奇数，并翻倍这些奇数。"><a href="#从nums里面过滤出所有奇数，并翻倍这些奇数。" class="headerlink" title="从nums里面过滤出所有奇数，并翻倍这些奇数。"></a>从nums里面过滤出所有奇数，并翻倍这些奇数。</h2><p>这个问题也不难是吧？</p><p>让我猜一下，一些少侠应该会写成下面这样：</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const double = num =&gt; num *2;const doubleNums = nums.filter(isOdd).map(double);console.log(doubleNums);</code></pre><h2 id="如果我们还想继续算出所有奇数翻倍后的和的话"><a href="#如果我们还想继续算出所有奇数翻倍后的和的话" class="headerlink" title="如果我们还想继续算出所有奇数翻倍后的和的话"></a>如果我们还想继续算出所有奇数翻倍后的和的话</h2><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const double = num =&gt; num *2;const add = (sum,num) =&gt; sum += num;const doubleNums = nums.filter(isOdd).map(double).reduce(add,0);console.log(doubleNums);</code></pre><p>嗯，一个串一个看起来很酷是吧？ 最后的结果也是正确的。</p><p>这样串起来的后果就是，我们会遍历3次数组，filter的时候遍历一次，map的时候遍历一次，reduce的时候再遍历一次。</p><p>现在数组只有10个数字，影响还不大，但是如果是很大的数组，比如100万个数字，遍历3遍的话，那么就会多访问<strong>150万次</strong>，</p><p>想象一下，如果让你自己从中间取出所有奇数，翻倍，并求和，你会觉得怎么做简单一些呢？</p><blockquote><p>是不是觉得下面这样才比较正常？</p></blockquote><ul><li>首先，从第一个数字开始，如果它是奇数，就拿出来，翻倍，然后找个地方放起来</li><li>接着，继续看第二个数字，如果是偶数，就跳过，如果是奇数，就拿出来，翻倍，然后和开始的翻倍后的奇数加起来，找个地方放起来。</li><li>接着看第三个数字，以此类推，只要是奇数，就翻倍，然后和之前的结果加起来。</li><li>直到我们找寻到最后一个数字，就可以算出最终结果了，</li></ul><p>如果使用迭代的话，就是下面这样:<br><a id="more"></a></p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const double = num =&gt; num *2;const add = (sum,num) =&gt; sum += num;// 保存最终结果let result = 0;for (let i =0; i&lt; nums.length; i++){    if(nums[i]%2 != 0){        result = result + nums[i]*2;    }}console.log(result); // 50</code></pre><p>没错，通常这样才是正常的操作。</p><p>但是，</p><p>这样的代码不太方便，</p><p>少侠你肯定也不想每次都写这么一大堆for循环语句吧？</p><p>所以，我们可以先试着继续优化一下。</p><p>我们首先试着用一个叫做magic(魔法)的函数把这些步骤包裹起来:</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const magic = array =&gt; {    const length = array.length,    let i = 0;    let sum = 0;    for(i, i &lt; length; i++){        if(array[i] % 2 !== 0){            sum = sum + array[i]*2;        }    }    return sum;}console.log(magic(nums)); // 50</code></pre><p>现在看起来好多了，不过，magic内部的操作看起来不是很清晰，</p><p>其他少侠看见了可能很难一眼就明白magic函数在做什么,</p><p>我们可以试着把里面的一些步骤分成更小的函数:</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const double = num =&gt; num *2;const add = (sum,num) =&gt; sum += num;const magic = array =&gt; {    const length = array.length,    let i = 0;    let sum = 0;    for(i, i &lt; length; i++){        if(isOdd(array[i])){            sum = add(sum,double(array[i]));        }    }    return sum;}console.log(magic(nums)); // 50</code></pre><p>现在比较简洁也比较清晰了，不过，假如我们现在要计算是偶数而不是奇数怎么办呢？</p><p>或者如果更复杂些，如果是偶数，就反过来，除以二，然后求和，又该怎么办呢？</p><p>难道我们又要复制一次magic函数，然后改动for循环里面的逻辑吗？</p><p>也许，我们可以把for循环内部的逻辑单独提取成一个外部函数！</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const isEvent = num =&gt; !isOdd(num)const double = num =&gt; num *2;const part = num =&gt; num /2;const add = (sum,num) =&gt; sum += num;const magic = (array,fn,sum) =&gt; {    const length = array.length,    let i = 0;    for(i, i &lt; length; i++){        sum = magicFriends(sum,array[i])    }    return sum;}function magicFriends(sum,num){    if(isOdd(num)){        sum = add(sum,double(num));    }    return sum ;}console.log(magic(nums,magicFriends,0)); // 50</code></pre><h2 id="接下来就是见证奇迹的时刻！"><a href="#接下来就是见证奇迹的时刻！" class="headerlink" title="接下来就是见证奇迹的时刻！"></a>接下来就是见证奇迹的时刻！</h2><p>首先，我们给代码里面部分函数和参数改一下名字:</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const isEvent = num =&gt; !isOdd(num)const double = num =&gt; num *2;const part = num =&gt; num /2;const add = (sum,num) =&gt; sum += num;const reduce = (array,reducer,result) =&gt; {    const length = array.length,    let i = 0;    for(i, i &lt; length; i++){        result = reducer(sum,array[i])    }    return result;}consot magicFriends = (sum,num) =&gt;{    if(isOdd(num)){        sum = add(sum,double(num));    }    return sum ;}console.log(reduce(nums,magicFriends,0)); // 50</code></pre><p>是不是有点眼熟了？ 接着，我们换成数组自带的reduce函数:</p><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const isEvent = num =&gt; !isOdd(num)const double = num =&gt; num *2;const part = num =&gt; num /2;const add = (sum,num) =&gt; sum += num;consot magicFriends = (sum,num) =&gt;{    if(isOdd(num)){        sum = add(sum,double(num));    }    return sum ;}console.log(nums.reduce(magicFriends,0)); // 50</code></pre><h2 id="最后回到我们上面的问题"><a href="#最后回到我们上面的问题" class="headerlink" title="最后回到我们上面的问题:"></a>最后回到我们上面的问题:</h2><pre><code class="js">const nums = [1,2,3,4,5,6,7,8,9,10];const isOdd = num =&gt; num % 2 !== 0;const double = num =&gt; num *2;const add = (sum,num) =&gt; sum += num;const result = nums.reduces((sum,num)=&gt; isOdd(num) ? add(sum,dobule(num) : sum,0));console.log(result); // 50</code></pre><p>这次我们用reduce只遍历了一次数组就完成了之前的操作！</p><p>现在知道为什么之前要把reduce叫做magic(魔法)了吧！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？&quot;&gt;&lt;a href=&quot;#比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？&quot; class=&quot;headerlink&quot; title=&quot;比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？&quot;&gt;&lt;/a&gt;比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？&lt;/h2&gt;&lt;p&gt;这个问题不难，有的少侠可能会使用for循环来过滤出偶数，某些少侠可能会使用while循环，又或是使用数组自带的filter方法。&lt;/p&gt;
&lt;p&gt;这里，我们先不考虑使用for和while这些迭代方法，我们选择使用数组自带的filter方法，如果使用filter方法的话，&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const nums = [1,2,3,4,5,6,7,8,9,10];
// 过滤出所有奇数
nums.filter(num =&amp;gt; num % 2 !== 0);

console.log(nums);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;还是挺简单的对吧？&lt;/p&gt;
&lt;p&gt;相信大部分少侠都能很轻松完成。&lt;/p&gt;
&lt;p&gt;在filter函数内部，我们使用 &lt;code&gt;num % 2 !== 0&lt;/code&gt; 来判断 是否是一个奇数，如果是一个奇数，就过滤出来。&lt;/p&gt;
&lt;p&gt;在这里，有的少侠可能就会想到，如果把这个判断过程单独分成一个函数，会方便一些，也方便以后的修改扩展。&lt;/p&gt;
&lt;p&gt;比如单独写一个isOdd函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const isOdd = num =&amp;gt; num % 2 !== 0;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后在filter里面使用这个函数，是吧？&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const nums = [1,2,3,4,5,6,7,8,9,10];

const isOdd = num =&amp;gt; num % 2 !== 0;
// 过滤出所有奇数
const odd = nums.filter(isOdd);

console.log(odd);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？&quot;&gt;&lt;a href=&quot;#如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？&quot; class=&quot;headerlink&quot; title=&quot;如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？&quot;&gt;&lt;/a&gt;如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？&lt;/h2&gt;&lt;p&gt;聪明的少侠这次肯定一下就明白了：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const nums = [1,2,3,4,5,6,7,8,9,10];
const double = num =&amp;gt; num *2;
const doubleNumbers = nums.map(double);
console.log(doubleNumbers);

&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;从nums里面过滤出所有奇数，并翻倍这些奇数。&quot;&gt;&lt;a href=&quot;#从nums里面过滤出所有奇数，并翻倍这些奇数。&quot; class=&quot;headerlink&quot; title=&quot;从nums里面过滤出所有奇数，并翻倍这些奇数。&quot;&gt;&lt;/a&gt;从nums里面过滤出所有奇数，并翻倍这些奇数。&lt;/h2&gt;&lt;p&gt;这个问题也不难是吧？&lt;/p&gt;
&lt;p&gt;让我猜一下，一些少侠应该会写成下面这样：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const nums = [1,2,3,4,5,6,7,8,9,10];

const isOdd = num =&amp;gt; num % 2 !== 0;
const double = num =&amp;gt; num *2;

const doubleNums = nums.filter(isOdd).map(double);

console.log(doubleNums);
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;如果我们还想继续算出所有奇数翻倍后的和的话&quot;&gt;&lt;a href=&quot;#如果我们还想继续算出所有奇数翻倍后的和的话&quot; class=&quot;headerlink&quot; title=&quot;如果我们还想继续算出所有奇数翻倍后的和的话&quot;&gt;&lt;/a&gt;如果我们还想继续算出所有奇数翻倍后的和的话&lt;/h2&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const nums = [1,2,3,4,5,6,7,8,9,10];

const isOdd = num =&amp;gt; num % 2 !== 0;
const double = num =&amp;gt; num *2;
const add = (sum,num) =&amp;gt; sum += num;

const doubleNums = nums.filter(isOdd).map(double).reduce(add,0);

console.log(doubleNums);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;嗯，一个串一个看起来很酷是吧？ 最后的结果也是正确的。&lt;/p&gt;
&lt;p&gt;这样串起来的后果就是，我们会遍历3次数组，filter的时候遍历一次，map的时候遍历一次，reduce的时候再遍历一次。&lt;/p&gt;
&lt;p&gt;现在数组只有10个数字，影响还不大，但是如果是很大的数组，比如100万个数字，遍历3遍的话，那么就会多访问&lt;strong&gt;150万次&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;想象一下，如果让你自己从中间取出所有奇数，翻倍，并求和，你会觉得怎么做简单一些呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;是不是觉得下面这样才比较正常？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;首先，从第一个数字开始，如果它是奇数，就拿出来，翻倍，然后找个地方放起来&lt;/li&gt;
&lt;li&gt;接着，继续看第二个数字，如果是偶数，就跳过，如果是奇数，就拿出来，翻倍，然后和开始的翻倍后的奇数加起来，找个地方放起来。&lt;/li&gt;
&lt;li&gt;接着看第三个数字，以此类推，只要是奇数，就翻倍，然后和之前的结果加起来。&lt;/li&gt;
&lt;li&gt;直到我们找寻到最后一个数字，就可以算出最终结果了，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果使用迭代的话，就是下面这样:&lt;br&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Js" scheme="https://zhanghao-web.github.io/tags/Js/"/>
    
  </entry>
  
  <entry>
    <title>如何使用 vue + typescript 编写页面(1)</title>
    <link href="https://zhanghao-web.github.io/2019/07/15/Ts/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-vue-typescript-%E7%BC%96%E5%86%99%E9%A1%B5%E9%9D%A2-1/"/>
    <id>https://zhanghao-web.github.io/2019/07/15/Ts/如何使用-vue-typescript-编写页面-1/</id>
    <published>2019-07-15T09:10:33.000Z</published>
    <updated>2020-01-28T10:04:15.067Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5c662a7de51d4562e71c4277#comment" target="_blank" rel="noopener">原文地址</a></p><h1 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h1><p>使用 vue-cli 创建项目</p><p><code>vue create demo</code> ，demo就是创建项目的名称<br>提示选择预设，选择 <code>Manually select features</code> 回车确认<br>选择<code>typescript</code> <code>vuex</code>  <code>router</code> <code>babel</code> <code>css pre-processors</code>，不使用<code>linter</code>，不选单元测试有需要另说<br>回车后按照需要选择合适的选项<br>选择完毕后回车等待资源准备</p><h2 id="编码开始"><a href="#编码开始" class="headerlink" title="编码开始"></a>编码开始</h2><p>熟悉几个vue的装饰器 <code>vue-property-decorator</code></p><p>以下的装饰器的功能和原js编写的功能相同/相似，可以参照官方文档类比解读。</p><pre><code class="js">import { Vue, Component, Inject, Provide, Prop, Model, Watch, Emit, Mixins } from &#39;vue-property-decorator&#39;</code></pre><h3 id="1-Vue-实际上就是-Vue-本身-继承vue相关属性和函数"><a href="#1-Vue-实际上就是-Vue-本身-继承vue相关属性和函数" class="headerlink" title="1. Vue 实际上就是 Vue 本身,继承vue相关属性和函数"></a>1. Vue 实际上就是 Vue 本身,继承vue相关属性和函数</h3><pre><code class="js">class MyComponent extends Vue { }</code></pre><h3 id="2-Component-声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件"><a href="#2-Component-声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件" class="headerlink" title="2. @Component 声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件"></a>2. @Component 声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件</h3><p>第一种方式，不需要定义额外内容:</p><pre><code class="js">@Componentclass MyComponent extends Vue { }</code></pre><p>第二种方式，定义相关内容:</p><pre><code class="js">@Component({    /* 这里和js版本编写的 vue 组件内容相同，     * 凡是不能在ts里面完成的都可以在这里完成      * 最终会被合并到一个实例中。     * 在这里定义的内容，不会被语法器获取到，因此必须要同步在class中声明     */    data(){        return { myname:&quot;&quot;,age:18 }    }})class MyComponent extends Vue {    private myname:string;    mounted(){        this.myname;            this.age;// 语法器报错，当前类找不到age属性    }}</code></pre><h3 id="3-Provide-向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称"><a href="#3-Provide-向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称" class="headerlink" title="3.@Provide 向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称"></a>3.@Provide 向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称</h3><pre><code class="js">@Componentclass ParentComponent extends Vue {     @Provide() private info!:string;    @Provide(&quot;next&quot;) private infoNext!:string;}</code></pre><h3 id="4-Inject-获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性"><a href="#4-Inject-获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性" class="headerlink" title="4. @Inject 获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性"></a>4. @Inject 获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性</h3><pre><code class="js">@Componentclass MyComponent extends Vue {     @Inject() private info!:string;    @Inject(&quot;next&quot;) private infoNext!:string;}</code></pre><h3 id="5-Prop-由标签属性注入，获取对应标签属性上值-可配置具体prop内容，参照js版本props内容"><a href="#5-Prop-由标签属性注入，获取对应标签属性上值-可配置具体prop内容，参照js版本props内容" class="headerlink" title="5. @Prop 由标签属性注入，获取对应标签属性上值,可配置具体prop内容，参照js版本props内容"></a>5. @Prop 由标签属性注入，获取对应标签属性上值,可配置具体prop内容，参照js版本props内容</h3><pre><code class="js">@Componentclass MyComponent extends Vue {    @Prop() age!:number;   @Prop({default:1}) sex!:number;}</code></pre><pre><code class="html">&lt;template&gt;    &lt;MyComponent :age=&quot;16&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;  import MyComponent from &#39;./MyComponent.vue&#39;;@Component({    components:{ MyComponent }})class PComponent extends Vue { }&lt;/script&gt;</code></pre><a id="more"></a><h3 id="6-Model-是v-model的装饰器，当自定义组件想使用v-model时，可以使用这种方式，配合emit可以双向传递属性值"><a href="#6-Model-是v-model的装饰器，当自定义组件想使用v-model时，可以使用这种方式，配合emit可以双向传递属性值" class="headerlink" title="6. @Model 是v-model的装饰器，当自定义组件想使用v-model时，可以使用这种方式，配合emit可以双向传递属性值"></a>6. @Model 是v-model的装饰器，当自定义组件想使用v-model时，可以使用这种方式，配合emit可以双向传递属性值</h3><pre><code class="html">&lt;template&gt;    &lt;input type=&quot;checkbox&quot; :checked=&quot;checked&quot; @change=&quot;changed&quot;/&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt;@Componentclass MyComponent extends Vue {    @Model(&quot;change&quot;) checked!:number;   changed(event:any){ /* 这里是偷懒写的any，在实际项目中需要避免 */       this.$emit(&quot;change&quot;,event.target.value)   }}&lt;/script&gt;</code></pre><pre><code class="html">&lt;template&gt;    &lt;MyComponent :age=&quot;16&quot; v-model=&quot;mycheck&quot; /&gt;&lt;/template&gt;&lt;script lang=&quot;ts&quot;&gt; import MyComponent from &#39;./MyComponent.vue&#39;;@Component({    components:{ MyComponent }})class PComponent extends Vue {    private mycheck:boolean = false;}&lt;/script&gt;</code></pre><h3 id="7-Watch-观察某个属性更新"><a href="#7-Watch-观察某个属性更新" class="headerlink" title="7. @Watch 观察某个属性更新"></a>7. @Watch 观察某个属性更新</h3><pre><code class="js">@Componentclass MyComponent extends Vue {    @Prop() age!:number;   @Watch(&quot;age&quot;)   ageChange(newVal:number,oldVal:number){       /*age属性更新时，处理相关内容*/   }}</code></pre><h3 id="8-Emit-this-emit-的装饰器-如果没有指定名称，默认使用函数名称。有返回值时，使用返回值，没有则使用"><a href="#8-Emit-this-emit-的装饰器-如果没有指定名称，默认使用函数名称。有返回值时，使用返回值，没有则使用" class="headerlink" title="8. @Emit this.$emit 的装饰器,如果没有指定名称，默认使用函数名称。有返回值时，使用返回值，没有则使用"></a>8. @Emit this.$emit 的装饰器,如果没有指定名称，默认使用函数名称。有返回值时，使用返回值，没有则使用</h3><pre><code class="js">@Componentclass MyComponent extends Vue {    private myname = &quot;&quot;;   @Emit()   ageChangeA(){ /* 仅发送 this.$emit(&#39;ageChangeA&#39;) */   }   @Emit()   ageChangeB(age:number){ /* 发送 age  this.$emit(&#39;ageChangeB&#39;,age) */   }   @Emit()   ageChangeC(age:number){  return 1 /* this.$emit(&#39;ageChangeC&#39;,1) 发送return 结果*/ }}</code></pre><h3 id="9-Mixins"><a href="#9-Mixins" class="headerlink" title="9. Mixins"></a>9. Mixins</h3><pre><code class="js">// MyMixin.ts@Componentexport default class MyMixin extends Vue {    /* 如果使用private 修饰，则两个相同的 私有属性混入时，会产生冲突 */   protected myname = &quot;张三&quot;;   created(){  /* 混入对象有自己的 生命周期函数*/ }   getMyName(){ console.log(&quot;张三混入&quot;) }}</code></pre><pre><code class="js">// OtherMixin.ts@Componentexport default class OtherMixin extends Vue {    /* 如果使用private 修饰，则两个相同的 私有属性混入时，会产生冲突 */   protected myname = &quot;李四&quot;;   created(){  /* 混入对象有自己的 生命周期函数*/ }   getMyName(){ console.log(&quot;李四混入&quot;) }}</code></pre><pre><code class="js">@Componentclass MyComponent extends Mixins(MyMixin,OtherMixin) {    private myname = &quot;&quot;; /* 混入对象已经定义，这里产生属性冲突 */   mounted(){       this.getMyName() // 李四混入   }}</code></pre><h3 id="对于computed，使用-get-替代"><a href="#对于computed，使用-get-替代" class="headerlink" title="对于computed，使用 get 替代"></a>对于computed，使用 get 替代</h3><pre><code class="js">@Componentclass MyComponent extends Vue {    private myname = &quot;&quot;; /* 混入对象已经定义，这里产生属性冲突 */   get upperName(){       return &quot;A&quot; + this.myname   }}</code></pre><p><strong>装饰器可以参照 <a href="https://link.juejin.im/?target=http%3A%2F%2Fnpm.taobao.org%2Fpackage%2Fvue-property-decorator">vue-property-decorator</a></strong></p><ul><li>没有filters,没有指令相关装饰器，有需要可以在@Component里面补充，或者可以直接定义函数调用计算返回值 在class里定义的属性即data属性，需要赋值初始值。</li></ul><h2 id="typescript-混用js"><a href="#typescript-混用js" class="headerlink" title="typescript 混用js"></a>typescript 混用js</h2><p>当我们引用了一个js编写的模块时会报错，这时候，如果不在引入的index文件里面添加.d.ts描述文件，那么这个模块就没法在语义上一致通过.</p><h3 id="通用兼容性解决方案"><a href="#通用兼容性解决方案" class="headerlink" title="通用兼容性解决方案"></a>通用兼容性解决方案</h3><p>如果这个模块是由npm下载的，并且有@types版本，可以直接使用<code>npm install @types/xx</code>下载</p><p>可惜,大部分都是没有编写声明文件的.但是又需要使用到这个模块时,应该怎么做.</p><p><strong>自定义描述文件</strong></p><p>在项目的【根目录】下定义【模块相同的名称】的描述文件A.d.ts,在描述文件内编写模块声明描述</p><pre><code class="js">// A.d.tsdeclare module &#39;*&#39;;</code></pre><p>这样属于一劳永逸的描述,但是无法描述到具体模块内容,因此这种方式仅仅引入的组件没有任何操作时,比如引入的是第三方开发的vue组件,可以用这种方式偷懒.</p><p><strong>详细描述文件</strong></p><pre><code class="js">// A.d.tsdeclare module  &quot;A&quot; {    // 添加具体的描述内容};</code></pre><p>可以从这里查询到<a href="http://microsoft.github.io/TypeSearch/" target="_blank" rel="noopener">@type</a>包查询，已经被编写的文件声明可以直接下载</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5c662a7de51d4562e71c4277#comment&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;起步&quot;&gt;&lt;a href=&quot;#起步&quot; class=&quot;headerlink&quot; title=&quot;起步&quot;&gt;&lt;/a&gt;起步&lt;/h1&gt;&lt;p&gt;使用 vue-cli 创建项目&lt;/p&gt;
&lt;p&gt;&lt;code&gt;vue create demo&lt;/code&gt; ，demo就是创建项目的名称&lt;br&gt;提示选择预设，选择 &lt;code&gt;Manually select features&lt;/code&gt; 回车确认&lt;br&gt;选择&lt;code&gt;typescript&lt;/code&gt; &lt;code&gt;vuex&lt;/code&gt;  &lt;code&gt;router&lt;/code&gt; &lt;code&gt;babel&lt;/code&gt; &lt;code&gt;css pre-processors&lt;/code&gt;，不使用&lt;code&gt;linter&lt;/code&gt;，不选单元测试有需要另说&lt;br&gt;回车后按照需要选择合适的选项&lt;br&gt;选择完毕后回车等待资源准备&lt;/p&gt;
&lt;h2 id=&quot;编码开始&quot;&gt;&lt;a href=&quot;#编码开始&quot; class=&quot;headerlink&quot; title=&quot;编码开始&quot;&gt;&lt;/a&gt;编码开始&lt;/h2&gt;&lt;p&gt;熟悉几个vue的装饰器 &lt;code&gt;vue-property-decorator&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以下的装饰器的功能和原js编写的功能相同/相似，可以参照官方文档类比解读。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { Vue, Component, Inject, Provide, Prop, Model, Watch, Emit, Mixins } from &amp;#39;vue-property-decorator&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;1-Vue-实际上就是-Vue-本身-继承vue相关属性和函数&quot;&gt;&lt;a href=&quot;#1-Vue-实际上就是-Vue-本身-继承vue相关属性和函数&quot; class=&quot;headerlink&quot; title=&quot;1. Vue 实际上就是 Vue 本身,继承vue相关属性和函数&quot;&gt;&lt;/a&gt;1. Vue 实际上就是 Vue 本身,继承vue相关属性和函数&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;class MyComponent extends Vue { }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;2-Component-声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件&quot;&gt;&lt;a href=&quot;#2-Component-声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件&quot; class=&quot;headerlink&quot; title=&quot;2. @Component 声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件&quot;&gt;&lt;/a&gt;2. @Component 声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件&lt;/h3&gt;&lt;p&gt;第一种方式，不需要定义额外内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;@Component
class MyComponent extends Vue { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;第二种方式，定义相关内容:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;@Component({
    /* 这里和js版本编写的 vue 组件内容相同，
     * 凡是不能在ts里面完成的都可以在这里完成 
     * 最终会被合并到一个实例中。
     * 在这里定义的内容，不会被语法器获取到，因此必须要同步在class中声明
     */
    data(){
        return { myname:&amp;quot;&amp;quot;,age:18 }
    }
})
class MyComponent extends Vue {
    private myname:string;
    mounted(){
        this.myname;    
        this.age;// 语法器报错，当前类找不到age属性
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;3-Provide-向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称&quot;&gt;&lt;a href=&quot;#3-Provide-向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称&quot; class=&quot;headerlink&quot; title=&quot;3.@Provide 向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称&quot;&gt;&lt;/a&gt;3.@Provide 向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;@Component
class ParentComponent extends Vue { 
    @Provide() private info!:string;
    @Provide(&amp;quot;next&amp;quot;) private infoNext!:string;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;4-Inject-获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性&quot;&gt;&lt;a href=&quot;#4-Inject-获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性&quot; class=&quot;headerlink&quot; title=&quot;4. @Inject 获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性&quot;&gt;&lt;/a&gt;4. @Inject 获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;@Component
class MyComponent extends Vue { 
    @Inject() private info!:string;
    @Inject(&amp;quot;next&amp;quot;) private infoNext!:string;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id=&quot;5-Prop-由标签属性注入，获取对应标签属性上值-可配置具体prop内容，参照js版本props内容&quot;&gt;&lt;a href=&quot;#5-Prop-由标签属性注入，获取对应标签属性上值-可配置具体prop内容，参照js版本props内容&quot; class=&quot;headerlink&quot; title=&quot;5. @Prop 由标签属性注入，获取对应标签属性上值,可配置具体prop内容，参照js版本props内容&quot;&gt;&lt;/a&gt;5. @Prop 由标签属性注入，获取对应标签属性上值,可配置具体prop内容，参照js版本props内容&lt;/h3&gt;&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;@Component
class MyComponent extends Vue { 
   @Prop() age!:number;
   @Prop({default:1}) sex!:number;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;template&amp;gt;
    &amp;lt;MyComponent :age=&amp;quot;16&amp;quot; /&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script lang=&amp;quot;ts&amp;quot;&amp;gt;  
import MyComponent from &amp;#39;./MyComponent.vue&amp;#39;;

@Component({
    components:{ MyComponent }
})
class PComponent extends Vue { }
&amp;lt;/script&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 的好处都有啥？和 JavaScript 的区别在哪？</title>
    <link href="https://zhanghao-web.github.io/2019/07/04/Ts/TypeScript-%E7%9A%84%E5%A5%BD%E5%A4%84%E9%83%BD%E6%9C%89%E5%95%A5%EF%BC%9F%E5%92%8C-JavaScript-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F/"/>
    <id>https://zhanghao-web.github.io/2019/07/04/Ts/TypeScript-的好处都有啥？和-JavaScript-的区别在哪？/</id>
    <published>2019-07-04T08:13:53.000Z</published>
    <updated>2020-01-28T10:04:15.066Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://zhuanlan.zhihu.com/p/38526585" target="_blank" rel="noopener">原文地址</a></p><p><strong>在我看来 TypeScript 相对于 JavaScript ，除了静态类型外没带来任何东西。</strong></p><p>既然如此</p><h2 id="静态类型有什么好处"><a href="#静态类型有什么好处" class="headerlink" title="静态类型有什么好处"></a>静态类型有什么好处</h2><p>静态类型的好处到处都有说，这里就不说得太详细了，随便列一点。</p><ul><li>杜绝手误导致的变量名错误</li><li>自动完成</li><li>重构支持</li><li>类型可以一定程度上充当文档</li></ul><p>静态类型解放脑容量，自动完成让我不需要记忆哪个变量里有哪些属性，也不需要记完整的变量名。</p><p>函数上的类型约束外加尽量主动写纯函数让我在写函数实现的时候不需要关注函数之外的任何东西，注意力聚焦在当前函数。</p><p>当然，也不只有好处。</p><h2 id="静态类型有什么不足"><a href="#静态类型有什么不足" class="headerlink" title="静态类型有什么不足"></a>静态类型有什么不足</h2><ul><li>类型标注麻烦。</li><li>现阶段大部分静态类型语言的类型系统还不够强。</li><li>eval 和 new Function() 这种骚操作类型系统管不到。</li><li>需要编译，类型检查会增加编译时长，语法和类型系统复杂的话时间特别特别长，比如 scala。</li></ul><p>标注麻烦的问题无法根绝，但是类型推导能解决大部分的类型标注问题。</p><p>类型系统不够强的问题会随着时间慢慢变好。</p><p>编译的问题在 ts 可能也并不算问题，ts 的类型检查并不影响 ts 编译成 js。</p><p>也就是说就算类型检查不通过 ts 也能跑起来。所以对 ts 来说类型检查可以从编译中提取出来，作为独立的编译和类型检查两部分。</p><p>先编译输出，再做类型检查，编译的部分相当于 babel 这种工具做的事。</p><p>类型检查也可以单独运行。</p><p>那么，</p><h2 id="TypeScript-的类型系统有哪些特点？"><a href="#TypeScript-的类型系统有哪些特点？" class="headerlink" title="TypeScript 的类型系统有哪些特点？"></a>TypeScript 的类型系统有哪些特点？</h2><ul><li><a href="https://link.zhihu.com/?target=https%3A//github.com/Microsoft/TypeScript/issues/14833">图灵完备</a>。（虽然不太清楚这意味着什么）</li><li>渐进的类型系统，所有类型标注都是可选的，既是天使又是恶魔的 <a href="https://link.zhihu.com/?target=https%3A//github.com/Microsoft/TypeScript/blob/master/doc/spec.md%233.1">any</a> 类型。（被 Haskell 大牛 <a href="https://www.zhihu.com/people/axurez" target="_blank" rel="noopener">Colliot</a> 称为 ts 类型系统的漏洞）</li><li>支持局部类型推导。</li><li>丰富的类型层面的计算，如 <a href="https://link.zhihu.com/?target=https%3A//www.typescriptlang.org/docs/handbook/advanced-types.html">index types, mapped types, conditional types</a> 等等。</li><li>支持<a href="">鸭子类型</a>。（或叫结构子类型？）</li><li>像 js 支持对象字面量一样支持方便的对象字面类型（object literal type），字符串和数字还有布尔值字面类型。</li><li>空安全。</li><li>基于控制流的类型分析</li></ul><p>还有许多我觉得比较平常的点就没有列出来，比如支持类型别名，泛型，协变逆变双变等等。</p><p>ts 是一门非常非常非常工程的语言，很强大，但是可能和优雅沾不上半点关系。</p><p>可选的类型标注搭配类型推导，让 ts 的类型系统更像是工具，而不是枷锁。好的产品是用完即走的。</p><p>有时候，稍微开个洞，能让事情变简单很多。比如 any。</p><p><code>鸭子类型</code>加上上面提到的特性可以让你依旧感觉和 js 一样，像大海里的鱼一样自由。</p><p><a href="https://link.zhihu.com/?target=https%3A//www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare">Null References: The Billion Dollar Mistake</a> ，而 js 里有两个 null（null 和 undefined），虽然前端通常不会造成非常严重的损失，但是 js 也慢慢被应用到不仅仅是前端的许多地方了。</p><p>ts 这么好，</p><h2 id="怎么学-TypeScript？"><a href="#怎么学-TypeScript？" class="headerlink" title="怎么学 TypeScript？"></a>怎么学 TypeScript？</h2><p>成也渐进，败也渐进，有部分人通过可选的类型标注，一步一步无痛地过渡到学会 ts。</p><p>而另一部分人玩了一会儿，发现和写 js 并没有一丁点区别，而且还离开了熟悉的环境，就放弃了。</p><p>ts 并不会强迫你使用类型，所以就需要更强的动力来推动自己学习。</p><p>如果身边有会 ts 的朋友的话，对学习 ts 会比较有帮助。</p><p>多让会 ts 的朋友看自己的代码，改良自己的写法。多写，很容易就能学会。</p><p>如果身边没有会 ts 的人，其实我更建议先用 <a href="https://github.com/Microsoft/TypeScript/wiki/JSDoc-support-in-JavaScript" target="_blank" rel="noopener">JSDoc</a>。</p><p>使用 vscode 或者 webstorm 的时候直接写 JSDoc 就行了，vsc 或 webstorm 会依靠 ts 来提供类型推导和自动完成。</p><p>这样可以在工作或自己写东西的时候慢慢习惯并且主动去使用类型标注。</p><p>在使用一段时间后感觉 JSDoc 已经不够用了，满足不了自己的需求了，再开始使用 ts。</p><p>同时也要多主动去了解和学习一些 ts 的代码，不然的话，不知道 ts 有多好，自然就不会觉得 JSDoc 不够用。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/38526585&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在我看来 TypeScript 相对于 JavaScript ，除了
      
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>vue中不常用的API的使用方法总结</title>
    <link href="https://zhanghao-web.github.io/2019/06/13/Vue/vue%E4%B8%AD%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84API%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zhanghao-web.github.io/2019/06/13/Vue/vue中不常用的API的使用方法总结/</id>
    <published>2019-06-13T05:46:23.000Z</published>
    <updated>2020-01-28T10:04:15.070Z</updated>
    
    <content type="html"><![CDATA[<h2 id="errorHandler"><a href="#errorHandler" class="headerlink" title="errorHandler"></a>errorHandler</h2><p>官网介绍及使用：</p><p>指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例</p><pre><code class="js">Vue.config.errorHandler = function (err, vm, info) {  //处理错误信息, 进行错误上报  //err错误对象  //vm Vue实例  //`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子  //只在 2.2.0+ 可用}</code></pre><h2 id="Vue-observable-object"><a href="#Vue-observable-object" class="headerlink" title="Vue.observable( object )"></a>Vue.observable( object )</h2><p>这个相当于一个简单的store管理，在不用vuex的情况下，不同组件之间通信可以用<code>Vue.observeable</code></p><p>官网介绍：</p><p>让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。</p><p>返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：</p><p>使用：</p><p>在store.js中</p><pre><code class="js">impor vue from &#39;vue&#39;;export const store = vue.observable({count:0});export const mutation = {    setCount(count){        store.count = count;    }}</code></pre><p>在组件中使用</p><pre><code class="js">&lt;template&gt;  &lt;div class=&quot;hello&quot;&gt;    &lt;p @click=&quot;setCount(testCount + 1)&quot;&gt;+&lt;/p&gt;    &lt;p @click=&quot;setCount(testCount - 1)&quot;&gt;-&lt;/p&gt;    &lt;test /&gt;    &lt;p&gt;{{testCount}}&lt;/p&gt;  &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import test from &#39;./test&#39;import { store,  mutation} from &#39;@/store&#39;export default {  name: &#39;HelloWorld&#39;,  data () {    return {      msg: &#39;Welcome to Your Vue.js App&#39;    }  },  components: {    test  },  methods: {    setCount: mutation.setCount  },  computed: {    testCount(){      return store.count    }  }}&lt;/script&gt;&lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt;&lt;style scoped&gt;h1, h2 {  font-weight: normal;}ul {  list-style-type: none;  padding: 0;}li {  display: inline-block;  margin: 0 10px;}a {  color: #42b983;}&lt;/style&gt;</code></pre><a id="more"></a><p>test 组件</p><pre><code class="js">&lt;template&gt;  &lt;div&gt;test{{testCount}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt;import { store } from &#39;@/store&#39;;export default {  computed: {    testCount(){      return store.count    }  }}&lt;/script&gt;&lt;style scoped&gt;&lt;/style&gt;</code></pre><h1 id="errorCaptured-2-5-0新增的生命周期钩子"><a href="#errorCaptured-2-5-0新增的生命周期钩子" class="headerlink" title="errorCaptured(2.5.0新增的生命周期钩子)"></a>errorCaptured(2.5.0新增的生命周期钩子)</h1><p>官网介绍：</p><p>当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。</p><p>与errorhandler的不同之处：</p><p>errorCaptured 和 errorHandler 的触发时机都是相同的，不同的是 errorCaptured 发生在前，且如果某个组件的 errorCaptured 方法返回了 false，那么这个异常信息不会再向上冒泡也不会再调用 errorHandler 方法</p><h1 id="parent"><a href="#parent" class="headerlink" title="parent"></a>parent</h1><p>官网介绍：</p><p>指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。</p><p>注意:节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信</p><p>使用:</p><pre><code class="js">    this.$parent.xxx() //直接在子组件调用父组件中方法</code></pre><h1 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h1><p>官网介绍：</p><p>mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。</p><p>mixins就是定义一部分公共的方法或者计算属性,然后混入到各个组件中使用,方便管理与统一修改</p><p>1、在assets文件夹下创建一个js文件</p><pre><code class="js">// 创建一个需要混入的对象 export const mixinTest1 = {    created() {        this.hello();    },    methods: {        hello() {            console.log(&#39;mixinTest1&#39;);        }    }};</code></pre><p>2、在组件中使用刚刚创建的混入</p><pre><code class="js">import {mixinTest1} from &#39;./../assets/js/mixin&#39;;export default {    mixins:[mixinTest1],    name: &#39;hello&#39;,    data () {        return {            msg: &#39;Welcome to Your Vue.js App&#39;        }    }}</code></pre><p>3、如果组件中定义的方法与混入对象中的方法/属性一样,组件中的优先级大于混入对象中的(方法会调用多次)</p><p>4、混入对象中可以定义抽象方法,使用混入的组件必须重写该方法</p><pre><code class="js">...methods: {    handlePlaylist() {        throw new Error(&#39;component must implement handlePlaylist method&#39;)    }}...</code></pre><h1 id="provide-inject"><a href="#provide-inject" class="headerlink" title="provide / inject"></a>provide / inject</h1><p>官网介绍：</p><p>这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。</p><p>provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。</p><p>inject 选项应该是：</p><p>一个字符串数组，或<br>一个对象，对象的 key 是本地的绑定名，value 是：<br>在可用的注入内容中搜索用的 key (字符串或 Symbol)，或<br>一个对象，该对象的：<br>from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)<br>default 属性是降级情况下使用的 value</p><ul><li>注意：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。</li></ul><p>我之前使用到<code>provide / inject</code>是<strong>模拟页面数据回到初始状态</strong>，相当于刷新当前页面，但是直接刷新当前页面会有几秒的空白期，体验不好，所以用到了<code>provide / inject</code></p><p>使用方法：</p><p>1.修改App.vue代码如下图所示</p><pre><code class="js">&lt;template&gt;    &lt;div id=&quot;app&quot;&gt;        &lt;router-view v-if=&quot;isRouterActive&quot;/&gt;    &lt;/div&gt;&lt;/template&gt;&lt;script&gt;    export default{        name: &#39;App&#39;,        provide:{            retrun{                reload:this.reload            }        },        data(){            return{                isRouterActive: true            }        },        methods:{            reload(){                this.isRouterActive = false;                this.$nextTick(()=&gt;{                     this.isRouterActive = true;                })            }        }    }&lt;/script&gt;</code></pre><p>通过声明reload方法，控制isRouterAlice属性true or false 来控制router-view的显示或隐藏，从而控制页面的再次加载</p><p>2.在需要当前页面刷新的页面中注入App.vue组件提供（provide）的 reload 依赖，然后直接用this.reload来调用就行</p><pre><code class="js">export defalut{    inject:[&#39;reload&#39;],    data(){        return{        }    },    methods:{        reloadPage(){            this.reload();        }    }}</code></pre><h1 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h1><p>官网介绍：</p><p><code>&lt;keep-alive&gt;</code> 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 <code>&lt;transition&gt;</code> 相似，<code>&lt;keep-alive&gt;</code> 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</p><p>当组件在 <code>&lt;keep-alive&gt;</code> 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;errorHandler&quot;&gt;&lt;a href=&quot;#errorHandler&quot; class=&quot;headerlink&quot; title=&quot;errorHandler&quot;&gt;&lt;/a&gt;errorHandler&lt;/h2&gt;&lt;p&gt;官网介绍及使用：&lt;/p&gt;
&lt;p&gt;指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;Vue.config.errorHandler = function (err, vm, info) {
  //处理错误信息, 进行错误上报
  //err错误对象
  //vm Vue实例
  //`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
  //只在 2.2.0+ 可用
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;Vue-observable-object&quot;&gt;&lt;a href=&quot;#Vue-observable-object&quot; class=&quot;headerlink&quot; title=&quot;Vue.observable( object )&quot;&gt;&lt;/a&gt;Vue.observable( object )&lt;/h2&gt;&lt;p&gt;这个相当于一个简单的store管理，在不用vuex的情况下，不同组件之间通信可以用&lt;code&gt;Vue.observeable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;官网介绍：&lt;/p&gt;
&lt;p&gt;让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。&lt;/p&gt;
&lt;p&gt;返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景：&lt;/p&gt;
&lt;p&gt;使用：&lt;/p&gt;
&lt;p&gt;在store.js中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;impor vue from &amp;#39;vue&amp;#39;;
export const store = vue.observable({count:0});
export const mutation = {
    setCount(count){
        store.count = count;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在组件中使用&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;template&amp;gt;
  &amp;lt;div class=&amp;quot;hello&amp;quot;&amp;gt;
    &amp;lt;p @click=&amp;quot;setCount(testCount + 1)&amp;quot;&amp;gt;+&amp;lt;/p&amp;gt;
    &amp;lt;p @click=&amp;quot;setCount(testCount - 1)&amp;quot;&amp;gt;-&amp;lt;/p&amp;gt;
    &amp;lt;test /&amp;gt;
    &amp;lt;p&amp;gt;{{testCount}}&amp;lt;/p&amp;gt;
  &amp;lt;/div&amp;gt;
&amp;lt;/template&amp;gt;

&amp;lt;script&amp;gt;
import test from &amp;#39;./test&amp;#39;
import { store,  mutation} from &amp;#39;@/store&amp;#39;
export default {
  name: &amp;#39;HelloWorld&amp;#39;,
  data () {
    return {
      msg: &amp;#39;Welcome to Your Vue.js App&amp;#39;
    }
  },
  components: {
    test
  },
  methods: {
    setCount: mutation.setCount
  },
  computed: {
    testCount(){
      return store.count
    }
  }
}
&amp;lt;/script&amp;gt;

&amp;lt;!-- Add &amp;quot;scoped&amp;quot; attribute to limit CSS to this component only --&amp;gt;
&amp;lt;style scoped&amp;gt;
h1, h2 {
  font-weight: normal;
}
ul {
  list-style-type: none;
  padding: 0;
}
li {
  display: inline-block;
  margin: 0 10px;
}
a {
  color: #42b983;
}
&amp;lt;/style&amp;gt;

&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/categories/Vue/"/>
    
    
      <category term="Vue" scheme="https://zhanghao-web.github.io/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>TypeScript 高级技巧</title>
    <link href="https://zhanghao-web.github.io/2019/06/12/Ts/TypeScript-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    <id>https://zhanghao-web.github.io/2019/06/12/Ts/TypeScript-高级技巧/</id>
    <published>2019-06-12T08:10:54.000Z</published>
    <updated>2020-01-28T10:04:15.066Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.im/post/5cffb431f265da1b7401f466?utm_source=gold_browser_extension" target="_blank" rel="noopener">原文地址</a></p><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>用了一段时间的 typescript 之后，深感中大型项目中 typescript 的必要性，它能够提前在编译期避免许多 bug，如很恶心的拼写问题。而越来越多的 package 也开始使用 ts，学习 ts 已是势在必行。</p><h2 id="01-keyof"><a href="#01-keyof" class="headerlink" title="01 keyof"></a>01 keyof</h2><p><code>keyof</code> 与 <code>Object.keys</code> 略有相似，只不过 <code>keyof</code> 取 <code>interface</code> 的键。</p><pre><code class="js">interface Point {    x: number;    y: number;}// type keys = &quot;x&quot; | &quot;y&quot;type keys = keyof Point;</code></pre><p>假设有一个 <code>object</code> 如下所示，我们需要使用 typescript 实现一个 get 函数来获取它的属性值</p><pre><code class="js">const data = {  a: 3,  hello: &#39;world&#39;}function get(o: object, name: string) {  return o[name]}</code></pre><p>我们刚开始可能会这么写，不过它有很多缺点<br>1.无法确认返回类型：这将损失 ts 最大的类型校验功能<br>2.无法对 key 做约束：可能会犯拼写错误的问题</p><p>这时可以使用 <code>keyof</code> 来加强 <code>get</code> 函数的类型功能，有兴趣的同学可以看看 <code>_.get</code> 的 <code>type</code> 标记以及实现</p><pre><code class="js">function get&lt;T extends object, K extends keyof T&gt;(o: T, name: K): T[K] {  return o[name]}</code></pre><h2 id="02-Partial-amp-Pick"><a href="#02-Partial-amp-Pick" class="headerlink" title="02 Partial &amp; Pick"></a>02 Partial &amp; Pick</h2><p>既然了解了 <code>keyof</code>，可以使用它对属性做一些扩展， 如实现 <code>Partial</code> 和 <code>Pick</code>，<code>Pick</code> 一般用在 <code>_.pick</code> 中</p><pre><code class="js">type Partial&lt;T&gt; = {  [P in keyof T]?: T[P];};type Pick&lt;T, K extends keyof T&gt; = {  [P in K]: T[P];};interface User {  id: number;  age: number;  name: string;};// 相当于: type PartialUser = { id?: number; age?: number; name?: string; }type PartialUser = Partial&lt;User&gt;// 相当于: type PickUser = { id: number; age: number; }type PickUser = Pick&lt;User, &quot;id&quot; | &quot;age&quot;&gt;</code></pre><h2 id="03-Condition-Type"><a href="#03-Condition-Type" class="headerlink" title="03 Condition Type"></a>03 Condition Type</h2><p>类似于 js 中的 <code>?:</code> 运算符，可以使用它扩展一些基本类型</p><pre><code class="js">T extends U ? X : Ytype isTrue&lt;T&gt; = T extends true ? true : false// 相当于 type t = falsetype t = isTrue&lt;number&gt;// 相当于 type t = falsetype t1 = isTrue&lt;false&gt;</code></pre><h2 id="04-never-amp-Exclude-amp-Omit"><a href="#04-never-amp-Exclude-amp-Omit" class="headerlink" title="04 never &amp; Exclude &amp; Omit"></a>04 never &amp; Exclude &amp; Omit</h2><p>官方文档对 <code>never</code> 的描述如下</p><blockquote><p>the never type represents the type of values that never occur.</p></blockquote><p>结合 <code>never</code> 与 <code>conditional type</code> 可以推出很多有意思而且实用的类型，比如 <code>Omit</code></p><pre><code class="js">type Exclude&lt;T, U&gt; = T extends U ? never : T;// 相当于: type A = &#39;a&#39;type A = Exclude&lt;&#39;x&#39; | &#39;a&#39;, &#39;x&#39; | &#39;y&#39; | &#39;z&#39;&gt;</code></pre><a id="more"></a><p>结合 <code>Exclude</code> 可以推出 <code>Omit</code> 的写法</p><pre><code class="js">type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;interface User {  id: number;  age: number;  name: string;};// 相当于: type PickUser = { age: number; name: string; }type OmitUser = Omit&lt;User, &quot;id&quot;&gt;</code></pre><h2 id="05-typeof"><a href="#05-typeof" class="headerlink" title="05 typeof"></a>05 typeof</h2><p>顾名思义，<code>typeof</code> 代表取某个值的 <code>type</code>，可以从以下示例来展示他们的用法</p><pre><code class="js">const a: number = 3// 相当于: const b: number = 4const b: typeof a = 4</code></pre><p>在一个典型的服务端项目中，我们经常需要把一些工具塞到 <code>context</code> 中，如<code>config</code>，<code>logger</code>，<code>db models</code>, <code>utils</code> 等，此时就使用到 <code>typeof</code>。</p><pre><code class="js">import logger from &#39;./logger&#39;import utils from &#39;./utils&#39;interface Context extends KoaContect {  logger: typeof logger,  utils: typeof utils}app.use((ctx: Context) =&gt; {  ctx.logger.info(&#39;hello, world&#39;)  // 会报错，因为 logger.ts 中没有暴露此方法，可以最大限度的避免拼写错误  ctx.loger.info(&#39;hello, world&#39;)})</code></pre><h2 id="06-is"><a href="#06-is" class="headerlink" title="06 is"></a>06 is</h2><p>在此之前，先看一个 koa 的错误处理流程，以下是对 error 进行集中处理，并且标识 code 的过程</p><pre><code class="js">app.use(async (ctx, next) =&gt; {  try {    await next();  } catch (err) {    let code = &#39;BAD_REQUEST&#39;    if (err.isAxiosError) {      code = `Axios-${err.code}`    } else if (err instanceof Sequelize.BaseError) {    }    ctx.body = {      code    }  }})</code></pre><p>在 <code>err.code</code> 处，会编译出错，提示 Property ‘code’ does not exist on type ‘Error’.ts(2339)。</p><p>此时可以使用 <code>as AxiosError</code> 或者 <code>as any</code> 来避免报错，不过强制类型转换也不够友好</p><pre><code class="js">if ((err as AxiosError).isAxiosError) {  code = `Axios-${(err as AxiosError).code}`}</code></pre><p>此时可以使用 is 来判定值的类型</p><pre><code class="js">function isAxiosError (error: any): error is AxiosError {  return error.isAxiosError}if (isAxiosError(err)) {  code = `Axios-${err.code}`}</code></pre><p>在 <code>GraphQL</code> 的源码中，有很多诸如此类的用法，用以标识类型</p><pre><code class="js">export function isType(type: any): type is GraphQLType;export function isScalarType(type: any): type is GraphQLScalarType;export function isObjectType(type: any): type is GraphQLObjectType;export function isInterfaceType(type: any): type is GraphQLInterfaceType;</code></pre><h2 id="07-interface-amp-type"><a href="#07-interface-amp-type" class="headerlink" title="07 interface &amp; type"></a>07 interface &amp; type</h2><p>interface 与 type 的区别是什么？可以参考以下 stackoverflow 的问题</p><p><a href="https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types" target="_blank" rel="noopener">https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types</a></p><p>一般来说，<code>1</code>interface<code>与</code>type` 区别很小，比如以下两种写法差不多</p><pre><code class="js">interface A {  a: number;  b: number;};type B {  a: number;  b: number;}</code></pre><p>其中 interface 可以如下合并多个，而 type 只能使用 &amp; 类进行连接。</p><pre><code class="js">interface A {    a: number;}interface A {    b: number;}const a: A = {    a: 3,    b: 4}</code></pre><h2 id="08-Dictionary-amp-Many"><a href="#08-Dictionary-amp-Many" class="headerlink" title="08 Dictionary &amp; Many"></a>08 Dictionary &amp; Many</h2><p>这几个语法糖是从 <code>lodash</code> 的 <code>types</code> 源码中学到的，平时工作中的使用频率还挺高。</p><pre><code class="js">interface Dictionary&lt;T&gt; {  [index: string]: T;};interface NumericDictionary&lt;T&gt; {  [index: number]: T;};const data:Dictionary&lt;number&gt; = {  a: 3,  b: 4}</code></pre><h2 id="09-使用-const-enum-维护常量表"><a href="#09-使用-const-enum-维护常量表" class="headerlink" title="09 使用 const enum 维护常量表"></a>09 使用 const enum 维护常量表</h2><p>相比使用字面量对象维护常量，const enum 可以提供更安全的类型检查</p><pre><code class="js">// 使用 object 维护常量const enum TODO_STATUS {    TODO = &#39;TODO&#39;,    DONE = &#39;DONE&#39;,    DOING = &#39;DOING&#39;}</code></pre><pre><code class="js">// 使用 const enum 伟华常量const enum TODO_STATUS {    TODO = &#39;TODO&#39;,    DONE = &#39;DONE&#39;,    DOING = &#39;DOING&#39;}function todos (status: TODO_STATUS): Todo[];todos(TODO_STATUS.TODO)</code></pre><h2 id="10-VS-Code-Tips-amp-Typescript-Command"><a href="#10-VS-Code-Tips-amp-Typescript-Command" class="headerlink" title="10 VS Code Tips &amp; Typescript Command"></a>10 VS Code Tips &amp; Typescript Command</h2><p>使用 VS Code 有时会出现，使用 tsc 编译时产生的问题与 vs code 提示的问题不一致</p><p>找到项目右下角的 Typescript 字样，右侧显示它的版本号，可以点击选择 Use Workspace Version，它表示与项目依赖的 typescript 版本一直。</p><p>或者编辑 <code>.vs-code/settings.json</code></p><pre><code class="js">{  &quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot;}</code></pre><h2 id="11-Typescript-Roadmap"><a href="#11-Typescript-Roadmap" class="headerlink" title="11 Typescript Roadmap"></a>11 Typescript Roadmap</h2><p>最后一条也是最重要的一条，翻阅 Roadmap，了解 ts 的一些新的特性与 bug 修复情况。</p><p><a href="https://github.com/Microsoft/TypeScript/wiki/Roadmap" target="_blank" rel="noopener">Typescript Roadmap</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.im/post/5cffb431f265da1b7401f466?utm_source=gold_browser_extension&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;用了一段时间的 typescript 之后，深感中大型项目中 typescript 的必要性，它能够提前在编译期避免许多 bug，如很恶心的拼写问题。而越来越多的 package 也开始使用 ts，学习 ts 已是势在必行。&lt;/p&gt;
&lt;h2 id=&quot;01-keyof&quot;&gt;&lt;a href=&quot;#01-keyof&quot; class=&quot;headerlink&quot; title=&quot;01 keyof&quot;&gt;&lt;/a&gt;01 keyof&lt;/h2&gt;&lt;p&gt;&lt;code&gt;keyof&lt;/code&gt; 与 &lt;code&gt;Object.keys&lt;/code&gt; 略有相似，只不过 &lt;code&gt;keyof&lt;/code&gt; 取 &lt;code&gt;interface&lt;/code&gt; 的键。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;interface Point {
    x: number;
    y: number;
}

// type keys = &amp;quot;x&amp;quot; | &amp;quot;y&amp;quot;
type keys = keyof Point;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;假设有一个 &lt;code&gt;object&lt;/code&gt; 如下所示，我们需要使用 typescript 实现一个 get 函数来获取它的属性值&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const data = {
  a: 3,
  hello: &amp;#39;world&amp;#39;
}

function get(o: object, name: string) {
  return o[name]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们刚开始可能会这么写，不过它有很多缺点&lt;br&gt;1.无法确认返回类型：这将损失 ts 最大的类型校验功能&lt;br&gt;2.无法对 key 做约束：可能会犯拼写错误的问题&lt;/p&gt;
&lt;p&gt;这时可以使用 &lt;code&gt;keyof&lt;/code&gt; 来加强 &lt;code&gt;get&lt;/code&gt; 函数的类型功能，有兴趣的同学可以看看 &lt;code&gt;_.get&lt;/code&gt; 的 &lt;code&gt;type&lt;/code&gt; 标记以及实现&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function get&amp;lt;T extends object, K extends keyof T&amp;gt;(o: T, name: K): T[K] {
  return o[name]
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;02-Partial-amp-Pick&quot;&gt;&lt;a href=&quot;#02-Partial-amp-Pick&quot; class=&quot;headerlink&quot; title=&quot;02 Partial &amp;amp; Pick&quot;&gt;&lt;/a&gt;02 Partial &amp;amp; Pick&lt;/h2&gt;&lt;p&gt;既然了解了 &lt;code&gt;keyof&lt;/code&gt;，可以使用它对属性做一些扩展， 如实现 &lt;code&gt;Partial&lt;/code&gt; 和 &lt;code&gt;Pick&lt;/code&gt;，&lt;code&gt;Pick&lt;/code&gt; 一般用在 &lt;code&gt;_.pick&lt;/code&gt; 中&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;type Partial&amp;lt;T&amp;gt; = {
  [P in keyof T]?: T[P];
};

type Pick&amp;lt;T, K extends keyof T&amp;gt; = {
  [P in K]: T[P];
};

interface User {
  id: number;
  age: number;
  name: string;
};

// 相当于: type PartialUser = { id?: number; age?: number; name?: string; }
type PartialUser = Partial&amp;lt;User&amp;gt;

// 相当于: type PickUser = { id: number; age: number; }
type PickUser = Pick&amp;lt;User, &amp;quot;id&amp;quot; | &amp;quot;age&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;03-Condition-Type&quot;&gt;&lt;a href=&quot;#03-Condition-Type&quot; class=&quot;headerlink&quot; title=&quot;03 Condition Type&quot;&gt;&lt;/a&gt;03 Condition Type&lt;/h2&gt;&lt;p&gt;类似于 js 中的 &lt;code&gt;?:&lt;/code&gt; 运算符，可以使用它扩展一些基本类型&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;T extends U ? X : Y

type isTrue&amp;lt;T&amp;gt; = T extends true ? true : false
// 相当于 type t = false
type t = isTrue&amp;lt;number&amp;gt;

// 相当于 type t = false
type t1 = isTrue&amp;lt;false&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;04-never-amp-Exclude-amp-Omit&quot;&gt;&lt;a href=&quot;#04-never-amp-Exclude-amp-Omit&quot; class=&quot;headerlink&quot; title=&quot;04 never &amp;amp; Exclude &amp;amp; Omit&quot;&gt;&lt;/a&gt;04 never &amp;amp; Exclude &amp;amp; Omit&lt;/h2&gt;&lt;p&gt;官方文档对 &lt;code&gt;never&lt;/code&gt; 的描述如下&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;the never type represents the type of values that never occur.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;结合 &lt;code&gt;never&lt;/code&gt; 与 &lt;code&gt;conditional type&lt;/code&gt; 可以推出很多有意思而且实用的类型，比如 &lt;code&gt;Omit&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;type Exclude&amp;lt;T, U&amp;gt; = T extends U ? never : T;

// 相当于: type A = &amp;#39;a&amp;#39;
type A = Exclude&amp;lt;&amp;#39;x&amp;#39; | &amp;#39;a&amp;#39;, &amp;#39;x&amp;#39; | &amp;#39;y&amp;#39; | &amp;#39;z&amp;#39;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Js" scheme="https://zhanghao-web.github.io/categories/Js/"/>
    
    
      <category term="Ts" scheme="https://zhanghao-web.github.io/tags/Ts/"/>
    
  </entry>
  
  <entry>
    <title>Node学习(十四) --Node项目-商品列表</title>
    <link href="https://zhanghao-web.github.io/2019/05/25/Node/Node%E5%AD%A6%E4%B9%A0(%E5%8D%81%E5%9B%9B)%20--Node%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8/"/>
    <id>https://zhanghao-web.github.io/2019/05/25/Node/Node学习(十四) --Node项目-商品列表/</id>
    <published>2019-05-25T09:23:20.000Z</published>
    <updated>2020-01-28T10:04:15.048Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Node-js项目介绍"><a href="#Node-js项目介绍" class="headerlink" title="Node.js项目介绍"></a>Node.js项目介绍</h1><p>利用学到的知识，实现一个简单但实用的小项目如下：</p><p>这是一个商品列表，具有展示商品信息，添加商品，删除商品的功能。</p><h2 id="项目的文件夹结构"><a href="#项目的文件夹结构" class="headerlink" title="项目的文件夹结构"></a>项目的文件夹结构</h2><p>├── package.json<br>├── server.js # 服务器代码<br>├── config # 项目配置文件夹<br>│     ├── config.dev.js # 开发环境配置<br>│     ├── config.prod.js # 生产环境配置<br>│     ├── index.js # 导出当前所处环境及配置<br>├── libs # 项目工具文件夹<br>│     ├── database.js # 连接数据库<br>│     ├── http.js # 服务器配置<br>│     ├── router.js # 处理路由<br>├── router # 项目路由配置文件夹<br>│     ├── index.js # 连接数据库<br>│     ├── list.js # 获取商品列表接口配置<br>│     ├── add.js # 增加商品接口配置<br>│     ├── del.js # 删除商品接口配置<br>├── static # 静态资源文件夹<br>│     ├── index.html # 前端HTML页面<br>│     ├── js # 前端JavaScript文件夹<br>│     ├── css # 前端CSS文件夹<br>│     ├── fonts # 前端字体文件夹<br>│     ├── upload # 前端上传文件夹</p><h2 id="判断当前所处环境"><a href="#判断当前所处环境" class="headerlink" title="判断当前所处环境"></a>判断当前所处环境</h2><p>通常项目在开发环境和生产环境要采用不同的，服务器、账号、域名、端口等配置，如果用人工进行切换操作麻烦且容易出错，因此通常使用环境变量进行判断。</p><p>首先引入process模块<code>const process=require(&#39;process&#39;)</code>，该模块提供了当前Node.js进程的信息。</p><p>1.可以通过process.env环境变量获取开发环境和生产环境系统等参数差异，如开发环境运行在Windows系统上，而生产环境运行在Linux系统，那么就可以使用<code>process.env.OS === &#39;Windows_NT&#39;</code>判断当前所处的是否开发环境。</p><pre><code class="js">const mode = process.env.OS === &#39;Windows_NT&#39; ? &#39;env&#39; : &#39;prod&#39;</code></pre><p>2.也可以通过package.json中配置的启动命令判断处于开发还是生产环境，如开发环境命令<code>npm start --dev</code>和生产环境命令<code>npm run build --build</code>。</p><pre><code class="js">const mode = process.argv[2] === &#39;--dev&#39; ? &#39;env&#39; : &#39;prod&#39;</code></pre><h2 id="初始化开发和生产环境配置"><a href="#初始化开发和生产环境配置" class="headerlink" title="初始化开发和生产环境配置"></a>初始化开发和生产环境配置</h2><p>在/config/index.js中，判断所处的环境，并将相应环境的标识和参数作为模块导出。开发过程中，可以直接引用相应的配置使用。</p><pre><code class="js">const process = require(&#39;process&#39;)// 可以通过开发环境和生产环境系统等参数差异，判断处于哪个环境。// const mode = process.env.OS === &#39;Windows_NT&#39; ? &#39;env&#39; : &#39;prod&#39;// 也可以通过package.json中配置的启动命令判断处于开发还是生产环境。const mode = process.argv[2] === &#39;--dev&#39; ? &#39;env&#39; : &#39;prod&#39;module.exports = {  mode, // 当前所处环境  ...(mode === &#39;env&#39; ? require(&#39;./config.dev&#39;) : require(&#39;./config.prod&#39;))  // 当前环境的配置}</code></pre><p>1.以开发环境为例，需要使用的配置为服务器域名、端口号、账号、密码、数据库名，以及HTTP端口、静态文件绝对路径、上传文件保存绝对路径，如下：</p><pre><code class="js">module.exports = {  // 数据库配置  DB_HOST: &#39;localhost&#39;,  DB_PORT: 3306,  DB_USER: &#39;root&#39;,  DB_PASS: &#39;&#39;,  DB_NAME: &#39;test&#39;,  // HTTP端口  HTTP_PORT: 8080,  // 静态文件绝对路径  HTTP_ROOT: path.resolve(__dirname, &#39;../static/&#39;),  // 上传文件保存绝对路径  HTTP_UPLOAD: path.resolve(__dirname, &#39;../static/upload&#39;)}</code></pre><h2 id="连接数据库"><a href="#连接数据库" class="headerlink" title="连接数据库"></a>连接数据库</h2><p>在lib文件夹下，创建database.js，用于连接数据库。</p><a id="more"></a><pre><code class="js">// 引入mysql和co-mysql，用于连接数据库const mysql = require(&#39;mysql&#39;)const coMysql = require(&#39;co-mysql&#39;)// 引入数据库配置const {  DB_HOST,  DB_PORT,  DB_USER,  DB_PASS,  DB_NAME} = require(&#39;../config&#39;)// 1. 创建服务器连接池const pool = mysql.createPool({  host: DB_HOST,  port: DB_PORT,  user: DB_USER,  password: DB_PASS,  database: DB_NAME})// 2. 使用co-mysql包装连接池，将连接转换为Async/Await异步方式const connection = coMysql(pool)// 3. 作为模块导出使用module.exports = connection</code></pre><p>创建数据库连接后，可以在server.js中，创建一个数据库连接，并查看item_table表的数据</p><pre><code class="js">const connection = require(&#39;./lib/database&#39;);(async () =&gt; {  // 查询item_table表中的数据  const response = await connection.query(`SELECT * FROM item_table`)  console.log(response)})()</code></pre><p>若正常连接，即可打印数据如下：</p><pre><code class="js">[ RowDataPacket { ID: 1, title: &#39;运动服&#39;, price: 299, count: 998 } ]ice: 199, count: 999 },  RowDataPacket { ID: 2, title: &#39;运动裤&#39;, price: 299, count: 998 } ]</code></pre><h2 id="创建路由"><a href="#创建路由" class="headerlink" title="创建路由"></a>创建路由</h2><p>在之前的例子中，我们总是要通过if else语句来判断请求的接口路径，并进行相应操作。</p><p>这样会极大地降低开发效率，也不利于后期代码维护。</p><p>因此，通常的开发中，都会使用路由对不同的接口进行操作。</p><p>现在我们就来自己实现一个简单的路由：</p><p><strong>1.先创建一个router对象，用于存储路由表。其中有2个属性，分别为get、post，分别用于存储相应get、post请求地址的回调方法</strong></p><pre><code class="js">// 创建路由表let router = {  // 存储get请求的路由  get: {  },  // 存储post请求的路由  post: {  }}</code></pre><p><strong>2. 创建一个addRouter方法，用于添加路由配置，参数method为请求方法，url为请求地址，callback为处理该请求的回调函数。</strong></p><pre><code class="js">// 添加路由的方法，method为请求方法，url为请求地址，callback为处理该请求的回调函数function addRouter(method, url, callback) {  // 为便于处理，将method和url统一转换成小写  method = method.toLowerCase()  url = url.toLowerCase()  // 将处理请求的回调函数，按方法名和地址储存到路由表中  router[method][url] = callback}</code></pre><p><strong>3. 创建一个findRouter方法，用于查找相应路由的回调函数。参数method为请求方法，url为请求地址，返回处理路由的回调函数。</strong></p><pre><code class="js">// 查找处理请求的回调函数的方法，method为请求方法，url为请求地址，返回处理路由的回调函数function findRouter(method, url) {  // 为便于处理，将method和url统一转换成小写  method = method.toLowerCase()  url = url.toLowerCase()  // 找到路由对应的回调函数，不存在则默认返回null  const callback = router[method][url] || null  // 将回调函数返回  return callback}</code></pre><p><strong>4. 将路由配置作为模块导出</strong></p><pre><code class="js">// 将添加路由和查找路由方法导出module.exports = {  addRouter,  findRouter}</code></pre><h2 id="创建服务器"><a href="#创建服务器" class="headerlink" title="创建服务器"></a>创建服务器</h2><p>在实现了路由之后，就可以以此为基础实现服务器了。</p><p>实现服务器分为以下几个步骤：</p><p>1.引入所需Node.js模块、服务器配置、路由模块<br>2.封装统一处理请求数据的方法<br>3.接收到的请求分为POST请求、GET请求，区分并进行处理<br>4.POST请求分为数据请求、文件上传请求，区分并进行处理<br>5.GET请求分为数据请求、读取文件请求，区分并进行处理</p><p>接下来，按步骤实现每部分代码。</p><p><strong>1. 引入所需Node.js模块、服务器配置、路由模块</strong></p><pre><code class="js">// 引入创建服务器所需的模块const http = require(&#39;http&#39;)const url = require(&#39;url&#39;)const querystring = require(&#39;querystring&#39;)const zlib = require(&#39;zlib&#39;)const fs = require(&#39;fs&#39;)const { Form } = require(&#39;multiparty&#39;)// 引入服务器配置const {  HTTP_PORT,  HTTP_ROOT,  HTTP_UPLOAD} = require(&#39;../config&#39;)// 引入路由模块的查找路由方法const { findRouter } = require(&#39;./router&#39;)const server = http.createServer((req, res) =&gt; {  // 服务器代码})// 监听配置的端口server.listen(HTTP_PORT)// 打印创建服务器成功信息console.log(`Server started at ${HTTP_PORT}`)</code></pre><p><strong>2. 封装统一处理请求数据的方法</strong></p><p>要处理所有请求接口，需要的参数为method（请求方法）、pathname（请求接口路径）、query（query数据）、post（post数据）、files（文件数据）。</p><p>首先，根据method（请求方法）、pathname（请求接口路径），获取在路由配置时，已经配置好的相应接口的回调函数。<br>其次，若回调函数存在，则直接将参数传入回调函数处理。<br>最后，若回调函数不存在，则默认为请求一个静态文件，即可将文件读取之后发送给前端。</p><pre><code class="js">// 引入创建服务器所需的模块...// 引入服务器配置...// 引入路由模块的查找路由方法...const server = http.createServer((req, res) =&gt; {  // 通过路由处理请求数据的公共方法  async function processData(method, pathname, query, post, files) {    const callback = findRouter(method, pathname)  // 获取处理请求的回调函数    // 若回调函数存在，则表示路由有配置相应的数据处理，即该请求不是获取静态文件。    if (callback) {      try {        // 根据路由处理接口数据        await callback(res, query, post, files)      } catch (error) {        // 出现错误的处理        res.writeHead(500)        res.write(&#39;Internal Server Error&#39;)        res.end()      }    } else {      // 若回调函数不存在，则表示该请求为请求一个静态文件，如html、css、js等      ...    }  }})// 监听配置的端口server.listen(HTTP_PORT)// 打印创建服务器成功信息console.log(`Server started at ${HTTP_PORT}`)</code></pre><p><strong>3. 接收到的请求分为POST请求、GET请求，区分并进行处理</strong></p><p>根据请求的method，将请求分为POST请求、GET请求。</p><p>若为POST请求，则需要进一步判断是普通数据请求，还是文件请求，并分别进行处理。</p><p>而GET请求，只需要将数据传入processData方法进行处理，在processData方法中，区分GET请求获取数据，还是获取静态文件。</p><pre><code class="js">// 引入创建服务器所需的模块...// 引入服务器配置...// 引入路由模块的查找路由方法...const server = http.createServer((req, res) =&gt; {  // 解析请求数据  // 获取请求路径及query数据  const method = req.method  const {    pathname,    query  } = url.parse(req.url, true)  // 处理POST请求  if (method === &#39;POST&#39;) {    // POST请求分为数据请求、文件上传请求，区分并进行处理    ...  } else {  // 处理GET请求    // 通过路由处理数据，因为此时是GET请求，只有query数据    processData(method, url, query, {}, {})  }  // 通过路由处理请求数据的公共方法  async function processData(method, pathname, query, post, files) {    ...  }})// 监听配置的端口server.listen(HTTP_PORT)// 打印创建服务器成功信息console.log(`Server started at ${HTTP_PORT}`)</code></pre><p><strong>4. POST请求分为数据请求、文件上传请求，区分并进行处理</strong></p><p>判断请求头的content-type为<code>application/x-www-form-urlencoded</code>时，表示该请求只是单纯传输数据，可以直接当做字符串处理。<br>若请求头的content-type不对，则表示该请求是上传文件，可以用multiparty进行处理。</p><pre><code class="js">// 引入创建服务器所需的模块...// 引入服务器配置...// 引入路由模块的查找路由方法...const server = http.createServer((req, res) =&gt; {  // 解析请求数据  // 获取请求路径及query数据  const method = req.method  const {    pathname,    query  } = url.parse(req.url, true)  // 处理POST请求  if (method === &#39;POST&#39;) {    // 根据请求头的content-type属性值，区分是普通POST请求，还是文件请求。    // content-type为application/x-www-form-urlencoded时，表示是普通POST请求    // 普通POST请求直接进行处理，文件请求使用multiparty处理    if (req.headers[&#39;content-type&#39;].startsWith(&#39;application/x-www-form-urlencoded&#39;)) {      // 普通POST请求      let arr = []  // 存储Buffer数据      // 接收数据      req.on(&#39;data&#39;, (buffer) =&gt; {        arr.push(buffer)      })      // 数据接收完成      req.on(&#39;end&#39;, () =&gt; {        const data = Buffer.concat(arr)  // 合并接收到的数据        const post = querystring.parse(data.toString()) // 将接收到的数据转换为JSON        // 通过路由处理数据，因为此时是普通POST请求，不存在文件数据        processData(method, pathname, query, post, {})      })    } else {      // 文件POST请求      const form = new Form({        uploadDir: HTTP_UPLOAD  // 指定文件存储目录      })      // 处理请求数据      form.parse(req)      let post = {} // 存储数据参数      let files = {}  // 存储文件数据      // 通过field事件处理普通数据      form.on(&#39;field&#39;, (name, value) =&gt; {        post[name] = value      })      // 通过file时间处理文件数据      form.on(&#39;file&#39;, (name, file) =&gt; {        files[name] = file      })      // 处理错误      form.on(&#39;error&#39;, (error) =&gt; {        console.error(error)      })      // 数据传输完成时，触发close事件      form.on(&#39;close&#39;, () =&gt; {        // 通过路由处理数据，因为此时是POST文件请求，query、post、files数据都存在        processData(method, pathname, query, post, files)      })    }  } else {  // 处理GET请求    // 通过路由处理数据，因为此时是GET请求，只有query数据    processData(method, url, query, {}, {})  }  // 通过路由处理请求数据的公共方法  async function processData(method, pathname, query, post, files) {    ...  }})// 监听配置的端口server.listen(HTTP_PORT)// 打印创建服务器成功信息console.log(`Server started at ${HTTP_PORT}`)</code></pre><p><strong>5. GET请求分为数据请求、读取文件请求，区分并进行处理</strong></p><p>GET请求可以直接用<code>processData</code>方法统一处理，若路由中未配置处理数据的方法，则表示该请求为获取静态文件，需要进行单独处理，否则只需要调用路由配置的回调函数处理即可。</p><pre><code class="js">// 引入创建服务器所需的模块...// 引入服务器配置...// 引入路由模块的查找路由方法...const server = http.createServer((req, res) =&gt; {  // 解析请求数据  // 获取请求路径及query数据  const method = req.method  const {    pathname,    query  } = url.parse(req.url, true)  // 处理POST请求  if (method === &#39;POST&#39;) {    ...  } else {  // 处理GET请求    // 通过路由处理数据，因为此时是GET请求，只有query数据    processData(method, url, query, {}, {})  }  // 通过路由处理请求数据的公共方法  async function processData(method, pathname, query, post, files) {    const callback = findRouter(method, pathname)  // 获取处理请求的回调函数    // 若回调函数存在，则表示路由有配置相应的数据处理，即该请求不是获取静态文件。    if (callback) {      try {        // 根据路由处理接口数据        await callback(res, query, post, files)      } catch (error) {        // 出现错误的处理        res.writeHead(500)        res.write(&#39;Internal Server Error&#39;)        res.end()      }    } else {      // 若回调函数不存在，则表示该请求为请求一个静态文件，如html、css、js等      const filePath = HTTP_ROOT + pathname      // 检查文件是否存在      fs.stat(filePath, (error, stat) =&gt; {        if (error) {          // 出现错误表示文件不存在          res.writeHead(404)          res.write(&#39;Not Found&#39;)          res.end()        } else {          // 文件存在则进行读取          // 创建一个可读流。          const readStream = fs.createReadStream(filePath)          // 创建一个Gzip对象，用于将文件压缩成          const gz = zlib.createGzip()          // 向浏览器发送经过gzip压缩的文件，设置响应头，否则浏览器无法识别，会自动进行下载。          res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;)          // 将读取的内容，通过gzip压缩之后，在通过管道推送到res中，由于res继承自Stream流，因此也可以接收管道的推送。          readStream.pipe(gz).pipe(res)          readStream.on(&#39;error&#39;, (error) =&gt; {            console.error(error)          })        }      })    }  }})// 监听配置的端口server.listen(HTTP_PORT)// 打印创建服务器成功信息console.log(`Server started at ${HTTP_PORT}`)</code></pre><h2 id="测试服务器"><a href="#测试服务器" class="headerlink" title="测试服务器"></a>测试服务器</h2><p>在server.js中引入封装的http模块：</p><pre><code class="js">const http = require(&#39;./lib/http&#39;)</code></pre><p>再使用node server.js启动服务器，就可以在浏览器中访问<code>http://localhost:8080/index.html</code>，看到html页面</p><h2 id="添加各接口路由配置"><a href="#添加各接口路由配置" class="headerlink" title="添加各接口路由配置"></a>添加各接口路由配置</h2><p>获取商品列表路由回调函数</p><p>查询<code>item_table</code>表中的商品数据后，返回给前台，并将回调函数作为模块导出。</p><pre><code class="js">const connection = require(&#39;../lib/database&#39;)module.exports = async (res, query, post, files) =&gt; {  try {    // 查询商品列表    const data = await connection.query(`SELECT * FROM item_table`)    res.writeJson({      error: 0, // error为0则表示接口正常      data  // 查询到的商品列表数据    })  } catch (error) {    console.error(error)    res.writeJson({      error: 1, // error为1则表示接口出错      msg: &#39;数据库出错&#39; // 接口的错误信息    })  }  res.end()}</code></pre><h3 id="添加商品路由回调函数"><a href="#添加商品路由回调函数" class="headerlink" title="添加商品路由回调函数"></a>添加商品路由回调函数</h3><p>应禁止query语句使用如下写法，容易造成注入攻击。<br><code>connection.query(INSERT INTO item_table (title, price, count) VALUES(&#39;${title}, ${price} ${count}&#39;))</code><br>此时若用户传入参数如下：</p><p><code>http://localhost:8080/add?title=a&#39;)%3B%20DELETE%20FROM%20item_table%3B%20SELECT%20(1&amp;price=19.8&amp;count=200</code></p><p>就会让服务器执行一个这样的语句：</p><pre><code class="js">INSERT INTO item_table (title, price, count) VALUES(&#39;a&#39;); DELETE FROM item_table; SELECT (&#39;1&#39;, 19.8, 200)</code></pre><p>其意义为：</p><p>1.插入一个虚假数据<br>2.删除item_table表中所有数据<br>3.返回一个虚假数据</p><p>这样就会导致item_table表中的所有数据被删除。</p><p>为防止注入攻击，可以使用占位符?代替需要插入数据库的参数，第二个数组参数中的3个值会按顺序填充占位符，该方法可以避免大部分注入攻击，如下：</p><pre><code class="js">await connection.query(`INSERT INTO item_table (title, price, count) VALUES(?,?,?)`, [title, price, count])</code></pre><pre><code class="js">const connection = require(&#39;../lib/database&#39;)module.exports = async (res, query, post, files) =&gt; {  let {    title,    price,    count  } = post  // 判断是否有传参  if (!title || !price || !count) {    res.writeJson({      error: 1,      msg: &#39;参数不合法&#39;    })  } else {    // 将价格和数量转为数字    price = Number(price)    count = Number(count)    // 判断价格和数量是否非数字    if (isNaN(price) || isNaN(count)) {      res.writeJson({        error: 1,        msg: &#39;参数不合法&#39;      })    } else {      try {        // 使用占位符?代替需要插入数据库的参数，第二个数组参数中的3个值会按顺序填充占位符，该方法可以避免大部分注入攻击。        await connection.query(`INSERT INTO item_table (title, price, count) VALUES(?,?,?)`, [title, price, count])        res.writeJson({          error: 0,          msg: &#39;添加商品成功&#39;        })      } catch (error) {        console.error(error)        res.writeJson({          error: 1,          msg: &#39;数据库内部错误&#39;        })      }    }  }  res.end()}</code></pre><h3 id="删除商品路由回调函数"><a href="#删除商品路由回调函数" class="headerlink" title="删除商品路由回调函数"></a>删除商品路由回调函数</h3><pre><code class="js">const connection = require(&#39;../lib/database&#39;)module.exports = async (res, query, post, files) =&gt; {  const ID = query.id  if (!ID) {    res.writeJson({      error: 1,      msg: &#39;参数不合法&#39;    })  } else {    await connection.query(`DELETE FROM item_table WHERE ID=${ID}`)    res.writeJson({      error: 0,      msg: &#39;删除成功&#39;    })  }  res.end()}</code></pre><h3 id="添加各接口路由配置-1"><a href="#添加各接口路由配置-1" class="headerlink" title="添加各接口路由配置"></a>添加各接口路由配置</h3><p>在<code>/router/index.js</code>中，引用各个接口的配置，并用addRouter方法添加到路由表中，即可在接收到请求时，查找路由并进行处理。</p><pre><code class="js">const {  addRouter} = require(&#39;../lib/router&#39;)// 添加获取商品列表接口addRouter(&#39;get&#39;, &#39;/list&#39;, require(&#39;./list&#39;))// 添加商品接口addRouter(&#39;post&#39;, &#39;/add&#39;, require(&#39;./add&#39;))// 删除商品接口addRouter(&#39;get&#39;, &#39;/del&#39;, require(&#39;./del&#39;))</code></pre><h3 id="在主模块中引用路由"><a href="#在主模块中引用路由" class="headerlink" title="在主模块中引用路由"></a>在主模块中引用路由</h3><p>在/server.js中，引用router模块，就可以完成整个服务端的配置。</p><pre><code class="js">const connection = require(&#39;./lib/database&#39;)const http = require(&#39;./lib/http&#39;)const router = require(&#39;./router&#39;)</code></pre><h3 id="完成前端功能"><a href="#完成前端功能" class="headerlink" title="完成前端功能"></a>完成前端功能</h3><p>在/static/index.html中，使用jquery为前端页面实现如下功能：</p><p>1.显示商品列表<br>2.添加随机名称、价格、库存的商品<br>3.删除对应商品</p><pre><code class="js">// 查询商品列表的方法function getList() {  $.ajax({    url: &#39;/list&#39;,    dataType: &#39;json&#39;  }).then(res =&gt; {    let html = ``    res.data.forEach((item, index) =&gt; {      html += (        `            &lt;tr&gt;              &lt;td&gt;${item.title}&lt;/td&gt;              &lt;td&gt;￥${item.price}&lt;/td&gt;              &lt;td&gt;${item.count}&lt;/td&gt;              &lt;td&gt;                &lt;a data-id=&quot;${item.ID}&quot; href=&quot;#&quot; class=&quot;glyphicon glyphicon-trash&quot;&gt;删除&lt;/a&gt;              &lt;/td&gt;            &lt;/tr&gt;          `      )    })    $(&#39;tbody&#39;).html(html)  });} getList()// 点击添加按钮，随机添加一个商品$(&#39;#addBtn&#39;).on(&#39;click&#39;, function () {  $.ajax({    url: &#39;/add&#39;,    method: &#39;post&#39;,    data: {      title: `test${Math.floor(Math.random() * 100)}`,      price: Math.floor(Math.random() * 100),      count: Math.floor(Math.random() * 100)    }  })    .then((response) =&gt; {      getList()    })})// 点击删除按钮$(&#39;tbody&#39;).on(&#39;click&#39;, &#39;a&#39;, function () {  $.ajax({    url: &#39;/del&#39;,    data: {      id: $(this).attr(&#39;data-id&#39;)    }  })    .then((response) =&gt; {      getList()    })})</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Node-js项目介绍&quot;&gt;&lt;a href=&quot;#Node-js项目介绍&quot; class=&quot;headerlink&quot; title=&quot;Node.js项目介绍&quot;&gt;&lt;/a&gt;Node.js项目介绍&lt;/h1&gt;&lt;p&gt;利用学到的知识，实现一个简单但实用的小项目如下：&lt;/p&gt;
&lt;p&gt;这是一个商品列表，具有展示商品信息，添加商品，删除商品的功能。&lt;/p&gt;
&lt;h2 id=&quot;项目的文件夹结构&quot;&gt;&lt;a href=&quot;#项目的文件夹结构&quot; class=&quot;headerlink&quot; title=&quot;项目的文件夹结构&quot;&gt;&lt;/a&gt;项目的文件夹结构&lt;/h2&gt;&lt;p&gt;├── package.json&lt;br&gt;├── server.js # 服务器代码&lt;br&gt;├── config # 项目配置文件夹&lt;br&gt;│     ├── config.dev.js # 开发环境配置&lt;br&gt;│     ├── config.prod.js # 生产环境配置&lt;br&gt;│     ├── index.js # 导出当前所处环境及配置&lt;br&gt;├── libs # 项目工具文件夹&lt;br&gt;│     ├── database.js # 连接数据库&lt;br&gt;│     ├── http.js # 服务器配置&lt;br&gt;│     ├── router.js # 处理路由&lt;br&gt;├── router # 项目路由配置文件夹&lt;br&gt;│     ├── index.js # 连接数据库&lt;br&gt;│     ├── list.js # 获取商品列表接口配置&lt;br&gt;│     ├── add.js # 增加商品接口配置&lt;br&gt;│     ├── del.js # 删除商品接口配置&lt;br&gt;├── static # 静态资源文件夹&lt;br&gt;│     ├── index.html # 前端HTML页面&lt;br&gt;│     ├── js # 前端JavaScript文件夹&lt;br&gt;│     ├── css # 前端CSS文件夹&lt;br&gt;│     ├── fonts # 前端字体文件夹&lt;br&gt;│     ├── upload # 前端上传文件夹&lt;/p&gt;
&lt;h2 id=&quot;判断当前所处环境&quot;&gt;&lt;a href=&quot;#判断当前所处环境&quot; class=&quot;headerlink&quot; title=&quot;判断当前所处环境&quot;&gt;&lt;/a&gt;判断当前所处环境&lt;/h2&gt;&lt;p&gt;通常项目在开发环境和生产环境要采用不同的，服务器、账号、域名、端口等配置，如果用人工进行切换操作麻烦且容易出错，因此通常使用环境变量进行判断。&lt;/p&gt;
&lt;p&gt;首先引入process模块&lt;code&gt;const process=require(&amp;#39;process&amp;#39;)&lt;/code&gt;，该模块提供了当前Node.js进程的信息。&lt;/p&gt;
&lt;p&gt;1.可以通过process.env环境变量获取开发环境和生产环境系统等参数差异，如开发环境运行在Windows系统上，而生产环境运行在Linux系统，那么就可以使用&lt;code&gt;process.env.OS === &amp;#39;Windows_NT&amp;#39;&lt;/code&gt;判断当前所处的是否开发环境。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const mode = process.env.OS === &amp;#39;Windows_NT&amp;#39; ? &amp;#39;env&amp;#39; : &amp;#39;prod&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;2.也可以通过package.json中配置的启动命令判断处于开发还是生产环境，如开发环境命令&lt;code&gt;npm start --dev&lt;/code&gt;和生产环境命令&lt;code&gt;npm run build --build&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const mode = process.argv[2] === &amp;#39;--dev&amp;#39; ? &amp;#39;env&amp;#39; : &amp;#39;prod&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;初始化开发和生产环境配置&quot;&gt;&lt;a href=&quot;#初始化开发和生产环境配置&quot; class=&quot;headerlink&quot; title=&quot;初始化开发和生产环境配置&quot;&gt;&lt;/a&gt;初始化开发和生产环境配置&lt;/h2&gt;&lt;p&gt;在/config/index.js中，判断所处的环境，并将相应环境的标识和参数作为模块导出。开发过程中，可以直接引用相应的配置使用。&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const process = require(&amp;#39;process&amp;#39;)

// 可以通过开发环境和生产环境系统等参数差异，判断处于哪个环境。
// const mode = process.env.OS === &amp;#39;Windows_NT&amp;#39; ? &amp;#39;env&amp;#39; : &amp;#39;prod&amp;#39;

// 也可以通过package.json中配置的启动命令判断处于开发还是生产环境。
const mode = process.argv[2] === &amp;#39;--dev&amp;#39; ? &amp;#39;env&amp;#39; : &amp;#39;prod&amp;#39;

module.exports = {
  mode, // 当前所处环境
  ...(mode === &amp;#39;env&amp;#39; ? require(&amp;#39;./config.dev&amp;#39;) : require(&amp;#39;./config.prod&amp;#39;))  // 当前环境的配置
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;1.以开发环境为例，需要使用的配置为服务器域名、端口号、账号、密码、数据库名，以及HTTP端口、静态文件绝对路径、上传文件保存绝对路径，如下：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;module.exports = {
  // 数据库配置
  DB_HOST: &amp;#39;localhost&amp;#39;,
  DB_PORT: 3306,
  DB_USER: &amp;#39;root&amp;#39;,
  DB_PASS: &amp;#39;&amp;#39;,
  DB_NAME: &amp;#39;test&amp;#39;,

  // HTTP端口
  HTTP_PORT: 8080,
  // 静态文件绝对路径
  HTTP_ROOT: path.resolve(__dirname, &amp;#39;../static/&amp;#39;),
  // 上传文件保存绝对路径
  HTTP_UPLOAD: path.resolve(__dirname, &amp;#39;../static/upload&amp;#39;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id=&quot;连接数据库&quot;&gt;&lt;a href=&quot;#连接数据库&quot; class=&quot;headerlink&quot; title=&quot;连接数据库&quot;&gt;&lt;/a&gt;连接数据库&lt;/h2&gt;&lt;p&gt;在lib文件夹下，创建database.js，用于连接数据库。&lt;/p&gt;
    
    </summary>
    
      <category term="Node" scheme="https://zhanghao-web.github.io/categories/Node/"/>
    
    
      <category term="Node" scheme="https://zhanghao-web.github.io/tags/Node/"/>
    
  </entry>
  
</feed>
