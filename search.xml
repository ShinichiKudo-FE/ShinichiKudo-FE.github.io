<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[尤雨溪在Vue3.0 Beta直播里聊到了这些…]]></title>
    <url>%2F2020%2F04%2F22%2FVue%2F%E5%B0%A4%E9%9B%A8%E6%BA%AA%E5%9C%A8Vue3-0-Beta%E7%9B%B4%E6%92%AD%E9%87%8C%E8%81%8A%E5%88%B0%E4%BA%86%E8%BF%99%E4%BA%9B%E2%80%A6%2F</url>
    <content type="text"><![CDATA[原文地址(https://juejin.im/post/5e9f6b3251882573a855cd52?utm_source=gold_browser_extension#heading-15) 前言4月21日晚，Vue作者尤雨溪在哔哩哔哩直播分享了Vue.js 3.0 Beta最新进展。 以下是直播内容整理 全新文档RFCs Vue.js 3.0 Beta发布后的工作重点是保证稳定性和推进各类库集成 所有的进度和文档都将在全新RFCs文档可以看到。 六大亮点 Performance：性能更比Vue 2.0强。 Tree shaking support：可以将无用模块“剪辑”，仅打包需要的。 Composition API：组合API Fragment, Teleport, Suspense：“碎片”，Teleport即Protal传送门，“悬念” Better TypeScript support：更优秀的Ts支持 Custom Renderer API：暴露了自定义渲染API Performance 重写了虚拟Dom的实现（且保证了兼容性，脱离模版的渲染需求旺盛）。 编译模板的优化。 更高效的组件初始化。 update性能提高1.3~2倍。 SSR速度提高了2~3倍。 下面是各项性能对比 要点1：编译模板的优化 假设要编译以下代码 &lt;div&gt; &lt;span/&gt; &lt;span&gt;{{ msg }}&lt;/span&gt; &lt;/div&gt; import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, null, &quot;static&quot;), _createVNode(&quot;span&quot;, null, _toDisplayString(_ctx.msg), 1 /* TEXT */) ])) } // Check the console for the AST 注意看第二个_createVNode结尾的“1”： Vue在运行时会生成number（大于0）值的PatchFlag，用作标记。 仅带有PatchFlag标记的节点会被真正追踪，且无论层级嵌套多深，它的动态节点都直接与Block根节点绑定，无需再去遍历静态节点 再看以下例子： &lt;div&gt; &lt;span&gt;static&lt;/span&gt; &lt;span :id=&quot;hello&quot; class=&quot;bar&quot;&gt;{{ msg }} &lt;/span&gt; &lt;/div&gt; import { createVNode as _createVNode, toDisplayString as _toDisplayString, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, null, &quot;static&quot;), _createVNode(&quot;span&quot;, { id: _ctx.hello, class: &quot;bar&quot; }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;id&quot;]) ])) } PatchFlag 变成了9 /* TEXT, PROPS */, [&quot;id&quot;]它会告知我们不光有TEXT变化，还有PROPS变化（id）这样既跳出了virtual dom性能的瓶颈，又保留了可以手写render的灵活性。等于是：既有react的灵活性，又有基于模板的性能保证。 要点2: 事件监听缓存：cacheHandlers 假设我们要绑定一个事件： &lt;div&gt; &lt;span @click=&quot;onClick&quot;&gt; {{msg}} &lt;/span&gt; &lt;/div&gt; 关闭cacheHandlers后： import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, { onClick: _ctx.onClick }, _toDisplayString(_ctx.msg), 9 /* TEXT, PROPS */, [&quot;onClick&quot;]) ])) } onClick会被视为PROPS动态绑定，后续替换点击事件时需要进行更新。 开启cacheHandlers后： import { toDisplayString as _toDisplayString, createVNode as _createVNode, openBlock as _openBlock, createBlock as _createBlock } from &quot;vue&quot; export function render(_ctx, _cache) { return (_openBlock(), _createBlock(&quot;div&quot;, null, [ _createVNode(&quot;span&quot;, { onClick: _cache[1] || (_cache[1] = $event =&gt; (_ctx.onClick($event))) }, _toDisplayString(_ctx.msg), 1 /* TEXT */) ])) } cache[1]，会自动生成并缓存一个内联函数，“神奇”的变为一个静态节点。 Ps：相当于React中useCallback自动化。 并且支持手写内联函数： &lt;div&gt; &lt;span @click=&quot;()=&gt;foo()&quot;&gt; {{msg}} &lt;/span&gt; &lt;/div&gt; 补充：PatchFlags枚举定义 而通过查询Ts枚举定义，我们可以看到分别定义了以下的追踪标记： export const enum PatchFlags { TEXT = 1,// 表示具有动态textContent的元素 CLASS = 1 &lt;&lt; 1, // 表示有动态Class的元素 STYLE = 1 &lt;&lt; 2, // 表示动态样式（静态如style=&quot;color: red&quot;，也会提升至动态） PROPS = 1 &lt;&lt; 3, // 表示具有非类/样式动态道具的元素。 FULL_PROPS = 1 &lt;&lt; 4, // 表示带有动态键的道具的元素，与上面三种相斥 HYDRATE_EVENTS = 1 &lt;&lt; 5, // 表示带有事件监听器的元素 STABLE_FRAGMENT = 1 &lt;&lt; 6, // 表示其子顺序不变的片段（没懂）。 KEYED_FRAGMENT = 1 &lt;&lt; 7, // 表示带有键控或部分键控子元素的片段。 UNKEYED_FRAGMENT = 1 &lt;&lt; 8, // 表示带有无key绑定的片段 NEED_PATCH = 1 &lt;&lt; 9, // 表示只需要非属性补丁的元素，例如ref或hooks DYNAMIC_SLOTS = 1 &lt;&lt; 10, // 表示具有动态插槽的元素 // 特殊 FLAGS ------------------------------------------------------------- HOISTED = -1, // 特殊标志是负整数表示永远不会用作diff,只需检查 patchFlag === FLAG. BAIL = -2 // 一个特殊的标志，指代差异算法（没懂） } 感兴趣的可以看源码：packages/shared/src/patchFlags.ts Tree shaking support 可以将无用模块“剪辑”，仅打包需要的（比如v-model,&lt;transition&gt;，用不到就不会打包）。 一个简单“HelloWorld”大小仅为：13.5kb11.75kb，仅Composition API。 包含运行时完整功能：22.5kb,拥有更多的功能，却比Vue 2更迷你。 很多时候，我们并不需要 vue提供的所有功能，在 vue 2 并没有方式排除掉，但是 3.0 都可能做成了按需引入。 Composition API 与React Hooks 类似的东西，实现方式不同。 可与现有的 Options API一起使用 灵活的逻辑组合与复用 vue 3的响应式模块可以和其他框架搭配使用 混入(mixin) 将不再作为推荐使用， Composition API可以实现更灵活且无副作用的复用代码。 感兴趣的可以查看：composition-api.vuejs.org/#summary Composition API包含了六个主要API composition-api.vuejs.org/api.html#setup Ps：其它的均为常见的工具函数，可先忽略不看。 Fragment Fragment翻译为：“碎片” 不再限于模板中的单个根节点 render 函数也可以返回数组了，类似实现了 React.Fragments 的功能 。 ‘Just works’ 以前称为&lt;Portal&gt;，译作传送门。 更多细节将由@Linusborg 分享 &lt;Teleport&gt;原先是对标 React Portal（增加多个新功能，更强） 但因为Chrome有个提案，会增加一个名为Portal的原生element，为避免命名冲突，改为Teleport Suspense翻译为：“悬念” 可在嵌套层级中等待嵌套的异步依赖项 支持async setup() 支持异步组件 虽然React 16引入了Suspense，但直至现在都不太能用。如何将其与异步数据结合，还没完整设计出来。Vue 3 的&lt;Suspense&gt;更加轻量：仅5%应用能感知运行时的调度差异，综合考虑下，Vue3 的&lt;Suspense&gt; 没和React一样做运行调度处理 更好的TypeScript支持 Vue 3是用TypeScript编写的库，可以享受到自动的类型定义提示 JavaScript和TypeScript中的API是相同的。事实上，代码也基本相同 支持TSX,class组件还会继续支持，但是需要引入vue-class-component@next，该模块目前还处在 alpha 阶段。 还有Vue 3 + TypeScript 插件正在开发，有类型检查，自动补全等功能。目前进展可喜。 Custom Renderer API：自定义渲染器API 正在进行NativeScript Vue集成 用户可以尝试WebGL自定义渲染器，与普通Vue应用程序一起使用（Vugel）。 意味着以后可以通过 vue， Dom 编程的方式来进行 webgl 编程 。感兴趣可以看这里：Getting started vugel 剩余工作 Docs &amp; Migration Guides 新的文档编写交由@NataliaTepluhina, @sdras, @bencodezen &amp; @phanan 负责 @sdras 正在做自动升级迁移工具 @sodatea 已经开始研究CodeMods Router 下一代 Router：vue-router@next已在alpha阶段，感谢@posva 有部分的API变动，可到RFC上看。 Vuex 下一代Vuex：，vuex@next（与Vue 3 compat相同的API），已在alpha阶段，感谢@KiaKing。 团队正在为下一次迭代试验Vuex API的简化 目前以兼容Vue 3为主，基本上没有API变动，莫慌。 CLI CLI插件：vue-cli-plugin-vue-next by @sodatea （wip）CodeMods支持升级Vue 2应用 新工具：vite（法语 “快”） 地址：github.com/vuejs/vite 一个简易的http服务器，无需webpack编译打包，根据请求的Vue文件，直接发回渲染，且支持热更新（非常快） vue-test-utils DevTools IDE Support (Vetur) Nuxt Vue 2.x还有2.7版本 将有最后一个小版本（2.7） 从Vue 3向后移植兼容的改进(不损坏兼容性前提下) 加上在Vue 3中删除的功能的弃用警告 LTS1 18个月。 最后建议：Vue 3虽好，如果你的项目很稳定，且对新功能无过多的要求或者迁移成本过高，则不建议升级。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue3.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于SaaS产品的一些思考和总结]]></title>
    <url>%2F2020%2F04%2F20%2F%E6%9D%82%E6%96%87%2F%E5%85%B3%E4%BA%8ESaaS%E4%BA%A7%E5%93%81%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%9D%E8%80%83%E5%92%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[SaaS的收费模式首年收取的是开户费(软件系统费和账号费等)，从第二年开始收取年费，Sass要提供持续的运营服务才能够持续收费 SaaS的运营框架基础工作弄懂产品了解产品，可不是注册一个账号，随便玩玩，然后提几个优化建议就完事了，这是敷衍。真正弄懂产品，可以从这4方面入手。 第一、了解产品相关的行业背景，如行业历史、现状、最新动态。了解产品涉及的基础知识，如技术原理，在行业的优势。 第二、阅读产品相关的材料，包括内部的文档、介绍、白皮书，外部的报道、技术分析等。 第三、经常和技术、产品、客服同学交流，了解内部人对产品的切身感受和想法。 第四、自己深度体验产品，多问几个为什么。为什么这个功能是这样设计的，在什么场景下为谁解决了什么问题？ 弄懂业务首先，要弄懂自己内部的业务。要把同事变成自己的助手，而不是阻力。一定要熟悉各部门的办事流程、各部门能支持的资源、老板能支持的资源，洞悉和掌握这些信息，有利于你开展工作，快速推进。 其次，要了解客户的业务。他们的业务是怎么运作的，每个人是如何分工配合的，遇到的问题是什么。弄懂客户的业务，才能更好的匹配客户需求，不然永远是门外汉。 弄懂用户路径用户是怎么认识你，为什么选择了你，最后又是怎么流失的？如果你能弄懂用户路径，那么就知道每个环节应该做什么，张弛有度，整体的运营工作开展就会很顺利。这一点非常重要，很多人就是没搞懂用户路径，不知道工作从哪着手，想到一点就做一点，完全没有章法，工作自然难出成绩。 SaaS的核心组件安全组件（保护用户数据）数据隔离组件可配置组件可扩展组件0停机时间升级维护产品多租户组件SaaS多租户下的数据模型分析数据存储架构现有的多租户用户数据存储主要分为三种方式： 独立数据库 共享数据库但隔离数据 共享数据库且共享数据 总体业务架构SaaS平台的用户管理系统主要是统一管理用户信息，用户通过SaaS平台统一注册、登录后，能够试用、采购各企业应用，实现各个第三方企业应用的集成 从功能结构上大致可以分成4个业务域：租户域、租户管理域、用户域、用户权限域等； 租户域：主要描述租户的基本信息，以及租户的组织结构、租户的用户成员（成员职位）等信息； 租户管理域：主要描述租户多级管理员详情，以及管理员对应管理的企业应用权限、数据范围权限； 用户域：主要描述用户基本信息，用户登录账号、实名认证、登录的第三方账号绑定等信息； 用户权限域：主要描述用户能够使用的企业应用以及数据范围的权限信息； 成熟SaaS产品的4个标志成熟可用是企业选择SaaS产品的最重要标准，这也是为什么我们行业为什么要坚持潜行相当长时间的原因。企业境况说是靠时间熬出来的，更准确地说是靠产品的成熟化熬出来的。成熟的SaaS果实一如褚橙般甜蜜。 那么如何判断一个产品是已经成熟的？ 稳定的商业模式，组分市场和顾客分层当一个商业模式和对应的价格水平能够稳定一到两年，感觉已经没有大幅修订的必要时，SaaS产品在商业模式上才算稳定下来，它是对产品成熟度的第一大贡献。 产品投射了专业和行业的最佳实践一个成熟的CRM应用必然需要将销售管理方法、流程和工具内置在产品中，它不仅需要提供一个程序，还需要提供一个使用程序的程序。 健全的用户入场协助为了做到这一点，SaaS产品需要首先拥有完善的团队账户架构，能够支持每个个体用户使用实名账户，被初始管理员授予合适的权限，如果有多个团队，还可能需要团队管理员这个角色来减轻大管家的压力。为了加入新成员，调整成员和分组的过程必须足够清晰和简单，让客户有动力来维持这个用户系统。相反，如果我们在这个问题上忽视，胡乱地分配一些001，002工号出去，甚至允许用户合用账号，那客户总是会走到混乱失序的那一天，距离客户流失也就不远了。 仅仅有了科学完善的账户结构体系还不够，我们还要帮助企业穿针引线，让多成员进入这个系统非常简单和轻松。比如一个BI应用，在配置外部数据源的时候，需要用户添加Google Analytics的Profile，问题是掌握这个信息的人可能不是管理员本人，他可能需要同事的帮忙才能完成这个配置，这时候软件可能需要直接将邀请成员完成一个配置作为一个用例来对待，设计出专门的交互界面。 有一次在机场顿悟，昂贵的机场设施和几乎所有的机场地勤人员其实只为一个事情，让乘客登上飞机。而我们去机场，其实是为了坐飞机旅行，我们不一定意识到onboarding的过程这么重要和昂贵。 当一个SaaS产品意识到这一点，把帮助用户上船，上飞机作为一个大型项目来看待，它距离成熟就不远了。 支持外部数据整合的开放性最后一点，成熟的SaaS产品必然考虑开放性，如果没有API，几乎就不可能成为一个长期存在的SaaS产品 一个标准化的SaaS软件可能增强到特性丰富，组织有序的良好状态，但是它绝无可能提供用户所要的所有功能，企业用户结合使用多个产品工具解决业务问题是一个常态。有了丰富的编程接口，至少让用户有机会能够通过变通的办法来实现他之所想。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）]]></title>
    <url>%2F2020%2F04%2F19%2FTs%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[TypeScript类型系统@types全局@types@types 支持全局和模块类型定义 npm install @type/jquery --save-dev 默认情况下，TypeScript 会自动包含支持全局使用的任何声明定义 局部@types安装完成后不需要做特别配置，只要想使用模块一样使用它一样 import * as $ from &#39;jquery&#39; 可以在typeconfig.json中可以配置有意义的类型 { compilerOptions{ &quot;type&quot; :[ &quot;jquery&quot; ] } } 声明文件可以使用declear关键字来告诉typescript，你试图表诉一个其他地方已经存在的代码 foo = 123 declear var foo:any foo = 123 在实际项目可以新建一个global.d.ts文件来把这些声明放到里面 接口接口运行时的影响为0.有多种方式可以声明变量的结构 //等效声明 //内联注解 declear const myPoint = {x:number,y:number} //接口实现 interface myPoint{ x: number, y: number } 类来实现接口interface myPoint{ x: string, y: string } class point implements myPoint{ x: string, y: string } 注意：并非每个接口都容易实现 interface Crazy{ new() { value: number } } class CrazyClass implements Crazy{ constructor(){ return { value: 123 } } } const crazy = new CrazyClass() 枚举枚举是收集有关连变量的一种方式, 作用就是管理常量，让常量更规范统一 数字枚举enum CradSuit{ Clubs, Diamonds, Hearts, Spades } let clubs = CradSuot.Clubs 字符串枚举enum CradSuit{ Clubs, Diamonds, Hearts, Spades } console.log(CardSuit.Clubs[0]) // &#39;Clubs&#39; console.log(CardSuit.[&#39;Diamonds&#39;]) // 0 改变与枚举关联的数字 enum CradSuit{ Clubs , // 0 Diamonds, // 1 Hearts, // 2 Spades // 3 } enum CradSuit{ Clubs = 3, // 3 Diamonds, // 4 Hearts, // 5 Spades // 6 常量枚举enum Fruit { Apple, banner, orange } console.log(Fruit.orange) // 2 静态方法的枚举enum Weekday{ Monday, Tuesday, Wednesday, Thursday, Friday, Saturday Sunday } namesapce Weekday{ export function isBusinessDay(weekday: Weekday){ switch(weekday){ case Weekday.Saturday: case Weekday.Sunday: return false; default: return true; } } } const mon = Weekday.Monday; const sun = Weekday.Sunday; console.log(Weekday.isBusinessDay(mon)); // true console.log(Weekday.isBusinessDay(sun)); lib.d.ts安装typescript的时候会有附带一个lib.d.ts的文件，里面的内容定义了(window,document,math，data,string)的变量声明 函数可组合系统的核心构建块 返回函数类型注解interface Foo { foo: string } function foo(sameple: foo) :foo{ console.log(foo) } 可选参数及默认参数值属性function person(speak:string =&quot;hello world&quot;,age?:number){ console.log(speak,age) } person(&#39;你好&#39;) person(...12) 函数重载function addOne(a:number,y?:number,z?:number,x?:number){ if(x === undefined &amp;&amp; y === undefined &amp;&amp; z === undefined){ x = y = z = a }else if( y === undefined &amp;&amp; z === undefined ){ z = a x = y } return { top: a, left: x, right: y, bottom: z } } addOne(1) addOne(1,1,1,1) 函数声明type londHand = { (a:number) : number } type ShortHand = (a:number) =&gt;{number} 可调用的interface Complex { (foo:string,age?:number,...other,boolean[]):number } 类型断言TypeScript 允许你覆盖它的推断，并且能以你任何你想要的方式分析它，这种机制被称为「类型断言」 as foo 与 &lt;foo&gt; &lt;foo&gt;可能会与jsx中冲突，推荐使用as foo 双重断言function handle(event:Event){ console.log(element = (event as any) as HTMLElement) } Freshness为了能让检查对象字面量类型更容易，提供Freshness更严格的类型检查 类型保护你可以使用更小范围的对象类型 typeof instanceof 字面量类型你可以使用一个准备的类型来定义一个对象 readOnly如字面意思一样，是只读的，不能随便更改的，是一种更安全的方式 type Foo = { readonly bar: number; readonly bas: number; }; // 初始化 const foo: Foo = { bar: 123, bas: 456 }; // 不能被改变 foo.bar = 456; // Error: foo.bar 为仅读属性 与const不同 const 用于变量，变量不能重新赋给其他任何事物 readOnly 用于属性，用于别名可以修改属性 泛型他的用途就是在你不确定要穿的值的属性时，那么就可以使用泛型去确定在成员之间提供有意义的约束，这些成员可以是： 类的实例成员 类的方法 函数参数 函数返回值 class Queue&lt;T&gt;{ private data: T[] = [] push = (item:&lt;T&gt;) =&gt; {this.data.push(item)} pop = ():T | undefiend =&gt; {this.data.shift()} } const queue = new Queue&lt;number&gt;() queue.push(1) queue.shift(&#39;1&#39;) // error &#39;1&#39; is string 你可以随意调用泛型参数，当你使用简单的泛型时，泛型常用 T、U、V 表示 类型推断TypeScript 能根据一些简单的规则推断（检查）变量的类型，你可以通过实践，很快的了解它们。 定义变量，函数返回类型，赋值，解构，结构化等都可以推断出类型 类型兼容性用于确定一个类型是否能赋值给其他类型 协变逆变，双向协变，不变 nevernever 类型是 TypeScript 中的底层类型。它自然被分配的一些例子： 一个从来不会有返回值的函数（如：如果函数内含有 while(true) {}）；一个总是会抛出错误的函数（如：function foo() { throw new Error(&#39;Not Implemented&#39;) }，foo 的返回类型是 never）； 但是，never 类型仅能被赋值给另外一个 never 用例：详细的检查function foo(x:string | number):boolean { if (typeof x === &#39;string&#39;) { return true; } else if (typeof x === &#39;number&#39;) { return false; } // 如果不是一个 never 类型，这会报错： // - 不是所有条件都有返回值 （严格模式下） // - 或者检查到无法访问的代码 // 但是由于 TypeScript 理解 `fail` 函数返回为 `never` 类型 // 它可以让你调用它，因为你可能会在运行时用它来做安全或者详细的检查。 return fail(&#39;Unexhaustive&#39;); } function fail(message: string): never { throw new Error(message); } never与void的区别void 表示没有任何类型，never 表示永远不存在的值的类型。 辨析联合类型当类中含有字面量成员时，我们可以用该类的属性来辨析联合类型。 interface Square { kind: &#39;square&#39;; size: number; } interface Rectangle { kind: &#39;rectangle&#39;; width: number; height: number; } type Shape = Square | Rectangle; 流动的类型TypeScript 类型系统非常强大，它支持其他任何单一语言无法实现的类型流动和类型片段。关键的动机：当你改变了其中一个时，其他相关的会自动更新，并且当有事情变糟糕时，你会得到一个友好的提示，就好像一个被精心设计过的约束系统。 复制类型和值如果你想移动一个类，你可能会想要做以下事情： class Foo {} const Bar = Foo; let bar: Bar; // Error: 不能找到名称 &#39;Bar&#39; //这会得到一个错误，因为 const 仅仅是复制了 Foo 到一个变量声明空间，因此你无法把 Bar 当作一个类型声明使用。正确的方式是使用 import 关键字，请注意，如果你在使用 namespace 或者 modules，使用 import 是你唯一能用的方式： namespace importing { export class Foo {} } import Bar = importing.Foo; let bar: Bar; // ok //这个 import 技巧，仅适合于类型和变量。 捕获变量的类型你可以通过 typeof 操作符在类型注解中使用变量 异常处理JavaScript 有一个 Error 类，用于处理异常。你可以通过 throw 关键字来抛出一个错误。然后通过 try/catch 块来捕获此错误： try{ throw new Error(&#39;Something bad happened&#39;); }catch(e){ console.log(e) } 除内置的 Error 类外，还有一些额外的内置错误，它们继承自 Error 类：RangeError,ReferenceError,SyntaxError,TypeError,URIError 混合TypeScript (和 JavaScript) 类只能严格的单继承，因此你不能做： class User extends Tagged, Timestamped { // ERROR : 不能多重继承 // .. } 从可重用组件构建类的另一种方式是通过基类来构建它们，这种方式称为混合。 常见的typescript错误常见的typescript错误]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是laaS,PaaS,SaaS?]]></title>
    <url>%2F2020%2F04%2F16%2F%E6%9C%8D%E5%8A%A1%2F%E4%BB%80%E4%B9%88%E6%98%AFlaaS-PaaS-SaaS%2F</url>
    <content type="text"><![CDATA[前言 首先云服务器可以分为 IaaS：基础设施即服务，Infrastructure-as-a-service PaaS：平台即服务，Platform-as-a-service SaaS：软件即服务，Software-as-a-service 数据即服务：如阿里云对象存储，七牛云存储等 其他软件服务：机器学习、人工智能等 公司要开发一个SaaS云服务器的软件，借此来加深下lasS,PaaS,SaaS的概念及区别 比喻lasS,PaaS,SaaS比喻来自阮一峰的网站 请设想你是一个餐饮业者，打算做披萨生意。 你可以从头到尾，自己生产披萨，但是这样比较麻烦，需要准备的东西多，因此你决定外包一部分工作，采用他人的服务。你有三个方案。 （1）方案一：IaaS 他人提供厨房、炉子、煤气，你使用这些基础设施，来烤你的披萨。 （2）方案二：PaaS 除了基础设施，他人还提供披萨饼皮。你只要把自己的配料洒在饼皮上，让他帮你烤出来就行了。也就是说，你要做的就是设计披萨的味道（海鲜披萨或者鸡肉披萨），他人提供平台服务，让你把自己的设计实现。 （3）方案三：SaaS 他人直接做好了披萨，不用你的介入，到手的就是一个成品。你要做的就是把它卖出去，最多再包装一下，印上你自己的 Logo。 从左到右，自己承担的工作量（上图蓝色部分）越来越少，IaaS &gt; PaaS &gt; SaaS。 对应软件开发，则是下面这张图。 SaaS 是软件的开发、管理、部署都交给第三方，不需要关心技术问题，可以拿来即用。普通用户接触到的互联网服务，几乎都是 SaaS，下面是一些例子。 客户管理服务 Salesforce 团队协同服务 Google Apps 储存服务 Box 储存服务 Dropbox 社交服务 Facebook / Twitter / Instagram PaaS 提供软件部署平台（runtime），抽象掉了硬件和操作系统细节，可以无缝地扩展（scaling）。开发者只需要关注自己的业务逻辑，不需要关注底层。下面这些都属于 PaaS。 Heroku Google App Engine OpenShift IaaS 是云服务的最底层，主要提供一些基础资源。它与 PaaS 的区别是，用户需要自己控制底层，实现基础设施的使用逻辑。下面这些都属于 IaaS。 Amazon EC2 Digital Ocean RackSpace Cloud SaaS详细介绍我们将着重介绍SaaS架构设计,并围绕WHAT（是什么？）、WHY（为什么？）、WHERE（在哪里？）和HOW（怎么样？）这四个问题 什么是SaaS？ 从宏观的角度来看，SaaS是一种软件应用程序交付方式，软件提供商集中化托管一个或多个软件应用程序，并通过互联网向租户体用这些软件应用程序;从分类上讲SaaS也是云计算的一部分 SaaS应用程序的任何更新或者修复漏洞操作都是由软件提供商负责实施和处理的，由于租户是通过互联网获取软件服务，所以租户端无需下载任何的升级包或者修复补丁，是一种开箱即获取最新软件产品的服务方式。 为什么选择SaaS？1.消费者角度获取软件服务的方式足够简单，SaaS也许是迄今为止使用软件最简单的方式之一，租户只需要动动鼠标和键盘，即可在几小时甚至几分钟内获得一个大型的软件服务。相比于传统使用软件的方式，租户省去了研发、部署、运维等一系列繁复的过程，且获得软件的时间和费用成本都大幅度降低 2.商业角度SaaS可以体用跨地域、跨平台的软件服务。与此同时，软件服务商可以统一对软件进行版本管理，这将带来以下几点好处（包括但不限于）： 1、缩短产品上线时间：多端适配，统一版本，统一更新2、降低维护成本：不需要同时维护多个版本的软件实例，运维压力减小3、容易升级：由于版本得到有效控制，一次升级，即可覆盖所有租户端 SaaS的特性及优势是什么?1.简单2.经济实惠3.安全4.兼任性 SaaS软件的适用范围从理论上讲，SaaS可以将任何的软件SaaS，下面列举一些通用的分类供大家参考： 1、Office在线办公类SaaS产品2、电子邮件和即时消息类SaaS产品3、社交媒体类SaaS产品4、第三方API类SaaS产品5、安全和访问控制类SaaS产品6、机器学习类SaaS产品7、人工智能类SaaS产品8、地理位置服务类SaaS产品9、数据流和数据检索类SaaS产品 SaaS产品的缺陷1.软件控制权与企业内部部署的软件不同，由于SaaS软件被击中托管在服务提供商的Web服务器中，所以租户无法控制所有的软件应用程序，SaaS化的软件比企业自行部署的软件获得的控制权更少，租户可操作的自定义控制权极度有限。 2.消费者基数小由于SaaS软件是将一套应用程序共享给一个或者多个租户共同使用，这种共享的消费方式还未被大多数的消费者所接受。同时，受制于市场环境的影响，目前还有大多数的软件还未SaaS化 3.性能瓶颈共享应用程序必然会带来服务器性能的下降、如计算速度、网络资源、I/O读写等都将面临严峻的考验。在性能方面，企业内部部署的“独享模式”的应用程序比SaaS软件的“共享模式”略胜一筹。 4.安全问题当租户在选择一款SaaS产品时，产品的安全性将会被放置在第一位进行考虑。如数据的隔离、敏感数据的加密、数据访问权限控制、个人隐私等问题。 SaaS产品的核心组件不同类型的SaaS产品，由于要面对不同的用户愿景，可能在功能和业务上会有所不同，但任何一个SaaS产品，都具备以下几个共同的核心组件。 安全组件在SaaS产品中，系统安全永远是第一位需要考虑的事情，如何保障租户数据的安全，是你首要的事情。这如同银行首选需要保障储户资金安全一样。安全组件就是统一的对SaaS产品进行安全防护，保障系统数据安全。 数据隔离组件安全组件解决了用户数据安全可靠的问题，但数据往往还需要解决隐私问题，各企业之间的数据必须相互不可见，即相互隔离。在SaaS产品中，如何识别、区分、隔离个租户的数据时你在实施SaaS软件架构设计时需要考虑的第二个问题。 可配置组件尽管SaaS产品在设计之初就考虑了大多数通用的功能，让租户开箱即用，但任然有为数不少的租户需要定制服务自身业务需求的配置项，如UI布局、主题、标识（Logo）等信息。正因为无法抽象出一个完全通用的应用程序，所以在SaaS产品中，你需要提供一个可用于自定义配置的组件。 可扩展组件随着SaaS产品业务和租户数量的增长，原有的服务器配置将无法继续满足新的需求，系统性能将会与业务量和用户量成反比。此时，SaaS产品应该具备水平扩展的能力。如通过网络负载均衡其和容器技术，在多个服务器上部署多个软件运行示例并提供相同的软件服务，以此实现水平扩展SaaS产品的整体服务性能。为了实现可扩展能力，就需要SaaS展示层的代码与业务逻辑部分的代码进行分离，两者独立部署。例如使用VUE+微服务构建前后端分离且可水平进行扩展的分布式SaaS应用产品。对于可扩展，还有另外一种方式，即垂直扩展，其做法比较简单，也比较粗暴：通过增加单台服务器的配置，如购买性能更好的CUP、存储更大的内存条、增大带宽等措施，让服务器能够处理更多的用户请求。但此做法对于提升产品性能没有质的改变，且成本很高。 0停机时间升级产品以往的软件在升级或者修复Bug时，都需要将运行的程序脱机一段时间，等待升级或修复工作完成后，再重新启动应用程序。而SaaS产品则需要全天候保障服务的可用性。这就需要你考虑如何实现在不重启原有应用程序的情况下，完成应用程序的升级修复工作。 多租户组件要将原有产品SaaS化，就必须提供多租户组件，多租户组件是衡量一个应用程序是否具备SaaS服务能力的重要指标之一。SaaS产品需要同时容纳多个租户的数据，同时还需要保证各租户之间的数据不会相互干扰，保证租户中的用户能够按期望索引到正确的数据，多租户组件是你必须要解决的一个问题。其余的组件都将围绕此组件展开各自的业务。]]></content>
      <categories>
        <category>Serve</category>
      </categories>
      <tags>
        <tag>服务端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue.config.js基本配置]]></title>
    <url>%2F2020%2F04%2F01%2FVue%2Fvue-config-js%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[// vue.config.js 基本配置方法 module.exports = { // 项目部署的基础路径 // 我们默认假设你的应用将会部署在域名的根部， // 比如 https://www.my-app.com/ // 如果你的应用时部署在一个子路径下，那么你需要在这里 // 指定子路径。比如，如果你的应用部署在 // https://www.foobar.com/my-app/ // 那么将这个值改为 `/my-app/` // 基本路径 baseURL已经过时 publicPath: &#39;./&#39;, // 打包项目时构建的文件目录，用法与webpack本身的output.path一致 outputDir: &#39;dist&#39;, // 静态资源目录 (js, css, img, fonts) assetsDir: &#39;assets&#39;, // eslint-loader 是否在保存的时候检查，编译不规范时，设为true在命令行中警告，若设为error则不仅警告，并且编译失败 lintOnSave: true, // 调整内部的 webpack 配置。查阅 https://github.com/vuejs/vue-docs-zh-cn/blob/master/vue-cli/webpack.md chainWebpack: () =&gt; {}, configureWebpack: () =&gt; {}, // vue-loader 配置项 https://vue-loader.vuejs.org/en/options.html vueLoader: {}, // 生产环境是否生成 sourceMap 文件，默认true，若不需要生产环境的sourceMap，可以设置为false，加速生产环境的构建 productionSourceMap: true, // css相关配置 css: { // 是否使用css分离插件 ExtractTextPlugin，采用独立样式文件载入，不采用&lt;style&gt;方式内联至html文件中 extract: true, // 是否在构建样式地图，false将提高构建速度 sourceMap: false, // css预设器配置项 loaderOptions: {}, // 启用 CSS modules for all css / pre-processor files. // 这个选项不会影响 `*.vue` 文件 modules: false }, // 在生产环境下为 Babel 和 TypeScript 使用 `thread-loader` // 在多核机器下会默认开启。 parallel: require(&#39;os&#39;).cpus().length &gt; 1, // 是否启用dll See https://github.com/vuejs/vue-cli/blob/dev/docs/cli-service.md#dll-mode dll: false, // PWA 插件相关配置 see https://github.com/vuejs/vue-cli/tree/dev/packages/%40vue/cli-plugin-pwa pwa: {}, // webpack-dev-server 相关配置 devServer: { open: process.platform === &#39;darwin&#39;, host: &#39;0.0.0.0&#39;,//如果是真机测试，就使用这个IP port: 1234, https: false, hotOnly: false, proxy: null, // 设置代理 // proxy: { // &#39;/api&#39;: { // target: &#39;&lt;url&gt;&#39;, // ws: true, // changOrigin: true // } // }, before: app =&gt; {} }, // 第三方插件配置 pluginOptions: { // ... } }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[（一）]]></title>
    <url>%2F2020%2F03%2F25%2FTs%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3TypeScript%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[书本地址https://jkchao.github.io/typescript-book-chinese/#why 什么是TypeScript,为什么要使用TypeScript?根据TypeScript官网中的介绍，TypeScript - JavaScript the scales (属于Js的超集)，Ts发展至今已经是很多大型项目的标配，它提供的静态类型检查，大大的提高了代码的可维护性及可读性；同时提供最新和不断发展的Javascript特性，让我们能建立更加强壮的组件。 从tsconfig.json配置看ts整体创建tsconfig.json文件，配置信息通过compilerOption来定制你的编译选项 { &quot;compilerOptions&quot;: { /* 基本选项 */ &quot;target&quot;: &quot;es5&quot;, // 指定 ECMAScript 目标版本: &#39;ES3&#39; (default), &#39;ES5&#39;, &#39;ES2015&#39;, &#39;ES2016&#39;, &#39;ES2017&#39;, or &#39;ESNEXT&#39; &quot;module&quot;: &quot;commonjs&quot;, // 指定使用模块: &#39;commonjs&#39;, &#39;amd&#39;, &#39;system&#39;, &#39;umd&#39; or &#39;es2015&#39; &quot;lib&quot;: [], // 指定要包含在编译中的库文件 &quot;allowJs&quot;: true, // 允许编译 javascript 文件 &quot;checkJs&quot;: true, // 报告 javascript 文件中的错误 &quot;jsx&quot;: &quot;preserve&quot;, // 指定 jsx 代码的生成: &#39;preserve&#39;, &#39;react-native&#39;, or &#39;react&#39; &quot;declaration&quot;: true, // 生成相应的 &#39;.d.ts&#39; 文件 &quot;sourceMap&quot;: true, // 生成相应的 &#39;.map&#39; 文件 &quot;outFile&quot;: &quot;./&quot;, // 将输出文件合并为一个文件 &quot;outDir&quot;: &quot;./&quot;, // 指定输出目录 &quot;rootDir&quot;: &quot;./&quot;, // 用来控制输出目录结构 --outDir. &quot;removeComments&quot;: true, // 删除编译后的所有的注释 &quot;noEmit&quot;: true, // 不生成输出文件 &quot;importHelpers&quot;: true, // 从 tslib 导入辅助工具函数 &quot;isolatedModules&quot;: true, // 将每个文件做为单独的模块 （与 &#39;ts.transpileModule&#39; 类似）. /* 严格的类型检查选项 */ &quot;strict&quot;: true, // 启用所有严格类型检查选项 &quot;noImplicitAny&quot;: true, // 在表达式和声明上有隐含的 any类型时报错 &quot;strictNullChecks&quot;: true, // 启用严格的 null 检查 &quot;noImplicitThis&quot;: true, // 当 this 表达式值为 any 类型的时候，生成一个错误 &quot;alwaysStrict&quot;: true, // 以严格模式检查每个模块，并在每个文件里加入 &#39;use strict&#39; /* 额外的检查 */ &quot;noUnusedLocals&quot;: true, // 有未使用的变量时，抛出错误 &quot;noUnusedParameters&quot;: true, // 有未使用的参数时，抛出错误 &quot;noImplicitReturns&quot;: true, // 并不是所有函数里的代码都有返回值时，抛出错误 &quot;noFallthroughCasesInSwitch&quot;: true, // 报告 switch 语句的 fallthrough 错误。（即，不允许 switch 的 case 语句贯穿） /* 模块解析选项 */ &quot;moduleResolution&quot;: &quot;node&quot;, // 选择模块解析策略： &#39;node&#39; (Node.js) or &#39;classic&#39; (TypeScript pre-1.6) &quot;baseUrl&quot;: &quot;./&quot;, // 用于解析非相对模块名称的基目录 &quot;paths&quot;: {}, // 模块名到基于 baseUrl 的路径映射的列表 &quot;rootDirs&quot;: [], // 根文件夹列表，其组合内容表示项目运行时的结构内容 &quot;typeRoots&quot;: [], // 包含类型声明的文件列表 &quot;types&quot;: [], // 需要包含的类型声明文件名列表 &quot;allowSyntheticDefaultImports&quot;: true, // 允许从没有设置默认导出的模块中默认导入。 /* Source Map Options */ &quot;sourceRoot&quot;: &quot;./&quot;, // 指定调试器应该找到 TypeScript 文件而不是源文件的位置 &quot;mapRoot&quot;: &quot;./&quot;, // 指定调试器应该找到映射文件而不是生成文件的位置 &quot;inlineSourceMap&quot;: true, // 生成单个 soucemaps 文件，而不是将 sourcemaps 生成不同的文件 &quot;inlineSources&quot;: true, // 将代码与 sourcemaps 生成到一个文件中，要求同时设置了 --inlineSourceMap 或 --sourceMap 属性 /* 其他选项 */ &quot;experimentalDecorators&quot;: true, // 启用装饰器 &quot;emitDecoratorMetadata&quot;: true // 为装饰器提供元数据的支持 } } Ts编译生成Js文件在目录下运行 tsc命令，会在当前目录或者父级目录下找tsconfig.json文件运行 tsc -p ./path-to-project-directory 。当然，这个路径可以是绝对路径，也可以是相对于当前目录的相对路径。使用 tsc -w 来启用 TypeScript 编译器的观测模式，在检测到文件改动之后，它将重新编译。 显示的指定编译文件{ &quot;files&quot;: [ &quot;./some/file.ts&quot; ] } 声明空间类型声明空间（class interface type）class Foo{} interface Bar{} type Bas{} 注意：尽管你定义了 interface Bar，却并不能够把它作为一个变量来使用，因为它没有定义在变量声明空间中。 变量声明空间class Foo {} const someOne = Foo const someOneVar = 123 注意 一些用 var 声明的变量，也只能在变量声明空间使用，不能用作类型注解。 模块全局模块类似js的中全局对象，是一种不安全的方式，可使用文件模块代替 const Foo = 123 const Bar = Foo 文件模块文件模块也可以叫做外部模块，通过import,export导入导出，从而才能使用 //foo.js export const foo = 123 //bar.js import {foo} from &#39;./foo.js&#39; const bar = foo 文件模块详情ES模块语法导出 //使用 export 关键字导出一个变量或类型 export const someVar = 123; export type someType = { foo: string; }; // export 的写法除了上面这种，还有另外一种： const someVar = 123; type someType = { type: string; }; export { someVar, someType }; // 可以用重命名变量的方式导出： const someVar = 123; export { someVar as aDifferentName }; 导入 //使用 import 关键字导入一个变量或者是一个类型： import { someVar, someType } from &#39;./foo&#39;; //通过重命名的方式导入变量或者类型： import { someVar as aDifferentName } from &#39;./foo&#39; //可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面： // 你可以使用 `foo.someVar` 和 `foo.someType` 以及其他任何从 `foo` 导出的变量或者类型 import * as foo from &#39;./foo&#39;; //只导入模块： import &#39;core-js&#39;; // 一个普通的 polyfill 库 //从其他模块导入后整体导出： export * from &#39;./foo&#39;; //从其他模块导入后，部分导出： export { someVar } from &#39;./foo&#39;; //通过重命名，部分导出从另一个模块导入的项目： export { someVar as aDifferentName } from &#39;./foo&#39;; //默认导入／导出,使用 export default // some var export default (someVar = 123); //导入使用 import someName from &#39;someModule&#39; 语法（你可以根据需要为导入命名）： import someLocalNameForThisFile from &#39;./foo&#39;; 模块路径这里存在两种截然不同的模块： 相对模块路径（路径以 . 开头，例如：./someFile 或者 ../../someFolder/someFile 等）；其他动态查找模块（如：core-js，typestyle，react 或者甚至是 react/core 等）。 什么是 place这个点指的应该是一个模块查找的过程 重写类型的动态查找在项目里，可以通过declare module &#39;somePath&#39; 声明一个全局模块的方式，来解决查找模块路径的问题。 import/require 仅仅是导入类型它实际上只做了两件事： 导入 foo 模块的所有类型信息； 确定 foo 模块运行时的依赖关系。 命名空间在 JavaScript 可以使用匿名函数创建一个命名空间 (function(something) { something.foo = 123; })(something || (something = {})); TypeScript 提供了 namespace 关键字来描述这种分组 namespace Utility { export function log(msg) { console.log(msg); } export function error(msg) { console.log(msg); } } // usage Utility.log(&#39;Call me&#39;); Utility.error(&#39;maybe&#39;); 动态导入表达式动态导入表达式是 ECMAScript 的一个新功能，它允许你在程序的任意位置异步加载一个模块]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的箭头函数]]></title>
    <url>%2F2020%2F03%2F15%2FJs%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[简言ES6的箭头函数，我们会在工作中经常知道，但是你知道什么时候使用箭头函数，什么时候不能使用箭头函数吗？ 什么时候使用箭头函数？ 为啥大多数情况都使用箭头函数？ 作用域安全性:当箭头函数被一致使用时，所有东西都保证使用与根对象相同的this。如果一个标准函数回调与一堆箭头函数混合在一起，那么作用域就有可能变得混乱。 紧凑性:箭头函数更容易读写。 清晰度:使用箭头函数可明确知道当前 this 指向 其它情况使用箭头函数。 什么时候不能使用箭头函数？定义对象方法定义字面量的方法const calculator = { array: [1, 2, 3], sum: () =&gt; { console.log(this === window); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); } }; console.log(this === window); // =&gt; true // Throws &quot;TypeError: Cannot read property &#39;reduce&#39; of undefined&quot; calculator.sum(); calculator.sum 使用箭头函数来定义，但是调用的时候会抛出 TypeError，因为运行时 this.array 是未定义的，调用 calculator.sum 的时候，执行上下文里面的 this 仍然指向的是 window，原因是箭头函数把函数上下文绑定到了 window 上，this.array 等价于 window.array，显然后者是未定义的。 解决的办法是，使用函数表达式或者方法简写（ES6 中已经支持）来定义方法，这样能确保 this 是在运行时是由包含它的上下文决定的， const calculator = { array: [1, 2, 3], sum() { console.log(this === calculator); // =&gt; true return this.array.reduce((result, item) =&gt; result + item); } }; calculator.sum(); // =&gt; 6 定义原型方法同样的规则适用于原型方法（prototype method）的定义，使用箭头函数会导致运行时的执行上下文错误 function Cat(name) { this.name = name; } Cat.prototype.sayCatName = () =&gt; { console.log(this === window); // =&gt; true return this.name; }; const cat = new Cat(&#39;Mew&#39;); cat.sayCatName(); // =&gt; undefined 解决方法:使用传统的函数表达式就能解决问题 定义事件回调函数const button = document.getElementById(&#39;myButton&#39;); button.addEventListener(&#39;click&#39;, () =&gt; { console.log(this === window); // =&gt; true this.innerHTML = &#39;Clicked button&#39;; }); 在全局上下文下定义的箭头函数执行时 this 会指向 window，当单击事件发生时，浏览器会尝试用 button 作为上下文来执行事件回调函数，但是箭头函数预定义的上下文是不能被修改的，这样 this.innerHTML 就等价于 window.innerHTML，而后者是没有任何意义的。 解决方法:使用传统的函数表达式就能解决问题 定义构造函数构造函数中的 this 指向新创建的对象，当执行 new Car() 的时候，构造函数 Car 的上下文就是新创建的对象，也就是说 this instanceof Car === true。显然，箭头函数是不能用来做构造函数， 实际上 JS 会禁止你这么做，如果你这么做了，它就会抛出异常。 const Message = (text) =&gt; { this.text = text; }; // Throws &quot;TypeError: Message is not a constructor&quot; const helloMessage = new Message(&#39;Hello World!&#39;); 追求过短的代码在代码可读性方面，最短的代码可能并不总是最好的。一定程度上，压缩了太多逻辑的简短代码，阅读起来就没有那么直观， const multiply = (a, b) =&gt; b === undefined ? b =&gt; a * b : a * b; const double = multiply(2); double(3); // =&gt; 6 multiply(2, 3); // =&gt; 6 multiply 函数会返回两个数字的乘积或者返回一个可以继续调用的固定了一个参数的函数。代码看起来很简短，但大多数人第一眼看上去可能无法立即搞清楚它干了什么，怎么让这段代码可读性更高呢？有很多办法，可以在箭头函数中加上括号、条件判断、返回语句，或者 function multiply(a, b) { if (b === undefined) { return function (b) { return a * b; } } return a * b; } const double = multiply(2); double(3); // =&gt; 6 multiply(2, 3); // =&gt; 6]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的 JSON.stringify() 的威力]]></title>
    <url>%2F2019%2F12%2F12%2FJs%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84-JSON-stringify-%E7%9A%84%E5%A8%81%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[原文地址 通过需求学习JSON.stringify()首先我们在开发的过程当中遇到这样一个处理数据的需求 const todayILearn = { _id: 1, content: &#39;今天学习 JSON.stringify()，我很开心！&#39;, created_at: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;, updated_at: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; } 我们需要将上面这个对象处理成下面这个对象 const todayILearn = { id: 1, content: &#39;今天学习 JSON.stringify()，我很开心！&#39;, createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;, updatedAt: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; } 也就是在不改变属性的值的前提下，将对象属性修改一下。 把_id 改成 id，把 updated_at 改成 updatedAt，把 created_at 改成 createdAt。我们现在通过这个小小的需求来见识一下 JSON.stringify() 的强大吧。 首先要解决这个问题我们有很多种解决方式，我们先提供两种不优雅的解决方案： 方案一：一次遍历+多声明一个变量 // 多一个变量存储 const todayILearnTemp = {}; for (const [key, value] of Object.entries(todayILearn)) { if (key === &quot;_id&quot;) todayILearnTemp[&quot;id&quot;] = value; else if (key === &quot;created_at&quot;) todayILearnTemp[&quot;createdAt&quot;] = value; else if (key === &quot;updatedAt&quot;) todayILearnTemp[&quot;updatedAt&quot;] = value; else todayILearnTemp[key] = value; } console.log(todayILearnTemp); // 结果： // { id: 1, // content: &#39;今天学习 JSON.stringify()，我很开心！&#39;, // createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;, // updated_at: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; // } 方案一完全没有问题，可以实现。但是多声明了一个变量又加上一层循环并且还有很多的 if else 语句，怎么都显得不太优雅。 方案二：暴力 delete 属性和增加属性 // 极致的暴力美学 todayILearn.id = todayILearn._id; todayILearn.createdAt = todayILearn.created_at; todayILearn.updatedAt = todayILearn.updated_at; delete todayILearn._id; delete todayILearn.created_at; delete todayILearn.updated_at; console.log(todayILearn); // 太暴力😢 //{ // content: &#39;今天学习 JSON.stringify()，我很开心！&#39;, // id: 1, // createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;, // updatedAt: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; //} 直接 delete 暴力解决太粗鲁了，而且有一个缺点，属性的顺序变了。 方案三：序列化+ replace 美学典范 const mapObj = { _id: &quot;id&quot;, created_at: &quot;createdAt&quot;, updated_at: &quot;updatedAt&quot; }; JSON.parse( JSON.stringify(todayILearn).replace( /_id|created_at|updated_at/gi, matched =&gt; mapObj[matched]) ) // { // id: 1, // content: &#39;今天学习 JSON.stringify()，我很开心！&#39;, // createdAt: &#39;Mon Nov 25 2019 14:03:55 GMT+0800 (中国标准时间)&#39;, // updatedAt: &#39;Mon Nov 25 2019 16:03:55 GMT+0800 (中国标准时间)&#39; // } JSON.stringify() 九大特性JSON.stringify()第一大特性对于 undefined、任意的函数以及 symbol 三个特殊的值分别作为对象属性的值、数组元素、单独的值时 JSON.stringify()将返回不同的结果。 首先，我们来复习一下知识点，看一道非常简单的面试题目：请问下面代码会输出什么？ const data = { a: &quot;aaa&quot;, b: undefined, c: Symbol(&quot;dd&quot;), fn: function() { return true; } }; JSON.stringify(data); // 输出：？ // &quot;{&quot;a&quot;:&quot;aaa&quot;}&quot; 很简单这道题目面试官主要考察的知识点是： undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 将跳过（忽略）对它们进行序列化 面试官追问：假设 undefined、任意的函数以及 symbol 值作为数组元素会是怎样呢？ JSON.stringify([&quot;aaa&quot;, undefined, function aa() { return true }, Symbol(&#39;dd&#39;)]) // 输出：？ // &quot;[&quot;aaa&quot;,null,null,null]&quot; 知识点是： undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 会将它们序列化为 null 我们稍微再动下脑筋，如果单独序列化这些值会是什么样的结果呢？ JSON.stringify(function a (){console.log(&#39;a&#39;)}) // undefined JSON.stringify(undefined) // undefined JSON.stringify(Symbol(&#39;dd&#39;)) // undefined 单独转换的结果就是： undefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时都会返回 undefined JSON.stringify() 第一大特性总结undefined、任意的函数以及 symbol 作为对象属性值时 JSON.stringify() 对跳过（忽略）它们进行序列化undefined、任意的函数以及 symbol 作为数组元素值时，JSON.stringify() 将会将它们序列化为 nullundefined、任意的函数以及 symbol 被 JSON.stringify() 作为单独的值进行序列化时，都会返回 undefined JSON.stringify() 第二大特性非数组对象的属性不能保证以特定的顺序出现在序列化后的字符串中。 const data = { a: &quot;aaa&quot;, b: undefined, c: Symbol(&quot;dd&quot;), fn: function() { return true; }, d: &quot;ddd&quot; }; JSON.stringify(data); // 输出：？ // &quot;{&quot;a&quot;:&quot;aaa&quot;,&quot;d&quot;:&quot;ddd&quot;}&quot; JSON.stringify([&quot;aaa&quot;, undefined, function aa() { return true }, Symbol(&#39;dd&#39;),&quot;eee&quot;]) // 输出：？ // &quot;[&quot;aaa&quot;,null,null,null,&quot;eee&quot;]&quot; 正如我们在第一特性所说，JSON.stringify() 序列化时会忽略一些特殊的值，所以不能保证序列化后的字符串还是以特定的顺序出现（数组除外）。 JSON.stringify() 第三大特性 转换值如果有 toJSON() 函数，该函数返回什么值，序列化结果就是什么值，并且忽略其他属性的值。 JSON.stringify({ say: &quot;hello JSON.stringify&quot;, toJSON: function() { return &quot;today i learn&quot;; } }) // &quot;today i learn&quot; JSON.stringify()第四大特性JSON.stringify() 将会正常序列化 Date 的值。 JSON.stringify({ now: new Date() }); // &quot;{&quot;now&quot;:&quot;2019-12-08T07:42:11.973Z&quot;}&quot; 实际上 Date 对象自己部署了 toJSON() 方法（同Date.toISOString()），因此 Date 对象会被当做字符串处理。 JSON.stringify() 第五大特性NaN 和 Infinity 格式的数值及 null 都会被当做 null。 JSON.stringify(NaN) // &quot;null&quot; JSON.stringify(null) // &quot;null&quot; JSON.stringify(Infinity) // &quot;null&quot; JSON.stringify() 第六大特性布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值。 JSON.stringify([new Number(1), new String(&quot;false&quot;), new Boolean(false)]); // &quot;[1,&quot;false&quot;,false]&quot; JSON.stringify() 第七大特性关于对象属性的是否可枚举： 其他类型的对象，包括 Map/Set/WeakMap/WeakSet，仅会序列化可枚举的属性。 // 不可枚举的属性默认会被忽略： JSON.stringify( Object.create( null, { x: { value: &#39;json&#39;, enumerable: false }, y: { value: &#39;stringify&#39;, enumerable: true } } ) ); // &quot;{&quot;y&quot;:&quot;stringify&quot;}&quot; JSON.stringify() 第八大特性我们都知道实现深拷贝最简单粗暴的方式就是序列化：JSON.parse(JSON.stringify())，这个方式实现深拷贝会因为序列化的诸多特性从而导致诸多的坑点：比如现在我们要说的循环引用问题。 // 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 const obj = { name: &quot;loopObj&quot; }; const loopObj = { obj }; // 对象之间形成循环引用，形成闭环 obj.loopObj = loopObj; // 封装一个深拷贝的函数 function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); } // 执行深拷贝，抛出错误 deepClone(obj) /** VM44:9 Uncaught TypeError: Converting circular structure to JSON --&gt; starting at object with constructor &#39;Object&#39; | property &#39;loopObj&#39; -&gt; object with constructor &#39;Object&#39; --- property &#39;obj&#39; closes the circle at JSON.stringify (&lt;anonymous&gt;) at deepClone (&lt;anonymous&gt;:9:26) at &lt;anonymous&gt;:11:13 */ 对包含循环引用的对象（对象之间相互引用，形成无限循环）执行此方法，会抛出错误。 这也就是为什么用序列化去实现深拷贝时，遇到循环引用的对象会抛出错误的原因 JSON.stringify() 第九大特性所有以 symbol 为属性键的属性都会被完全忽略掉，即便 replacer 参数中强制指定包含了它们。 JSON.stringify({ [Symbol.for(&quot;json&quot;)]: &quot;stringify&quot; }, function(k, v) { if (typeof k === &quot;symbol&quot;) { return v; } }) // undefined replacer 是 JSON.stringify() 的第二个参数，我们比较少用到，所以很多时候我们会忘记 JSON.stringify() 第二个、第三个参数，场景不多，但是用的好的话会非常方便，关于 JSON.stringify() 第九大特性的例子中对 replacer 参数不明白的同学先别急，其实很简单，我们马上就会在下面的学习中弄懂。 第二个参数和第三个参数JSON.stringify() 第二个参数和第三个参数 强大的第二个参数：作为函数时，它有两个参数，键（key）和值（value），函数类似就是数组方法 map、filter 等方法的回调函数，对每一个属性值都会执行一次该函数（期间我们还简单实现过一个 map 函数）。如果 replacer 是一个数组，数组的值代表将被序列化成 JSON 字符串的属性名。 华丽的第三个参数：如果是一个数字, 则在字符串化时每一级别会比上一级别缩进多这个数字值的空格（最多10个空格）； 如果是一个字符串，则每一级别会比上一级别多缩进该字符串（或该字符串的前10个字符）。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用vue高阶组件]]></title>
    <url>%2F2019%2F11%2F25%2FVue%2F%E4%BD%BF%E7%94%A8vue%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[前文高阶组件(HOC)是一种架构模式，在 React 中非常常见，但也可以在 Vue 中使用。它可以被描述为一种在组件之间共享公共功能而不需要重复代码的方法。HOC 的目的是增强组件的功能。它允许在项目中实现可重用性和可维护性。 只要你向一个方法传入组件，然后返回一个新的组件，这就是一个 HOC。 高阶组件在以下方面非常有用: 1.操作属性。 2.操作数据和数据抽象。 3.代码重用 预备知识在我们开始教程之前，需要了解以下几点： 使用 Vue 框架的经验。知道如何使用 vue-cli 设置应用程序。JavaScript 和 Vue 的基本知识Node (8)npm (5.2.0) Vue 中的高阶组件模式虽然高阶组件通常与 React 相关联，但是为 Vue 组件创建高阶组件是很有可能的。在 Vue 中创建高阶组件的模式如下所示。 // hoccomponent.js import Vue from &quot;vue&quot; import ComponentExample from &#39;@/components/ComponentExample.vue&#39; const HoComponent = (component) =&gt; { return Vue.component(&#39;withSubscription&#39;, { render(createElement) { return createElement(component) } } } const HoComponentEnhanced = HoComponent(ComponentExample); 如上面的代码块所示，HoComponent 函数接受一个组件作为参数，并创建一个新组件来渲染传进来的组件。 一个简单的 HOC 示例在本教程中，我们将介绍一个使用高阶组件的示例。在介绍高阶组件之前，我们将了解在没有高阶组件的情况下，当前的代码库是如何工作的，然后了解如何进行抽象。 https://codesandbox.io/embed/llvq04nx4l 正如上面的 CodeSandbox 所示，该应用程序会显示一个纸业公司及其净资产的列表，以及《办公室》(美国)中的人物及其获奖情况。 我们获得应用程序所需的所有数据来源只有一个，那就是mockData.js文件。 // src/components/mockData.js const staff = [ { name: &quot;Michael Scott&quot;, id: 0, awards: 2 }, { name: &quot;Toby Flenderson&quot;, id: 1, awards: 0 }, { name: &quot;Dwight K. Schrute&quot;, id: 2, awards: 10 }, { name: &quot;Jim Halpert&quot;, id: 3, awards: 1 }, { name: &quot;Andy Bernard&quot;, id: 4, awards: 0 }, { name: &quot;Phyllis Vance&quot;, id: 5, awards: 0 }, { name: &quot;Stanley Hudson&quot;, id: 6, awards: 0 } ]; const paperCompanies = [ { id: 0, name: &quot;Staples&quot;, net: 10000000 }, { id: 1, name: &quot;Dundler Mufflin&quot;, net: 5000000 }, { id: 2, name: &quot;Michael Scott Paper Company&quot;, net: 300000 }, { id: 3, name: &quot;Prince Family Paper&quot;, net: 30000 } ]; export default { getStaff() { return staff; }, getCompanies() { return paperCompanies; }, increaseAward(id) { staff[id].awards++; }, decreaseAward(id) { staff[id].awards--; }, setNetWorth(id) { paperCompanies[id].net = Math.random() * (5000000 - 50000) + 50000; } }; 在上面的代码片段中，有几个 const 变量保存了公司和员工列表的信息。我们也导出了一些函数， 实现以下功能：返回员工列表返回公司列表增加和减少对特定员工的奖励，最后最后，设定公司的净值 接下来，我们看看 Staff.vue 和 Companies.vue 组件。 // src/components/Staff.vue &lt;template&gt; &lt;main&gt; &lt;h3&gt;Staff List&lt;/h3&gt; &lt;div v-for=&quot;(staff, i) in staffList&quot; :key=&quot;i&quot;&gt; {{ staff.name }}: {{ staff.awards }} Salesman of the year Award 🎉 &lt;button @click=&quot;increaseAwards(staff.id);&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decreaseAwards(staff.id);&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; import mockData from &quot;./mockData.js&quot;; export default { data() { return { staffList: mockData.getStaff() }; }, methods: { increaseAwards(id) { mockData.increaseAward(id); this.staffList = mockData.getStaff(); }, decreaseAwards(id) { mockData.decreaseAward(id); this.staffList = mockData.getStaff(); } } }; &lt;/script&gt; 在上面的代码块中，数据实例变量staffList被赋值为函数mockData.getStaff()返回的内容。我们也有increaseAwards和decreaseAwards函数，分别调用mockData.increaseAward 和 mockData.decreaseAward。传递给这些函数的id 是从渲染的模板中获得的。 // src/components/Companies.vue &lt;template&gt; &lt;main&gt; &lt;h3&gt;Paper Companies&lt;/h3&gt; &lt;div v-for=&quot;(companies, i) in companies&quot; :key=&quot;i&quot;&gt; {{ companies.name }} - ${{ companies.net }}&lt;button @click=&quot;setWorth(companies.id);&quot;&gt;Set Company Value&lt;/button&gt; &lt;/div&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; import mockData from &quot;./mockData.js&quot;; export default { data() { return { companies: mockData.getCompanies() }; }, methods: { setWorth(id) { mockData.setNetWorth(id); this.companies = mockData.getCompanies(); } } }; &lt;/script&gt; 在上面的代码块中，数据实例变量companies 被赋值为函数mockData.getCompanies()的返回内容。我们还有setWorth函数，它通过将公司的 id 传递给mockData.setNetWorth来设置一个随机值作为净值。传递给函数的id是从渲染的模板中获得的。 现在我们已经看到了这两个组件是如何工作的，我们可以 找出它们之间的共同点，并将其抽象如下： 从数据源获取数据 (mockData.js)onClick 函数 我们来看看如何将上面的操作放到高阶组件中，以避免代码重复并确保可重用性。 HoComponent 函数接受两个参数，一个组件和fetchData。fetchData方法用于确定要在表示组件中显示什么。这意味着无论在哪里使用高阶组件，作为fetchData 传递的函数都将被用来从mockData 中获取数据。 然后将数据实例returnedData 设置为fetchData的内容，然后作为props 传递给在高阶组件中创建的新组件。 让我们看看新创建的高阶组件如何在应用程序中使用。我们需要编辑Staff.vue 和Companies.vue。 // src/components/Staff.vue &lt;template&gt; &lt;main&gt; &lt;h3&gt;Staff List&lt;/h3&gt; &lt;div v-for=&quot;(staff, i) in returnedData&quot; :key=&quot;i&quot;&gt; {{ staff.name }}: {{ staff.awards }} Salesman of the year Award 🎉 &lt;button @click=&quot;increaseAwards(staff.id);&quot;&gt;+&lt;/button&gt; &lt;button @click=&quot;decreaseAwards(staff.id);&quot;&gt;-&lt;/button&gt; &lt;/div&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&quot;returnedData&quot;] }; &lt;/script&gt; // src/components/Companies.vue &lt;template&gt; &lt;main&gt; &lt;h3&gt;Paper Companies&lt;/h3&gt; &lt;div v-for=&quot;(companies, i) in returnedData&quot; :key=&quot;i&quot;&gt; {{ companies.name }} - ${{ companies.net }}&lt;button @click=&quot;setWorth(companies.id);&quot;&gt;Set Company Value&lt;/button&gt; &lt;/div&gt; &lt;/main&gt; &lt;/template&gt; &lt;script&gt; export default { props: [&quot;returnedData&quot;] }; &lt;/script&gt; 正如你在上面的代码块中看到的，对于这两个组件，我们去掉了函数和数据实例变量，显示内容所需的所有数据现在都将从这些props中获得。对于删掉的函数，我们将很快会讲到。 在 App.vue 组件中，用以下代码编辑script 标签中的现有内容： // src/App.vue &lt;script&gt; // import the Companies component import Companies from &quot;./components/Companies&quot;; // import the Staff component import Staff from &quot;./components/Staff&quot;; // import the higher order component import HoComponent from &quot;./components/HoComponent.js&quot;; // Create a const variable which contains the Companies component wrapped in the higher order component const CompaniesComponent = HoComponent(Companies, mockData =&gt; mockData.getCompanies() ); // Create a const variable which contains the Staff component wrapped in the higher order component const StaffComponent = HoComponent(Staff, mockData =&gt; mockData.getStaff()); export default { name: &quot;App&quot;, components: { CompaniesComponent, StaffComponent } }; &lt;/script&gt; 在上面的代码块中，HoComponent用于包装 Staff 和 Companies 组件。 每个组件作为HoComponent 的第一个参数传入，第二个参数是一个函数，它返回另一个函数，指定应该从mockData获取什么数据。这是我们之前创建的高阶组件(HoComponent.js)中的fetchData 函数。 如果你现在刷新应用程序，你应该仍然可以看到来自mockData 文件的数据像往常一样呈现。唯一的区别是，这些按钮无法工作，因为它们还没有绑定到任何函数。让我们解决这个问题。 // src/App.vue &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;CompaniesComponent @click=&quot;onEventHappen&quot; /&gt; &lt;StaffComponent @click=&quot;onEventHappen&quot; /&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // import the Companies component import Companies from &quot;./components/Companies&quot;; // import the Staff component import Staff from &quot;./components/Staff&quot;; // import the higher order component import HoComponent from &quot;./components/HoComponent.js&quot;; // import the source data from mockData only to be used for event handlers import sourceData from &quot;./components/mockData.js&quot;; // Create a const variable which contains the Companies component wrapped in the higher order component const CompaniesComponent = HoComponent(Companies, mockData =&gt; mockData.getCompanies() ); // Create a const variable which contains the Staff component wrapped in the higher order component const StaffComponent = HoComponent(Staff, mockData =&gt; mockData.getStaff()); export default { name: &quot;App&quot;, components: { CompaniesComponent, StaffComponent }, methods: { onEventHappen(value) { // set the variable setFunction to the name of the function that was passed iin the value emitted from child component i.e. if value.name is &#39;increaseAward&#39;, setFunction is set to increaseAward() let setFunction = sourceData[value.name]; // call the corresponding function with the id passed as an argument. setFunction(value.id); } } }; &lt;/script&gt; &lt;style&gt; #app { font-family: &quot;Avenir&quot;, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } &lt;/style&gt; 在上面的代码块中，我们在App.vue组件中添加了一个事件监听器。 vue的组件。每当Staff.vue 或Companies.vue 组件被点击时，onEventHappen 方法将会被调用。 在onEventHappen方法中，我们将变量setFunction 设置为从子组件发出的值中传递的函数名，也就是说，如果value.name是’increaseAward’，那么setFunction设置为increaseAward()。setFunction 将以id作为参数执行。 最后，为了将事件监听器传递给封装在高阶组件中的组件，我们需要在 HoComponent.js文件中添加下面这行代码。 props: { returnedData: this.returnedData }, on: { ...this.$listeners } vue-hoc或者，您可以使用vue-hoc库来帮助创建高阶组件。vue-hoc帮助你轻松地创建高阶组件，你要做的就是传递基本组件、应用于HOC的一系列组件选项和在渲染阶段传递给组件的数据属性。vue-hoc 可用如下命令安装： npm install --save vue-hoc 复制代码vue-hoc插件有一些例子可以让你开始创建更高阶的组件，你可以查看这里.]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一张图理清 Vue 3.0 的响应式系统]]></title>
    <url>%2F2019%2F10%2F29%2FVue%2F%E4%B8%80%E5%BC%A0%E5%9B%BE%E7%90%86%E6%B8%85-Vue-3-0-%E7%9A%84%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[转自 作者：Jrain链接 一个基本的例子Vue 3.0 的响应式系统是独立的模块，可以完全脱离 Vue 而使用，所以我们在 clone 了源码下来以后，可以直接在 packages/reactivity 模块下调试。 1.在项目根目录运行 yarn dev reactivity，然后进入 packages/reactivity 目录找到产出的 dist/reactivity.global.js 文件。2.新建一个 index.html，写入如下代码： &lt;script src=&quot;./dist/reactivity.global.js&quot;&gt;&lt;/script&gt; &lt;script&gt; const { reactive, effect } = VueObserver const origin = { count: 0 } const state = reactive(origin) const fn = () =&gt; { const count = state.count console.log(`set count to ${count}`) } effect(fn) &lt;/script&gt; 在浏览器打开该文件，于控制台执行 state.count++，便可看到输出 set count to 1。 在上述的例子中，我们使用 reactive() 函数把 origin 对象转化成了Proxy 对象 state；使用 effect() 函数把 fn() 作为响应式回调。当 state.count 发生变化时，便触发了 fn()。接下来我们将以这个例子结合上文的流程图，来讲解这套响应式系统是怎么运行的。 初始化阶段 在初始化阶段，主要做了两件事。 1.把 origin 对象转化成响应式的 Proxy 对象 state。2.把函数 fn() 作为一个响应式的 effect 函数。 大家都知道，Vue 3.0 使用了 Proxy 来代替之前的 Object.defineProperty()，改写了对象的 getter/setter，完成依赖收集和响应触发。但是在这一阶段中，我们暂时先不管它是如何改写对象的 getter/setter 的，这个在后续的”依赖收集阶段“会详细说明。为了简单起见，我们可以把这部分的内容浓缩成一个只有两行代码的 reactive() 函数： export default reactive (target){ const observed = new Proxy(target,handler); return observed; } 当一个普通的函数 fn() 被 effect() 包裹之后，就会变成一个响应式的 effect 函数，而 fn() 也会被立即执行一次。 由于在 fn() 里面有引用到 Proxy 对象的属性，所以这一步会触发对象的 getter，从而启动依赖收集。 除此之外，这个 effect 函数也会被压入一个名为”activeReactiveEffectStack“（此处为 effectStack）的栈中，供后续依赖收集的时候使用。 export function effect (fn) { // 构造一个 effect const effect = function effect(...args) { return run(effect, fn, args) } // 立即执行一次 effect() return effect } export function run(effect, fn, args) { if (effectStack.indexOf(effect) === -1) { try { // 往池子里放入当前 effect effectStack.push(effect) // 立即执行一遍 fn() // fn() 执行过程会完成依赖收集，会用到 effect return fn(...args) } finally { // 完成依赖收集后从池子中扔掉这个 effect effectStack.pop() } } } 至此，初始化阶段已经完成。接下来就是整个系统最关键的一步——依赖收集阶段。 依赖收集阶段这个阶段的触发时机，就是在 effect 被立即执行，其内部的 fn() 触发了 Proxy 对象的 getter 的时候。简单来说，只要执行到类似 state.count 的语句，就会触发 state 的 getter。 依赖收集阶段最重要的目的，就是建立一份”依赖收集表“，也就是图示的”targetMap“。targetMap 是一个 WeakMap，其 key 值是当前的 Proxy 对象 state代理前的对象origin，而 value 则是该对象所对应的 depsMap。 depsMap 是一个 Map，key 值为触发 getter 时的属性值（此处为 count），而 value 则是触发过该属性值所对应的各个 effect。 还是有点绕？那么我们再举个例子。假设有个 Proxy 对象和 effect 如下： const state = reactive({ count: 0, age: 18 }) const effect1 = effect(() =&gt; { console.log(&#39;effect1: &#39; + state.count) }) const effect2 = effect(() =&gt; { console.log(&#39;effect2: &#39; + state.age) }) const effect3 = effect(() =&gt; { console.log(&#39;effect3: &#39; + state.count, state.age) }) 这样，{ target -&gt; key -&gt; dep } 的对应关系就建立起来了，依赖收集也就完成了 export function track (target, operationType, key) { const effect = effectStack[effectStack.length - 1] if (effect) { let depsMap = targetMap.get(target) if (depsMap === void 0) { targetMap.set(target, (depsMap = new Map())) } let dep = depsMap.get(key) if (dep === void 0) { depsMap.set(key, (dep = new Set())) } if (!dep.has(effect)) { dep.add(effect) } } } 弄明白依赖收集表 targetMap 是非常重要的，因为这是整个响应式系统核心中的核心。 响应阶段回顾上一章节的例子，我们得到了一个 { count: 0, age: 18 } 的 Proxy，并构造了三个 effect。在控制台上看看效果： 当修改对象的某个属性值的时候，会触发对应的 setter。 setter 里面的 trigger() 函数会从依赖收集表里找到当前属性对应的各个 dep，然后把它们推入到 effects 和 computedEffects（计算属性） 队列中，最后通过 scheduleRun() 挨个执行里面的 effect。 由于已经建立了依赖收集表，所以要找到属性所对应的 dep 也就轻而易举了 export function trigger (target, operationType, key) { // 取得对应的 depsMap const depsMap = targetMap.get(target) if (depsMap === void 0) { return } // 取得对应的各个 dep const effects = new Set() if (key !== void 0) { const dep = depsMap.get(key) dep &amp;&amp; dep.forEach(effect =&gt; { effects.add(effect) }) } // 简化版 scheduleRun，挨个执行 effect effects.forEach(effect =&gt; { effect() }) } 至此，响应式阶段完成。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue3.x</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解Node.js中的进程与线程]]></title>
    <url>%2F2019%2F09%2F30%2FNode%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Node-js%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[原文地址 前言进程与线程是一个程序员的必知概念，面试经常被问及，但是一些文章内容只是讲讲理论知识，可能一些小伙伴并没有真的理解，在实际开发中应用也比较少。本篇文章除了介绍概念，通过Node.js 的角度讲解进程与线程，并且讲解一些在项目中的实战的应用，让你不仅能迎战面试官还可以在实战中完美应用 文章导览 面试会问 Node.js是单线程吗？ Node.js 做耗时的计算时候，如何避免阻塞？ Node.js如何实现多进程的开启和关闭？ Node.js可以创建线程吗？ 你们开发过程中如何实现进程守护的？ 除了使用第三方模块，你们自己是否封装过一个多进程架构? 进程进程Process是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础，进程是线程的容器（来自百科）。进程是资源分配的最小单位。我们启动一个服务、运行一个实例，就是开一个服务进程，例如 Java 里的 JVM 本身就是一个进程，Node.js 里通过 node app.js 开启一个服务进程，多进程就是进程的复制（fork），fork 出来的每个进程都拥有自己的独立空间地址、数据栈，一个进程无法访问另外一个进程里定义的变量、数据结构，只有建立了 IPC 通信，进程之间才可数据共享。 Node.js开启服务进程例子 const http = require(&#39;http&#39;); const server = http.createServer(); server.listen(3000,()=&gt;{ process.title=&#39;程序员成长指北测试进程&#39;; console.log(&#39;进程id&#39;,process.pid) }) 运行上面代码后，以下为 Mac 系统自带的监控工具 “活动监视器” 所展示的效果，可以看到我们刚开启的 Nodejs 进程 7663 线程线程是操作系统能够进行运算调度的最小单位，首先我们要清楚线程是隶属于进程的，被包含于进程之中。一个线程只能隶属于一个进程，但是一个进程是可以拥有多个线程的。 单线程单线程就是一个进程只开一个线程 Javascript 就是属于单线程，程序顺序执行(这里暂且不提JS异步)，可以想象一下队列，前面一个执行完之后，后面才可以执行，当你在使用单线程语言编码时切勿有过多耗时的同步操作，否则线程会造成阻塞，导致后续响应无法处理。你如果采用 Javascript 进行编码时候，请尽可能的利用Javascript异步操作的特性。 经典计算耗时造成线程阻塞的例子 const http = require(&#39;http&#39;); const longComputation = () =&gt; { let sum = 0; for (let i = 0; i &lt; 1e10; i++) { sum += i; }; return sum; }; const server = http.createServer(); server.on(&#39;request&#39;, (req, res) =&gt; { if (req.url === &#39;/compute&#39;) { console.info(&#39;计算开始&#39;,new Date()); const sum = longComputation(); console.info(&#39;计算结束&#39;,new Date()); return res.end(`Sum is ${sum}`); } else { res.end(&#39;Ok&#39;) } }); server.listen(3000); //打印结果 //计算开始 2019-07-28T07:08:49.849Z //计算结束 2019-07-28T07:09:04.522Z 查看打印结果，当我们调用127.0.0.1:3000/compute的时候，如果想要调用其他的路由地址比如127.0.0.1/大约需要15秒时间，也可以说一个用户请求完第一个compute接口后需要等待15秒，这对于用户来说是极其不友好的。下文我会通过创建多进程的方式child_process.fork 和cluster 来解决解决这个问题。 单线程的一些说明 Node.js 虽然是单线程模型，但是其基于事件驱动、异步非阻塞模式，可以应用于高并发场景，避免了线程创建、线程之间上下文切换所产生的资源开销。 当你的项目中需要有大量计算，CPU 耗时的操作时候，要注意考虑开启多进程来完成了。 Node.js 开发过程中，错误会引起整个应用退出，应用的健壮性值得考验，尤其是错误的异常抛出，以及进程守护是必须要做的。 单线程无法利用多核CPU，但是后来Node.js 提供的API以及一些第三方工具相应都得到了解决，文章后面都会讲到。 Node.js 中的进程与线程Node.js 是 Javascript 在服务端的运行环境，构建在 chrome 的 V8 引擎之上，基于事件驱动、非阻塞I/O模型，充分利用操作系统提供的异步 I/O 进行多任务的执行，适合于 I/O 密集型的应用场景，因为异步，程序无需阻塞等待结果返回，而是基于回调通知的机制，原本同步模式等待的时间，则可以用来处理其它任务 科普：在 Web 服务器方面，著名的 Nginx 也是采用此模式（事件驱动），避免了多线程的线程创建、线程上下文切换的开销，Nginx 采用 C 语言进行编写，主要用来做高性能的 Web 服务器，不适合做业务。 Web业务开发中，如果你有高并发应用场景那么 Node.js 会是你不错的选择。 在单核 CPU 系统之上我们采用 单进程 + 单线程 的模式来开发。在多核 CPU 系统之上，可以通过 child_process.fork 开启多个进程（Node.js 在 v0.8 版本之后新增了Cluster 来实现多进程架构） ，即 多进程 + 单线程 模式。注意：开启多进程不是为了解决高并发，主要是解决了单进程模式下 Node.js CPU 利用率不足的情况，充分利用多核 CPU 的性能。 Node.js 中的进程process 模块Node.js 中的进程 Process 是一个全局对象，无需 require 直接使用，给我们提供了当前进程中的相关信息。官方文档提供了详细的说明，感兴趣的可以亲自实践下 Process 文档。 process.env：环境变量，例如通过 process.env.NODE_ENV 获取不同环境项目配置信息 process.nextTick：这个在谈及 Event Loop 时经常为会提到 process.pid：获取当前进程id process.ppid：当前进程对应的父进程 process.cwd()：获取当前进程工作目录， process.platform：获取当前进程运行的操作系统平台 process.uptime()：当前进程已运行时间，例如：pm2 守护进程的 uptime 值 进程事件：process.on(‘uncaughtException’, cb) 捕获异常信息、process.on(‘exit’, cb）进程推出监听 三个标准流：process.stdout 标准输出、process.stdin 标准输入、process.stderr 标准错误输出 process.title 指定进程名称，有的时候需要给进程指定一个名称 以上仅列举了部分常用到功能点，除了 Process 之外 Node.js 还提供了 child_process 模块用来对子进程进行操作，在下文 Nodejs进程创建会继续讲述。 Node.js 进程创建进程创建有多种方式，本篇文章以child_process模块和cluster模块进行讲解。 child_process模块child_process 是 Node.js 的内置模块，官网地址： child_process 官网地址：nodejs.cn/api/child_p… 几个常用函数： 四种方式 child_process.spawn()：适用于返回大量数据，例如图像处理，二进制数据处理。 child_process.exec()：适用于小量数据，maxBuffer 默认值为 200 * 1024 超出这个默认值将会导致程序崩溃，数据量过大可采用 spawn。 child_process.execFile()：类似 child_process.exec()，区别是不能通过 shell 来执行，不支持像 I/O 重定向和文件查找这样的行为 child_process.fork()： 衍生新的进程，进程之间是相互独立的，每个进程都有自己的 V8 实例、内存，系统资源是有限的，不建议衍生太多的子进程出来，通长根据系统 CPU 核心数设置。 CPU 核心数这里特别说明下，fork 确实可以开启多个进程，但是并不建议衍生出来太多的进程，cpu核心数的获取方式const cpus = require(&#39;os&#39;).cpus();,这里 cpus 返回一个对象数组，包含所安装的每个 CPU/内核的信息，二者总和的数组哦。假设主机装有两个cpu，每个cpu有4个核，那么总核数就是8。 fork开启子进程 Demo fork开启子进程解决文章起初的计算耗时造成线程阻塞。 在进行 compute 计算时创建子进程，子进程计算完成通过 send 方法将结果发送给主进程，主进程通过 message 监听到信息后处理并退出。 fork_app.js const http = require(&#39;http&#39;); const fork = require(&#39;child_process&#39;).fork; const server = http.createServer((req, res) =&gt; { if(req.url == &#39;/compute&#39;){ const compute = fork(&#39;./fork_compute.js&#39;); compute.send(&#39;开启一个新的子进程&#39;); // 当一个子进程使用 process.send() 发送消息时会触发 &#39;message&#39; 事件 compute.on(&#39;message&#39;, sum =&gt; { res.end(`Sum is ${sum}`); compute.kill(); }); // 子进程监听到一些错误消息退出 compute.on(&#39;close&#39;, (code, signal) =&gt; { console.log(`收到close事件，子进程收到信号 ${signal} 而终止，退出码 ${code}`); compute.kill(); }) }else{ res.end(`ok`); } }); server.listen(3000, 127.0.0.1, () =&gt; { console.log(`server started at http://${127.0.0.1}:${3000}`); }); fork_compute.js 针对文初需要进行计算的的例子我们创建子进程拆分出来单独进行运算。 const computation = () =&gt; { let sum = 0; console.info(&#39;计算开始&#39;); console.time(&#39;计算耗时&#39;); for (let i = 0; i &lt; 1e10; i++) { sum += i }; console.info(&#39;计算结束&#39;); console.timeEnd(&#39;计算耗时&#39;); return sum; }; process.on(&#39;message&#39;, msg =&gt; { console.log(msg, &#39;process.pid&#39;, process.pid); // 子进程id const sum = computation(); // 如果Node.js进程是通过进程间通信产生的，那么，process.send()方法可以用来给父进程发送消息 process.send(sum); }) cluster模块cluster 开启子进程Demo const http = require(&#39;http&#39;); const numCPUs = require(&#39;os&#39;).cpus().length; const cluster = require(&#39;cluster&#39;); if(cluster.isMaster){ console.log(&#39;Master proces id is&#39;,process.pid); // fork workers for(let i= 0;i&lt;numCPUs;i++){ cluster.fork(); } cluster.on(&#39;exit&#39;,function(worker,code,signal){ console.log(&#39;worker process died,id&#39;,worker.process.pid) }) }else{ // Worker可以共享同一个TCP连接 // 这里是一个http服务器 http.createServer(function(req,res){ res.writeHead(200); res.end(&#39;hello word&#39;); }).listen(8000); } cluster原理分析 cluster模块调用fork方法来创建子进程，该方法与child_process中的fork是同一个方法。 cluster模块采用的是经典的主从模型，Cluster会创建一个master，然后根据你指定的数量复制出多个子进程，可以使用cluster.isMaster属性判断当前进程是master还是worker(工作进程)。由master进程来管理所有的子进程，主进程不负责具体的任务处理，主要工作是负责调度和管理。 cluster模块使用内置的负载均衡来更好地处理线程之间的压力，该负载均衡使用了Round-robin算法（也被称之为循环算法）。当使用Round-robin调度策略时，master accepts()所有传入的连接请求，然后将相应的TCP请求处理发送给选中的工作进程（该方式仍然通过IPC来进行通信）。 开启多进程时候端口疑问讲解：如果多个Node进程监听同一个端口时会出现 Error:listen EADDRIUNS的错误，而cluster模块为什么可以让多个子进程监听同一个端口呢?原因是master进程内部启动了一个TCP服务器，而真正监听端口的只有这个服务器，当来自前端的请求触发服务器的connection事件后，master会将对应的socket具柄发送给子进程。 child_process 模块与cluster 模块总结无论是 child_process 模块还是 cluster 模块，为了解决 Node.js 实例单线程运行，无法利用多核 CPU 的问题而出现的。核心就是父进程（即 master 进程）负责监听端口，接收到新的请求后将其分发给下面的 worker 进程。 cluster模块的一个弊端： cluster内部隐时的构建TCP服务器的方式来说对使用者确实简单和透明了很多，但是这种方式无法像使用child_process那样灵活，因为一直主进程只能管理一组相同的工作进程，而自行通过child_process来创建工作进程，一个主进程可以控制多组进程。原因是child_process操作子进程时，可以隐式的创建多个TCP服务器，对比上面的两幅图应该能理解我说的内容。 Node.js进程通信原理前面讲解的无论是child_process模块，还是cluster模块，都需要主进程和工作进程之间的通信。通过fork()或者其他API，创建了子进程之后，为了实现父子进程之间的通信，父子进程之间才能通过message和send()传递信息。 IPC这个词我想大家并不陌生，不管那一张开发语言只要提到进程通信，都会提到它。IPC的全称是Inter-Process Communication,即进程间通信。它的目的是为了让不同的进程能够互相访问资源并进行协调工作。实现进程间通信的技术有很多，如命名管道，匿名管道，socket，信号量，共享内存，消息队列等。Node中实现IPC通道是依赖于libuv。windows下由命名管道(name pipe)实现，*nix系统则采用Unix Domain Socket实现。表现在应用层上的进程间通信只有简单的message事件和send()方法，接口十分简洁和消息化。 IPC创建和实现示意图 IPC通信管道是如何创建的 父进程在实际创建子进程之前，会创建IPC通道并监听它，然后才真正的创建出子进程，这个过程中也会通过环境变量（NODE_CHANNEL_FD）告诉子进程这个IPC通道的文件描述符。子进程在启动的过程中，根据文件描述符去连接这个已存在的IPC通道，从而完成父子进程之间的连接 Node.js句柄传递讲句柄之前，先想一个问题，send句柄发送的时候，真的是将服务器对象发送给了子进程？ 子进程对象send()方法可以发送的句柄类型net.Socket TCP套接字net.Server TCP服务器，任意建立在TCP服务上的应用层服务都可以享受它带来的好处net.Native C++层面的TCP套接字或IPC管道dgram.Socket UDP套接字dgram.Native C++层面的UDP套接字 send句柄发送原理分析结合句柄的发送与还原示意图更容易理解。 send()方法在将消息发送到IPC管道前，实际将消息组装成了两个对象，一个参数是hadler，另一个是message。message参数如下所示： { cmd:&#39;NODE_HANDLE&#39;, type:&#39;net.Server&#39;, msg:message } 发送到IPC管道中的实际上是我们要发送的句柄文件描述符。这个message对象在写入到IPC管道时，也会通过JSON.stringfy()进行序列化。所以最终发送到IPC通道中的信息都是字符串，send()方法能发送消息和句柄并不意味着它能发送任何对象。 连接了IPC通道的子线程可以读取父进程发来的消息，将字符串通过JSON.parse()解析还原为对象后，才触发message事件将消息传递给应用层使用。在这个过程中，消息对象还要被进行过滤处理，message.cmd的值如果以NODE_为前缀，它将响应一个内部事件internalMessage，如果message.cmd值为NODE_HANDLE,它将取出message.type值和得到的文件描述符一起还原出一个对应的对象。 以发送的TCP服务器句柄为例，子进程收到消息后的还原过程代码如下: function(message,handle,emit){ var self = this; var server = new net.Server(); server.listen(handler,function(){ emit(server); }); } 总结多进程 vs 多线程 属性多进程多线程比较 数据数据共享复杂，需要用IPC；数据是分开的，同步简单因为共享进程数据，数据共享简单，同步复杂各有千秋 CPU、内存占用内存多，切换复杂，CPU利用率低占用内存少，切换简单，CPU利用率高多线程更好 销毁、切换创建销毁、切换复杂，速度慢创建销毁、切换简单，速度很快多线程更好 coding编码简单、调试方便编码、调试复杂编码、调试复杂 可靠性进程独立运行，不会相互影响线程同呼吸共命运多进程更好 分布式可用于多机多核分布式，易于扩展只能用于多核分布式多进程更好]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在17道题中理解javascript的类型转换]]></title>
    <url>%2F2019%2F08%2F08%2FJs%2F%E5%9C%A817%E9%81%93%E9%A2%98%E4%B8%AD%E7%90%86%E8%A7%A3javascript%E7%9A%84%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[原文地址 类型转换是将值从一种类型转换为另一种类型的过程（比如字符串转数字，对象转布尔值等）。任何类型不论是原始类型还是对象类型都可以进行类型转换，JavaScript 的原始类型有：number, string, boolean, null, undefined, Symbol。 true + false 12 / &quot;6&quot; &quot;number&quot; + 15 + 3 15 + 3 + &quot;number&quot; [1] &gt; null &quot;foo&quot; + + &quot;bar&quot; &quot;true&quot; == true false == &quot;false&quot; null == &quot;&quot; !!&quot;false&quot; == !!&quot;true&quot; [&quot;x&quot;] == &quot;x&quot; [] + null + 1 [1,2,3] == [1,2,3] {} + [] + {} + [1] ! + [] + [] + ![] new Date(0) - 0 new Date(0) + 0 类似于上面的这些问题大概率也会在 JS 面试中被问到, 所以继续往下读。 隐式转换VS显示转换类型转换可以分为隐式类型转换和显式类型转换。 当开发人员通过编写适当的代码(如Number(value))用于在类型之间进行转换时，就称为显式类型强制转换(或强制类型转换)。 然而 JavaScript 是弱类型语言，在某些操作下，值可以在两种类型之间自动的转换，这叫做隐式类型转换。在对不同类型的值使用运算符时通常会发生隐式类型转换。比如 1 == null, 2 / “5”, null + new Date()。当值被 if 语句包裹时也有可能发生，比如 if(value) {} 会将 value 转换为 boolean类型。 严格相等运算符（===）不会触发类型隐式转换，所以它可以用来比较值和类型是否都相等。 隐式类型转换是一把双刃剑，使用它虽然可以写更少的代码但有时候会出现难以被发现的bug。 三种类型转换我们需要知道的第一个规则是：在 JS 中只有 3 种类型的转换 to string to boolean to number 第二，类型转换的逻辑在原始类型和对象类型上是不同的，但是他们都只会转换成上面 3 种类型之一。 我们首先分析一下原始类型转换。 String 类型转换String() 方法可以用来显式将值转为字符串，隐式转换通常在有 + 运算符并且有一个操作数是 string 类型时被触发，如： String(123) // 显式类型转换 123 + &#39;&#39; // 隐式类型转换 所有原始类型转 String 类型 String(123) // &#39;123&#39; String(-12.3) // &#39;-12.3&#39; String(null) // &#39;null&#39; String(undefined) // &#39;undefined&#39; String(true) // &#39;true&#39; Symbol 类型转 String 类型是比较严格的，它只能被显式的转换 String(Symbol(&#39;symbol&#39;)) // &#39;Symbol(symbol)&#39; &#39;&#39; + Symbol(&#39;symbol&#39;) // TypeError is thrown Boolean 类型转换Boolean() 方法可以用来显式将值转换成 boolean 型。 隐式类型转换通常在逻辑判断或者有逻辑运算符时被触发（|| &amp;&amp; !）。 Boolean(2) // 显示类型转换 if(2) {} // 逻辑判断触发隐式类型转换 !!2 // 逻辑运算符触发隐式类型转换 2 || &#39;hello&#39; // 逻辑运算符触发隐式类型转换 注意: 逻辑运算符（比如 || 和 &amp;&amp;）是在内部做了 boolean 类型转换，但实际上返回的是原始操作数的值，即使他们都不是 boolean 类型。 // 返回 number 类型 123，而不是 boolean 型 true // &#39;hello&#39; 和 &#39;123&#39; 仍然在内部会转换成 boolean 型来计算表达式 let x = &#39;hello&#39; &amp;&amp; 123 // x === 123 boolean 类型转换只会有 true 或者 false 两种结果。 Boolean(&#39;&#39;) // false Boolean(0) // false Boolean(-0) // false Boolean(NaN) // false Boolean(null) // false Boolean(undefined) // false Boolean(false) // false 任何不在上面列表中的值都会转换为 true, 包括 object, function, Array, Date 等，Symbol 类型是真值，空对象和空数组也是真值。 Boolean({}) // true Boolean([]) // true Boolean(Symbol()) // true !!Symbol() // true Boolean(function() {}) // true Number 类型转换和 Boolean()、String() 方法一样， Number() 方法可以用来显式将值转换成 number 类型。number 的隐式类型转换是比较复杂的，因为它可以在下面多种情况下被触发。 比较操作（&gt;, &lt;, &lt;=, &gt;=） 按位操作（| &amp; ^ ~） 算数操作（- + * / %）， 注意，当 + 操作存在任意的操作数是 string 类型时，不会触发 number 类型的隐式转换 一 元 + 操作 非严格相等操作（== 或者 != ），注意，== 操作两个操作数都是 string 类型时，不会发生 number 类型的隐式转换 Number(&#39;123&#39;) // 显示类型转换 + &#39;123&#39; // 隐式类型转换 123 != &quot;456&quot; // 隐式类型转换 4 &gt; &quot;5&quot; // 隐式类型转换 5 / null // 隐式类型转换 true | 0 // 隐式类型转换 接下来看一下原始类型显示转换 number 类型会发生什么 Number(null) // 0 Number(undefined) // NaN Number(true) // 1 Number(false) // 0 Number(&quot; 12 &quot;) // 12 Number(&quot;-12.34&quot;) // -12.34 Number(&quot;\n&quot;) // 0 Number(&quot; 12s &quot;) // NaN Number(123) // 123 当将一个字符串转换为一个数字时，引擎首先删除前尾空格、\n、\t 字符，如果被修剪的字符串不成为一个有效的数字，则返回 NaN。如果字符串为空，则返回 0。 Number() 方法对于 null 和 undefined 的处理是不同的， null 会转换为 0, undefined 会转换为 NaN 不管是显式还是隐式转换都不能将 Symbol 类型转为 number 类型，当试图这样操作时，会抛出错误。 Number(Symbol(&#39;my symbol&#39;)) // TypeError is thrown +Symbol(&#39;123&#39;) // TypeError is thrown 这里有 2 个特殊的规则需要记住： 当将 == 应用于 null 或 undefined 时，不会发生数值转换。null 只等于 null 或 undefined，不等于其他任何值。null == 0 // false, null is not converted to 0 null == null // true undefined == undefined // true null == undefined // true undefined == 0 // false NaN 不等于任何值，包括它自己 NaN === NaN // false if(value !== value) { console.log(&#39;the value is NaN&#39;) } object 类型转换到这里我们已经深入了解了原始类型的转换，接下来我们来看一下 object 类型的转换。 当涉及到对象的操作比如：[1] + [2,3]，引擎首先会尝试将 object 类型转为原始类型，然后在将原始类型转为最终需要的类型，而且仍然只有 3 种类型的转换：number, string, boolean 最简单的情况是 boolean 类型的转换，任何非原始类型总是会转换成 true,无论对象或数组是否为空。 对象通过内部 [[ToPrimitive]] 方法转换为原始类型，该方法负责数字和字符串转换。 [[ToPrimitive]] 方法接受两个参数一个输入值和一个需要转换的类型（Numer or String）number 和 string的转换都使用了对象的两个方法： valueOf 和 toString。这两个方法都在 Object.prototype 上被声明，因此可用于任何派生类，比如 Date, Array等。 通常上 [[ToPrimitive]] 算法如下： 如果输入的值已经是原始类型，直接返回这个值。 输入的值调用 toString() 方法，如果结果是原始类型，则返回。 输入的值调用 valueOf() 方法，如果结果是原始类型，则返回。 如果上面 3 个步骤之后，转换后的值仍然不是原始类型，则抛出 TypeError 错误。 number 类型的转换首先会调用 valueOf() 方法，如果不是原始值在调用 toString() 方法。 string 类型的转换则相反。 大多数 JS 内置对象类型的 valueOf() 返回这个对象本身，其结果经常被忽略，因为它不是一个原始类型。所以大多数情况下当 object 需要转换成 number 或 string 类型时最终都调用了 toString() 方法。 当运算符不同时，[[ToPrimitive]] 方法接受的转换类型参数也不相同。当存在 == 或者 + 运算符时一般会先触发 number 类型的转换再触发 string 类型转换。 在 JS 中你可以通过重写对象的 toString 和 valueOf 方法来修改对象到原始类型转换的逻辑。 答案解析true + false // 1 // &#39;+&#39; 运算符会触发 number 类型转换对于 true 和 false 12 / &quot;6&quot; // 2 //算数运算符会把字符串 ‘6’ 转为 number 类型 &quot;number&quot; + 15 + 3 // &#39;number153&#39; // &#39;+&#39; 运算符按从左到右的顺序的执行，所以优先执行 “number” + 15, 把 15 转为 string 类型，得到 “number15” 然后同理执行 “number15” + 3 15 + 3 + &quot;number&quot; // &quot;18number&quot; // 15 + 3 先执行，运算符两边都是 number 类型 ，不用转换，然后执行 18 + “number” 最终得到 “18number” [1] &gt; null // true // ==&gt; &#39;1&#39; &gt; 0 // ==&gt; 1 &gt; 0 // ==&gt; true // 比较运算符 &gt; 执行 number 类型隐式转换。 &quot;foo&quot; + + &quot;bar&quot; // &quot;fooNaN&quot; // ==&gt; &quot;foo&quot; + (+&quot;bar&quot;) // ==&gt; &quot;foo&quot; + NaN // ==&gt; &quot;fooNaN&quot; // 一元 + 运算符比二元 + 运算符具有更高的优先级。所以 + bar表达式先求值。一元加号执行字符串“bar” 的 number 类型转换。因为字符串不代表一个有效的数字，所以结果是NaN。在第二步中，计算表达式&#39;foo&#39; + NaN。 &quot;true&quot; == true // false false == &quot;false&quot; // false // == 运算符执行 number 类型转换，&#39;true&#39; 转换为 NaN， boolean 类型 true 转换为 1 null == &quot;&quot; // false // null 不等于任何值除了 null 和 undefined !!&quot;false&quot; == !!&quot;true&quot; // true // !! 运算符将字符串 &#39;true&#39; 和 &#39;false&#39; 转为 boolean 类型 true, 因为不是空字符串，然后两边都是 boolean 型不在执行隐式转换操作。 [&quot;x&quot;] == &quot;x&quot; // true // == 运算符对数组类型执行 number 转换，先调用对象的 valueOf() 方法，结果是数组本身，不是原始类型值，所以执行对象的 toString() 方法，得到字符串 &#39;x&#39; [] + null + 1 // &#39;null1&#39; // &#39;+&#39; 运算符执行 number 类型转换，先调用对象的 valueOf() 方法，结果是数组本身，不是原始类型值，所以执行对象的 toString() 方法，得到字符串 &#39;&#39;， 接下来执行表达式 &#39;&#39; + null + 1。 [1,2,3] == [1,2,3] // false // 当运算符两边类型相同时，不会执行类型转换，两个数组的内存地址不一样，所以返回 false 0 || &quot;0&quot; &amp;&amp; {} // {} // 逻辑运算符 || 和 &amp;&amp; 将值转为 boolean 型，但是会返回原始值（不是 boolean）。 {} + [] + {} + [1] // &#39;0[object Object]1&#39; // 所有的操作数都不是原始类型，所以会按照从左到右的顺序执行 number 类型的隐式转换， object 和 array 类型的 valueOf() 方法返回它们本身，所以直接忽略，执行 toString() 方法。 这里的技巧是，第一个 {} 不被视为 object，而是块声明语句，因此它被忽略。计算从 +[] 表达式开始，该表达式通过toString()方法转换为空字符串，然后转换为0。 ! + [] + [] + ![] // &#39;truefalse&#39; // 一元运算符优先执行，+[] 转为 number 类型 0，![] 转为 boolean 型 false。 new Date(0) - 0 // 0 // &#39;-&#39; 运算符执行 number 类型隐式转换对于 Date 型的值，Date.valueOf() 返回到毫秒的时间戳。 new Date(0) + 0 //&quot;Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)0&quot; // +&#39; 运算符触发默认转换，因此使用 toString() 方法，而不是 valueOf()。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript异步编程回调地狱的一些解决方案]]></title>
    <url>%2F2019%2F08%2F01%2FJs%2FJavaScript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%E5%9B%9E%E8%B0%83%E5%9C%B0%E7%8B%B1%E7%9A%84%E4%B8%80%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[原文地址 异步编程在JavaScript中非常重要。过多的异步编程也带了回调嵌套的问题，本文会提供一些解决“回调地狱”的方法。 setTimeout(function(){ console.log(&quot;延时触发&quot;) },2000) fs.readFile(&#39;./samp.txt&#39;,&#39;utf-8&#39;,function(res,error){ console.log(res); }) 上面就是典型的回调函数，不论是在浏览器中，还是在node中，JavaScript本身是单线程，因此，为了应对一些单线程带来的问题，异步编程成为了JavaScript中非常重要的一部分。 不论是浏览器中最为常见的ajax、事件监听，还是node中文件读取、网络编程、数据库等操作，都离不开异步编程。在异步编程中，许多操作都会放在回调函数（callback）中。同步与异步的混杂、过多的回调嵌套都会使得代码变得难以理解与维护，这也是常受人诟病的地方。 先看下面这段代码 fs.readFile(&#39;./sample.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; { let keyword = content.substring(0, 5); db.find(`select * from sample where kw = ${keyword}`, (err, res) =&gt; { get(`/sampleget?count=${res.length}`, data =&gt; { console.log(data); }); }); }); 首先我们读取的一个文件中的关键字keyword，然后根据该keyword进行数据库查询，最后依据查询结果请求数据。 文件读取：fs.readFile 数据库查询：db.find http请求：get 可以看到，我们没增加一个异步请求，就会多添加一层回调函数的嵌套，这段代码中三个异步函数的嵌套已经开始使一段本可以语言明确的代码编程不易阅读与维护了。 抽象出来这种代码会变成下面这样： asyncFunc1(opt, (...args1) =&gt; { asyncFunc2(opt, (...args2) =&gt; { asyncFunc3(opt, (...args3) =&gt; { asyncFunc4(opt, (...args4) =&gt; { // some operation }); }); }); }); 左侧明显出现了一个三角形的缩进区域，过多的回调也就让我们陷入“回调地狱”。接下来会介绍一些方法来规避回调地狱。 一、拆解function回调嵌套所带来的一个重要问题就是代码不易阅读与维护。因为普遍来说，过多的缩进（嵌套）会极大的影响代码的可读性。基于这一点，可以进行一个最简单的优化——将各步拆解为单个的function function getData(count) { get(`/sampleget?count=${count}`, data =&gt; { console.log(data); }); } function queryDB(kw) { db.find(`select * from sample where kw = ${kw}`, (err, res) =&gt; { getData(res.length); }); } function readFile(filepath) { fs.readFile(filepath, &#39;utf-8&#39;, (err, content) =&gt; { let keyword = content.substring(0, 5); queryDB(keyword); }); } readFile(&#39;./sample.txt&#39;); 可以看到，通过上面的改写方式，代码清晰了许多。该方法非常简单，具有一定的效果，但是缺少通用性。 二、事件发布/监听模式如果在浏览器中写过事件监听addEventListener，那么你对这种事件发布/监听的模式一定不陌生。 借鉴这种思想，一方面，我们可以监听某一事件，当事件发生时，进行相应回调操作；另一方面，当某些操作完成后，通过发布事件触发回调。这样就可以将原本捆绑在一起的代码解耦。 const events = require(&#39;events&#39;); const eventEmitter = new events.EventEmitter(); eventEmitter.on(&#39;db&#39;, (err, kw) =&gt; { db.find(`select * from sample where kw = ${kw}`, (err, res) =&gt; { eventEmitter(&#39;get&#39;, res.length); }); }); eventEmitter.on(&#39;get&#39;, (err, count) =&gt; { get(`/sampleget?count=${count}`, data =&gt; { console.log(data); }); }); fs.readFile(&#39;./sample.txt&#39;, &#39;utf-8&#39;, (err, content) =&gt; { let keyword = content.substring(0, 5); eventEmitter. emit(&#39;db&#39;, keyword); }); 使用这种模式的实现需要一个事件发布/监听的库。上面代码中使用node原生的events模块，当然你可以使用任何你喜欢的库。 三、PromisePromise是一种异步解决方案，最早由社区提出并实现，后来写进了es6规范。 目前一些主流的浏览器已经原生实现了Promise的API，可以在Can I use里查看浏览器的支持情况。当然，如果想要做浏览器的兼容，可以考虑使用一些Promise的实现库，例如bluebird、 Q等。下面以bluebird为例： 首先，我们需要将异步方法改写为Promise，对于符合node规范的回调函数（第一个参数必须是Error），可以使用bluebird的promisify方法。该方法接收一个标准的异步方法并返回一个Promise对象。 const bluebird = require(&#39;bluebird&#39;); const fs = require(&quot;fs&quot;); const readFile = bluebird.promisify(fs.readFile); 这样，readFile就变成了一个Promise对象。 但是，有的异步方法无法进行转换，或者我们需要使用原生Promise，这就需要我们手动进行一些改造。下面提供一种改造的方法。 以fs.readFile为例，借助原生Promise来改造该方法： const readFile = function (filepath) { let resolve, reject; let promise = new Promise((_resolve, _reject) =&gt; { resolve = _resolve; reject = _reject; }); let deferred = { resolve, reject, promise }; fs.readFile(filepath, &#39;utf-8&#39;, function (err, ...args) { if (err) { deferred.reject(err); } else { deferred.resolve(...args); } }); return deferred.promise; } 我们在方法中创建了一个Promise对象，并在异步回调中根据不同的情况使用reject与resolve来改变Promise对象的状态。该方法返回这个Promise对象。其他的一些异步方法也可以参照这种方式进行改造。 假设通过改造，readFile、queryDB与getData方法均会返回一个Promise对象。代码就变为了: readFile(&#39;./sample.txt&#39;).then(content =&gt; { let keyword = content.substring(0, 5); return queryDB(keyword); }).then(res =&gt; { return getData(res.length); }).then(data =&gt; { console.log(data); }).catch(err =&gt; { console.warn(err); }); 可以看到，之前的嵌套操作编程了通过then连接的链式操作。代码的整洁度上有了一个较大的提高。 四、generatorgenerator是es6中的一个新的语法。在function关键字后添加*即可将函数变为generator。 const gen = function* () { yield 1; yield 2; return 3; } 执行generator将会返回一个遍历器对象，用于遍历generator内部的状态 let g = gen(); g.next(); // { value: 1, done: false } g.next(); // { value: 2, done: false } g.next(); // { value: 3, done: true } g.next(); // { value: undefined, done: true } 可以看到，generator函数有一个最大的特点，可以在内部执行的过程中交出程序的控制权，yield相当于起到了一个暂停的作用；而当一定情况下，外部又将控制权再移交回来。 想象一下，我们用generator来封装代码，在异步任务处使用yield关键词，此时generator会将程序执行权交给其他代码，而在异步任务完成后，调用next方法来恢复yield下方代码的执行。以readFile为例，大致流程如下： // 我们的主任务——显示关键字 // 使用yield暂时中断下方代码执行 // yield后面为promise对象 const showKeyword = function* (filepath) { console.log(&#39;开始读取&#39;); let keyword = yield readFile(filepath); console.log(`关键字为${filepath}`); } // generator的流程控制 let gen = showKeyword(); let res = gen.next(); res.value.then(res =&gt; gen.next(res)); 在主任务部分，原本readFile异步的部分变成了类似同步的写法，代码变得非常清晰。而在下半部分，则是对于什么时候需要移交回控制权给generator的流程控制。 然而，我们需要手动控制generator的流程，如果能够自动执行generator——在需要的时候自动移交控制权，那么会更加具有实用性。为此，我们可以使用 co 这个库。它可以是省去我们对于generator流程控制的代码 const co = reuqire(&#39;co&#39;); // 我们的主任务——显示关键字 // 使用yield暂时中断下方代码执行 // yield后面为promise对象 const showKeyword = function* (filepath) { console.log(&#39;开始读取&#39;); let keyword = yield readFile(filepath); console.log(`关键字为${filepath}`); } // 使用co co(showKeyword); 其中，yeild关键字后面需要是functio, promise, generator, array或object。可以改写文章一开始的例子： const co = reuqire(&#39;co&#39;); const task = function* (filepath) { let keyword = yield readFile(filepath); let count = yield queryDB(keyword); let data = yield getData(res.length); console.log(data); }); co(task, &#39;./sample.txt&#39;); 五、async/await 可以看到，上面的方法虽然都在一定程度上解决了异步编程中回调带来的问题。然而 function拆分的方式其实仅仅只是拆分代码块，时常会不利于后续维护； 事件发布/监听方式模糊了异步方法之间的流程关系； Promise虽然使得多个嵌套的异步调用能够通过链式的API进行操作，但是过多的then也增加了代码的冗余，也对阅读代码中各阶段的异步任务产生了一定干扰； 通过generator虽然能提供较好的语法结构，但是毕竟generator与yield的语境用在这里多少还有些不太贴切。 因此，这里再介绍一个方法，它就是es7中的async/await。 简单介绍一下async/await。基本上，任何一个函数都可以成为async函数，以下都是合法的书写形式： async function foo () {}; const foo = async function () {}; const foo = async () =&gt; {}; 在async函数中可以使用await语句。await后一般是一个Promise对象。 async function foo () { console.log(&#39;开始&#39;); let res = await post(data); console.log(`post已完成，结果为：${res}`); }; 当上面的函数执行到await时，可以简单理解为，函数挂起，等待await后的Promise返回，再执行下面的语句。 值得注意的是，这段异步操作的代码，看起来就像是“同步操作”。这就大大方便了异步代码的编写与阅读。下面改写我们的例子。 const printData = async function (filepath) { let keyword = await readFile(filepath); let count = await queryDB(keyword); let data = await getData(res.length); console.log(data); }); printData(&#39;./sample.txt&#39;); 可以看到，代码简洁清晰，异步代码也具有了“同步”代码的结构。 注意，其中readFile、queryDB与getData方法都需要返回一个Promise对象。这可以通过在第三部分Promise里提供的方式进行改写。 后记异步编程作为JavaScript中的一部分，具有非常重要的位置，它帮助我们避免同步代码带来的线程阻塞的同时，也为编码与阅读带来了一定的困难。过多的回调嵌套很容易会让我们陷入“回调地狱”中，使代码变成一团乱麻。为了解决“回调地狱”，我们可以使用文中所述的这五种常用方法： function拆解 事件发布/订阅模式 Promise Generator async / await 理解各类方法的原理与实现方式，了解其中利弊，可以帮助我们更好得进行异步编程。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Webpack Freestyle 之 Long Term Cache(webpack 实现持久性缓存)]]></title>
    <url>%2F2019%2F07%2F31%2FTools%2FWebpack-Freestyle-%E4%B9%8B-Long-Term-Cache-webpack-%E5%AE%9E%E7%8E%B0%E6%8C%81%E4%B9%85%E6%80%A7%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[原文地址 How Browser Cache Works首先，我们要搞清楚浏览器缓存是怎么工作的。 那么，就让我画一张图来告诉大家吧，嘻嘻。 浏览器: 我需要 foo.js 服务器: 让我找找。找到了，给你，缓存有效期为 1 年。 浏览器: 好，我把他缓存到磁盘里。 过了 2 天， 浏览器: 我需要 foo.js ，在缓存里找到了。缓存还有效，那直接读缓存。用户：哇塞，这网页秒开啊。 又过了 2 天，foo.js 的代码更新了。（内容从 Hello world 变成了 Goodbye world ） 浏览器：我需要 foo.js ，在缓存里找到了。缓存还有效，那直接读缓存。产品经理：？？？这页面怎么跟以前一样啊？ 很尴尬。foo.js 明明更新了，但是浏览器还是读取在缓存中旧的 foo.js ，原因是我们用了缓存，不用缓存就没这事儿了。? 解决办法嘛，当然有的。比如每次利用缓存之前，先向服务器确认文件是否有更新，有更新则使用新的否则读缓存。还有一种方法是把缓存破坏掉，也就是下面要说的*Cache Busting Technique* Cache Busting Technique因为 foo.js 的代码变化了，但是他的缓存还没失效，此时浏览器还是会读取以前的缓存了的 foo.js ，并不会去服务器下载最新的。这显然不是我们想要的，怎么办呢？我们需要破坏缓存（ Cache Busting ）。 破坏缓存并不是禁止缓存，而是换一种方式让缓存失效。比如： 1.修改文件的名字：foo.js -&gt; foo.v2.js2.修改文件的路径：/static/foo.js -&gt; /static/v2/foo.js3.加 query string : foo.js -&gt; foo.js?v=qwer 我们下面将采用第一种方法，也就是修改文件的名字。我们把更新后的 foo.js 的文件名改成 foo.v2.js 。这样，浏览器就不会去读取缓存里的旧的 foo.js ，而是向服务请请求 foo.v2.js ，如下图所示： 那么，假设我们现在有很多很多的静态文件，然后每次需要更新很多很多的文件，那是不是要手动地一个一个地修改文件的名字呢？我们的理想当然是：哪个文件更新了，就自动地生成一个新的文件名。 另外，如果我们打包出来的静态文件只有一个单独的 JavaScript 文件 app.js ，那么每次改动一点代码，app.js 的文件名肯定都会变。但实际上，我只改动了某个模块的代码（其他模块并没有修改），就破坏了其他模块的缓存，这显然没有充分利用到缓存啊。我们的想法是：哪个模块更新了破坏他的缓存，没更新的模块继续利用缓存。 这个时候，我们就需要用到 webpack 的 code splitting（如果还不会的话，可以阅读 Webpack 大法之 Code Splitting ）。把整个 App 分成一个个 chunk ，然后哪个 chunk 发生改变，我就破坏他的缓存；没有更新的 chunk ，则继续利用缓存。这样一来，我们就把缓存的作用发挥到淋漓尽致～ 所以，code splitting 的作用除了”减少文件大小”之外，还能更充分地利用缓存。所以，下面就让我们用 webpack 来实现持久性缓存吧。 Webpack &amp; Caching首先，把我们的 demo 项目（已经实现了 code splitting ）下载并安装好依赖。 接着，修改 webpack 配置文件，给我们打包后的静态文件生成随机的唯一的名字。（ changed files ） // webpack.config.js module.exports = { output: { //... filename: &#39;[name].[chunkhash:8].js&#39;, chunkFilename: &#39;[name].[chunkhash:8].chunk.js&#39;, //... }, } 我们使用了 [chunkhash] 这个占位符，并且为了更好地分辨和展示 demo ，我们截取了他的前 8 个字符 [chunkhash:8]，但是在实际生产中我们不要那么做！ 好咯，现在来看看我们的打包后的文件： Asset Size Chunk Names common-in-lazy.fa79d198.chunk.js 11.6 kB common-in-lazy used-twice.c2c4927c.chunk.js 17.1 kB used-twice Photos.28d663ec.chunk.js 8.57 kB Photos Emoji.d3ea8991.chunk.js 1.15 kB Emoji app.724a238a.js 2.53 kB app vendor.05be8f94.js 104 kB vendor 那么，现在我们来修改一下 App.vue ，添加个 &lt;footer&gt; 标签（ changed files ） : &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- old codes --&gt; &lt;footer&gt; A Footer &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; 此时的打包变成了： Asset Size Chunk Names common-in-lazy.fa79d198.chunk.js 11.6 kB common-in-lazy used-twice.c2c4927c.chunk.js 17.1 kB used-twice Photos.28d663ec.chunk.js 8.57 kB Photos Emoji.d3ea8991.chunk.js 1.15 kB Emoji app.fdc2eedb.js 2.57 kB app vendor.b611a5da.js 104 kB vendor 注意到，我们的 app chunk 的 hash 从 724a238a 变成了 fdc2eedb ，这是我们所希望看到的东西。但是，与此同时 vendor chunk 的 hash 也变了（05be8f94 -&gt; b611a5da）。然而，我们并没有修改 vendor chunk 的代码，为什么他的 hash 也变了呢？? 原因是 vendor chunk 里面包含了 webpack 的 runtime 代码（用来解析和加载模块之类的运行时代码）： 解决办法就是把 webpack 的 runtime 代码提取出来（ changed files ）： new webpack.optimize.CommonsChunkPlugin({ name: [&#39;manifast&#39;] }), 把之前 App.vue 更新了的代码暂时去掉，也就是上面添加的 &lt;footer&gt; 标签去掉： 接着按照之前的，修改 App.vue ，添加 标签（ changed files ）： &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- old codes --&gt; &lt;footer&gt; A Footer &lt;/footer&gt; &lt;/div&gt; &lt;/template&gt; 而此时的打包： Asset Size Chunk Names common-in-lazy.fa79d198.chunk.js 11.6 kB common-in-lazy used-twice.c2c4927c.chunk.js 17.1 kB used-twice Photos.28d663ec.chunk.js 8.57 kB Photos Emoji.d3ea8991.chunk.js 1.15 kB Emoji app.fdc2eedb.js 2.57 kB app vendor.3b70f9d8.js 103 kB vendor manifast.1442e3f3.js 1.54 kB manifast 很开心，此时只有 app.js 和 manifast.js 这 2 个 chunk 的文件名的 hash 发生了改变，vendor.js chunk 和其他 chunk 都没变，舒服。 但是，假如我们给 App.vue 随便引入一个模块的话，比如（ changed files ）： &lt;script&gt; //... import noop from &#39;./shared/utils.js&#39; &lt;/script&gt; 而此时的打包： Asset Size Chunk Names common-in-lazy.30b1e9b6.chunk.js 11.6 kB common-in-lazy used-twice.9eccbe5a.chunk.js 17.1 kB used-twice Photos.6096611c.chunk.js 8.57 kB Photos Emoji.6208da60.chunk.js 1.15 kB Emoji app.4675a374.js 2.61 kB app vendor.8b538297.js 103 kB vendor manifast.25580296.js 1.54 kB manifast 卧槽居然所有 chunk 的 hash 都发生了改变，这是为什么？ 原因是在 webpack 里每个模块都有一个 module id ，module id 是该模块在模块依赖关系图里按顺序分配的序号，如果这个 module id 发生了变化，那么他的 chunkhash 也会发生变化。（不确定这里是否正确，希望大佬指出错误） 所以呢，我们需要用一种新的方式来计算 module id 。 HashedModuleIdsPlugin 这个插件，他是根据模块所在路径来映射其 module id ，这样就算引入了新的模块，也不会影响 module id 的值，只要模块的路径不改变的话。 修改我们的 webpack 配置。并且，去掉上面 App.vue 引入的 noop 模块。（ changed files ） // webpack.config.js plugins: [ new webpack.HashedModuleIdsPlugin(), // ... ], 可以看到，只有 app chunk 和 manifast chunk 的 hash 发生了改变，其他 chunk 不变所以他们的缓存就没被破坏。 总结用 webpack 实现 long term cache ： 生成稳定的 hash 文件名 提取 webpack 的 runtime 代码 code splitting 还有一些东西我们是没讲到的，比如 CSS 的 cache ，内联 manifast chunk 等等，就留给大家去探索咯。 最后需要注意的是，webpack 是允许其他 plugin 来修改 chunkhash 的，如果他们不能正确地处理的话，那么，假设你更新了代码，但是对应的 chunkhash 没变，并且此时缓存还没失效，就会导致线上的代码还是旧的，用户看到的还是以前的页面。因此，一定要特别注意 chunkhash 到底正不正确！！ 希望本文可以帮助到大家，这样我会很开心的。( )]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过一个问题学习map,filter,reduce语法]]></title>
    <url>%2F2019%2F07%2F24%2FJs%2F%E9%80%9A%E8%BF%87%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%E5%AD%A6%E4%B9%A0map-filter-reduce%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[比如一个从1-10的简单的数组，需要从中取奇数，你会怎么做？这个问题不难，有的少侠可能会使用for循环来过滤出偶数，某些少侠可能会使用while循环，又或是使用数组自带的filter方法。 这里，我们先不考虑使用for和while这些迭代方法，我们选择使用数组自带的filter方法，如果使用filter方法的话， const nums = [1,2,3,4,5,6,7,8,9,10]; // 过滤出所有奇数 nums.filter(num =&gt; num % 2 !== 0); console.log(nums); 还是挺简单的对吧？ 相信大部分少侠都能很轻松完成。 在filter函数内部，我们使用 num % 2 !== 0 来判断 是否是一个奇数，如果是一个奇数，就过滤出来。 在这里，有的少侠可能就会想到，如果把这个判断过程单独分成一个函数，会方便一些，也方便以后的修改扩展。 比如单独写一个isOdd函数 const isOdd = num =&gt; num % 2 !== 0; 然后在filter里面使用这个函数，是吧？ const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; // 过滤出所有奇数 const odd = nums.filter(isOdd); console.log(odd); 如果要把nums里面的数字翻倍，用map函数，又该怎么做呢？聪明的少侠这次肯定一下就明白了： const nums = [1,2,3,4,5,6,7,8,9,10]; const double = num =&gt; num *2; const doubleNumbers = nums.map(double); console.log(doubleNumbers); 从nums里面过滤出所有奇数，并翻倍这些奇数。这个问题也不难是吧？ 让我猜一下，一些少侠应该会写成下面这样： const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const double = num =&gt; num *2; const doubleNums = nums.filter(isOdd).map(double); console.log(doubleNums); 如果我们还想继续算出所有奇数翻倍后的和的话const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const double = num =&gt; num *2; const add = (sum,num) =&gt; sum += num; const doubleNums = nums.filter(isOdd).map(double).reduce(add,0); console.log(doubleNums); 嗯，一个串一个看起来很酷是吧？ 最后的结果也是正确的。 这样串起来的后果就是，我们会遍历3次数组，filter的时候遍历一次，map的时候遍历一次，reduce的时候再遍历一次。 现在数组只有10个数字，影响还不大，但是如果是很大的数组，比如100万个数字，遍历3遍的话，那么就会多访问150万次， 想象一下，如果让你自己从中间取出所有奇数，翻倍，并求和，你会觉得怎么做简单一些呢？ 是不是觉得下面这样才比较正常？ 首先，从第一个数字开始，如果它是奇数，就拿出来，翻倍，然后找个地方放起来 接着，继续看第二个数字，如果是偶数，就跳过，如果是奇数，就拿出来，翻倍，然后和开始的翻倍后的奇数加起来，找个地方放起来。 接着看第三个数字，以此类推，只要是奇数，就翻倍，然后和之前的结果加起来。 直到我们找寻到最后一个数字，就可以算出最终结果了， 如果使用迭代的话，就是下面这样: const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const double = num =&gt; num *2; const add = (sum,num) =&gt; sum += num; // 保存最终结果 let result = 0; for (let i =0; i&lt; nums.length; i++){ if(nums[i]%2 != 0){ result = result + nums[i]*2; } } console.log(result); // 50 没错，通常这样才是正常的操作。 但是， 这样的代码不太方便， 少侠你肯定也不想每次都写这么一大堆for循环语句吧？ 所以，我们可以先试着继续优化一下。 我们首先试着用一个叫做magic(魔法)的函数把这些步骤包裹起来: const nums = [1,2,3,4,5,6,7,8,9,10]; const magic = array =&gt; { const length = array.length, let i = 0; let sum = 0; for(i, i &lt; length; i++){ if(array[i] % 2 !== 0){ sum = sum + array[i]*2; } } return sum; } console.log(magic(nums)); // 50 现在看起来好多了，不过，magic内部的操作看起来不是很清晰， 其他少侠看见了可能很难一眼就明白magic函数在做什么, 我们可以试着把里面的一些步骤分成更小的函数: const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const double = num =&gt; num *2; const add = (sum,num) =&gt; sum += num; const magic = array =&gt; { const length = array.length, let i = 0; let sum = 0; for(i, i &lt; length; i++){ if(isOdd(array[i])){ sum = add(sum,double(array[i])); } } return sum; } console.log(magic(nums)); // 50 现在比较简洁也比较清晰了，不过，假如我们现在要计算是偶数而不是奇数怎么办呢？ 或者如果更复杂些，如果是偶数，就反过来，除以二，然后求和，又该怎么办呢？ 难道我们又要复制一次magic函数，然后改动for循环里面的逻辑吗？ 也许，我们可以把for循环内部的逻辑单独提取成一个外部函数！ const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const isEvent = num =&gt; !isOdd(num) const double = num =&gt; num *2; const part = num =&gt; num /2; const add = (sum,num) =&gt; sum += num; const magic = (array,fn,sum) =&gt; { const length = array.length, let i = 0; for(i, i &lt; length; i++){ sum = magicFriends(sum,array[i]) } return sum; } function magicFriends(sum,num){ if(isOdd(num)){ sum = add(sum,double(num)); } return sum ; } console.log(magic(nums,magicFriends,0)); // 50 接下来就是见证奇迹的时刻！首先，我们给代码里面部分函数和参数改一下名字: const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const isEvent = num =&gt; !isOdd(num) const double = num =&gt; num *2; const part = num =&gt; num /2; const add = (sum,num) =&gt; sum += num; const reduce = (array,reducer,result) =&gt; { const length = array.length, let i = 0; for(i, i &lt; length; i++){ result = reducer(sum,array[i]) } return result; } consot magicFriends = (sum,num) =&gt;{ if(isOdd(num)){ sum = add(sum,double(num)); } return sum ; } console.log(reduce(nums,magicFriends,0)); // 50 是不是有点眼熟了？ 接着，我们换成数组自带的reduce函数: const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const isEvent = num =&gt; !isOdd(num) const double = num =&gt; num *2; const part = num =&gt; num /2; const add = (sum,num) =&gt; sum += num; consot magicFriends = (sum,num) =&gt;{ if(isOdd(num)){ sum = add(sum,double(num)); } return sum ; } console.log(nums.reduce(magicFriends,0)); // 50 最后回到我们上面的问题:const nums = [1,2,3,4,5,6,7,8,9,10]; const isOdd = num =&gt; num % 2 !== 0; const double = num =&gt; num *2; const add = (sum,num) =&gt; sum += num; const result = nums.reduces((sum,num)=&gt; isOdd(num) ? add(sum,dobule(num) : sum,0)); console.log(result); // 50 这次我们用reduce只遍历了一次数组就完成了之前的操作！ 现在知道为什么之前要把reduce叫做magic(魔法)了吧！]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用 vue + typescript 编写页面(1)]]></title>
    <url>%2F2019%2F07%2F15%2FTs%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-vue-typescript-%E7%BC%96%E5%86%99%E9%A1%B5%E9%9D%A2-1%2F</url>
    <content type="text"><![CDATA[原文地址 起步使用 vue-cli 创建项目 vue create demo ，demo就是创建项目的名称提示选择预设，选择 Manually select features 回车确认选择typescript vuex router babel css pre-processors，不使用linter，不选单元测试有需要另说回车后按照需要选择合适的选项选择完毕后回车等待资源准备 编码开始熟悉几个vue的装饰器 vue-property-decorator 以下的装饰器的功能和原js编写的功能相同/相似，可以参照官方文档类比解读。 import { Vue, Component, Inject, Provide, Prop, Model, Watch, Emit, Mixins } from &#39;vue-property-decorator&#39; 1. Vue 实际上就是 Vue 本身,继承vue相关属性和函数class MyComponent extends Vue { } 2. @Component 声明成一个vue的组件实例，如果不使用，则不能得到一个vue组件第一种方式，不需要定义额外内容: @Component class MyComponent extends Vue { } 第二种方式，定义相关内容: @Component({ /* 这里和js版本编写的 vue 组件内容相同， * 凡是不能在ts里面完成的都可以在这里完成 * 最终会被合并到一个实例中。 * 在这里定义的内容，不会被语法器获取到，因此必须要同步在class中声明 */ data(){ return { myname:&quot;&quot;,age:18 } } }) class MyComponent extends Vue { private myname:string; mounted(){ this.myname; this.age;// 语法器报错，当前类找不到age属性 } } 3.@Provide 向任意层级的子组件提供可访问的属性，默认为当前属性的名称，可以指定名称@Component class ParentComponent extends Vue { @Provide() private info!:string; @Provide(&quot;next&quot;) private infoNext!:string; } 4. @Inject 获取父级由Provide提供的属性，默认为当前属性的名称，可以指定名称，多个父级提供相同名称属性时，获取最近父级的名称属性@Component class MyComponent extends Vue { @Inject() private info!:string; @Inject(&quot;next&quot;) private infoNext!:string; } 5. @Prop 由标签属性注入，获取对应标签属性上值,可配置具体prop内容，参照js版本props内容@Component class MyComponent extends Vue { @Prop() age!:number; @Prop({default:1}) sex!:number; } &lt;template&gt; &lt;MyComponent :age=&quot;16&quot; /&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot;&gt; import MyComponent from &#39;./MyComponent.vue&#39;; @Component({ components:{ MyComponent } }) class PComponent extends Vue { } &lt;/script&gt; 6. @Model 是v-model的装饰器，当自定义组件想使用v-model时，可以使用这种方式，配合emit可以双向传递属性值&lt;template&gt; &lt;input type=&quot;checkbox&quot; :checked=&quot;checked&quot; @change=&quot;changed&quot;/&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot;&gt; @Component class MyComponent extends Vue { @Model(&quot;change&quot;) checked!:number; changed(event:any){ /* 这里是偷懒写的any，在实际项目中需要避免 */ this.$emit(&quot;change&quot;,event.target.value) } } &lt;/script&gt; &lt;template&gt; &lt;MyComponent :age=&quot;16&quot; v-model=&quot;mycheck&quot; /&gt; &lt;/template&gt; &lt;script lang=&quot;ts&quot;&gt; import MyComponent from &#39;./MyComponent.vue&#39;; @Component({ components:{ MyComponent } }) class PComponent extends Vue { private mycheck:boolean = false; } &lt;/script&gt; 7. @Watch 观察某个属性更新@Component class MyComponent extends Vue { @Prop() age!:number; @Watch(&quot;age&quot;) ageChange(newVal:number,oldVal:number){ /*age属性更新时，处理相关内容*/ } } 8. @Emit this.$emit 的装饰器,如果没有指定名称，默认使用函数名称。有返回值时，使用返回值，没有则使用@Component class MyComponent extends Vue { private myname = &quot;&quot;; @Emit() ageChangeA(){ /* 仅发送 this.$emit(&#39;ageChangeA&#39;) */ } @Emit() ageChangeB(age:number){ /* 发送 age this.$emit(&#39;ageChangeB&#39;,age) */ } @Emit() ageChangeC(age:number){ return 1 /* this.$emit(&#39;ageChangeC&#39;,1) 发送return 结果*/ } } 9. Mixins// MyMixin.ts @Component export default class MyMixin extends Vue { /* 如果使用private 修饰，则两个相同的 私有属性混入时，会产生冲突 */ protected myname = &quot;张三&quot;; created(){ /* 混入对象有自己的 生命周期函数*/ } getMyName(){ console.log(&quot;张三混入&quot;) } } // OtherMixin.ts @Component export default class OtherMixin extends Vue { /* 如果使用private 修饰，则两个相同的 私有属性混入时，会产生冲突 */ protected myname = &quot;李四&quot;; created(){ /* 混入对象有自己的 生命周期函数*/ } getMyName(){ console.log(&quot;李四混入&quot;) } } @Component class MyComponent extends Mixins(MyMixin,OtherMixin) { private myname = &quot;&quot;; /* 混入对象已经定义，这里产生属性冲突 */ mounted(){ this.getMyName() // 李四混入 } } 对于computed，使用 get 替代@Component class MyComponent extends Vue { private myname = &quot;&quot;; /* 混入对象已经定义，这里产生属性冲突 */ get upperName(){ return &quot;A&quot; + this.myname } } 装饰器可以参照 vue-property-decorator 没有filters,没有指令相关装饰器，有需要可以在@Component里面补充，或者可以直接定义函数调用计算返回值 在class里定义的属性即data属性，需要赋值初始值。 typescript 混用js当我们引用了一个js编写的模块时会报错，这时候，如果不在引入的index文件里面添加.d.ts描述文件，那么这个模块就没法在语义上一致通过. 通用兼容性解决方案如果这个模块是由npm下载的，并且有@types版本，可以直接使用npm install @types/xx下载 可惜,大部分都是没有编写声明文件的.但是又需要使用到这个模块时,应该怎么做. 自定义描述文件 在项目的【根目录】下定义【模块相同的名称】的描述文件A.d.ts,在描述文件内编写模块声明描述 // A.d.ts declare module &#39;*&#39;; 这样属于一劳永逸的描述,但是无法描述到具体模块内容,因此这种方式仅仅引入的组件没有任何操作时,比如引入的是第三方开发的vue组件,可以用这种方式偷懒. 详细描述文件 // A.d.ts declare module &quot;A&quot; { // 添加具体的描述内容 }; 可以从这里查询到@type包查询，已经被编写的文件声明可以直接下载]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 的好处都有啥？和 JavaScript 的区别在哪？]]></title>
    <url>%2F2019%2F07%2F04%2FTs%2FTypeScript-%E7%9A%84%E5%A5%BD%E5%A4%84%E9%83%BD%E6%9C%89%E5%95%A5%EF%BC%9F%E5%92%8C-JavaScript-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文地址 在我看来 TypeScript 相对于 JavaScript ，除了静态类型外没带来任何东西。 既然如此 静态类型有什么好处静态类型的好处到处都有说，这里就不说得太详细了，随便列一点。 杜绝手误导致的变量名错误 自动完成 重构支持 类型可以一定程度上充当文档 静态类型解放脑容量，自动完成让我不需要记忆哪个变量里有哪些属性，也不需要记完整的变量名。 函数上的类型约束外加尽量主动写纯函数让我在写函数实现的时候不需要关注函数之外的任何东西，注意力聚焦在当前函数。 当然，也不只有好处。 静态类型有什么不足 类型标注麻烦。 现阶段大部分静态类型语言的类型系统还不够强。 eval 和 new Function() 这种骚操作类型系统管不到。 需要编译，类型检查会增加编译时长，语法和类型系统复杂的话时间特别特别长，比如 scala。 标注麻烦的问题无法根绝，但是类型推导能解决大部分的类型标注问题。 类型系统不够强的问题会随着时间慢慢变好。 编译的问题在 ts 可能也并不算问题，ts 的类型检查并不影响 ts 编译成 js。 也就是说就算类型检查不通过 ts 也能跑起来。所以对 ts 来说类型检查可以从编译中提取出来，作为独立的编译和类型检查两部分。 先编译输出，再做类型检查，编译的部分相当于 babel 这种工具做的事。 类型检查也可以单独运行。 那么， TypeScript 的类型系统有哪些特点？ 图灵完备。（虽然不太清楚这意味着什么） 渐进的类型系统，所有类型标注都是可选的，既是天使又是恶魔的 any 类型。（被 Haskell 大牛 Colliot 称为 ts 类型系统的漏洞） 支持局部类型推导。 丰富的类型层面的计算，如 index types, mapped types, conditional types 等等。 支持鸭子类型。（或叫结构子类型？） 像 js 支持对象字面量一样支持方便的对象字面类型（object literal type），字符串和数字还有布尔值字面类型。 空安全。 基于控制流的类型分析 还有许多我觉得比较平常的点就没有列出来，比如支持类型别名，泛型，协变逆变双变等等。 ts 是一门非常非常非常工程的语言，很强大，但是可能和优雅沾不上半点关系。 可选的类型标注搭配类型推导，让 ts 的类型系统更像是工具，而不是枷锁。好的产品是用完即走的。 有时候，稍微开个洞，能让事情变简单很多。比如 any。 鸭子类型加上上面提到的特性可以让你依旧感觉和 js 一样，像大海里的鱼一样自由。 Null References: The Billion Dollar Mistake ，而 js 里有两个 null（null 和 undefined），虽然前端通常不会造成非常严重的损失，但是 js 也慢慢被应用到不仅仅是前端的许多地方了。 ts 这么好， 怎么学 TypeScript？成也渐进，败也渐进，有部分人通过可选的类型标注，一步一步无痛地过渡到学会 ts。 而另一部分人玩了一会儿，发现和写 js 并没有一丁点区别，而且还离开了熟悉的环境，就放弃了。 ts 并不会强迫你使用类型，所以就需要更强的动力来推动自己学习。 如果身边有会 ts 的朋友的话，对学习 ts 会比较有帮助。 多让会 ts 的朋友看自己的代码，改良自己的写法。多写，很容易就能学会。 如果身边没有会 ts 的人，其实我更建议先用 JSDoc。 使用 vscode 或者 webstorm 的时候直接写 JSDoc 就行了，vsc 或 webstorm 会依靠 ts 来提供类型推导和自动完成。 这样可以在工作或自己写东西的时候慢慢习惯并且主动去使用类型标注。 在使用一段时间后感觉 JSDoc 已经不够用了，满足不了自己的需求了，再开始使用 ts。 同时也要多主动去了解和学习一些 ts 的代码，不然的话，不知道 ts 有多好，自然就不会觉得 JSDoc 不够用。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中不常用的API的使用方法总结]]></title>
    <url>%2F2019%2F06%2F13%2FVue%2Fvue%E4%B8%AD%E4%B8%8D%E5%B8%B8%E7%94%A8%E7%9A%84API%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[errorHandler官网介绍及使用： 指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例 Vue.config.errorHandler = function (err, vm, info) { //处理错误信息, 进行错误上报 //err错误对象 //vm Vue实例 //`info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子 //只在 2.2.0+ 可用 } Vue.observable( object )这个相当于一个简单的store管理，在不用vuex的情况下，不同组件之间通信可以用Vue.observeable 官网介绍： 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生改变时触发相应的更新。也可以作为最小化的跨组件状态存储器，用于简单的场景： 使用： 在store.js中 impor vue from &#39;vue&#39;; export const store = vue.observable({count:0}); export const mutation = { setCount(count){ store.count = count; } } 在组件中使用 &lt;template&gt; &lt;div class=&quot;hello&quot;&gt; &lt;p @click=&quot;setCount(testCount + 1)&quot;&gt;+&lt;/p&gt; &lt;p @click=&quot;setCount(testCount - 1)&quot;&gt;-&lt;/p&gt; &lt;test /&gt; &lt;p&gt;{{testCount}}&lt;/p&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import test from &#39;./test&#39; import { store, mutation} from &#39;@/store&#39; export default { name: &#39;HelloWorld&#39;, data () { return { msg: &#39;Welcome to Your Vue.js App&#39; } }, components: { test }, methods: { setCount: mutation.setCount }, computed: { testCount(){ return store.count } } } &lt;/script&gt; &lt;!-- Add &quot;scoped&quot; attribute to limit CSS to this component only --&gt; &lt;style scoped&gt; h1, h2 { font-weight: normal; } ul { list-style-type: none; padding: 0; } li { display: inline-block; margin: 0 10px; } a { color: #42b983; } &lt;/style&gt; test 组件 &lt;template&gt; &lt;div&gt;test{{testCount}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; import { store } from &#39;@/store&#39;; export default { computed: { testCount(){ return store.count } } } &lt;/script&gt; &lt;style scoped&gt; &lt;/style&gt; errorCaptured(2.5.0新增的生命周期钩子)官网介绍： 当捕获一个来自子孙组件的错误时被调用。此钩子会收到三个参数：错误对象、发生错误的组件实例以及一个包含错误来源信息的字符串。此钩子可以返回 false 以阻止该错误继续向上传播。 与errorhandler的不同之处： errorCaptured 和 errorHandler 的触发时机都是相同的，不同的是 errorCaptured 发生在前，且如果某个组件的 errorCaptured 方法返回了 false，那么这个异常信息不会再向上冒泡也不会再调用 errorHandler 方法 parent官网介绍： 指定已创建的实例之父实例，在两者之间建立父子关系。子实例可以用 this.$parent 访问父实例，子实例被推入父实例的 $children 数组中。 注意:节制地使用 $parent 和 $children - 它们的主要目的是作为访问组件的应急方法。更推荐用 props 和 events 实现父子组件通信 使用: this.$parent.xxx() //直接在子组件调用父组件中方法 mixin官网介绍： mixins 选项接受一个混入对象的数组。这些混入实例对象可以像正常的实例对象一样包含选项，他们将在 Vue.extend() 里最终选择使用相同的选项合并逻辑合并。举例：如果你的混入包含一个钩子而创建组件本身也有一个，两个函数将被调用。 mixins就是定义一部分公共的方法或者计算属性,然后混入到各个组件中使用,方便管理与统一修改 1、在assets文件夹下创建一个js文件 // 创建一个需要混入的对象 export const mixinTest1 = { created() { this.hello(); }, methods: { hello() { console.log(&#39;mixinTest1&#39;); } } }; 2、在组件中使用刚刚创建的混入 import {mixinTest1} from &#39;./../assets/js/mixin&#39;; export default { mixins:[mixinTest1], name: &#39;hello&#39;, data () { return { msg: &#39;Welcome to Your Vue.js App&#39; } } } 3、如果组件中定义的方法与混入对象中的方法/属性一样,组件中的优先级大于混入对象中的(方法会调用多次) 4、混入对象中可以定义抽象方法,使用混入的组件必须重写该方法 ... methods: { handlePlaylist() { throw new Error(&#39;component must implement handlePlaylist method&#39;) } } ... provide / inject官网介绍： 这对选项需要一起使用，以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。如果你熟悉 React，这与 React 的上下文特性很相似。 provide 选项应该是一个对象或返回一个对象的函数。该对象包含可注入其子孙的属性。在该对象中你可以使用 ES2015 Symbols 作为 key，但是只在原生支持 Symbol 和 Reflect.ownKeys 的环境下可工作。 inject 选项应该是： 一个字符串数组，或一个对象，对象的 key 是本地的绑定名，value 是：在可用的注入内容中搜索用的 key (字符串或 Symbol)，或一个对象，该对象的：from 属性是在可用的注入内容中搜索用的 key (字符串或 Symbol)default 属性是降级情况下使用的 value 注意：provide 和 inject 主要为高阶插件/组件库提供用例。并不推荐直接用于应用程序代码中。 我之前使用到provide / inject是模拟页面数据回到初始状态，相当于刷新当前页面，但是直接刷新当前页面会有几秒的空白期，体验不好，所以用到了provide / inject 使用方法： 1.修改App.vue代码如下图所示 &lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-view v-if=&quot;isRouterActive&quot;/&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default{ name: &#39;App&#39;, provide:{ retrun{ reload:this.reload } }, data(){ return{ isRouterActive: true } }, methods:{ reload(){ this.isRouterActive = false; this.$nextTick(()=&gt;{ this.isRouterActive = true; }) } } } &lt;/script&gt; 通过声明reload方法，控制isRouterAlice属性true or false 来控制router-view的显示或隐藏，从而控制页面的再次加载 2.在需要当前页面刷新的页面中注入App.vue组件提供（provide）的 reload 依赖，然后直接用this.reload来调用就行 export defalut{ inject:[&#39;reload&#39;], data(){ return{ } }, methods:{ reloadPage(){ this.reload(); } } } keep-alive官网介绍： &lt;keep-alive&gt; 包裹动态组件时，会缓存不活动的组件实例，而不是销毁它们。和 &lt;transition&gt; 相似，&lt;keep-alive&gt; 是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。 当组件在 &lt;keep-alive&gt; 内被切换，它的 activated 和 deactivated 这两个生命周期钩子函数将会被对应执行。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 高级技巧]]></title>
    <url>%2F2019%2F06%2F12%2FTs%2FTypeScript-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[原文地址 前言用了一段时间的 typescript 之后，深感中大型项目中 typescript 的必要性，它能够提前在编译期避免许多 bug，如很恶心的拼写问题。而越来越多的 package 也开始使用 ts，学习 ts 已是势在必行。 01 keyofkeyof 与 Object.keys 略有相似，只不过 keyof 取 interface 的键。 interface Point { x: number; y: number; } // type keys = &quot;x&quot; | &quot;y&quot; type keys = keyof Point; 假设有一个 object 如下所示，我们需要使用 typescript 实现一个 get 函数来获取它的属性值 const data = { a: 3, hello: &#39;world&#39; } function get(o: object, name: string) { return o[name] } 我们刚开始可能会这么写，不过它有很多缺点1.无法确认返回类型：这将损失 ts 最大的类型校验功能2.无法对 key 做约束：可能会犯拼写错误的问题 这时可以使用 keyof 来加强 get 函数的类型功能，有兴趣的同学可以看看 _.get 的 type 标记以及实现 function get&lt;T extends object, K extends keyof T&gt;(o: T, name: K): T[K] { return o[name] } 02 Partial &amp; Pick既然了解了 keyof，可以使用它对属性做一些扩展， 如实现 Partial 和 Pick，Pick 一般用在 _.pick 中 type Partial&lt;T&gt; = { [P in keyof T]?: T[P]; }; type Pick&lt;T, K extends keyof T&gt; = { [P in K]: T[P]; }; interface User { id: number; age: number; name: string; }; // 相当于: type PartialUser = { id?: number; age?: number; name?: string; } type PartialUser = Partial&lt;User&gt; // 相当于: type PickUser = { id: number; age: number; } type PickUser = Pick&lt;User, &quot;id&quot; | &quot;age&quot;&gt; 03 Condition Type类似于 js 中的 ?: 运算符，可以使用它扩展一些基本类型 T extends U ? X : Y type isTrue&lt;T&gt; = T extends true ? true : false // 相当于 type t = false type t = isTrue&lt;number&gt; // 相当于 type t = false type t1 = isTrue&lt;false&gt; 04 never &amp; Exclude &amp; Omit官方文档对 never 的描述如下 the never type represents the type of values that never occur. 结合 never 与 conditional type 可以推出很多有意思而且实用的类型，比如 Omit type Exclude&lt;T, U&gt; = T extends U ? never : T; // 相当于: type A = &#39;a&#39; type A = Exclude&lt;&#39;x&#39; | &#39;a&#39;, &#39;x&#39; | &#39;y&#39; | &#39;z&#39;&gt; 结合 Exclude 可以推出 Omit 的写法 type Omit&lt;T, K extends keyof any&gt; = Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;; interface User { id: number; age: number; name: string; }; // 相当于: type PickUser = { age: number; name: string; } type OmitUser = Omit&lt;User, &quot;id&quot;&gt; 05 typeof顾名思义，typeof 代表取某个值的 type，可以从以下示例来展示他们的用法 const a: number = 3 // 相当于: const b: number = 4 const b: typeof a = 4 在一个典型的服务端项目中，我们经常需要把一些工具塞到 context 中，如config，logger，db models, utils 等，此时就使用到 typeof。 import logger from &#39;./logger&#39; import utils from &#39;./utils&#39; interface Context extends KoaContect { logger: typeof logger, utils: typeof utils } app.use((ctx: Context) =&gt; { ctx.logger.info(&#39;hello, world&#39;) // 会报错，因为 logger.ts 中没有暴露此方法，可以最大限度的避免拼写错误 ctx.loger.info(&#39;hello, world&#39;) }) 06 is在此之前，先看一个 koa 的错误处理流程，以下是对 error 进行集中处理，并且标识 code 的过程 app.use(async (ctx, next) =&gt; { try { await next(); } catch (err) { let code = &#39;BAD_REQUEST&#39; if (err.isAxiosError) { code = `Axios-${err.code}` } else if (err instanceof Sequelize.BaseError) { } ctx.body = { code } } }) 在 err.code 处，会编译出错，提示 Property ‘code’ does not exist on type ‘Error’.ts(2339)。 此时可以使用 as AxiosError 或者 as any 来避免报错，不过强制类型转换也不够友好 if ((err as AxiosError).isAxiosError) { code = `Axios-${(err as AxiosError).code}` } 此时可以使用 is 来判定值的类型 function isAxiosError (error: any): error is AxiosError { return error.isAxiosError } if (isAxiosError(err)) { code = `Axios-${err.code}` } 在 GraphQL 的源码中，有很多诸如此类的用法，用以标识类型 export function isType(type: any): type is GraphQLType; export function isScalarType(type: any): type is GraphQLScalarType; export function isObjectType(type: any): type is GraphQLObjectType; export function isInterfaceType(type: any): type is GraphQLInterfaceType; 07 interface &amp; typeinterface 与 type 的区别是什么？可以参考以下 stackoverflow 的问题 https://stackoverflow.com/questions/37233735/typescript-interfaces-vs-types 一般来说，1interface与type` 区别很小，比如以下两种写法差不多 interface A { a: number; b: number; }; type B { a: number; b: number; } 其中 interface 可以如下合并多个，而 type 只能使用 &amp; 类进行连接。 interface A { a: number; } interface A { b: number; } const a: A = { a: 3, b: 4 } 08 Dictionary &amp; Many这几个语法糖是从 lodash 的 types 源码中学到的，平时工作中的使用频率还挺高。 interface Dictionary&lt;T&gt; { [index: string]: T; }; interface NumericDictionary&lt;T&gt; { [index: number]: T; }; const data:Dictionary&lt;number&gt; = { a: 3, b: 4 } 09 使用 const enum 维护常量表相比使用字面量对象维护常量，const enum 可以提供更安全的类型检查 // 使用 object 维护常量 const enum TODO_STATUS { TODO = &#39;TODO&#39;, DONE = &#39;DONE&#39;, DOING = &#39;DOING&#39; } // 使用 const enum 伟华常量 const enum TODO_STATUS { TODO = &#39;TODO&#39;, DONE = &#39;DONE&#39;, DOING = &#39;DOING&#39; } function todos (status: TODO_STATUS): Todo[]; todos(TODO_STATUS.TODO) 10 VS Code Tips &amp; Typescript Command使用 VS Code 有时会出现，使用 tsc 编译时产生的问题与 vs code 提示的问题不一致 找到项目右下角的 Typescript 字样，右侧显示它的版本号，可以点击选择 Use Workspace Version，它表示与项目依赖的 typescript 版本一直。 或者编辑 .vs-code/settings.json { &quot;typescript.tsdk&quot;: &quot;node_modules/typescript/lib&quot; } 11 Typescript Roadmap最后一条也是最重要的一条，翻阅 Roadmap，了解 ts 的一些新的特性与 bug 修复情况。 Typescript Roadmap]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Ts</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(十四) --Node项目-商品列表]]></title>
    <url>%2F2019%2F05%2F25%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%8D%81%E5%9B%9B)%20--Node%E9%A1%B9%E7%9B%AE-%E5%95%86%E5%93%81%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[Node.js项目介绍利用学到的知识，实现一个简单但实用的小项目如下： 这是一个商品列表，具有展示商品信息，添加商品，删除商品的功能。 项目的文件夹结构├── package.json├── server.js # 服务器代码├── config # 项目配置文件夹│ ├── config.dev.js # 开发环境配置│ ├── config.prod.js # 生产环境配置│ ├── index.js # 导出当前所处环境及配置├── libs # 项目工具文件夹│ ├── database.js # 连接数据库│ ├── http.js # 服务器配置│ ├── router.js # 处理路由├── router # 项目路由配置文件夹│ ├── index.js # 连接数据库│ ├── list.js # 获取商品列表接口配置│ ├── add.js # 增加商品接口配置│ ├── del.js # 删除商品接口配置├── static # 静态资源文件夹│ ├── index.html # 前端HTML页面│ ├── js # 前端JavaScript文件夹│ ├── css # 前端CSS文件夹│ ├── fonts # 前端字体文件夹│ ├── upload # 前端上传文件夹 判断当前所处环境通常项目在开发环境和生产环境要采用不同的，服务器、账号、域名、端口等配置，如果用人工进行切换操作麻烦且容易出错，因此通常使用环境变量进行判断。 首先引入process模块const process=require(&#39;process&#39;)，该模块提供了当前Node.js进程的信息。 1.可以通过process.env环境变量获取开发环境和生产环境系统等参数差异，如开发环境运行在Windows系统上，而生产环境运行在Linux系统，那么就可以使用process.env.OS === &#39;Windows_NT&#39;判断当前所处的是否开发环境。 const mode = process.env.OS === &#39;Windows_NT&#39; ? &#39;env&#39; : &#39;prod&#39; 2.也可以通过package.json中配置的启动命令判断处于开发还是生产环境，如开发环境命令npm start --dev和生产环境命令npm run build --build。 const mode = process.argv[2] === &#39;--dev&#39; ? &#39;env&#39; : &#39;prod&#39; 初始化开发和生产环境配置在/config/index.js中，判断所处的环境，并将相应环境的标识和参数作为模块导出。开发过程中，可以直接引用相应的配置使用。 const process = require(&#39;process&#39;) // 可以通过开发环境和生产环境系统等参数差异，判断处于哪个环境。 // const mode = process.env.OS === &#39;Windows_NT&#39; ? &#39;env&#39; : &#39;prod&#39; // 也可以通过package.json中配置的启动命令判断处于开发还是生产环境。 const mode = process.argv[2] === &#39;--dev&#39; ? &#39;env&#39; : &#39;prod&#39; module.exports = { mode, // 当前所处环境 ...(mode === &#39;env&#39; ? require(&#39;./config.dev&#39;) : require(&#39;./config.prod&#39;)) // 当前环境的配置 } 1.以开发环境为例，需要使用的配置为服务器域名、端口号、账号、密码、数据库名，以及HTTP端口、静态文件绝对路径、上传文件保存绝对路径，如下： module.exports = { // 数据库配置 DB_HOST: &#39;localhost&#39;, DB_PORT: 3306, DB_USER: &#39;root&#39;, DB_PASS: &#39;&#39;, DB_NAME: &#39;test&#39;, // HTTP端口 HTTP_PORT: 8080, // 静态文件绝对路径 HTTP_ROOT: path.resolve(__dirname, &#39;../static/&#39;), // 上传文件保存绝对路径 HTTP_UPLOAD: path.resolve(__dirname, &#39;../static/upload&#39;) } 连接数据库在lib文件夹下，创建database.js，用于连接数据库。 // 引入mysql和co-mysql，用于连接数据库 const mysql = require(&#39;mysql&#39;) const coMysql = require(&#39;co-mysql&#39;) // 引入数据库配置 const { DB_HOST, DB_PORT, DB_USER, DB_PASS, DB_NAME } = require(&#39;../config&#39;) // 1. 创建服务器连接池 const pool = mysql.createPool({ host: DB_HOST, port: DB_PORT, user: DB_USER, password: DB_PASS, database: DB_NAME }) // 2. 使用co-mysql包装连接池，将连接转换为Async/Await异步方式 const connection = coMysql(pool) // 3. 作为模块导出使用 module.exports = connection 创建数据库连接后，可以在server.js中，创建一个数据库连接，并查看item_table表的数据 const connection = require(&#39;./lib/database&#39;) ;(async () =&gt; { // 查询item_table表中的数据 const response = await connection.query(`SELECT * FROM item_table`) console.log(response) })() 若正常连接，即可打印数据如下： [ RowDataPacket { ID: 1, title: &#39;运动服&#39;, price: 299, count: 998 } ]ice: 199, count: 999 }, RowDataPacket { ID: 2, title: &#39;运动裤&#39;, price: 299, count: 998 } ] 创建路由在之前的例子中，我们总是要通过if else语句来判断请求的接口路径，并进行相应操作。 这样会极大地降低开发效率，也不利于后期代码维护。 因此，通常的开发中，都会使用路由对不同的接口进行操作。 现在我们就来自己实现一个简单的路由： 1.先创建一个router对象，用于存储路由表。其中有2个属性，分别为get、post，分别用于存储相应get、post请求地址的回调方法 // 创建路由表 let router = { // 存储get请求的路由 get: { }, // 存储post请求的路由 post: { } } 2. 创建一个addRouter方法，用于添加路由配置，参数method为请求方法，url为请求地址，callback为处理该请求的回调函数。 // 添加路由的方法，method为请求方法，url为请求地址，callback为处理该请求的回调函数 function addRouter(method, url, callback) { // 为便于处理，将method和url统一转换成小写 method = method.toLowerCase() url = url.toLowerCase() // 将处理请求的回调函数，按方法名和地址储存到路由表中 router[method][url] = callback } 3. 创建一个findRouter方法，用于查找相应路由的回调函数。参数method为请求方法，url为请求地址，返回处理路由的回调函数。 // 查找处理请求的回调函数的方法，method为请求方法，url为请求地址，返回处理路由的回调函数 function findRouter(method, url) { // 为便于处理，将method和url统一转换成小写 method = method.toLowerCase() url = url.toLowerCase() // 找到路由对应的回调函数，不存在则默认返回null const callback = router[method][url] || null // 将回调函数返回 return callback } 4. 将路由配置作为模块导出 // 将添加路由和查找路由方法导出 module.exports = { addRouter, findRouter } 创建服务器在实现了路由之后，就可以以此为基础实现服务器了。 实现服务器分为以下几个步骤： 1.引入所需Node.js模块、服务器配置、路由模块2.封装统一处理请求数据的方法3.接收到的请求分为POST请求、GET请求，区分并进行处理4.POST请求分为数据请求、文件上传请求，区分并进行处理5.GET请求分为数据请求、读取文件请求，区分并进行处理 接下来，按步骤实现每部分代码。 1. 引入所需Node.js模块、服务器配置、路由模块 // 引入创建服务器所需的模块 const http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const querystring = require(&#39;querystring&#39;) const zlib = require(&#39;zlib&#39;) const fs = require(&#39;fs&#39;) const { Form } = require(&#39;multiparty&#39;) // 引入服务器配置 const { HTTP_PORT, HTTP_ROOT, HTTP_UPLOAD } = require(&#39;../config&#39;) // 引入路由模块的查找路由方法 const { findRouter } = require(&#39;./router&#39;) const server = http.createServer((req, res) =&gt; { // 服务器代码 }) // 监听配置的端口 server.listen(HTTP_PORT) // 打印创建服务器成功信息 console.log(`Server started at ${HTTP_PORT}`) 2. 封装统一处理请求数据的方法 要处理所有请求接口，需要的参数为method（请求方法）、pathname（请求接口路径）、query（query数据）、post（post数据）、files（文件数据）。 首先，根据method（请求方法）、pathname（请求接口路径），获取在路由配置时，已经配置好的相应接口的回调函数。其次，若回调函数存在，则直接将参数传入回调函数处理。最后，若回调函数不存在，则默认为请求一个静态文件，即可将文件读取之后发送给前端。 // 引入创建服务器所需的模块 ... // 引入服务器配置 ... // 引入路由模块的查找路由方法 ... const server = http.createServer((req, res) =&gt; { // 通过路由处理请求数据的公共方法 async function processData(method, pathname, query, post, files) { const callback = findRouter(method, pathname) // 获取处理请求的回调函数 // 若回调函数存在，则表示路由有配置相应的数据处理，即该请求不是获取静态文件。 if (callback) { try { // 根据路由处理接口数据 await callback(res, query, post, files) } catch (error) { // 出现错误的处理 res.writeHead(500) res.write(&#39;Internal Server Error&#39;) res.end() } } else { // 若回调函数不存在，则表示该请求为请求一个静态文件，如html、css、js等 ... } } }) // 监听配置的端口 server.listen(HTTP_PORT) // 打印创建服务器成功信息 console.log(`Server started at ${HTTP_PORT}`) 3. 接收到的请求分为POST请求、GET请求，区分并进行处理 根据请求的method，将请求分为POST请求、GET请求。 若为POST请求，则需要进一步判断是普通数据请求，还是文件请求，并分别进行处理。 而GET请求，只需要将数据传入processData方法进行处理，在processData方法中，区分GET请求获取数据，还是获取静态文件。 // 引入创建服务器所需的模块 ... // 引入服务器配置 ... // 引入路由模块的查找路由方法 ... const server = http.createServer((req, res) =&gt; { // 解析请求数据 // 获取请求路径及query数据 const method = req.method const { pathname, query } = url.parse(req.url, true) // 处理POST请求 if (method === &#39;POST&#39;) { // POST请求分为数据请求、文件上传请求，区分并进行处理 ... } else { // 处理GET请求 // 通过路由处理数据，因为此时是GET请求，只有query数据 processData(method, url, query, {}, {}) } // 通过路由处理请求数据的公共方法 async function processData(method, pathname, query, post, files) { ... } }) // 监听配置的端口 server.listen(HTTP_PORT) // 打印创建服务器成功信息 console.log(`Server started at ${HTTP_PORT}`) 4. POST请求分为数据请求、文件上传请求，区分并进行处理 判断请求头的content-type为application/x-www-form-urlencoded时，表示该请求只是单纯传输数据，可以直接当做字符串处理。若请求头的content-type不对，则表示该请求是上传文件，可以用multiparty进行处理。 // 引入创建服务器所需的模块 ... // 引入服务器配置 ... // 引入路由模块的查找路由方法 ... const server = http.createServer((req, res) =&gt; { // 解析请求数据 // 获取请求路径及query数据 const method = req.method const { pathname, query } = url.parse(req.url, true) // 处理POST请求 if (method === &#39;POST&#39;) { // 根据请求头的content-type属性值，区分是普通POST请求，还是文件请求。 // content-type为application/x-www-form-urlencoded时，表示是普通POST请求 // 普通POST请求直接进行处理，文件请求使用multiparty处理 if (req.headers[&#39;content-type&#39;].startsWith(&#39;application/x-www-form-urlencoded&#39;)) { // 普通POST请求 let arr = [] // 存储Buffer数据 // 接收数据 req.on(&#39;data&#39;, (buffer) =&gt; { arr.push(buffer) }) // 数据接收完成 req.on(&#39;end&#39;, () =&gt; { const data = Buffer.concat(arr) // 合并接收到的数据 const post = querystring.parse(data.toString()) // 将接收到的数据转换为JSON // 通过路由处理数据，因为此时是普通POST请求，不存在文件数据 processData(method, pathname, query, post, {}) }) } else { // 文件POST请求 const form = new Form({ uploadDir: HTTP_UPLOAD // 指定文件存储目录 }) // 处理请求数据 form.parse(req) let post = {} // 存储数据参数 let files = {} // 存储文件数据 // 通过field事件处理普通数据 form.on(&#39;field&#39;, (name, value) =&gt; { post[name] = value }) // 通过file时间处理文件数据 form.on(&#39;file&#39;, (name, file) =&gt; { files[name] = file }) // 处理错误 form.on(&#39;error&#39;, (error) =&gt; { console.error(error) }) // 数据传输完成时，触发close事件 form.on(&#39;close&#39;, () =&gt; { // 通过路由处理数据，因为此时是POST文件请求，query、post、files数据都存在 processData(method, pathname, query, post, files) }) } } else { // 处理GET请求 // 通过路由处理数据，因为此时是GET请求，只有query数据 processData(method, url, query, {}, {}) } // 通过路由处理请求数据的公共方法 async function processData(method, pathname, query, post, files) { ... } }) // 监听配置的端口 server.listen(HTTP_PORT) // 打印创建服务器成功信息 console.log(`Server started at ${HTTP_PORT}`) 5. GET请求分为数据请求、读取文件请求，区分并进行处理 GET请求可以直接用processData方法统一处理，若路由中未配置处理数据的方法，则表示该请求为获取静态文件，需要进行单独处理，否则只需要调用路由配置的回调函数处理即可。 // 引入创建服务器所需的模块 ... // 引入服务器配置 ... // 引入路由模块的查找路由方法 ... const server = http.createServer((req, res) =&gt; { // 解析请求数据 // 获取请求路径及query数据 const method = req.method const { pathname, query } = url.parse(req.url, true) // 处理POST请求 if (method === &#39;POST&#39;) { ... } else { // 处理GET请求 // 通过路由处理数据，因为此时是GET请求，只有query数据 processData(method, url, query, {}, {}) } // 通过路由处理请求数据的公共方法 async function processData(method, pathname, query, post, files) { const callback = findRouter(method, pathname) // 获取处理请求的回调函数 // 若回调函数存在，则表示路由有配置相应的数据处理，即该请求不是获取静态文件。 if (callback) { try { // 根据路由处理接口数据 await callback(res, query, post, files) } catch (error) { // 出现错误的处理 res.writeHead(500) res.write(&#39;Internal Server Error&#39;) res.end() } } else { // 若回调函数不存在，则表示该请求为请求一个静态文件，如html、css、js等 const filePath = HTTP_ROOT + pathname // 检查文件是否存在 fs.stat(filePath, (error, stat) =&gt; { if (error) { // 出现错误表示文件不存在 res.writeHead(404) res.write(&#39;Not Found&#39;) res.end() } else { // 文件存在则进行读取 // 创建一个可读流。 const readStream = fs.createReadStream(filePath) // 创建一个Gzip对象，用于将文件压缩成 const gz = zlib.createGzip() // 向浏览器发送经过gzip压缩的文件，设置响应头，否则浏览器无法识别，会自动进行下载。 res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;) // 将读取的内容，通过gzip压缩之后，在通过管道推送到res中，由于res继承自Stream流，因此也可以接收管道的推送。 readStream.pipe(gz).pipe(res) readStream.on(&#39;error&#39;, (error) =&gt; { console.error(error) }) } }) } } }) // 监听配置的端口 server.listen(HTTP_PORT) // 打印创建服务器成功信息 console.log(`Server started at ${HTTP_PORT}`) 测试服务器在server.js中引入封装的http模块： const http = require(&#39;./lib/http&#39;) 再使用node server.js启动服务器，就可以在浏览器中访问http://localhost:8080/index.html，看到html页面 添加各接口路由配置获取商品列表路由回调函数 查询item_table表中的商品数据后，返回给前台，并将回调函数作为模块导出。 const connection = require(&#39;../lib/database&#39;) module.exports = async (res, query, post, files) =&gt; { try { // 查询商品列表 const data = await connection.query(`SELECT * FROM item_table`) res.writeJson({ error: 0, // error为0则表示接口正常 data // 查询到的商品列表数据 }) } catch (error) { console.error(error) res.writeJson({ error: 1, // error为1则表示接口出错 msg: &#39;数据库出错&#39; // 接口的错误信息 }) } res.end() } 添加商品路由回调函数应禁止query语句使用如下写法，容易造成注入攻击。connection.query(INSERT INTO item_table (title, price, count) VALUES(&#39;${title}, ${price} ${count}&#39;))此时若用户传入参数如下： http://localhost:8080/add?title=a&#39;)%3B%20DELETE%20FROM%20item_table%3B%20SELECT%20(1&amp;price=19.8&amp;count=200 就会让服务器执行一个这样的语句： INSERT INTO item_table (title, price, count) VALUES(&#39;a&#39;); DELETE FROM item_table; SELECT (&#39;1&#39;, 19.8, 200) 其意义为： 1.插入一个虚假数据2.删除item_table表中所有数据3.返回一个虚假数据 这样就会导致item_table表中的所有数据被删除。 为防止注入攻击，可以使用占位符?代替需要插入数据库的参数，第二个数组参数中的3个值会按顺序填充占位符，该方法可以避免大部分注入攻击，如下： await connection.query(`INSERT INTO item_table (title, price, count) VALUES(?,?,?)`, [title, price, count]) const connection = require(&#39;../lib/database&#39;) module.exports = async (res, query, post, files) =&gt; { let { title, price, count } = post // 判断是否有传参 if (!title || !price || !count) { res.writeJson({ error: 1, msg: &#39;参数不合法&#39; }) } else { // 将价格和数量转为数字 price = Number(price) count = Number(count) // 判断价格和数量是否非数字 if (isNaN(price) || isNaN(count)) { res.writeJson({ error: 1, msg: &#39;参数不合法&#39; }) } else { try { // 使用占位符?代替需要插入数据库的参数，第二个数组参数中的3个值会按顺序填充占位符，该方法可以避免大部分注入攻击。 await connection.query(`INSERT INTO item_table (title, price, count) VALUES(?,?,?)`, [title, price, count]) res.writeJson({ error: 0, msg: &#39;添加商品成功&#39; }) } catch (error) { console.error(error) res.writeJson({ error: 1, msg: &#39;数据库内部错误&#39; }) } } } res.end() } 删除商品路由回调函数const connection = require(&#39;../lib/database&#39;) module.exports = async (res, query, post, files) =&gt; { const ID = query.id if (!ID) { res.writeJson({ error: 1, msg: &#39;参数不合法&#39; }) } else { await connection.query(`DELETE FROM item_table WHERE ID=${ID}`) res.writeJson({ error: 0, msg: &#39;删除成功&#39; }) } res.end() } 添加各接口路由配置在/router/index.js中，引用各个接口的配置，并用addRouter方法添加到路由表中，即可在接收到请求时，查找路由并进行处理。 const { addRouter } = require(&#39;../lib/router&#39;) // 添加获取商品列表接口 addRouter(&#39;get&#39;, &#39;/list&#39;, require(&#39;./list&#39;)) // 添加商品接口 addRouter(&#39;post&#39;, &#39;/add&#39;, require(&#39;./add&#39;)) // 删除商品接口 addRouter(&#39;get&#39;, &#39;/del&#39;, require(&#39;./del&#39;)) 在主模块中引用路由在/server.js中，引用router模块，就可以完成整个服务端的配置。 const connection = require(&#39;./lib/database&#39;) const http = require(&#39;./lib/http&#39;) const router = require(&#39;./router&#39;) 完成前端功能在/static/index.html中，使用jquery为前端页面实现如下功能： 1.显示商品列表2.添加随机名称、价格、库存的商品3.删除对应商品 // 查询商品列表的方法 function getList() { $.ajax({ url: &#39;/list&#39;, dataType: &#39;json&#39; }).then(res =&gt; { let html = `` res.data.forEach((item, index) =&gt; { html += ( ` &lt;tr&gt; &lt;td&gt;${item.title}&lt;/td&gt; &lt;td&gt;￥${item.price}&lt;/td&gt; &lt;td&gt;${item.count}&lt;/td&gt; &lt;td&gt; &lt;a data-id=&quot;${item.ID}&quot; href=&quot;#&quot; class=&quot;glyphicon glyphicon-trash&quot;&gt;删除&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; ` ) }) $(&#39;tbody&#39;).html(html) }); } getList() // 点击添加按钮，随机添加一个商品 $(&#39;#addBtn&#39;).on(&#39;click&#39;, function () { $.ajax({ url: &#39;/add&#39;, method: &#39;post&#39;, data: { title: `test${Math.floor(Math.random() * 100)}`, price: Math.floor(Math.random() * 100), count: Math.floor(Math.random() * 100) } }) .then((response) =&gt; { getList() }) }) // 点击删除按钮 $(&#39;tbody&#39;).on(&#39;click&#39;, &#39;a&#39;, function () { $.ajax({ url: &#39;/del&#39;, data: { id: $(this).attr(&#39;data-id&#39;) } }) .then((response) =&gt; { getList() }) })]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(十三) --Stream流]]></title>
    <url>%2F2019%2F05%2F06%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%B8%89)%20--Stream%E6%B5%81%2F</url>
    <content type="text"><![CDATA[File System的问题我们通常会使用File System模块对文件进行读取，如下： fs.readFile(&#39;./test.txt&#39;, (error, buffer) =&gt; { if (error) { console.error(error) } else { // 读取文件成功 res.write(buffer) } }) 这样操作简单有效，但这也存在一些问题： 1.占用内存使用fs读取文件，它是一次性将文件的所有内容读取到内存中，再一次性发送到客户端，因此会占用大量内存。 2.资源使用效率低从磁盘读取文件期间，磁盘处于忙碌状态，而网络处于空闲状态。磁盘读取完成后，开始发送文件时，情况正相反，网络处于忙碌状态，此时磁盘却处于空闲状态 Stream流相比File System，Stream流读取文件是读一份，发一份，Stream流的写入操作也有同样特点，因此可以解决File System在上面提到的2个问题。 接下来实现一个简单的流，将1.txt文件的内容写入到2.txt中： const fs = require(&#39;fs&#39;) // 创建一个可读流。 const readStream = fs.createReadStream(&#39;./1.txt&#39;) // 创建一个可写流。 const writeStream = fs.createWriteStream(&#39;./2.txt&#39;) // 将可读流读取的数据，通过管道pipe推送到写入流中，即可将1.txt的内容，写入到2.txt中。 readStream.pipe(writeStream) // 读取出现错误时会触发error事件。 readStream.on(&#39;error&#39;, (error) =&gt; { console.error(error) }) // 写入完成时，触发finish事件。 writeStream.on(&#39;finish&#39;, () =&gt; { console.log(&#39;finish&#39;) }) 使用Zlib压缩文件可以使用Zlib模块，配合Stream流，实现文件压缩功能，如下： const fs = require(&#39;fs&#39;) // 引入zlib模块，用于实现压缩功能 const zlib = require(&#39;zlib&#39;) // 创建一个可读流。 const readStream = fs.createReadStream(&#39;./google.jpg&#39;) // 创建一个可写流。 const writeStream = fs.createWriteStream(&#39;./google.jpg.gz&#39;) // 创建一个Gzip对象，用于将文件压缩成.gz文件 const gzip = zlib.createGzip() // 将可读流读取的数据，先通过管道pipe推送到gzip中，再推送到写入流中。 // 也就是先将可读流的数据压缩，再推送到可写流中。 readStream.pipe(gzip).pipe(writeStream) // 读取出现错误时会触发error事件。 readStream.on(&#39;error&#39;, (error) =&gt; { console.error(error) }) // 写入完成时，触发finish事件。 writeStream.on(&#39;finish&#39;, () =&gt; { console.log(&#39;finish&#39;) }) 使用流传输文件到前台学习了流，我们就可以更加高效地将文件传输到前台： const http = require(&#39;http&#39;) const zlib = require(&#39;zlib&#39;) const url = require(&#39;url&#39;) const fs = require(&#39;fs&#39;) const server = http.createServer((req, res) =&gt; { const { pathname } = url.parse(req.url, true) // 创建一个可读流。 const readStream = fs.createReadStream(`./${pathname}`) // 创建一个Gzip对象，用于将文件压缩成.gz文件 const gzip = zlib.createGzip() // 将读取的内容，在通过管道推送到res中，该方法不经过压缩 readStream.pipe(res) // 处理可读流报错，防止请求不存在的文件 readStream.on(&#39;error&#39;, (error) =&gt; { console.error(error); res.writeHead(404) res.write(&#39;Not Found&#39;) res.end() }) }) server.listen(8080) 但可以看到，在这个例子里，虽然实现了使用流传输文件，但并没有用到gzip压缩，在传输时还是更多地消耗网络资源，接下来可以引入gzip压缩。 文件经过gzip压缩后传输到前台但此时如果只是简单的用readStream.pipe(gzip).pipe(res)传输文件，浏览器在访问时无法直接打开，而是会触发文件下载。这是因为未设置请求头属性content-encoding的值，导致浏览器无法识别用gzip压缩过的文件，这就需要修改请求头res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;)，让浏览器可以识别。 这样浏览器就可以正常打开文件了，但若浏览器访问的是不存在的文件，浏览器会报错“无法访问此网站”，这是因为请求头属性content-encoding已被设置为gzip，但服务端传给浏览器的是Not Found字符串，浏览器无法识别。 此时可以使用fs.stat方法，先检查文件是否存在，若不存在则返回Not Found，若存在则继续传输。 const http = require(&#39;http&#39;) const zlib = require(&#39;zlib&#39;) const url = require(&#39;url&#39;) const fs = require(&#39;fs&#39;) const server = http.createServer((req, res) =&gt; { const { pathname } = url.parse(req.url, true) // 文件的相对路径 const filepath = `./${pathname}` // 检查文件是否存在 fs.stat(filepath, (error, stat) =&gt; { if (error) { console.error(error); res.setHeader(&#39;content-encoding&#39;, &#39;identity&#39;) res.writeHead(404) res.write(&#39;Not Found&#39;) res.end() } else { // 创建一个可读流。 const readStream = fs.createReadStream(filepath) // 创建一个Gzip对象，用于将文件压缩成.gz文件 const gzip = zlib.createGzip() // 向浏览器发送经过gzip压缩的文件，设置响应头，否则浏览器无法识别，会自动进行下载。 res.setHeader(&#39;content-encoding&#39;, &#39;gzip&#39;) // 将读取的内容，通过gzip压缩之后，在通过管道推送到res中，由于res继承自Stream流，因此也可以接收管道的推送。 readStream.pipe(gzip).pipe(res) // 处理可读流报错，防止文件中途被删除或出错，导致报错。 readStream.on(&#39;error&#39;, (error) =&gt; { console.error(error); res.setHeader(&#39;content-encoding&#39;, &#39;identity&#39;) res.writeHead(404) res.write(&#39;Not Found&#39;) res.end() }) } }) }) server.listen(8080) 启动器常用的启动器有forever、pm2等，它们主要用在项目部署阶段 1.使应用不间断运行，如果不使用启动器，命令行窗口一旦关闭，或者出现报错，应用就会停止运行，启动器会帮助应用自动重启。2.若出现服务器重启，启动器会自动启动应用，不需要手动操作。 常用的启动器有forever、pm2等，接下来介绍一下forever的使用。 foreverforever文档可参考：github.com/foreverjs/f… 使用forever启动一个服务： 安装forever：npm install forever -g 在命令行运行forever start server.js，替代node server.js命令。 命令行窗口提示info: Forever processing file: server.js，表示启动成功，此时如果将窗口关闭，应用照样可以访问。 如果需要关闭服务，可以运行forever stop server.js。还有一个命令是forever stopall，停止全部在运行的任务，但使用要慎重。 forever启动时，还可以添加一些配置，例如forever start xxx.js -l c:/xxx.log -e c:/xxx_err.log -a，forever start xxx.js表示启动xxx.js。 -l c:/xxx.log表示将log信息输出到c:/xxx.log文件。-e c:/xxx_err.log表示将错误信息输出到c:/xxx_err.log文件。-a 表示新的日志添加到旧日志之后，即保留旧日志。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(十二) --使用async/await异步操作数据库]]></title>
    <url>%2F2019%2F04%2F29%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%BA%8C)%20--%E4%BD%BF%E7%94%A8async-await%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[上一篇使用Node.js操作数据库，虽然能实现功能，但是异步操作需要不断写回调函数，代码严重冗余，而且阅读困难。 可以使用co-mysql，将query方法该写为返回一个Promise，就可以使用async/await进行异步处理。 我们可以参考一下它的源码，看看它是如何实现将回调函数转换为 module.exports = wrapper; var slice = [].slice; // 该模块导出为一个包装函数，运行它的返回值是一个带有query方法的对象。 function wrapper(client) { // client即为mysql.createPool或mysql.createConnection方法创建的连接对象。 var query = client.query; var o = {}; o.query = function () { // 提取调用query方法时，传入的所有参数，将其存入一个数组。 var args = slice.call(arguments); // 创建一个Promise对象，它将作为o.query的返回值，让其支持async/await方式调用。 var p = new Promise(function (resolve, reject) { // 为args增加一个回调函数，它将作为client.query方法的回调函数运行，它接收到结果时，将进行判断运行reject还是resolve args.push(function (err, rows) { if (err) { reject(err); } else { resolve(rows); } }); // 用apply方法，将o.query接收到的参数都传给client.query，它可以等同于 /* client.query(args[0], function(err, rows) { if (err) { reject(err); } else { resolve(rows); } }) */ query.apply(client, args); }); return p; }; return o; } 于是上一篇的代码可以进行如下优化： const http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const fs = require(&#39;fs&#39;) const mysql = require(&#39;mysql&#39;) const coMysql = require(&#39;co-mysql&#39;) // 1. 连接服务器 const pool = mysql.createPool({ connectionLimit: 10, // 建立的连接数量，默认为10个 host: &#39;localhost&#39;, // 地址 port: 3306, // 端口，不传则默认3306 user: &#39;root&#39;, // 登录名 password: &#39;&#39;, // 密码 database: &#39;test&#39; // 连接的数据库 }) const connection = coMysql(pool) /* const username = &#39;lily&#39; const password = &#39;888888&#39; // 向数据库中插入数据 connection.query(`INSERT INTO user_table (username, password) VALUES (&#39;${username}&#39;, &#39;${password}&#39;)`, (err, data) =&gt; { if (err) { console.error(err) } else { console.log(data) } }) // 查询user_table表的数据 connection.query(`SELECT * FROM User_table`, (err, data) =&gt; { if (err) { console.error(err) } else { console.log(data) } }) */ // more // 2. 与HTTP模块配合使用 const server = http.createServer(async (req, res) =&gt; { const { pathname, query } = url.parse(req.url, true) if (pathname === &#39;/reg&#39;) { // 获取get请求数据 const { username, password } = query // 校验参数是否正确 if (!username || !password) { res.write(JSON.stringify({ error: 1, msg: &#39;用户名或密码不可为空&#39; })) res.end() } else if (username.length &gt; 32) { res.write(JSON.stringify({ error: 1, msg: &#39;用户名的长度不可超过32位&#39; })) res.end() } else if (password.length &gt; 32) { res.write(JSON.stringify({ error: 1, msg: &#39;密码的长度不可超过32位&#39; })) res.end() } else { // 校验通过，开始注册流程 try { // 检查用户名是否已存在 const data = await connection.query(`SELECT ID FROM User_table WHERE username=&#39;${username}&#39;`) if (data.length) { res.write(JSON.stringify({ error: 1, msg: &#39;此用户名已被占用&#39; })) } else { // 将用户名和密码插入数据库 await connection.query(`INSERT INTO userddd_table (username, password) VALUES(&#39;${username}&#39;, &#39;${password}&#39;)`) res.write(JSON.stringify({ error: 0, msg: &#39;注册成功&#39; })) } } catch (error) { console.error(error) res.writeHead(500) } res.end() } } else if (pathname === &#39;/login&#39;) { let arr = [] req.on(&#39;data&#39;, (buffer) =&gt; { // 获取POST请求的Buffer数据 arr.push(buffer) }) req.on(&#39;end&#39;, async () =&gt; { // 将Buffer数据合并 let buffer = Buffer.concat(arr) // 处理接收到的POST数据 const post = JSON.parse(buffer.toString()) // 获取post请求数据 const { username, password } = post try { // 根据用户名查询 const data = await connection.query(`SELECT username, password FROM User_table WHERE username=&#39;${username}&#39;`) if (!data.length) { // 用户不存在 res.write(JSON.stringify({ error: 1, msg: &#39;用户名或密码错误&#39; })) } else if (data[0].password !== password) { // 密码不正确 res.write(JSON.stringify({ error: 1, msg: &#39;用户名或密码错误&#39; })) } else { res.write(JSON.stringify({ error: 0, msg: &#39;登录成功&#39; })) } } catch (error) { console.error(error) res.writeHead(500) } res.end() }) } else { // 若请求不为接口，则默认为请求文件 if (pathname !== &#39;/favicon.ico&#39;) { fs.readFile(`.${pathname}`, (err, buffer) =&gt; { if (err) { res.writeHead(404) } else { res.write(buffer) } res.end() }) } else { res.writeHead(404) res.end() } } }) server.listen(8080)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(十一) --使用Nodejs操作数据库]]></title>
    <url>%2F2019%2F04%2F21%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%8D%81%E4%B8%80%EF%BC%89--%E4%BD%BF%E7%94%A8Nodejs%E6%93%8D%E4%BD%9C%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[Nodejs操作数据库Nodejs操作数据库需要用到mysql模块，通过npm i mysql -D进行安装。 之后可以通过mysql.createConnection方法新建一个数据库连接，需要传入的参数有地址、端口、登录名、密码，以及需要连接的数据库。 mysql.createConnection会返回一个connection对象，可使用connection.query方法，传入SQL语句，对数据库进行相应操作。 const mysql = require(&#39;mysql&#39;) // 1. 连接服务器 const connection = mysql.createConnection({ host: &#39;localhost&#39;, // 地址 port: 3306, // 端口，不传则默认3306 user: &#39;root&#39;, // 登录名 password: &#39;&#39;, // 密码 database: &#39;test&#39; // 连接的数据库 }) const username = &#39;zzz&#39; const password = &#39;888888&#39; // 向数据库中插入数据 connection.query(`INSERT INTO user_table (username, password) VALUES (&#39;${username}&#39;, &#39;${password}&#39;)`, (err, data) =&gt; { if (err) { console.error(err) } else { console.log(data) } }) // 查询user_table表的数据 db.query(`SELECT * FROM User_table`, (err, data) =&gt; { if (err) { console.error(err) } else { console.log(data) } }) INSERT语句的打印的是插入结果： OkPacket { fieldCount: 0, affectedRows: 1, insertId: 8, // 返回了当前插入语句的id，可以用来告知前端插入数据的id serverStatus: 2, warningCount: 0, message: &#39;&#39;, protocol41: true, changedRows: 0 } SELECT语句的打印结果为查询到的所有数据： [ RowDataPacket { ID: 1, username: &#39;lee&#39;, password: &#39;123456&#39; }, RowDataPacket { ID: 3, username: &#39;chen&#39;, password: &#39;654321&#39; }, RowDataPacket { ID: 8, username: &#39;zzz&#39;, password: &#39;888888&#39; } ] 但mysql.createConnection方法有一个缺陷，就是它一次只能创建一个连接，一旦有多个用户同时请求，就会造成请求排队等待。 因此为了提高性能，可以改用mysql.createPool方法，创建一个连接池，它可以创建n个与服务器之间的连接，需要使用时，可以自动从中选取一个空闲的连接使用。 const connection = mysql.createPool({ connectionLimit: 10, // 建立的连接数量，默认为10个 host: &#39;localhost&#39;, // 地址 port: 3306, // 端口，不传则默认3306 user: &#39;root&#39;, // 登录名 password: &#39;&#39;, // 密码 database: &#39;test&#39; // 连接的数据库 }) 与HTTP模块配合实现接口完成了基本操作后，就可以实现一个完整的注册、登录流程 const http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const fs = require(&#39;fs&#39;) const mysql = require(&#39;mysql&#39;) // 1. 连接服务器 const connection = mysql.createPool({ connectionLimit: 10, // 建立的连接数量，默认为10个 host: &#39;localhost&#39;, // 地址 port: 3306, // 端口，不传则默认3306 user: &#39;root&#39;, // 登录名 password: &#39;&#39;, // 密码 database: &#39;test&#39; // 连接的数据库 }) // 2. 与HTTP模块配合使用 const server = http.createServer((req, res) =&gt; { const { pathname, query } = url.parse(req.url, true) if (pathname === &#39;/reg&#39;) { // 获取get请求数据 const { username, password } = query // 校验参数是否正确 if (!username || !password) { res.write(JSON.stringify({ error: 1, msg: &#39;用户名或密码不可为空&#39; })) res.end() } else if (username.length &gt; 32) { res.write(JSON.stringify({ error: 1, msg: &#39;用户名的长度不可超过32位&#39; })) res.end() } else if (password.length &gt; 32) { res.write(JSON.stringify({ error: 1, msg: &#39;密码的长度不可超过32位&#39; })) } else { // 校验通过，开始注册流程 // 检查用户名是否已存在 connection.query(`SELECT ID FROM User_table WHERE username=&#39;${username}&#39;`, (err, data) =&gt; { if (err) { res.writeHead(500) res.end() } else { if (data.length) { res.write(JSON.stringify({ error: 1, msg: &#39;此用户名已被占用&#39; })) res.end() } else { // 将用户名和密码插入数据库 connection.query(`INSERT INTO user_table (username, password) VALUES(&#39;${username}&#39;, &#39;${password}&#39;)`, (err, data) =&gt; { if (err) { res.writeHead(500) res.end() } else { res.write(JSON.stringify({ error: 0, msg: &#39;注册成功&#39; })) res.end() } }) } } }) } } else if (pathname === &#39;/login&#39;) { let arr = [] req.on(&#39;data&#39;, (buffer) =&gt; { // 获取POST请求的Buffer数据 arr.push(buffer) }) req.on(&#39;end&#39;, () =&gt; { // 将Buffer数据合并 let buffer = Buffer.concat(arr) // 处理接收到的POST数据 const post = JSON.parse(buffer.toString()) // 获取post请求数据 const { username, password } = post // 根据用户名查询 connection.query(`SELECT username, password FROM User_table WHERE username=&#39;${username}&#39;`, (err, data) =&gt; { if (err) { console.error(err) } else { if (!data.length) { // 用户不存在 res.write(JSON.stringify({ error: 1, msg: &#39;用户名或密码错误&#39; })) res.end() } else if (data[0].password !== password) { // 密码不正确 res.write(JSON.stringify({ error: 1, msg: &#39;用户名或密码错误&#39; })) res.end() } else { res.write(JSON.stringify({ error: 0, msg: &#39;登录成功&#39; })) res.end() } } }) }) } else { // 若请求不为接口，则默认为请求文件 fs.readFile(`.${pathname}`, (err, buffer) =&gt; { if (err) { res.writeHead(404) res.write(buffer) } else { res.write(buffer) } res.end() }) } }) server.listen(8080)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(十) --数据库入门]]></title>
    <url>%2F2019%2F04%2F21%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%8D%81)%20--%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[数据库的分类1.文件数据库 它的优点是：数据保存在单一文件中，因此部署十分方便，常用来嵌入到APP中保存数据，以及手机中的短信、通话记录等。 常用的有SQLite、Access等。 2.关系型数据库 关系型数据库的功能强大，适用场景丰富，它的特点是数据之间互相是关联的。 比如淘宝，一个用户下有个人信息、订单信息、聊天记录等，可以分别存储在不同表中，通过用户ID相互关联起来。但它的性能不是最强的。 常用有SQL。 3.分布式数据库 它的特点是可以安装在多台机器上，可以将查询等操作分散开，合理利用服务器资源。 还可以将数据设置多个备份，一旦其中一台服务器异常，可以由其他服务器同步数据。 常用的有MongoDB。 4.NoSQL 它只能支持简单查询，但性能强于关系型数据库，常用来做接口、数据缓存等。 常用的有MongoDB、Memcached、Redis等。 SQL语句结构化查询语言(Structured Query Language)简称SQL，它主要用来存取、查询、更新和管理关系数据库系统。 SQL 分为两个部分：数据定义语言 (DDL)和数据操作语言 (DML) 。 DDL语句CREATE DATABASE - 创建新数据库ALTER DATABASE - 修改数据库CREATE TABLE - 创建新表ALTER TABLE - 变更（改变）数据库表DROP TABLE - 删除表CREATE INDEX - 创建索引（搜索键）DROP INDEX - 删除索引 DDM语句数据操作语言 (DML) 是最常用的操作，即增删改查，它包括如下部分： 1.增INSERT INTO - 向数据库表中插入数据INSERT INTO &lt;表&gt; (字段, …) VALUES(值, …);INSERT INTO user_table (username, password) VALUES(‘lee’, ‘123456’);在user_table表中插入一条数据。 2.删DELETE - 从数据库表中删除数据DELETE FROM &lt;表&gt; WHERE 条件;DELETE FROM user_table WHERE ID=2;删除user_table表中ID为2的项目。 3.改UPDATE - 更新数据库表中的数据UPDATE &lt;表&gt; SET 字段=新值,字段=新值,… WHERE 条件;UPDATE user_table SET password=’888888’, username=’chen’ WHERE ID=1;将user_table表中ID为1的用户名和密码更新。 4.查SELECT - 从数据库表中获取数据SELECT 字段列表 FROM &lt;表&gt; WHERE 条件 ORDER BY 字段 LIMIT 30,30;SELECT ID FROM user_table WHERE username=‘lee’ ORDER BY ID ASC LIMIT 0,10;查询user_table表中username为lee的用户的ID，取0~10个，按升序排列。 数据库索引数据库的索引需要作用是提高查询性能，另外还可以对数据进行限制，如限制为“唯一”。 索引的类型有四种，如下： 1.主键 具有“唯一”和“索引”的双重优点。 2.唯一 定义字段为唯一，即不可重复。 3.索引 优点：提高查询性能，相当于书的目录。 缺点：降低增、删、改的性能，因为这些操作可能会触发数据库整理、重建索引。另外，索引也会占用磁盘空间。 4.全文索引 适合文本搜索，常用在搜索引擎中。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(九)--Websocket]]></title>
    <url>%2F2019%2F04%2F20%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E4%B9%9D)%20--Websocket%2F</url>
    <content type="text"><![CDATA[WebSocket的优势1.性能高。 根据测试环境数据的不同，大约会比普通Ajax请求高2-10倍。 HTTP是文本协议，数据量比较大。 而WebSocket是基于二进制的协议，在建立连接时用的虽然是文本数据，但之后传输的都是二进制数据，因此性能比Ajax请求高。 2.双向通信。 如果是普通Ajax请求，需要实时获取数据，只能用计时器定时发送请求，这样会浪费服务器资源和流量。 而通过WebSocket，服务器可以主动向前端发送信息。 3.安全性高 由于WebSocket出现较晚，相比HTTP协议，在安全性上考虑的更加充分。 接下来，尝试用Socket.io建立一个基于WebSocket的双向通信。 Socket.ioSocket.io是在使用WebSocket时的一个常用库，它会自动判断在支持WebSocket的浏览器中使用WebSocket，在其他浏览器中，会使用如flash等方式完成通信。 1.操作简单2.兼容低端浏览器，如IE63.自动进行数据解析4.自动重连 若出现连接断开的情况，WebSocket会进行自动重连。 使用Socket.io建立一个WebSocket应用const http = require(&#39;http&#39;) const io = require(&#39;socket.io&#39;) // 1. 建立HTTP服务器。 const server = http.createServer((req, res) =&gt; { }) server.listen(8080) // 2. 建立WebSocket，让socket.io监听HTTP服务器，一旦发现是WebSocket请求，则会自动进行处理。 const ws = io.listen(server) // 建立连接完成后，触发connection事件。 // 该事件会返回一个socket对象（https://socket.io/docs/server-api/#Socket），可以利用socket对象进行发送、接收数据操作。 ws.on(&#39;connection&#39;, (socket) =&gt; { // 根据事件名，向客户端发送数据，数据数量不限。 socket.emit(&#39;msg&#39;, &#39;服务端向客户端发送数据第一条&#39;, &#39;服务端向客户端发送数据第二条&#39;) // 根据事件名接收客户端返回的数据 socket.on(&#39;msg&#39;, (...msgs) =&gt; { console.log(msgs) }) // 使用计时器向客户端发送数据 setInterval(() =&gt; { socket.emit(&#39;timer&#39;, new Date().getTime()) }, 500); }) &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 引用Socket.io的客户端js文件，由于Socket.io已在服务端监听了HTTP服务器的请求，一旦收到对该文件的请求，则会自动返回该文件，不需要开发人员配置。 --&gt; &lt;!-- 该文件在服务端的位置为/node_modules/socket.io/node_modules/socket.io-client/dist/socket.io.js --&gt; &lt;script src=&quot;http://localhost:8080/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 与服务器建立WebSocket连接，该连接为ws协议，socket.io不需要担心跨域问题。 const socket = io.connect(&#39;ws://localhost:8080/&#39;) // 根据事件名，向服务端发送数据，数据数量不限。 socket.emit(&#39;msg&#39;, &#39;客户端向服务端发送数据第一条&#39;, &#39;客户端向服务端发送数据第二条&#39;) // 根据事件名接收服务端返回的数据 socket.on(&#39;msg&#39;, (...msgs) =&gt; { console.log(msgs) }) // 接收服务端通过计时器发送来的数据 socket.on(&#39;timer&#39;, (time) =&gt; { console.log(time) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 用浏览器打开index.html，即可在控制台看到打印的消息。 原生实现WebSocket应用上面使用了Socket.io实现WebSocket，也是开发中常用的方式。 但这样不利于了解其原理，这里使用Nodejs的Net模块和Web端的WebSocket API实现WebSocket服务器。 服务端创建一个Net服务器// 引入net模块 const net = require(&#39;net&#39;) // 使用net模块创建服务器，返回的是一个原始的socket对象，与Socket.io的socket对象不同。 const server = net.createServer((socket) =&gt; { }) server.listen(8080) Web端创建一个WebSocket链接创建一个WebSocket连接，此时控制台的Network模块可以看到一个处于pending状态的HTTP连接。 这个连接是一个HTTP请求，与普通HTTP请求的请求你头相比，增加了以下内容： Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits // 扩展信息 Sec-WebSocket-Key: O3PKSb95qaSB7/+XfaTg7Q== // 发送一个Key到服务端，用于校验服务端是否支持WebSocket Sec-WebSocket-Version: 13 // WebSocket版本 Upgrade: websocket // 告知服务器通信协议将会升级到WebSocket若服务器支持则继续下一步 const ws = new WebSocket(&#39;ws://localhost:8080/&#39;) 服务端使用socket.once，触发一次data事件处理HTTP请求头数据socket.once(&#39;data&#39;, (buffer) =&gt; { // 接收到HTTP请求头数据 const str = buffer.toString() console.log(str) }) 打印结果如下: GET / HTTP/1.1 Host: localhost:8080 Connection: Upgrade Pragma: no-cache Cache-Control: no-cache Upgrade: websocket Origin: file:// Sec-WebSocket-Version: 13 User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36 Accept-Encoding: gzip, deflate, br Accept-Language: zh-CN,zh;q=0.9 Cookie: _ga=GA1.1.1892261700.1545540050; _gid=GA1.1.774798563.1552221410; io=7X0VY8jhwRTdRHBfAAAB Sec-WebSocket-Key: JStOineTIKaQskxefzer7Q== Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits 将回车符转换为\r\n显示，结果如下： GET / HTTP/1.1\r\nHost: localhost:8080\r\nConnection: Upgrade\r\nPragma: no-cache\r\nCache-Control: no-cache\r\nUpgrade: websocket\r\nOrigin: file://\r\nSec-WebSocket-Version: 13\r\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36\r\nAccept-Encoding: gzip, deflate, br\r\nAccept-Language: zh-CN,zh;q=0.9\r\nCookie: _ga=GA1.1.1892261700.1545540050; _gid=GA1.1.774798563.1552221410; io=7X0VY8jhwRTdRHBfAAAB\r\nSec-WebSocket-Key: dRB1xDJ/vV+IAGnG7TscNQ==\r\nSec-WebSocket-Extensions: permessage-deflate; client_max_window_bits\r\n\r\n 将请求头字符串转为对象创建一个parseHeader方法处理请求头。 function parseHeader(str) { // 将请求头数据按回车符切割为数组，得到每一行数据 let arr = str.split(&#39;\r\n&#39;).filter(item =&gt; item) // 第一行数据为GET / HTTP/1.1，可以丢弃。 arr.shift() console.log(arr) /* 处理结果为： [ &#39;Host: localhost:8080&#39;, &#39;Connection: Upgrade&#39;, &#39;Pragma: no-cache&#39;, &#39;Cache-Control: no-cache&#39;, &#39;Upgrade: websocket&#39;, &#39;Origin: file://&#39;, &#39;Sec-WebSocket-Version: 13&#39;, &#39;User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#39;, &#39;Accept-Encoding: gzip, deflate, br&#39;, &#39;Accept-Language: zh-CN,zh;q=0.9&#39;, &#39;Cookie: _ga=GA1.1.1892261700.1545540050; _gid=GA1.1.774798563.1552221410; io=7X0VY8jhwRTdRHBfAAAB&#39;, &#39;Sec-WebSocket-Key: jqxd7P0Xx9TGkdMfogptRw==&#39;, &#39;Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits&#39; ] */ let headers = {} // 存储最终处理的数据 arr.forEach((item) =&gt; { // 需要用&quot;:&quot;将数组切割成key和value let [name, value] = item.split(&#39;:&#39;) // 去除无用的空格，将属性名转为小写 name = name.replace(/^\s|\s+$/g, &#39;&#39;).toLowerCase() value = value.replace(/^\s|\s+$/g, &#39;&#39;) // 获取所有的请求头属性 headers[name] = value }) return headers } 打印结果如下: { host: &#39;localhost&#39;, connection: &#39;Upgrade&#39;, pragma: &#39;no-cache&#39;, &#39;cache-control&#39;: &#39;no-cache&#39;, upgrade: &#39;websocket&#39;, origin: &#39;file&#39;, &#39;sec-websocket-version&#39;: &#39;13&#39;, &#39;user-agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&#39;, &#39;accept-encoding&#39;: &#39;gzip, deflate, br&#39;, &#39;accept-language&#39;: &#39;zh-CN,zh;q=0.9&#39;, cookie: &#39;_ga=GA1.1.1892261700.1545540050; _gid=GA1.1.585339125.1552405260&#39;, &#39;sec-websocket-key&#39;: &#39;TipyPZNW+KNvV3fePNpriw==&#39;, &#39;sec-websocket-extensions&#39;: &#39;permessage-deflate; client_max_window_bits&#39; } 根据请求头参数，判断是否WebSocket请求根据headers[&#39;upgrade&#39;] !== &#39;websocket&#39;，判断该HTTP连接是否可升级为WebSocket，若可以升级，表示为WebSocket请求。根据headers[&#39;sec-websocket-version&#39;] !== &#39;13&#39;，判断WebSocket的版本是否为13，以免因为版本不同出现兼容问题。 socket.once(&#39;data&#39;, (buffer) =&gt; { // 接收到HTTP请求头数据 const str = buffer.toString() console.log(str) // 4. 将请求头数据转为对象 const headers = parseHeader(str) console.log(headers) // 5. 判断请求是否为WebSocket连接 if (headers[&#39;upgrade&#39;] !== &#39;websocket&#39;) { // 若当前请求不是WebSocket连接，则关闭连接 console.log(&#39;非WebSocket连接&#39;) socket.end() } else if (headers[&#39;sec-websocket-version&#39;] !== &#39;13&#39;) { // 判断WebSocket版本是否为13，防止是其他版本，造成兼容错误 console.log(&#39;WebSocket版本错误&#39;) socket.end() } else { // 请求为WebSocket连接时，进一步处理 } }) 校验Sec-WebSocket-Key，完成连接根据协议规定的方式，向前端返回一个请求头，完成建立WebSocket连接的过程。 若客户端校验结果正确，在控制台的Network模块可以看到HTTP请求的状态码变为101 Switching Protocols，同时客户端的ws.onopen事件被触发。 socket.once(&#39;data&#39;, (buffer) =&gt; { // 接收到HTTP请求头数据 const str = buffer.toString() console.log(str) // 4. 将请求头数据转为对象 const headers = parseHeader(str) console.log(headers) // 5. 判断请求是否为WebSocket连接 if (headers[&#39;upgrade&#39;] !== &#39;websocket&#39;) { // 若当前请求不是WebSocket连接，则关闭连接 console.log(&#39;非WebSocket连接&#39;) socket.end() } else if (headers[&#39;sec-websocket-version&#39;] !== &#39;13&#39;) { // 判断WebSocket版本是否为13，防止是其他版本，造成兼容错误 console.log(&#39;WebSocket版本错误&#39;) socket.end() } else { // 6. 校验Sec-WebSocket-Key，完成连接 /* 协议中规定的校验用GUID，可参考如下链接： https://tools.ietf.org/html/rfc6455#section-5.5.2 https://stackoverflow.com/questions/13456017/what-does-258eafa5-e914-47da-95ca-c5ab0dc85b11-means-in-websocket-protocol */ const GUID = &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39; const key = headers[&#39;sec-websocket-key&#39;] const hash = crypto.createHash(&#39;sha1&#39;) // 创建一个签名算法为sha1的哈希对象 hash.update(`${key}${GUID}`) // 将key和GUID连接后，更新到hash const result = hash.digest(&#39;base64&#39;) // 生成base64字符串 const header = `HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-Websocket-Accept: ${result}\r\n\r\n` // 生成供前端校验用的请求头 socket.write(header) // 返回HTTP头，告知客户端校验结果，HTTP状态码101表示切换协议：https://httpstatuses.com/101。 // 若客户端校验结果正确，在控制台的Network模块可以看到HTTP请求的状态码变为101 Switching Protocols，同时客户端的ws.onopen事件被触发。 console.log(header) // 处理聊天数据 } }) 建立连接后，通过data事件接收客户端的数据并处理连接开始后，可以在控制台的Network模块看到，该连接会一直保留在pending状态，直到连接断开。 此时可以通过data事件处理客户端的数据，但此时双方通信的数据为二进制，需要按照其格式进行处理后才可以正常使用。 格式如下： 处理收到的数据： function decodeWsFrame(data) { let start = 0; let frame = { isFinal: (data[start] &amp; 0x80) === 0x80, opcode: data[start++] &amp; 0xF, masked: (data[start] &amp; 0x80) === 0x80, payloadLen: data[start++] &amp; 0x7F, maskingKey: &#39;&#39;, payloadData: null }; if (frame.payloadLen === 126) { frame.payloadLen = (data[start++] &lt;&lt; 8) + data[start++]; } else if (frame.payloadLen === 127) { frame.payloadLen = 0; for (let i = 7; i &gt;= 0; --i) { frame.payloadLen += (data[start++] &lt;&lt; (i * 8)); } } if (frame.payloadLen) { if (frame.masked) { const maskingKey = [ data[start++], data[start++], data[start++], data[start++] ]; frame.maskingKey = maskingKey; frame.payloadData = data .slice(start, start + frame.payloadLen) .map((byte, idx) =&gt; byte ^ maskingKey[idx % 4]); } else { frame.payloadData = data.slice(start, start + frame.payloadLen); } } console.dir(frame) return frame; } 处理发出的数据： function encodeWsFrame(data) { const isFinal = data.isFinal !== undefined ? data.isFinal : true, opcode = data.opcode !== undefined ? data.opcode : 1, payloadData = data.payloadData ? Buffer.from(data.payloadData) : null, payloadLen = payloadData ? payloadData.length : 0; let frame = []; if (isFinal) frame.push((1 &lt;&lt; 7) + opcode); else frame.push(opcode); if (payloadLen &lt; 126) { frame.push(payloadLen); } else if (payloadLen &lt; 65536) { frame.push(126, payloadLen &gt;&gt; 8, payloadLen &amp; 0xFF); } else { frame.push(127); for (let i = 7; i &gt;= 0; --i) { frame.push((payloadLen &amp; (0xFF &lt;&lt; (i * 8))) &gt;&gt; (i * 8)); } } frame = payloadData ? Buffer.concat([Buffer.from(frame), payloadData]) : Buffer.from(frame); console.dir(decodeWsFrame(frame)); return frame; } 对聊天数据进行处理： socket.once(&#39;data&#39;, (buffer) =&gt; { // 接收到HTTP请求头数据 const str = buffer.toString() console.log(str) // 4. 将请求头数据转为对象 const headers = parseHeader(str) console.log(headers) // 5. 判断请求是否为WebSocket连接 if (headers[&#39;upgrade&#39;] !== &#39;websocket&#39;) { // 若当前请求不是WebSocket连接，则关闭连接 console.log(&#39;非WebSocket连接&#39;) socket.end() } else if (headers[&#39;sec-websocket-version&#39;] !== &#39;13&#39;) { // 判断WebSocket版本是否为13，防止是其他版本，造成兼容错误 console.log(&#39;WebSocket版本错误&#39;) socket.end() } else { // 6. 校验Sec-WebSocket-Key，完成连接 /* 协议中规定的校验用GUID，可参考如下链接： https://tools.ietf.org/html/rfc6455#section-5.5.2 https://stackoverflow.com/questions/13456017/what-does-258eafa5-e914-47da-95ca-c5ab0dc85b11-means-in-websocket-protocol */ const GUID = &#39;258EAFA5-E914-47DA-95CA-C5AB0DC85B11&#39; const key = headers[&#39;sec-websocket-key&#39;] const hash = crypto.createHash(&#39;sha1&#39;) // 创建一个签名算法为sha1的哈希对象 hash.update(`${key}${GUID}`) // 将key和GUID连接后，更新到hash const result = hash.digest(&#39;base64&#39;) // 生成base64字符串 const header = `HTTP/1.1 101 Switching Protocols\r\nUpgrade: websocket\r\nConnection: Upgrade\r\nSec-Websocket-Accept: ${result}\r\n\r\n` // 生成供前端校验用的请求头 socket.write(header) // 返回HTTP头，告知客户端校验结果，HTTP状态码101表示切换协议：https://httpstatuses.com/101。 // 若客户端校验结果正确，在控制台的Network模块可以看到HTTP请求的状态码变为101 Switching Protocols，同时客户端的ws.onopen事件被触发。 console.log(header) // 7. 建立连接后，通过data事件接收客户端的数据并处理 socket.on(&#39;data&#39;, (buffer) =&gt; { const data = decodeWsFrame(buffer) console.log(data) console.log(data.payloadData &amp;&amp; data.payloadData.toString()) // opcode为8，表示客户端发起了断开连接 if (data.opcode === 8) { socket.end() // 与客户端断开连接 } else { // 接收到客户端数据时的处理，此处默认为返回接收到的数据。 socket.write(encodeWsFrame({ payloadData: `服务端接收到的消息为：${data.payloadData ? data.payloadData.toString() : &#39;&#39;}` })) } }) } }) 这样，一个简单的基于WebSocket的聊天应用就创建完成了，在启动服务器后，可以打开index.html看到效果。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(八)--Ajax跨域]]></title>
    <url>%2F2019%2F04%2F20%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%85%AB)%20--Ajax%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[Ajax跨域问题的产生原因Ajax请求无法跨域，在前端开发中是个常见问题，它的产生原因是，在浏览器接收服务端返回数据时，会检查该数据是否和当前发起请求的网址在同一域名下。若不是，则会丢弃该数据，并返回一个跨域错误。 在Ajax请求中，遵循如下流程：网页提交一个Ajax请求到浏览器，浏览器将请求发至服务器，服务器接收到请求后，返回响应数据给浏览器（服务器通常不会对域名进行区分），浏览器接收到响应数据时，检测返回数据的域名是否和当前页面域名相同，若相同则将数据返回给网页，不同则丢弃数据。 Ajax跨域的处理方法既然跨域问题的产生原因在于浏览器的限制，那么网页端在请求时无法主动规避，此时就需要服务端进行处理。 服务端只需要在响应Ajax请求时，在请求头中加入一个Access-Control-Allow-Origin属性，并设置为*（表示全部域名）或者当前域名就可以让浏览器不再进行限制. const http = require(&#39;http&#39;) const server = http.createServer((req, res) =&gt; { console.log(req.headers.origin) res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;) res.write(`{&quot;resultCode&quot;: &quot;0000&quot;, &quot;msg&quot;: &quot;success&quot;}`) res.end() }) server.listen(8080) 当然在实际项目中，不可以简单地设置res.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;*&#39;)，而是要通过req.headers.origin判断发起请求的域名是否合法，再设置Access-Control-Allow-Origin属性，以免出现安全问题。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(七) --POST文件上传]]></title>
    <url>%2F2019%2F04%2F04%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E4%B8%83)%20--POST%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%2F</url>
    <content type="text"><![CDATA[简单的文件上传例子处理文件上传数据，也是前后端交互中重要的功能，它的处理方式与数据不同。 接下来，通过一个例子查看服务端接收到的文件上传数据。 首先，在post_file.html中，新建一个用与上传文件的表单： form的属性enctype=&quot;multipart/form-data&quot;代表表单上传的是文件。 enctype的默认值为enctype=&quot;application/x-www-form-urlencoded&quot;表示上传的是数据类型，此时服务端接收到的数据为“username=lee&amp;password=123456&amp;file=upload.txt”。 &lt;form action=&quot;http://localhost:8080/upload&quot; method=&quot;POST&quot; enctype=&quot;multipart/form-data&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot; value=&quot;lee&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;123456&quot;&gt;&lt;br/&gt; &lt;input type=&quot;file&quot; name=&quot;file&quot; id=&quot;&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 其次，在server.js中，查看接收到的表单提交数据： const http = require(&#39;http&#39;) const server = http.createServer((req, res) =&gt; { let arr = [] req.on(&#39;data&#39;, (buffer) =&gt; { arr.push(buffer) }) req.on(&#39;end&#39;, () =&gt; { let buffer = Buffer.concat(arr) console.log(buffer.toString()) }) }) server.listen(8080) 最后，在表单中上传/lesson16/upload.txt文件，并查看打印出的结果： ------WebKitFormBoundaryL5AGcit70yhKB92Y Content-Disposition: form-data; name=&quot;username&quot; lee ------WebKitFormBoundaryL5AGcit70yhKB92Y Content-Disposition: form-data; name=&quot;password&quot; 123456 Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;upload.txt&quot; Content-Type: text/plain upload ------WebKitFormBoundaryL5AGcit70yhKB92Y-- 文件上传数据分析通过分析上面这个例子中，服务端接收到的数据，可以得到以下信息： .表单上传的数据，被分隔符“------WebKitFormBoundaryL5AGcit70yhKB92Y”隔开，分隔符在每次上传时都不同。分隔符数据可以从req.headers[‘content-type’]中获取，如：const boundary = ‘–’ + req.headers[‘content-type’].split(‘; ‘)[1].split(‘=’)[1]`。 2.前两段数据中，分别可以获取到表单上传的字段名name=”username”，以及数据“lee”。 3.第三段数据中，多了一个字段filename=”upload.txt”，它表示的是文件的原始名称。以及可以获取到文件类型“Content-Type: text/plain”，表示这是一个文本文件。最后是文件的内容“upload”。 由此可以看出，文件上传数据虽然有些乱，但还是有规律的，那么处理思路就是按照规律，将数据切割之后，取出其中有用的部分。 文件上传数据简化先回顾一下上面的数据，并将回车符标记出来： ------WebKitFormBoundaryL5AGcit70yhKB92Y\r\n Content-Disposition: form-data; name=&quot;username&quot;\r\n \r\n lee\r\n ------WebKitFormBoundaryL5AGcit70yhKB92Y\r\n Content-Disposition: form-data; name=&quot;password&quot;\r\n \r\n 123456\r\n Content-Disposition: form-data; name=&quot;file&quot;; filename=&quot;upload.txt&quot;\r\n Content-Type: text/plain\r\n \r\n upload\r\n ------WebKitFormBoundaryL5AGcit70yhKB92Y-- 可以看出，每段数据的结构其实是这样的： ------WebKitFormBoundaryL5AGcit70yhKB92Y\r\nContent-Disposition: form-data; name=&quot;username&quot;\r\n\r\nlee\r\ 将每段上传数据简化如下： &lt;分隔符&gt;\r\n字段头\r\n\r\n内容\r\n 也就是说，整个表单的数据，就是按照这样的数据格式组装而成。 需要注意的是，在表单数据的结尾不再是\r\n，而是“–”。 文件上传数据处理步骤1.用&lt;分隔符&gt;切分数据： 2.删除数组头尾数据： 3.将每一项数据头尾的的\r\n删除： 4.将每一项数据中间的\r\n\r\n删除，得到最终结果： Buffer的数据处理由于文件都是二进制数据，不能直接将其转换为字符串后再进行处理，否则数据会出错，因此要通过Buffer模块进行数据处理操作。 Buffer模块提供了indexOf方法获取Buffer数据中，其参数所在位置的index值。 Buffer模块提供了slice方法，可通过index值切分Buffer数据。 let buffer = Buffer.from(&#39;lee\r\nchen\r\ntest&#39;) const index = buffer.indexOf(&#39;\r\n&#39;) console.log(index) console.log(buffer.slice(0, index).toString()) 可以看到打印结果分别为3和”lee”，也就是说，我们先找到了”\r\n”所在的index为3，之后从Buffer数据的index为0的位置，切割到index为3的位置，得到了正确的结果。 由此，可以封装一个专门用于切割Buffer数据的方法： module.exports = function bufferSplit(buffer, separator) { let result = []; let index = 0; while ((index = buffer.indexOf(separator)) != -1) { result.push(buffer.slice(0, index)); buffer = buffer.slice(index + separator.length); } result.push(buffer); return result; } 有了bufferSplit方法，就可以正式开始处理数据了。 文件上传数据处理根据上面的思路，就可以实现一个完整的文件上传流程。 const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) const bufferSplit = require(&#39;./bufferSplit&#39;) const server = http.createServer((req, res) =&gt; { const boundary = `--${req.headers[&#39;content-type&#39;].split(&#39;; &#39;)[1].split(&#39;=&#39;)[1]}` // 获取分隔符 let arr = [] req.on(&#39;data&#39;, (buffer) =&gt; { arr.push(buffer) }) req.on(&#39;end&#39;, () =&gt; { const buffer = Buffer.concat(arr) console.log(buffer.toString()) // 1. 用&lt;分隔符&gt;切分数据 let result = bufferSplit(buffer, boundary) console.log(result.map(item =&gt; item.toString())) // 2. 删除数组头尾数据 result.pop() result.shift() console.log(result.map(item =&gt; item.toString())) // 3. 将每一项数据头尾的的\r\n删除 result = result.map(item =&gt; item.slice(2, item.length - 2)) console.log(result.map(item =&gt; item.toString())) // 4. 将每一项数据中间的\r\n\r\n删除，得到最终结果 result.forEach(item =&gt; { console.log(bufferSplit(item, &#39;\r\n\r\n&#39;).map(item =&gt; item.toString())) let [info, data] = bufferSplit(item, &#39;\r\n\r\n&#39;) // 数据中含有文件信息，保持为Buffer类型 info = info.toString() // info为字段信息，这是字符串类型数据，直接转换成字符串，若为文件信息，则数据中含有一个回车符\r\n，可以据此判断数据为文件还是为普通数据。 if (info.indexOf(&#39;\r\n&#39;) &gt;= 0) { // 若为文件信息，则将Buffer转为文件保存 // 获取字段名 let infoResult = info.split(&#39;\r\n&#39;)[0].split(&#39;; &#39;) let name = infoResult[1].split(&#39;=&#39;)[1] name = name.substring(1, name.length - 1) // 获取文件名 let filename = infoResult[2].split(&#39;=&#39;)[1] filename = filename.substring(1, filename.length - 1) console.log(name) console.log(filename) // 将文件存储到服务器 fs.writeFile(`./upload/${filename}`, data, err =&gt; { if (err) { console.log(err) } else { console.log(&#39;文件上传成功&#39;) } }) } else { // 若为数据，则直接获取字段名称和值 let name = info.split(&#39;; &#39;)[1].split(&#39;=&#39;)[1] name = name.substring(1, name.length - 1) const value = data.toString() console.log(name, value) } }) }) }) server.listen(8080) multiparty我们可以尝试使用第三方库来完成POST请求的处理，如multiparty。 multiparty demo通过如下例子，可以测试一下multiparty的功能。 它会在field事件中，将数据信息的字段名和值返回。在file事件中，将文件的字段名和信息返回。 上传成功后，会在指定的文件夹创建一个上传的文件，并会将文件重命名（如：IqUHkFe0u2h2TsiBztjKxoBR.jpg），以防止重名。 若上传出现失败，已保存的文件会自动删除。 close事件表示表单数据全部解析完成，用户可以在其中处理已经接收到的信息。 const http = require(&#39;http&#39;) const multiparty = require(&#39;multiparty&#39;) const server = http.createServer((req, res) =&gt; { const form = new multiparty.Form({ uploadDir: &#39;./upload&#39; // 指定文件存储目录 }) form.parse(req) // 将请求参数传入，multiparty会进行相应处理 form.on(&#39;field&#39;, (name, value) =&gt; { // 接收到数据参数时，触发field事件 console.log(name, value) }) form.on(&#39;file&#39;, (name, file, ...rest) =&gt; { // 接收到文件参数时，触发file事件 console.log(name, file) }) form.on(&#39;close&#39;, () =&gt; { // 表单数据解析完成，触发close事件 console.log(&#39;表单数据解析完成&#39;) }) }) server.listen(8080)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(六) --基本模块]]></title>
    <url>%2F2019%2F04%2F01%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%85%AD)%20--%E5%9F%BA%E6%9C%AC%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[assert (断言)assert（断言）通常用来对代码进行校验，若出错则阻止程序运行，并抛出一个错误。 用法const assert = require(&#39;assert&#39;) assert(2 &gt; 1, &#39;2 &gt; 1&#39;) assert(1 &gt; 2, &#39;1 &gt; 2&#39;) 代码在运行到assert(2 &gt; 1, ‘2 &gt; 1’)时，由于2 &gt; 1为true，此时不会抛出错误。 而运行到assert(1 &gt; 2, ‘1 &gt; 2’)时，由于1 &gt; 2为false，此时会抛出错误如下： AssertionError [ERR_ASSERTION]: 1 &gt; 2 at Object.&lt;anonymous&gt; (C:\projects\nodejs-tutorial\lesson11\assert.js:5:1) at Module._compile (internal/modules/cjs/loader.js:734:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:745:10) at Module.load (internal/modules/cjs/loader.js:626:32) at tryModuleLoad (internal/modules/cjs/loader.js:566:12) at Function.Module._load (internal/modules/cjs/loader.js:558:3) at Function.Module.runMain (internal/modules/cjs/loader.js:797:12) at executeUserCode (internal/bootstrap/node.js:526:15) at startMainThreadExecution (internal/bootstrap/node.js:439:3) 使用方式通常可以在一个模块或函数的每个阶段使用assert，或者在对函数传参进行assert校验，以保证代码运行的正确性。 assert.deepStrictEqualassert.deepStrictEqual(actual, expected[, message])用于对actual 参数和 expected的深度比较，即不仅校验它们是否相等，同时也要校验它们的成员之间是否相等。 assert.deepStrictEqual在校验对象或数组时比较有用。 assert.deepStrictEqual的比较相当于===，也就是不仅是值相等，值的类型也要相等。 assert.deepStrictEqual的用法1.使用assert.deepStrictEqual比较对象： const assert = require(&#39;assert&#39;) const obj1 = { a: 1, b: 2, children: { c: 3 } } const obj2 = { a: 1, b: 2, children: { c: 3 } } const obj3 = { a: 1, b: 2, children: { c: &#39;3&#39; } } assert.deepStrictEqual(obj1, obj2, &#39;obj1 !== obj2&#39;) assert.deepStrictEqual(obj1, obj3, &#39;obj1 !== obj3&#39;) 代码会抛出错误：obj1 !== obj3。 2.使用assert.deepStrictEqual比较数组 const assert = require(&#39;assert&#39;) const arr1 = [{ a: 1, b: 2, children: [{ c: 3 }] }] const arr2 = [{ a: 1, b: 2, children: [{ c: 3 }] }] const arr3 = [{ a: 1, b: 2, children: [{ c: &#39;3&#39; }] }] assert.deepStrictEqual(arr1, arr2, &#39;arr1 !== arr2&#39;) assert.deepStrictEqual(arr1, arr3, &#39;arr1 !== arr3&#39;) path(路径)path模块主要用来对文件路径进行处理，比如提取路径、后缀，拼接路径等。 使用const path = require(&#39;path&#39;) const str = &#39;/root/a/b/1.txt&#39; console.log(path.dirname(str)) // 获取文件目录：/root/a/b console.log(path.basename(str)) // 获取文件名：1.txt console.log(path.extname(str)) // 获取文件后缀：.txt console.log(path.resolve(str, &#39;../c&#39;, &#39;build&#39;, &#39;strict&#39;)) // 将路径解析为绝对路径：C:\root\a\b\c\build\strict console.log(path.resolve(str, &#39;../c&#39;, &#39;build&#39;, &#39;strict&#39;, &#39;../..&#39;, &#39;assets&#39;)) // 将路径解析为绝对路径：C:\root\a\b\c\assets console.log(path.resolve(__dirname, &#39;build&#39;)) // 将路径解析为绝对路径：C:\projects\nodejs-tutorial\lesson12\build 值得一提的是path.resolve方法，它可以接收任意个参数，然后根据每个路径参数之间的关系，将路径最终解析为一个绝对路径。 __dirname指的是当前模块所在的绝对路径名称，它的值会自动根据当前的绝对路径变化，等同于path.dirname(__filename)的结果。 URL模块url.parseURL模块用于对URL的解析，常用的是url.parse方法。 假设有一个url为https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4，可以用url.parse方法进行解析。 const url = require(&#39;url&#39;) const str = &#39;https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#39; console.log(url.parse(str)) 打印结果如下： Url { protocol: &#39;https:&#39;, slashes: true, auth: null, host: &#39;www.google.com:8080&#39;, port: &#39;8080&#39;, hostname: &#39;www.google.com&#39;, hash: null, search: &#39;?x=1&amp;y=2&amp;y=3&amp;y=4&#39;, query: &#39;x=1&amp;y=2&amp;y=3&amp;y=4&#39;, pathname: &#39;/a/b&#39;, path: &#39;/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#39;, href: &#39;https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#39; } 可以看到url的信息如端口号、域名、query参数等都被解析出来了。 如果需要将query参数转为对象，则可以为url.parse函数的第二个参数传true，如console.log(url.parse(str, true))，打印结果如下： Url { protocol: &#39;https:&#39;, slashes: true, auth: null, host: &#39;www.google.com:8080&#39;, port: &#39;8080&#39;, hostname: &#39;www.google.com&#39;, hash: null, search: &#39;?x=1&amp;y=2&amp;y=3&amp;y=4&#39;, query: [Object: null prototype] { x: &#39;1&#39;, y: [ &#39;2&#39;, &#39;3&#39;, &#39;4&#39; ] }, pathname: &#39;/a/b&#39;, path: &#39;/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#39;, href: &#39;https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#39; } 同时可以看到y=2&amp;y=3&amp;y=4参数被解析为了y: [ ‘2’, ‘3’, ‘4’ ]。 new URL()除了用url.parse方法解析url，还可以通过构造函数URL，创建一个实例，其中带有解析后的数据。 实例有一个toString方法，可以将实例解析为字符串url。 const { URL } = require(&#39;url&#39;) const urlObj = new URL(str) console.log(urlObj) console.log(urlObj.toString()) URL { href: &#39;https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4&#39;, origin: &#39;https://www.google.com:8080&#39;, protocol: &#39;https:&#39;, username: &#39;&#39;, password: &#39;&#39;, host: &#39;www.google.com:8080&#39;, hostname: &#39;www.google.com&#39;, port: &#39;8080&#39;, pathname: &#39;/a/b&#39;, search: &#39;?x=1&amp;y=2&amp;y=3&amp;y=4&#39;, searchParams: URLSearchParams { &#39;x&#39; =&gt; &#39;1&#39;, &#39;y&#39; =&gt; &#39;2&#39;, &#39;y&#39; =&gt; &#39;3&#39;, &#39;y&#39; =&gt; &#39;4&#39; }, hash: &#39;&#39; } https://www.google.com:8080/a/b?x=1&amp;y=2&amp;y=3&amp;y=4 // toString方法解析出的url querystring模块querystring用来对url中的query字符串进行解析，常用的方法有querystring.parse和querystring.stringify。 querystring.parsequerystring.parse方法用于解析URL 查询字符串。 const querystring = require(&#39;querystring&#39;) console.log(querystring.parse(&#39;foo=bar&amp;abc=xyz&amp;abc=123&#39;)) //{ foo: &#39;bar&#39;, abc: [ &#39;xyz&#39;, &#39;123&#39; ] } querystring.stringifyquerystring.stringify用于将对象转换为URL查询字符串。 console.log(querystring.stringify({ foo: &#39;bar&#39;, baz: [&#39;qux&#39;, &#39;quux&#39;], corge: &#39;&#39; })) // foo=bar&amp;baz=qux&amp;baz=quux&amp;corge= net模块net 模块用于创建基于流的 TCP 或 IPC 的服务器（net.createServer()）与客户端（net.createConnection()）。 net模块是专门用于网络通信的模块，若当前的数据交互不通过HTTP协议，就可以使用net模块，如WebSocket。 HTTP协议本质上是以文本形式传输数据，它的传输数据量较大，而且它的传输需要二进制和文本之间进行转换和解析。 在nodejs中，HTTP模块是继承自net模块的。 OSI参考模型OSI（Open System Interconnect），即开放式系统互联。 它是ISO（国际标准化组织）组织在1985年研究的网络互联模型。该体系结构标准定义了网络互联的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层和应用层），即OSI开放系统互连参考模型。在这一框架下进一步详细规定了每一层的功能，以实现开放系统环境中的互连性、互操作性和应用的可移植性。 OSI参考模型分层OSI参考模型可以分为以下七层： 物理层 → 数据链路层 → 网络层（IP协议） → 传输层（TCP层） → 会话层 → 表现层 → 应用层（HTTP协议等） OSI参考模型详细介绍如下： 第1层物理层：处于OSI参考模型的最底层。物理层的主要功能是利用物理传输介质为数据链路层提供物理连接，以便透明的传送比特流。常用设备有（各种物理设备）网卡、集线器、中继器、调制解调器、网线、双绞线、同轴电缆。 第2层数据链路层：在此层将数据分帧，并处理流控制。屏蔽物理层，为网络层提供一个数据链路的连接，在一条有可能出差错的物理连接上，进行几乎无差错的数据传输（差错控制）。本层指定拓扑结构并提供硬件寻址。常用设备有网桥、交换机； 第3层网络层：本层通过寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。它包括通过互连网络来路由和中继数据 ；除了选择路由之外，网络层还负责建立和维护连接，控制网络上的拥塞以及在必要的时候生成计费信息。 第4层传输层：—常规数据递送－面向连接或无连接。为会话层用户提供一个端到端的可靠、透明和优化的数据传输服务机制。包括全双工或半双工、流控制和错误恢复服务；传输层把消息分成若干个分组，并在接收端对它们进行重组。不同的分组可以通过不同的连接传送到主机。这样既能获得较高的带宽，又不影响会话层。在建立连接时传输层可以请求服务质量，该服务质量指定可接受的误码率、延迟量、安全性等参数，还可以实现基于端到端的流量控制功能。 第5层会话层：在两个节点之间建立端连接。为端系统的应用程序之间提供了对话控制机制。此服务包括建立连接是以全双工还是以半双工的方式进行设置，尽管可以在层4中处理双工方式 ；会话层管理登入和注销过程。它具体管理两个用户和进程之间的对话。如果在某一时刻只允许一个用户执行一项特定的操作，会话层协议就会管理这些操作，如阻止两个用户同时更新数据库中的同一组数据。 第6层表示层：主要用于处理两个通信系统中交换信息的表示方式。为上层用户解决用户信息的语法问题。它包括数据格式交换、数据加密与解密、数据压缩与终端类型的转换。 第7层应用层：OSI中的最高层。为特定类型的网络应用提供了访问OSI环境的手段。应用层确定进程之间通信的性质，以满足用户的需要。应用层不仅要提供应用进程所需要的信息交换和远程操作，而且还要作为应用进程的用户代理，来完成一些为进行信息交换所必需的功能。它包括：文件传送访问和管理FTAM、虚拟终端VT、事务处理TP、远程数据库访问RDA、制造报文规范MMS、目录服务DS等协议；应用层能与应用程序界面沟通，以达到展示给用户的目的。 在此常见的协议有:HTTP，HTTPS，FTP，TELNET，SSH，SMTP，POP3等。 OSI参考模型各层功能(1)物理层(Physical Layer)物理层是OSI参考模型的最低层，它利用传输介质为数据链路层提供物理连接。它主要关心的是通过物理链路从一个节点向另一个节点传送比特流，物理链路可能是铜线、卫星、微波或其他的通讯媒介。它关心的问题有：多少伏电压代表1？多少伏电压代表0？时钟速率是多少？采用全双工还是半双工传输？总的来说物理层关心的是链路的机械、电气、功能和规程特性。 (2)数据链路层(Data Link Layer)数据链路层是为网络层提供服务的，解决两个相邻结点之间的通信问题，传送的协议数据单元称为数据帧。数据帧中包含物理地址（又称MAC地址）、控制码、数据及校验码等信息。该层的主要作用是通过校验、确认和反馈重发等手段，将不可靠的物理链路转换成对网络层来说无差错的数据链路。此外，数据链路层还要协调收发双方的数据传输速率，即进行流量控制，以防止接收方因来不及处理发送方来的高速数据而导致缓冲器溢出及线路阻塞。 (3)网络层(Network Layer)网络层是为传输层提供服务的，传送的协议数据单元称为数据包或分组。该层的主要作用是解决如何使数据包通过各结点传送的问题，即通过路径选择算法（路由）将数据包送到目的地。另外，为避免通信子网中出现过多的数据包而造成网络阻塞，需要对流入的数据包数量进行控制（拥塞控制）。当数据包要跨越多个通信子网才能到达目的地时，还要解决网际互连的问题。 (4)传输层(Transport Layer)传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。传输层传送的协议数据单元称为段或报文。 (5)会话层(Session Layer)会话层主要功能是管理和协调不同主机上各种进程之间的通信（对话），即负责建立、管理和终止应用程序之间的会话。会话层得名的原因是它很类似于两个实体间的会话概念。例如，一个交互的用户会话以登录到计算机开始，以注销结束。 (6)表示层(Presentation Layer)表示层处理流经结点的数据编码的表示方式问题，以保证一个系统应用层发出的信息可被另一系统的应用层读出。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据表示格式转换成网络通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。 (7)应用层(Application Layer)应用层是OSI参考模型的最高层，是用户与网络的接口。该层通过应用程序来完成网络用户的应用需求，如文件传输、收发电子邮件等。 TCPTCP完成了OSI参考模型中的第四层传输层的功能，net模块简单来说就是TCP协议的node实现。 TCP（Transmission Control Protocol 传输控制协议）是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC 793定义。 当应用层向TCP层发送用于网间传输的、用8位字节表示的数据流，TCP则把数据流分割成适当长度的报文段，最大传输段大小（MSS）通常受该计算机连接的网络的数据链路层的最大传送单元（MTU）限制。之后TCP把数据包传给IP层，由它来通过网络将包传送给接收端实体的TCP层。TCP为了保证报文传输的可靠 [1] ，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。TCP的可靠性虽然很好，但它也因此牺牲了效率，它比较适合于传输文件等场景。如果在对可靠性要求不高，但对效率要求很高的场景，如视频直播等，就可以使用UDP。 UDPUDP 是User Datagram Protocol的简称， 中文名是用户数据报协议，是OSI（Open System Interconnection，开放式系统互联） 参考模型中一种无连接的传输层协议，提供面向事务的简单不可靠信息传送服务，IETF RFC 768是UDP的正式规范。UDP在IP报文的协议号是17。 UDP报文没有可靠性保证、顺序保证和流量控制字段等，可靠性较差。但是正因为UDP协议的控制选项较少，在数据传输过程中延迟小、数据传输效率高，适合对可靠性要求不高的应用程序，如音频、视频和普通数据在传送时使用UDP较多，或者可以保障可靠性的应用程序，如DNS、TFTP、SNMP等。 Nodejs也提供了UDP/Datagram模块，可以在需要使用UDP时调用。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中axios请求的封装]]></title>
    <url>%2F2019%2F03%2F29%2FVue%2Fvue%E4%B8%ADaxios%E8%AF%B7%E6%B1%82%E7%9A%84%E5%B0%81%E8%A3%85%2F</url>
    <content type="text"><![CDATA[前言Axios 是一个基于 promise 的 HTTP 库，可以用在浏览器和 node.js 中, 也是vue官方推荐使用的http库；封装axios，一方面为了以后维护方便，另一方面也可以对请求进行自定义处理，不多BB,开搞 设置接口请求前缀一般我们开发都会有开发、测试、生产环境，前缀需要加以区分，我们利用node环境变量来作判断 if(process.env.NODE_ENV === &quot;development&quot;){ axios.default.baseURL = &quot;XXXX&quot; }else if(process.env.NODE_ENV === &quot;production&quot;){ axios.default.baseURL = &quot;XXXX&quot; } 在localhost调试时，直接用开发地址一般都会有跨域的问题，所以我们还需要vue.config.js配置代理 module.exports = { devServer: { proxy: { &#39;/proxyApi&#39;: { target: &#39;http://dev.xxx.com&#39;, changeOrigin: true, pathRewrite: { &#39;/proxyApi&#39;: &#39;&#39; } } } } } 这样就成功把/proxyApi 指向了 XXXX，重启服务 拦截器接着设置超时时间和请求头信息 axios.defaults.timeout = 10000 // 请求头信息是为post请求设置 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded;charset=UTF-8&#39; axios很好用，其中之一就是它的拦截器十分强大，我们就可以为请求和响应设置拦截器，比如请求拦截器可以在每个请求里加上token，做了统一处理后维护起来也方便，响应拦截器可以在接收到响应后先做一层操作，如根据状态码判断登录状态、授权。 // 请求拦截器 axios.interceptors.request.use( config =&gt; { // 每次发送请求之前判断是否存在token // 如果存在，则统一在http请求的header都加上token，这样后台根据token判断你的登录情况，此处token一般是用户完成登录后储存到localstorage里的 token &amp;&amp; (config.headers.Authorization = token) return config }, error =&gt; { return Promise.error(error) }) // 响应拦截器 axios.interceptors.response.use(response =&gt; { // 如果返回的状态码为200，说明接口请求成功，可以正常拿到数据 // 否则的话抛出错误 if (response.status === 200) { if (response.data.code === 511) { // 未授权调取授权接口 } else if (response.data.code === 510) { // 未登录跳转登录页 } else { return Promise.resolve(response) } } else { return Promise.reject(response) } }, error =&gt; { // 我们可以在这里对异常状态作统一处理 if (error.response.status) { // 处理请求失败的情况 // 对不同返回码对相应处理 return Promise.reject(error.response) } }) get post的封装httpGet: 一个参数是请求的url,一个就携带的请求参数，返回promise对象 // get 请求 export function httpGet({ url, params = {} }) { return new Promise((resolve, reject) =&gt; { axios.get(url, { params }).then((res) =&gt; { resolve(res.data) }).catch(err =&gt; { reject(err) }) }) } httpPost: 原理和get差不多，需要注意，这里多了个data参数，post请求提交前需要对它进行序列号操作，这里是通过transformRequest做处理；另外两个参数url,params和get请求的一样； // post请求 export function httpPost({ url, data = {}, params = {} }) { return new Promise((resolve, reject) =&gt; { axios({ url, method: &#39;post&#39;, transformRequest: [function (data) { let ret = &#39;&#39; for (let it in data) { ret += encodeURIComponent(it) + &#39;=&#39; + encodeURIComponent(data[it]) + &#39;&amp;&#39; } return ret }], // 发送的数据 data, // url参数 params }).then(res =&gt; { resolve(res.data) }) }) } 如何使用我把所有的接口调用都在api.js文件中 先引入封装好的方法，再在要调用的接口重新封装成一个方法暴露出去 import { httpGet, httpPost } from &#39;./http&#39; export const getorglist = (params = {}) =&gt; httpGet({ url: &#39;apps/api/org/list&#39;, params }) 在页面中可以这样调用： // .vue import { getorglist } from &#39;@/assets/js/api&#39; getorglist({ id: 200 }).then(res =&gt; { console.log(res) }) 这样可以把api统一管理起来，以后维护修改只需要在api.js文件操作即可 完整代码http.js// http.js import axios from &#39;axios&#39; // 环境的切换 if (process.env.NODE_ENV === &#39;development&#39;) { axios.defaults.baseURL = &#39;/proxyApi&#39; } else if (process.env.NODE_ENV === &#39;production&#39;) { axios.defaults.baseURL = &#39;http://prod.xxx.com&#39; } // 请求拦截器 axios.interceptors.request.use( config =&gt; { token &amp;&amp; (config.headers.Authorization = token) return config }, error =&gt; { return Promise.error(error) }) axios.defaults.timeout = 10000 axios.defaults.headers.post[&#39;Content-Type&#39;] = &#39;application/x-www-form-urlencoded;charset=UTF-8&#39; // 响应拦截器 axios.interceptors.response.use(response =&gt; { if (response.status === 200) { if (response.data.code === 511) { // 未授权调取授权接口 } else if (response.data.code === 510) { // 未登录跳转登录页 } else { return Promise.resolve(response) } } else { return Promise.reject(response) } }, error =&gt; { // 我们可以在这里对异常状态作统一处理 if (error.response.status) { // 处理请求失败的情况 // 对不同返回码对相应处理 return Promise.reject(error.response) } }) // get 请求 export function httpGet({ url, params = {} }) { return new Promise((resolve, reject) =&gt; { axios.get(url, { params }).then((res) =&gt; { resolve(res.data) }).catch(err =&gt; { reject(err) }) }) } // post请求 export function httpPost({ url, data = {}, params = {} }) { return new Promise((resolve, reject) =&gt; { axios({ url, method: &#39;post&#39;, transformRequest: [function (data) { let ret = &#39;&#39; for (let it in data) { ret += encodeURIComponent(it) + &#39;=&#39; + encodeURIComponent(data[it]) + &#39;&amp;&#39; } return ret }], // 发送的数据 data, // url参数 params }).then(res =&gt; { resolve(res.data) }) }) } api.js// api.js import { httpGet, httpPost } from &#39;./http&#39; export const getorglist = (params = {}) =&gt; httpGet({ url: &#39;apps/api/org/list&#39;, params }) export const save = (data) =&gt; { return httpPost({ url: &#39;apps/wechat/api/save_member&#39;, data }) } vue// .vue &lt;script&gt; import { getorglist } from &#39;@/assets/js/api&#39; export default { name: &#39;upload-card&#39;, data() {}, mounted() { getorglist({ id: 200 }).then(res =&gt; { // console.log(res) }) }, } &lt;/script&gt;]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何在 Web 关闭页面时发送 Ajax 请求]]></title>
    <url>%2F2019%2F03%2F28%2FAjax%2F%E5%A6%82%E4%BD%95%E5%9C%A8-Web-%E5%85%B3%E9%97%AD%E9%A1%B5%E9%9D%A2%E6%97%B6%E5%8F%91%E9%80%81-Ajax-%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[前言有时候我们需要在用户离开页面的时候，做一些上报来记录用户行为。又或者是发送服务器ajax请求，通知服务器用户已经离开，比如直播间内的退房操作。 本文主要分两部分来讲解怎么完成退出行为的上报。 事件监听浏览器有两个事件可以用来监听页面关闭，beforeunload和unload。beforeunload是在文档和资源将要关闭的时候调用的， 这时候文档还是可见的，并且在这个关闭的事件还是可以取消的。比如下面这种写法就会让用户导致在刷新或者关闭页面时候，有个弹窗提醒用户是否关闭。 window.addEventListener(&quot;beforeunload&quot;, function (event) { // Cancel the event as stated by the standard. event.preventDefault(); // Chrome requires returnValue to be set. event.returnValue = &#39;&#39;; }); unload则是在页面已经正在被卸载时发生，此时文档所处的状态是：1.所有资源仍存在（图片，iframe等）；2.对于用户所有资源不可见；3.界面交互无效（window.open, alert, confirm 等）；4.错误不会停止卸载文档的过程。 基于以上两个方法就可以实现对页面关闭的事件监听了，为了稳妥，可以两个事件都监听。然后对监听函数做处理，让关闭事件只调用一次。 请求发送有了上面的监听，事情只完成了一半，如果我们在监听中直接发送ajax请求，就会发现请求被浏览器abort了，无法发送出去。在页面卸载的时候，浏览器并不能保证异步的请求能够成功发出去。 我们有几种方式可以解决这个问题： 方案1: 发送同步的ajax请求var oAjax = new XMLHttpRequest(); oAjax.open(&#39;POST&#39;, url + &#39;/user/register&#39;, false);//false表示同步请求 oAjax.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;); oAjax.onreadystatechange = function() { if (oAjax.readyState == 4 &amp;&amp; oAjax.status == 200) { var data = JSON.parse(oAjax.responseText); } else { console.log(oAjax); } }; oAjax.send(&#39;a=1&amp;b=2&#39;); 这种方式虽然有效，但是用户需要等待请求结束才可以关闭页面。对用户的体验不好。 发送异步请求，并且在服务端忽略ajax的abort虽然异步请求会被浏览器abort，但是如果服务端可以忽略abort，仍然正常执行，也是可以的。比如PHP有ignore_user_abort函数可以忽略abort。这样需要改造后台，一般不太可行.. 方案3：使用navigator.sendBeacon发送异步请求根据MDN的介绍： 这个方法主要用于满足 统计和诊断代码 的需要，这些代码通常尝试在卸载（unload）文档之前向web服务器发送数据。过早的发送数据可能导致错过收集数据的机会。然而， 对于开发者来说保证在文档卸载期间发送数据一直是一个困难。因为用户代理通常会忽略在卸载事件处理器中产生的异步 XMLHttpRequest 。 navigator.sendBeacon(url [, data]); sendBeacon支持发送的data可以是ArrayBufferView, Blob, DOMString, 或者 FormData 类型的数据。 下面是几种使用sendBeacon发送请求的方式，可以修改header和内容的格式，因为一般和服务器的通信方式都是固定的，如果修改了header或者内容，服务器就无法正常识别出来了。 （1）使用Blob来发送 使用blob发送的好处是可以自己定义内容的格式和header。比如下面这种设置方式，就是可以设置content-type为application/x-www-form-urlencoded。 blob = new Blob([`room_id=123`], {type : &#39;application/x-www-form-urlencoded&#39;}); navigator.sendBeacon(&quot;/cgi-bin/leave_room&quot;, blob); （2）使用FormData对象，但是这时content-type会被设置成&quot;multipart/form-data&quot;。 var fd = new FormData(); fd.append(&#39;room_id&#39;, 123); navigator.sendBeacon(&quot;/cgi-bin/leave_room&quot;, fd); （3）数据也可以使用URLSearchParams 对象，content-type会被设置成”text/plain;charset=UTF-8” 。 var params = new URLSearchParams({ room_id: 123 }) navigator.sendBeacon(&quot;/cgi-bin/leave_room&quot;, params); 通过尝试，可以发现使用blob发送比较方便，内容的设置也比较灵活，如果发送的消息抓包后发现后台没有识别出来，可以尝试修改内容的string或者header，来找到合适的方式发送请求。 原文地址]]></content>
      <categories>
        <category>Ajax</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[「从源码中学习」面试官都不知道的Vue题目答案]]></title>
    <url>%2F2019%2F03%2F27%2FVue%2F%E3%80%8C%E4%BB%8E%E6%BA%90%E7%A0%81%E4%B8%AD%E5%AD%A6%E4%B9%A0%E3%80%8D%E9%9D%A2%E8%AF%95%E5%AE%98%E9%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Vue%E9%A2%98%E7%9B%AE%E7%AD%94%E6%A1%88%2F</url>
    <content type="text"><![CDATA[原文地址 前言当回答面试官问及的Vue问题，我们除了照本宣科的回答外，其实还可以根据少量的源码来秀一把，来体现出你对Vue的深度了解。 “new Vue() 做了什么？”new关键字代表实例化一个对象, 而Vue实际上是一个类, 源码位置是/src/core/instance/index.js。 function Vue (options) { if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; !(this instanceof Vue) ) { warn(&#39;Vue is a constructor and should be called with the `new` keyword&#39;) } this._init(options) } 接着我们跳转追踪至this._init()，即Vue.prototype._init,位于src\core\instance\init.js在_init()方法的内部有一系列 init* 的方法 Vue.prototype._init = function (options?: Object) { const vm: Component = this // ...忽略，从第45行看起 if (process.env.NODE_ENV !== &#39;production&#39;) { initProxy(vm) } else { vm._renderProxy = vm } // expose real self vm._self = vm initLifecycle(vm) initEvents(vm) initRender(vm) callHook(vm, &#39;beforeCreate&#39;) initInjections(vm) // resolve injections before data/props initState(vm) initProvide(vm) // resolve provide after data/props callHook(vm, &#39;created&#39;) // ...忽略 if (vm.$options.el) { vm.$mount(vm.$options.el) } } } 这里我们叙述一下 initProxy，作用域代理，拦截组件内访问其它组件的数据。 initLifecycle, 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。如：$children、$refs、_isMounted等。 initEvents，用来存放除@hook:生命周期钩子名称=”绑定的函数”事件的对象。如：$on、$emit等。 initRender，用于初始化$slots、$attrs、$listeners initInjections，初始化inject，一般用于更深层次的组件通信，相当于加强版的props。用于组件库开发较多。 只要在上一层级的声明的provide，那么下一层级无论多深都能够通过inject来访问到provide的数据。这么做也是有明显的缺点：在任意层级都能访问，导致数据追踪比较困难，不知道是哪一个层级声明了这个或者不知道哪一层级或若干个层级使用。 initState，是很多选项初始化的汇总，包括：props、methods、data、computed 和 watch 等。 initProvide，初始化provide。 vm.$mount，挂载实例。 “什么阶段才能访问DOM？”这个回答可以从beforeCreate以及 created的调用时机谈起，我们根据上面的概述，来简化下代码: callHook(vm, &#39;beforeCreate&#39;) // 初始化 inject // 初始化 props、methods、data、computed 和 watch // 初始化 provide callHook(vm, &#39;created&#39;) // 挂载实例 vm.$mount(vm.$options.el) 所以当面试官问你： beforeCreate以及 created 调用时，哪些数据能用与否？ 什么阶段才能访问DOM？ 为什么created之后才挂载实例？ “谈谈你对Vue的生命周期的理解”常规回答这里就不说了，来稍微深入点的： 1.created/mounted/updated/destroyed，以及对应的before钩子。分别是创建=&gt;挂载=&gt;更新=&gt;销毁。 2.Vue源码中定义了一个mergeHook函数来遍历一个常量数组LIFECYCLE_HOOKS，该数组实际上是由与生命周期钩子同名的字符串组成的数组。 // v2.6.10 最新版 var LIFECYCLE_HOOKS = [ &#39;beforeCreate&#39;, &#39;created&#39;, &#39;beforeMount&#39;, &#39;mounted&#39;, &#39;beforeUpdate&#39;, &#39;updated&#39;, &#39;beforeDestroy&#39;, &#39;destroyed&#39;, &#39;activated&#39;, &#39;deactivated&#39;, &#39;errorCaptured&#39;, // v2.6+ &#39;serverPrefetch&#39; ]; 于是，你可以答多activated &amp; deactivated（keep-alive 组件激活/停用）、errorCaptured（v2.5 以上版本有的一个钩子，用于处理错误）这三个。 新生命周期钩子：serverPrefetch是什么？可以看到，serverPrefetch前身是ssrPrefetch。顾名思义，这是用来处理ssr的。允许我们在渲染过程中“等待”异步数据。可在任何组件中使用，而不仅仅是路由组件。 &lt;!-- Item.vue --&gt; &lt;template&gt; &lt;div v-if=&quot;item&quot;&gt;{{ item.title }}&lt;/div&gt; &lt;div v-else&gt;...&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { computed: { item () { return this.$store.state.items[this.$route.params.id] } }, serverPrefetch () { return this.fetchItem() }, mounted () { if (!this.item) { this.fetchItem() } }, methods: { fetchItem () { // return the Promise from the action return this.$store.dispatch(&#39;fetchItem&#39;, this.$route.params.id) } } } &lt;/script&gt; 绝大多数的面试官都不会去关注v2.6+ 以后的代码记录和变更。这里如果你说出这个v2.6.10的变化，啧啧…面试官肯定更加欣赏你。 生命周期钩子的合并策略拿callHook(vm, &#39;created&#39;)讲，先判断组件的选项中有无对应名字的生命周期钩子，再判断是否有 parentVal(vm)。若存在parentVal(vm)且都有对应的生命周期钩子，则会将两者concat为一个数组(parentVal.concat(childVal))。所以，生命周期钩子其实是可以写成数组。如： created: [ function () { console.log(&#39;first&#39;) }, function () { console.log(&#39;second&#39;) }, function () { console.log(&#39;third&#39;) }] 钩子函数将按顺序执行 Vue-router 路由模式有几种？”三种 &quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;，一般人只知道两种&quot;hash&quot; | &quot;history&quot;。 switch (mode) { case &#39;history&#39;: this.history = new HTML5History(this, options.base) break case &#39;hash&#39;: this.history = new HashHistory(this, options.base, this.fallback) break case &#39;abstract&#39;: this.history = new AbstractHistory(this, options.base) break default: if (process.env.NODE_ENV !== &#39;production&#39;) { assert(false, `invalid mode: ${mode}`) } } # mode类型: string默认值: &quot;hash&quot; (浏览器环境) | &quot;abstract&quot; (Node.js 环境)可选值: &quot;hash&quot; | &quot;history&quot; | &quot;abstract&quot;配置路由模式: hash: 使用 URL hash 值来作路由。支持所有浏览器，包括不支持 HTML5 History Api 的浏览器。history: 依赖 HTML5 History API 和服务器配置。查看 HTML5 History 模式。abstract: 支持所有 JavaScript 运行环境，如 Node.js 服务器端。如果发现没有浏览器的 API，路由会自动强制进入这个模式. “谈谈你对keep-alive的了解？”先贴一个常规回答： keep-alive是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。在vue 2.1.0 版本之后，keep-alive新加入了两个属性: include(包含的组件缓存) 与 exclude(排除的组件不缓存，优先级大于include) 。 然后你可以开始骚了： 1.&lt;keep-alive&gt;是 Vue 源码中实现的一个全局抽象组件，通过自定义 render 函数并且利用了插槽来实现数据缓存和更新。它的定义在src/core/components/keep-alive.js 中： export default { name: &#39;keep-alive&#39;, abstract: true, ... } 2.所有的抽象组件是通过定义abstract选项来声明的。抽象组件不渲染真实DOM，且不会出现在父子关系的路径上（initLifecycle会忽略抽象组件），相关代码片段： if (parent &amp;&amp; !options.abstract) { // abstract 即 `ptions.abstract` // while 循环查找第一个非抽象的父组件 while (parent.$options.abstract &amp;&amp; parent.$parent) { parent = parent.$parent } parent.$children.push(vm) } 了解Vue2.6+新全局API：Vue.observable()吗？”Vue2.6+新的全局API是Vue.observable(),它的使用方式 import vue from vue; const state = Vue.observable ({ counter: 0, }); export default { render () { return ( &lt;div&gt; {state.counter} &lt;button v-on:click={() =&gt; {state.counter ++; }}&gt; Increment counter &lt;/ button&gt; &lt;/ div&gt; ); }, }; 而它定义在/src/core/global-api/index.js第48行： import { observe } from &#39;core/observer/index&#39; // ... // 2.6 explicit observable API Vue.observable = &lt;T&gt;(obj: T): T =&gt; { observe(obj) return obj } 再看看它import的observe，最近一次提交在12/1/2018 核心就是暴露出observe(obj)观测后的数据，代码啥都没改]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(五) --Node.js的模块化]]></title>
    <url>%2F2019%2F03%2F26%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E4%BA%94)%20--Node-js%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%2F</url>
    <content type="text"><![CDATA[Nodejs定义模块Nodejs的模块化由于出现的较早，因此它遵循的是CommonJS规范，而非ES6的模块化。 在Nodejs的模块化中，最常用到的有module对象、exports对象、require方法。 其中module和exports用于输出模块，require用于引用模块。 一个简单的模块例子先新建一个module1.js文件，代码如下： module.exports.a = 1 module.exports.b = 2 let c = 3 在require.js中，引入模块并打印： const module1 = require(&#39;./module1&#39;) console.log(module1) 可以看到打印结果：{ a: 1, b: 2 }。 这段代码的含义如下： 1.module1.js对外输出了module.exports，module.exports为一个对象，它含有a和b属性。 2.module1.js中虽然定义了变量c，但它只在module1.js这个模块中存在，从外部无法访问。 3.在require.js中引用module1.js，必须使用相对路径或绝对路径。 4.若引用时不带路径，而是直接使用模块名称，则会默认引用项目目录下的node_modules文件夹下的模块，如： const module2 = require(&#39;module2&#39;) console.log(module2) // { a: 1, b: 2 } 若此时项目目录下的node_modules文件夹下存在module2.js文件，则会引用该文件。 若不存在，则会查找系统的node_modules文件夹下，即全局安装的模块，是否存在module2。 若还不存在该模块，则会报错。 通过require导入的模块，可以被任意命名，因此写成const a = require(‘module2’)也是可以的。 module.exports上面这个例子中的模块导出，还可以省略module，直接写成exports.a = 1; exports.b = 1; …。 但直接使用exports导出，也仅支持这种写法，若写成： exports = { a: 1, b: 2 } 在引用模块时，只能接收到{}，也就是说exports只支持exports.a = 1;这样的语法。 如果要将整个模块直接定义为一个对象、函数、变量、类，则需要使用module.exports = 123。 module.exports = { a: 1, b: 2 } module.exports = 123 module.exports = { a: 1, b: 2, c: 3 } module.exports = function () { console.log(&#39;test&#39;) } module.exports = class { constructor(name) { this.name = name } show() { console.log(`Show ${this.name}`) } } module.exports可以让模块被赋值成任意类型，但需要注意的是此时module.exports类似于一个模块内的全局变量。 对它的重复赋值，只有最后的值有效，之前的值会直接被覆盖。 在这个例子中，module3.js模块最终导出为一个类。 因此，通常推荐使用module.exports，可以避免出错。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(四) --处理接收到的POST数据]]></title>
    <url>%2F2019%2F03%2F25%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E5%9B%9B)%20--%E5%A4%84%E7%90%86%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84POST%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[POST数据量通常较大，通常不会一次性从客户端发送到服务端，具体每次发送的大小由协议，以及客户端与服务端之间的协商决定。 因此，Nodejs在处理POST数据时，需要通过request对象的data事件，获取每次传输的数据，并在end事件调用时，处理所有获取的数据。 request对象是一个http.IncomingMessage 类，而它实现了可读流接口，因此具有了可读流的data、end等事件。 需要注意的是，data事件中传入的参数是Buffer，Buffer只是一个二进制的数据，它有可能只是一段字符串数据，也有可能是文件的一部分，所以处理Buffer数据的时候要注意这一点。 const http = require(&#39;http&#39;) const querystring = require(&#39;querystring&#39;) const server = http.createServer((req, res) =&gt; { let bufferArray = [] // 用于存储data事件获取的Buffer数据。 req.on(&#39;data&#39;, (buffer) =&gt; { bufferArray.push(buffer) // 将Buffer数据存储在数组中。 }) req.on(&#39;end&#39;, () =&gt; { // Buffer 类是一个全局变量，使用时无需 require(&#39;buffer&#39;).Buffer。 // Buffer.concat方法用于合并Buffer数组。 const buffer = Buffer.concat(bufferArray) // 已知Buffer数据只是字符串，则可以直接用toString将其转换成字符串。 const post = querystring.parse(buffer.toString()) console.log(post) }) }) server.listen(8080) 同时处理GET/POST请求通常在开发过程中，同一台服务器需要接收多种类型的请求，并区分不同接口，向客户端返回数据。 最常用的方式，就是对请求的方法、url进行区分判断，获取到每个请求的数据后，统一由一个回调函数进行处理。 const http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const querystring = require(&#39;querystring&#39;) const server = http.createServer((req, res) =&gt; { // 定义公共变量，存储请求方法、路径、数据 const method = req.method let path = &#39;&#39; let get = {} let post = {} // 判断请求方法为GET还是POST，区分处理数据 if (method === &#39;GET&#39;) { // 使用url.parse解析get数据 const { pathname, query } = url.parse(req.url, true) path = pathname get = query complete() } else if (method === &#39;POST&#39;) { path = req.url let arr = [] req.on(&#39;data&#39;, (buffer) =&gt; { // 获取POST请求的Buffer数据 arr.push(buffer) }) req.on(&#39;end&#39;, () =&gt; { // 将Buffer数据合并 let buffer = Buffer.concat(arr) // 处理接收到的POST数据 post = querystring.parse(buffer.toString()) complete() }) } // 在回调函数中统一处理解析后的数据 function complete() { console.log(method, path, get, post) } }) server.listen(8080) 实现一个带接口请求的简单服务器虽然当前还未涉及到数据库的知识，但已经可以通过文件读写，实现一个简单的服务器，需求如下： 用户通过GET方法请求/reg接口，实现注册流程。 用户通过POST方法请求/login接口，实现登录流程。 非接口请求则直接返回相应文件。 实现思路 新建users.json文件，用于存放用户列表数据。 新建index.html文件，实现表单及注册、登录的前端请求功能。 服务端判断请求路径，决定是前端是通过接口校验用户数据，还是请求HTML文件。 若是接口请求，则通过用户列表判断用户状态，实现注册和登录流程。 代码及示例html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot; id=&quot;username&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot; id=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;button&quot; value=&quot;注册&quot; id=&quot;reg&quot;&gt; &lt;input type=&quot;button&quot; value=&quot;登录&quot; id=&quot;login&quot;&gt; &lt;script&gt; // 注册 document.querySelector(&#39;#reg&#39;).addEventListener(&#39;click&#39;, async function () { const response = await fetch(`/reg?username=${document.querySelector(&#39;#username&#39;).value}&amp;password=${document.querySelector(&#39;#password&#39;).value}`) const result = await response.json() console.log(result) alert(result.msg) }) // 登录 document.querySelector(&#39;#login&#39;).addEventListener(&#39;click&#39;, async function () { const response = await fetch(`/login`, { method: &#39;POST&#39;, body: JSON.stringify({ username: document.querySelector(&#39;#username&#39;).value, password: document.querySelector(&#39;#password&#39;).value }) }) const result = await response.json() console.log(result) alert(result.msg) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; server.jsconst http = require(&#39;http&#39;) const url = require(&#39;url&#39;) const fs = require(&#39;fs&#39;) const querystring = require(&#39;querystring&#39;) const server = http.createServer((req, res) =&gt; { // 定义公共变量，存储请求方法、路径、数据 const method = req.method let path = &#39;&#39; let get = {} let post = {} // 判断请求方法为GET还是POST，区分处理数据 if (method === &#39;GET&#39;) { // 使用url.parse解析get数据 const { pathname, query } = url.parse(req.url, true) path = pathname get = query complete() } else if (method === &#39;POST&#39;) { path = req.url let arr = [] req.on(&#39;data&#39;, (buffer) =&gt; { // 获取POST请求的Buffer数据 arr.push(buffer) }) req.on(&#39;end&#39;, () =&gt; { // 将Buffer数据合并 let buffer = Buffer.concat(arr) // 处理接收到的POST数据 post = JSON.parse(buffer.toString()) complete() }) } // 在回调函数中统一处理解析后的数据 function complete() { try { if (path === &#39;/reg&#39;) { // 获取get请求数据 const { username, password } = get // 读取user.json文件 fs.readFile(&#39;./users.json&#39;, (error, data) =&gt; { if (error) { res.writeHead(404) } else { // 读取用户数据 const users = JSON.parse(data.toString()) const usernameIndex = users.findIndex((item) =&gt; { return username === item.username }) // 判断用户名是否存在 if (usernameIndex &gt;= 0) { res.write(JSON.stringify({ error: 1, msg: &#39;此用户名已存在&#39; })) res.end() } else { // 用户名不存在则在用户列表中增加一个用户 users.push({ username, password }) // 将新的用户列表保存到user.json文件中 fs.writeFile(&#39;./users.json&#39;, JSON.stringify(users), (error) =&gt; { if (error) { res.writeHead(404) } else { res.write(JSON.stringify({ error: 0, msg: &#39;注册成功&#39; })) } res.end() }) } } }) } else if (path === &#39;/login&#39;) { const { username, password } = post // 读取users.json fs.readFile(&#39;./users.json&#39;, (error, data) =&gt; { if (error) { res.writeHead(404) } else { // 获取user列表数据 const users = JSON.parse(data.toString()) const usernameIndex = users.findIndex((item) =&gt; { return username === item.username }) if (usernameIndex &gt;= 0) { // 用户名存在，则校验密码是否正确 if (users[usernameIndex].password === password) { res.write(JSON.stringify({ error: 0, msg: &#39;登录成功&#39; })) } else { res.write(JSON.stringify({ error: 1, msg: &#39;密码错误&#39; })) } } else { res.write(JSON.stringify({ error: 1, msg: &#39;该用户不存在&#39; })) } } res.end() }) } else { // 若不是注册或登录接口，则直接返回相应文件 fs.readFile(`.${path}`, (error, data) =&gt; { if (error) { res.writeHead(404) } else { res.write(data) } res.end() }) } } catch (error) { console.error(error); } } }) server.listen(8080)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(三) --处理接收到的GET数据]]></title>
    <url>%2F2019%2F03%2F19%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E4%B8%89)%20--%E5%A4%84%E7%90%86%E6%8E%A5%E6%94%B6%E5%88%B0%E7%9A%84GET%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[常用请求方式GET和POST是最常用的HTTP请求方法，除此之外还有DELETE、HEAD、OPTIONS、PUT、TRACE等，但都很少用到。 GET POST 主要用于获取数据 主要用于发送数据 数据放在HTTP请求Header中，通过URL进行传输，容量&lt;=32k 数据放在HTTP请求body中,容量大，通常上限2G 处理Get数据我们可以使用Nodejs自带的url和querystring模块处理接收到的GET数据。 首先新建一个带form表单的HTML文件，讲输入的数据提交到服务器地址： &lt;form action=&quot;http://localhost:8080/login&quot; method=&quot;get&quot;&gt; 用户：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt; 密码：&lt;input type=&quot;text&quot; name=&quot;password&quot;&gt;&lt;br/&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; 服务端在接收到请求数据时，可以有3种方式处理数据： 将请求数据中的req.url进行字符串切割，再用querystring模块获取数据。 const [ pathname, queryStr ] = req.url.split(&#39;?&#39;) const query = querystring.parse(queryStr) console.log(pathname, query) 用URL构造函数实例化一个url对象，从中获取到pathname和search值，再用querystring模块解析search数据 const url = new URL(`http://localhost:8080${req.url}`) const { pathname, search } = url const query = querystring.parse(search.substring(1, url.search.length)) console.log(pathname, query) 使用url模块的parse方法，直接解析出数据。 // parse方法第二个参数若传true，则会直接将解析出的query值转为对象形式，否则它只是字符串形式 const { pathname, query } = url.parse(req.url, true) console.log(pathname, query)]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(二) --使用http和fs模块实现一个简单的服务器]]></title>
    <url>%2F2019%2F03%2F19%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E4%BA%8C)%20--%E4%BD%BF%E7%94%A8http%E5%92%8Cfs%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%9C%8D%E5%8A%A1%E5%99%A8%2F</url>
    <content type="text"><![CDATA[准备1.创建一个www目录，存储静态文件1.html、1.jpg。 * html文件内容如下： &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 网页内容 &lt;img src=&quot;/1.jpg&quot; alt=&quot;&quot;&gt; &lt;/body&gt; &lt;/html&gt; 预期实现的结果为： a. 在浏览器访问http://localhost:8080/1.html。 b. 读取到www/1.html，由HTML文件发起对www/1.jpg的请求。 c. 网页中显示HTML内容和图片。 使用Nodejs实现服务端代码： const http = require(&#39;http&#39;) const fs = require(&#39;fs&#39;) const server = http.createServer((request, response) =&gt; { console.log(request.url) // 在request对象中，可以获取请求的URL，通过URL判断请求的资源。 fs.readFile(`./www${request.url}`, (error, buffer) =&gt; { // 根据URL查找读取相应的文件。 if (error) { // 若读取错误，则向前端返回404状态码，以及内容Not Found。 response.writeHead(404) response.write(&#39;Not Found&#39;) } else { // 若读取成功，则向前端返回读取到的文件。 response.write(buffer) } response.end() // 关闭连接。 }) }) server.listen(8080) 服务器需要具备的基本功能1.响应请求 如上面的例子，可以根据客户端的请求做出回应，如返回静态文件。2 数据交互 定义接口，客户端根据接口，与服务端进行数据交互。 例如在一个购物流程中，客户端向服务端请求商品数据，展现给客户，客户在购买时，客户端将购买的商品信息发送给服务端处理。 数据库3.对数据库中存储的数据进行读写操作。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node学习(一) --NodeJs简介]]></title>
    <url>%2F2019%2F03%2F18%2FNode%2FNode%E5%AD%A6%E4%B9%A0(%E4%B8%80)%20--NodeJs%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[NodeJs简介 简单的说Node.js就是运行在服务端的Javascript Node.js是一个基于ChromeV8引擎的Javascript的执行环境 Node.js使用了一个事件驱动，非阻塞式I/O的模型，使其轻量有高效 NodeJs的应用环境由于Nodejs目前还不够成熟，因此一般不会用作独立开发，它的主要用途如下 中间层通常在开发应用时，出于安全考虑，后端的主服务器都不会直接暴露给客户端，两端之间通常需要有一个中间层进行通信。 这样做的好处是，如果中间层出现问题，不会影响后端的主服务器。另外，中间层可以做缓存，或者实现一些业务逻辑，起到降低主服务器复杂度，提高性能的作用。 中间层也可以像CDN一样在各处部署，以提高用户的访问效率。 小型服务可以实现一些小型应用，或某个功能模块。 工具类工具类 Nodejs可以用来开发一些实用工具，如Webpack、Gulp等等。 Nodejs的优势 Nodejs的语法与前台JavaScript相同，因此便于前端开发入手 性能高 利于与前端代码结合，例如在做同样一个数据校验时，前后台代码可以共用，不需要单独开发。 Nodejs的卸载当需要升级Nodejs时，建议先完全卸载旧版本，特别是全局已下载的依赖，否则有小概率会出现更新版本后，新安装依赖时报错。 完整卸载步骤：通过系统自带卸载工具，卸载Nodejs，之后最好将Nodejs安装目录整个删除。手动删除安装目录，如C:\Program Files\nodejs目录下的node_modules文件夹。找到用户目录，如C:\Users\你的用户名，其中如果有node_modules文件夹，则一起删除。 启动一个Nodejs服务器我们可以新建一个server.js文件，在命令行通过node server.js命令，就可以运行一个服务器，在浏览器访问中访问http://127.0.0.1:3000/，就可以看到Hello World。 // 引入Nodejs自带的http模块 const http = require(&#39;http&#39;); // 引入Nodejs自带的child_process模块 const childProcess = require(&#39;child_process&#39;); const hostname = &#39;127.0.0.1&#39;; // 本机地址 const port = 3000; // 端口 // 创建一个服务器 const server = http.createServer((req, res) =&gt; { res.statusCode = 200; // 设置响应状态码 res.setHeader(&#39;Content-Type&#39;, &#39;text/plain&#39;); // 设置响应头 res.end(&#39;Hello World\n&#39;); // 向前台输出内容 }); // 开启监听 server.listen(port, hostname, () =&gt; { // 在命令行打印运行结果 console.log(`Server running at http://${hostname}:${port}/`); // 使用默认浏览器打开地址 childProcess.exec(`start http://${hostname}:${port}/`); }); response.write我们使用了http.createServer创建一个服务器，在它的回调函数中，会传入2个参数，分别为request（请求对象）和response（响应对象）。 通常使用response.write方法向前端返回数据，该方法可调用多次，返回的数据会被拼接到一起。 需要注意的是，必须调用response.end方法结束请求，否则前端会一直处于等待状态，response.end方法也可以用来向前端返回数据。 const server = http.createServer((request, response) =&gt; { response.write(&#39;a&#39;) response.write(&#39;b&#39;) response.write(&#39;c&#39;) response.end(&#39;d&#39;) }) File SystemFile System是Nodejs中用来操作文件的库，可以通过const fs = require(&#39;fs&#39;)引用。 常用的方法有异步文件读取fs.readFile、异步文件写入fs.writeFile、同步文件读取fs.readFileSync、同步文件写入fs.writeFileSync。由于同步操作可能会造成阻塞，通常建议使用异步操作避免该问题。 fs.writeFilefs.writeFile可向文件写入信息，若文件不存在会自动创建。 fs.writeFile(&#39;./test.txt&#39;, &#39;test&#39;, (error) =&gt; { if (error) { console.log(&#39;文件写入失败&#39;, error) } else { console.log(&#39;文件写入成功&#39;) } }) fs.writeFile的主要参数： 第一个参数为写入的文件路径第二个参数为写入内容（可为&lt;string&gt; | | | ）第三个参数为回调函数，传入数据为error对象，其为null时表示成功。 fs.readFilefs.readFile用来读取文件。 fs.readFile(&#39;./test.txt&#39;, (error, data) =&gt; { if (error) { console.log(&#39;文件读取失败&#39;, error) } else { // 此处因确定读取到的数据是字符串，可以直接用toString方法将Buffer转为字符串。 // 若是需要传输给浏览器可以直接用Buffer，机器之间通信是直接用Buffer数据。 console.log(&#39;文件读取成功&#39;, data.toString()) } }) fs.readFile主要参数：第一个参数为读取的文件路径第二个参数为回调函数。回调函数传入第一个参数为error对象，其为null时表示成功，第二个为数据，可为&lt;string&gt; | &lt;Buffer&gt;。]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES2019的新功能]]></title>
    <url>%2F2019%2F03%2F16%2FJs%2FES2019%E7%9A%84%E6%96%B0%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[前言ECMAScript 每年都会发布一个新版本，其中的提案是已经正式通过的，并分发给开发者和用户。本文将讨论该语言的最新版本，以及它又具有了什么新功能。 ES10/ES2019 在本次更新中有很大的改进。它引入了一些新的函数和方法，使开发者能够编写更少的代码，并提高工作效率。 flat()flat() 是一种用于扁平数组的方法。在某些时候，数组的元素还是数组，这些类型的数组称为嵌套数组。 要取消数组的嵌套（扁平它们），我们不得不使用递归。现在引入flat()，可以用一行代码完成。 一个被展平的数组是一个深度为 0 的数组，flat() 接受一个参数，一个代表深度的数字。深度指的是数组内嵌套的数量。下面这个例子可以帮你理解嵌套和深度。 var arr = [1,2,3,[4,5,6,[7,8,9,[1,2,3]]]]; console.log(arr.flat(3)); // [1,2,3,4,5,6,7,8,9,1,2,3] 通常在 JavaScript 中，数组的深度可以为无穷大，或者直到内存不足为止。假设一个数组的嵌套深度为3，并且我们仅将其展平到深度 2，那么主数组中仍然会存在一个嵌套数组。 flatMap()flatMap() 用于展平嵌套数组并根据给出的像 map() 这样的函数更改值。此函数作用于数组并用一个回调函数作为参数。回调函数用于指示数组应该怎样被展平。它就像 map 一样工作，此外也使它变得扁平。如果你想了解有关 map 的更多信息，请查看关于this的文章。 flatMap() 可用于展平深度为1的数组，它在内部调用 map 函数，后跟着参数深度为1的 flat 函数. var array = arr.flatMap((callback(currentValue))); 返回值 带有操纵值的扁平数组，由提供给它的回调函数提供。就像一个map一样。 map() + flat() =&gt; flatmap() var arr = [1,2,3,4]; console.log(arr.map(x=&gt;[x*2])); // [2],[4],[6],[8] console.log(arr.flatMap(x=&gt;[x*2])); //[2,4,6,8] 在此例中，我们逐个显示 map 和 flatMap 以显示两个函数之间的差异。 map() 返回嵌套数组，而flatMap() 的输出除了数组的展平外，还与 map 的结构相同。 Object.fromEntries()另一个非常有用的函数 Object.fromEntries 用于根据提供的键值对生成对象。它接受一个键值对列表，并返回一个对象，对象的属性由参数 entries66n 给出。它的作用与 Object.entries()相反 参数接受任何可迭代的对象，即数组。 返回值返回有给定键值对的对象。 const entries = new Map([ [&#39;apple&#39;,&#39;orange&#39;], [&#39;grapes&#39;,&#39;peach&#39;] ]); const obj = Object.formEntries(entries); console.log(obj);// {apple:&quot;orange&quot;,grapes:&quot;peach&quot;} 我们可以看到，当向 fromEntries() 函数提供了一个map（将值成对存储）时，会得到一个对象，其对应的键值对和 map 中一样。 trimStart()trimStart() 方法删除字符串开头的空格。 trimLeft() 是此方法的别名。 var message = &#39; Hello World&#39;; console.log(message);// &#39; Hello World&#39; console.log(message.trimStart());//&#39;Hello World&#39; trimEnd()trimEnd() 方法删除字符串末尾的空格。 trimRight() 是此方法的别名。 var message = &#39;Hello World &#39;; console.log(message);// &#39; Hello World&#39; console.log(message.trimEnd());//&#39;Hello World&#39; 修改 catch 绑定在 ES10 之前，我们必须通过语法为 catch 子句绑定异常变量，无论是否有必要。很多时候 catch 块是多余的。 ES10 提案使我们能够简单的把变量省略掉。 示例 function isValid(ison){ try{ JSON.parse(json); return true; }catch { return false; } } 在上面的例子中，可以看到没有为 catch 提供变量。 符号描述当我们在 JS 中创建一个 Symbol 时，可以指定一个在以后用于调试的描述。得到这个描述的过程有点无聊，必须再次重新构造 Symbol，并在 toString() 方法的帮助下才能访问描述。 ES10添加了一个新的名为 description 的只读属性，它返回 Symbol 的描述。 示例 const symbol = Symbol(&quot;this is a symbol&quot;); console.log(symbol.toString()); // Symbol(My Symbol); console.log(symbol.destription); // My Symbol 可以看到使用 Symbol 的.description 属性能够直接获取描述。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[怎么提高代码质量？-来自Google的研发经验总结]]></title>
    <url>%2F2019%2F03%2F14%2F%E6%9D%82%E6%96%87%2F%E6%80%8E%E4%B9%88%E6%8F%90%E9%AB%98%E4%BB%A3%E7%A0%81%E8%B4%A8%E9%87%8F%EF%BC%9F-%E6%9D%A5%E8%87%AAGoogle%E7%9A%84%E7%A0%94%E5%8F%91%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[原文地址 你的团队有没有过这样的经历：开发效率低，招了很多人，天天加班，出活却不多，线上bug频发，领导发飙，中层束手无策，工程师抱怨不断，查找bug困难。其实这些都是代码质量差惹的祸。代码质量是研发质量管理的根本，它决定了整个开发团队的开发效率，项目质量，其他监控，告警，日志等手段都只能是事后补偿。本文就如何保证代码质量总结了一些经验和方法，供大家参考。 代码质量本身并没有一个特别明确的量化指标，而且根据公司发展的不同阶段，团队规模的大小不同，项目性质的不同等，对代码质量的要求也不尽相同．不过如果项目中出现以下情况时候，就说明代码质量要值得重视了． 添加或修改一个简单功能时，涉及要修改的地方特别多，而且很分散； 代码不可复用：相似的功能无法复用代码，要重新开发； 线上bug频发，排错困难，修复难度大，时间长； 有很多奇怪的代码，代码读不懂，新人无法很快了解代码； 代码中坑特别多，不敢大动，一不小心就踩坑； 以上这些问题，基本上都是代码质量不高导致的，包括 代码无注释，无文档，命名差，项目层次结构差，调用关系混乱，到处hardcode，临时解决方案等等。怎么才能时刻保证代码的高质量，避免以上问题发生？当然团队的技术素质很重要，除此之外，还有一些方法可循的 吹毛求疵般地执行编码规范严格执行代码编写规范，可以使一个项目乃至一个公司的代码具有完全统一的风格，就像同一个人编写的一样，而且命名良好的变量，函数，类和注释，也无疑可以提高代码的可读性．具体落实到执行层面，可以参照Google的编码规范或者java官方的编码规范，网上可以找到，关键是要严格遵守，并且在code review时，严格要求，没有按照规范的一定要指出并且要求修改． 实际情况往往是虽然大家都知道优秀的代码规范是怎样的，但在具体写代码的过程中，却执行的差强人意，很多情况是认识上不够重视，觉得一个变量或者函数的命名成哪样关系不大，所以不够推敲，注释很多也都不写，code review的时候大家也都事不关己心态，或者觉得没必要太抠细节，导致慢慢的整个code base变得越来越差．所以这里还是要强调一下，细节决定成败，提高团队对代码规范的认同及其严格的执行是关键． 编写高质量的单元测试单元测试是最容易执行，且对提高代码质量见效最快的方法之一还。但还是有很多公司对单元测试重视不够，包括一些大的互联网公司，不写或者随便写写 有些工程师觉得有测试团队就够了，再写单元测试就是浪费时间。其实测试团队的测试和单元测试是在不同层面上的，测试团队的测试一般是黑盒测试，系统层面的集成测试，对于复杂系统来说，组合爆炸，测试团队无法穷举所有的测试用例。单元测试是代码层面的测试，一般是针对类的测试。既然无法从系统的整体上保证100%符合我们的预期，那单元测试起码能保证我们代码在细粒度上运行符合预期。 有些工程师认为开发任务重没时间写。这个还是没有足够重视单元测试，觉得是可有可无的部分，才会有这样的想法。写好单元测试，节省很多解决线上bug的时间，开发时间反而更充足了。 还有很多工程师虽然在写单元测试，但只对正常流程做测试。代码中的bug多数是写代码时异常情况没有考虑全面导致的，正常流程一般不会出问题。单元测试的作用就在于测试各种异常情况下代码的运行是否符合预期，所以只对正常流程测试无法发挥单元测试真正的作用 一般情况下，单元测试代码量要比要测试的代码多，一般是1-2倍的样子，写单元测试本身没有太多的技术挑战，主要看工程师逻辑是否缜密，能够考虑各种异常情况，写起来比较枯燥，所以写高质量的单元测试的一方面要靠工程师的耐心执行，另一方面要靠团队的严格要求。当然这些都是建立在对单元测试重要性的认同之上。 不流于形式的Code Review如果说单元测试很多工程师不怎么重视，那code review就是不怎么接受．跟很多大型互联网公司的人聊过，对code review都不怎么认可，大部分反应都是，这玩意不可能很好的执行，浪费时间，是的，code review做的再流畅，也是要花时间的，关键在于我们是愿意花2天写代码花5天修bug,还是愿意花３天写代码花半天修bug. 其实，code review的好处不仅仅是能够大大提高代码质量，减少代码bug，你想想如果我们没有code review，平时写的代码“偷偷”就commit了，难免有人不自律，有了code review，直播代码，曝光dirty code，大家就会更认真些．其次来讲，code review也是一种有效技术传帮带的途径，每次code review都是一次案例的剖析，可以帮助初级的工程师培养编码规范，提高编码质量，设计能力甚至于架构能力，反过来，review别人写的好的代码，对自己也是一种学习和提高 除此之外，严格的code review不仅能保证代码的质量，还能形成良好的技术氛围。 开发未动文档先行编写技术文档对大部分工程师来说都是挺反感的事情。一般来讲在开发某个系统或者重要模块或者功能之前需要先写技术文档，然后发送给同组或者相关同事审查，在审查没有问题的情况下再开发，这样能够事先达成共识，开发出来的东西不至于走样，而且当开发完成之后进行code review的阶段，代码审查者通过阅读开发文档也可以快速的理解代码． 除此之外，文档对于团队和公司来讲都是重要的财富，对于新人加入公司熟悉代码，产品，对于任务的交接等等都很有帮助，而且作为一个规范化的技术团队，技术文档是一种摒弃作坊式开发和个人英雄主义的有效方法，是保证团队有效协作的途径． 不过，有很多工程师提出说不会写技术文档，不知道写什么，希望给一个模板或者目录．我之前曾经想过是否可以给出一个固定的模板，但最后还是放弃了，比较难，难点在于，每个项目侧重点都不一样不容易总结，如果硬要给出一个很宽泛的目录，不具有指导性也没有意义．大体上来讲，文档的内容主要是将做的东西讲清楚，包括出问题背景，解决了什么问题，外部怎么用或调用，内部如何实现，大的架构，关键功能和算法等，以及一些非功能性的考虑。 持续重构，重构，重构个人比较反对平时不注重代码质量，堆砌烂代码，实在维护不了了就大刀阔斧的重构甚至重写。有时候项目代码太多了，重构很难做到彻底，最后又搞出来一个四不像的怪物，更麻烦了！ 优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司或产品也都是迭代出来的一样的，我们无法100%遇见未来的需求，也没有足够的精力，时间，资源为遥远的未来买单，所以随着系统的演进，重构代码也是不可避免的，虽然上面说了不支持大刀阔斧推到重来式的大重构，但持续的小重构还是比较推崇的，也是时刻保证代码质量防止代码腐化有效手段．简单一句话就是不要等到问题堆得太多了再采取重构，要时刻有人对代码整体负责任，平时没事就改改代码，而不要觉得重构代码就是浪费时间，不务正业！ 特别是一些业务开发团队，有时候为了快速完成一个产品或者业务功能，只追求速度，到处hard code，在完全不考虑非功能性需求的情况下，堆砌一些烂代码，这种情况还是比较常见的。不过没关系，等有时间一定要记着重构，不然烂代码越堆越多，总有一天会没人能维护。 项目与团队”微服务化”只有小项目是可以维护的，大项目是无法维护的．团队人比较少的时候，十几个人的样子，代码量也不多，不超过10万行，怎么开发，怎么管理都没问题，大家互相都了解彼此做的东西，代码质量太差了，大不了重写一遍．但如果是一个极其庞大的项目，几十万行代码，几十个开发维护，那基本上没人能对代码负责了． 所以当项目太大了之后，就需要对代码和团队进行拆分，模块化，大团队拆成几个小团队，大项目拆成几个小项目，这样每个团队每个项目的代码都不至于很多，也不至于出现代码质量太差无法维护的情况，其实很多技术也都体现了这种思想，比如大到soa, 微服务，小到jar, .so等lib模块开发，Class类的封装，都是一种拆分的思想． 重视代码关注细节以上其他的所有方法都是治标不治本，找到对的人用好对的人，打造优秀的技术文化，才是能一直卓越的根本。有很多工程师比较热衷于学习架构，工具，框架层面的东西，见过很多工程师，还没写三五年代码就转做架构师，不写代码了，到处忽悠，很不好，互联网信息如此透明，不同的人去做同一个项目，其实最后设计出来的架构,功能大约都差不多，最后大家都能把这个系统实现，但有些人做出来的系统，bug很多，性能很差，扩展性也不好，最多能叫个POC。 高手之间的竞争还是在于细节，一个算法够不够优化，数据存取的效率高不高，内存是否够节省等等，这是累积起来决定了一个系统是不是够优秀。 国内工程师普遍深度不够，做几年技术就转管理或者纯架构设计不写代码了，而国外不一样，大龄码农很多，所以国外的优秀开源项目比较多，而国内很少 工欲善其事必先利其器代码中的很多低级质量问题不需要人工去审查，java开发有很多现成的工具可以使用，比如：checkstyle，findbugs, pmd, jacaco, sonar等。 Checkstyle,findbugs,pmd是静态代码分析工具，通过分析源代码或者字节码，找出代码的缺陷，比如参数不匹配，有歧义的嵌套语句，错误的递归，非法计算，可能出现的空指针引用等等。三者都可以集成到gradle等构建工具中。 Jacoco是一种单元测试覆盖率统计工具，也可以集成到gradle等构建工具中，可以生成漂亮的测试覆盖率统计报表，同时Eclipse提供了插件可以EclEmma可以直观的在IDE中查看单元测试的覆盖情况。 Sonar Sonar 是一个用于代码质量管理的平台。可以在一个统一的平台上显示管理静态分析，单元测试覆盖率等质量报告。 最后，总结以上所有的这些方法论应该都没啥新奇的，也没有葵花宝典似的杀手锏，说出来感觉都很简单的，现在互联网这么发达，信息都很透明，所以大方向大家都知道，具体的策略和架构各家也都差不多，最后谁做的好，关键在于执行和细节，经常听到有人说我们做了单元测试啊，我们做了性能测试，可最后还是一堆性能问题一堆bug，那就要去考虑一下到底做的够不够好，是否做到了具体问题具体分析，不生搬硬套，从决策到执行再到考核是否形成了闭环，很多时候只是空喊口号，口号喊得100分，落实到执行只能得５0分，最后又完全没考核，好坏大家也都不知，切记敏于言而讷于行]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 Class中的constructor方法和super的作用]]></title>
    <url>%2F2019%2F03%2F12%2FJs%2FES6-Class%E4%B8%AD%E7%9A%84constructor%E6%96%B9%E6%B3%95%E5%92%8Csuper%E7%9A%84%E4%BD%9C%E7%94%A8%2F</url>
    <content type="text"><![CDATA[前言首先，ES6 的 class 属于一种“语法糖”，所以只是写法更加优雅，更加像面对对象的编程，其思想和 ES5 是一致的。 construcotfunction Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function() { return &#39;(&#39; + this.x + &#39;,&#39; + this.y + &#39;)&#39;; } 等同于 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return &#39;(&#39; + this.x + &#39;,&#39; + this.y + &#39;)&#39;; } } 其中 constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 constructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。 super下面好好分析一下 super 关键字的作用： super 这个关键字，既可以当做函数使用，也可以当做对象使用。这两种情况下，它的用法完全不用。 1.当函数使用 class A {} class B extends A { constructor() { super(); // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。 } } 注：在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 `A.prototype.constructor.call(this, props)。 class A { constructor() { console.log(new.target.name); // new.target 指向当前正在执行的函数 } } class B extends A { constructor() { super(); } } new A(); // A new B(); // B 可以看到，在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。 2.当对象使用 在普通方法中，指向父类的原型对象；在静态方法中，指向父类。 class A { c() { return 2; } } class B extends A { constructor() { super(); console.log(super.c()); // 2 } } let b = new B(); 上面代码中，子类 B 当中的 super.c()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向 A.prototype，所以 super.c() 就相当于 A.prototype.c()。 通过 super 调用父类的方法时，super 会绑定子类的 this。 class A { constructor() { this.x = 1; } s() { console.log(this.x); } } class B extends A { constructor() { super(); this.x = 2; } m() { super.s(); } } let b = new B(); b.m(); // 2 上面代码中，super.s() 虽然调用的是 A.prototytpe.s()，但是 A.prototytpe.s()会绑定子类 B 的 this，导致输出的是 2，而不是 1。也就是说，实际上执行的是 super.s.call(this)。由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。 由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性。 class A { constructor() { this.x = 1; } } class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 } } let b = new B(); 上面代码中，super.x 赋值为 3，这时等同于对 this.x 赋值为 3。而当读取 super.x 的时候，调用的是 A.prototype.x，但并没有 x 方法，所以返回 undefined。注意，使用 super 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。 class A {} class B extends A { constructor() { super(); console.log(super); // 报错 } } 上面代码中，console.log(super); 的当中的 super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这是，如果能清晰的表明 super 的数据类型，就不会报错。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。 结语：ES6 的 class 毕竟是一个“语法糖”，所以只要理解了 JavaScript 中对象的概念和面向对象的思想，class 就不难理解啦]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[30 Seconds of ES6 （一）]]></title>
    <url>%2F2019%2F01%2F27%2FJs%2F30-Seconds-of-ES6-%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[项目背景简介30 seconds of code 是一个非常优质精选的 JavaScript 项目 ，总结了大量的使用 ES6 语法实现的代码块，项目的设计目标就是更简洁，更高效，更快速的实现基础代码模块，碎片化学习实用干货， 30 秒掌握一个高质量 ES6 代码块 。 学习初衷学习 ES6 基础知识，提升程序算法能力；学习 JavaScript 基础从 API 开始。每篇精选 5 段优秀代码块，和 5 个以上 API ，为前端大全栈打下坚实根基！ 学习方法认真解读英文版 30 seconds of code 的每个 ES6 代码块，并把其中的 API 重点分析。认识新单词，提升英语水平，目标可以轻松翻阅英文版专业书，全面提升前端技术软实力。 Adapter 适配器 ary创建一个接受最多 n 个参数的函数，忽略任何其他参数。使用 Array.prototype.slice（0，n） 方法和 spread 扩展运算符 （…） 调用提供的函数 fn （最多 n 个参数）。 const ary = (fn , n) =&gt; (...args) =&gt; fn(...args.slice(0, n)); const firstTwoMax = ary(Math.max, 2); console.log([[2, 6, &#39;a&#39;], [8, 4, 6], [10]].map(x =&gt; firstTwoMax(...x)));//[6, 8, 10] MDN 解析 Array.prototype.slice() 案例该 slice() 方法返回一个阵列的一部分的一个浅拷贝，到选自新的数组对象 begin 到 end ( end 不包括)。原始数组不会被修改。 var animals = [&#39;ant&#39;, &#39;bison&#39;, &#39;camel&#39;, &#39;duck&#39;, &#39;elephant&#39;]; console.log(animals.slice(2,4));//[&#39;camel&#39;, &#39;duck&#39;] console.log(animals);// [&quot;ant&quot;, &quot;bison&quot;, &quot;camel&quot;, &quot;duck&quot;, &quot;elephant&quot;] MDN 解析 Math.max() 案例该 Math.max() 函数返回零个或多个数字中的最大值。 console.log(Math.max(-10, 20)); //20 Array 数组 all如果提供的谓词函数对集合中的所有元素都返回 true ，则返回 true，否则返回 false 。使用 Array.prototype.every（） 测试集合中的所有元素是否基于 fn 返回 true 。省略第二个参数 fn ，将布尔值用作默认值。 const all = (arr, fn = Boolean) =&gt; arr.every(fn); console.log(all); console.log(all([4, 2, 3], x =&gt; x &gt;1));//true console.log(all([1, 2, 3]));//true MDN 解析 Array.prototype.every() 案例该 every() 方法测试数组中的所有元素是否都通过了由提供的函数实现的测试。对于空数组，任何情况下调用该方法都会返回 true。 console.log([12, 5, 8, 130, 44].every(x =&gt; x &gt;= 10));//false console.log([12, 54, 18, 130, 44].every(x =&gt; x &gt;=10));//true console.log([].every(x =&gt; x));//true Array 数组 allEqual检查数组中的所有元素是否相等。使用 Array.prototype.every（） 检查数组中的所有元素是否与第一个元素相同。 const allEqual = arr =&gt; arr.every( val =&gt; val === arr[0]); console.log(allEqual([1, 2, 3, 4, 5, 6]));//false console.log(allEqual([1, 1, 1, 1]));//true Array 数组 any如果提供的谓词函数对集合中的至少一个元素返回 true ，则返回 true ，否则返回 false 。使用 Array.prototype.some（） 测试集合中的任何元素是否基于 fn 返回 true 。省略第二个参数 fn ，将布尔值用作默认值。 const any = (arr, fn = Boolean) =&gt; arr.some(fn);+ console.log(any([0, 1, 2, 0], x =&gt; x &gt;=2));//true console.log(any([0, 0, 1, 0]));//true MDN 解析 Array.prototype.some() 案例该 some () 方法测试数组中是否至少有一个元素通过了由提供的函数实现的测试。此方法返回 false 放在空数组上的任何条件。 console.log([2, 5, 8, 1, 4].some(x =&gt; x &gt; 10));//false console.log([12, 5, 8 ,1 , 4].some( x =&gt; x &gt;10));//true Array 数组 arrayToCSV将二维数组转换为逗号分隔值（ csv ）字符串。使用 Array.prototype.map () 和 Array.prototype.join（delimiter） 将一维数组组合成字符串。使用 Array.prototype.join（’\n’） （ ，换行符号）两个组合的全行到 CSV 格式的字符串，每排分捡和一个换行符。在第二 omit 参数delimiter ，使用 delimiter（默认）。 const arrayToCSV = (arr, delimiter = &#39;,&#39;) =&gt; arr.map( v =&gt; v.map( x =&gt; `&quot;${x}&quot;`).join(delimiter)).join(&#39;\n&#39;); console.log(arrayToCSV([[&#39;a&#39;, &#39;b&#39;], [&#39;c&#39;, &#39;d&#39;]])); //&quot;a&quot;,&quot;b&quot; //&quot;c&quot;,&quot;d&quot; console.log(arrayToCSV([[&#39;a&#39;, &#39;b&#39;],[&#39;c&#39;, &#39;d&#39;]],&#39;;&#39;)); //&quot;a&quot;,&quot;b&quot; //&quot;c&quot;,&quot;d&quot; MDN 解析 Array.prototype.map() 案例该 map() 方法创建一个新数组，其结果是在调用数组中的每个元素上调用提供的函数。 var array1 = [1, 4, 9 ,16]; const map1 = array1.map(x =&gt; x * 2); console.log(map1);// [2, 8, 18, 32] console.log(array1);//[1, 4, 9, 16] MDN 解析 Array.prototype.join() 案例该 join() 方法通过连接数组（或类数组对象）中的所有元素（由逗号或指定的分隔符字符串分隔）来创建并返回新字符串。如果数组只有一个项目，那么将返回该项目而不使用分隔符。如果元素是 undefined 或 null ，则将其转换为空字符串。 var elements = [&#39;Fire&#39;, &#39;Wind&#39;, &#39;Rain&#39;]; console.log(console.log(elements.join(&#39;-&#39;)));//Fire-Wind-Rain]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Es6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 组件之间的通信]]></title>
    <url>%2F2019%2F01%2F20%2FVue%2Fvue-%E7%BB%84%E4%BB%B6%E4%B9%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%2F</url>
    <content type="text"><![CDATA[什么是Vue组件？组件 (Component) 是 Vue.js 最强大的功能之一。组件可以扩展 HTML 元素，封装可重用的代码。在较高层面上，组件是自定义元素，Vue.js 的编译器为它添加特殊功能。在有些情况下，组件也可以是原生 HTML 元素的形式，以 is 特性扩展。 Vue组件间通信常见使用场景可以分为三类: 父子组件通信: props; $parent / $children; provide / inject ; ref ; $attrs / $listeners兄弟组件通信: eventBus ; vuex跨级通信: eventBus；Vuex；provide / inject 、$attrs / $listeners 父组件向子组件通信 方法一：props 使用props，父组件可以使用props向子组件传递数据。 父组件vue模板father.vue &lt;template&gt; &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt; &lt;/template&gt; &lt;script&gt; import child from &#39;./child.vue&#39;; export default { components: { child }, data () { return { message: &#39;father message&#39;; } } } &lt;/script&gt; 子组件vue模板child.vue &lt;template&gt; &lt;div&gt;{{msg}}&lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { msg: { type: String, required: true } } } &lt;/script&gt; 方法二 使用$children 使用$children可以在父组件中访问子组件。 子组件向父组件通信 方法一:使用vue事件父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件。 父组件vue模板father.vue &lt;template&gt; &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt; &lt;/template&gt; &lt;script&gt; import child from &#39;./child.vue&#39;; export default { components: { child }, methods: { func (msg) { console.log(msg); } } } &lt;/script&gt; 子组件vue模板child.vue &lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt; &lt;/template&gt; &lt;script&gt; export default { props: { msg: { type: String, required: true } }, methods () { handleClick () { //........ this.$emit(&#39;msgFunc&#39;); } } } &lt;/script&gt; 方法二： 通过修改父组件传递的props来修改父组件数据 这种方法只能在父组件传递一个引用变量时可以使用，字面变量无法达到相应效果。因为引用变量最终无论是父组件中的数据还是子组件得到的props中的数据都是指向同一块内存地址，所以修改了子组件中props的数据即修改了父组件的数据。 但是并不推荐这么做，并不建议直接修改props的值，如果数据是用于显示修改的，在实际开发中我经常会将其放入data中，在需要回传给父组件的时候再用事件回传数据。这样做保持了组件独立以及解耦，不会因为使用同一份数据而导致数据流异常混乱，只通过特定的接口传递数据来达到修改数据的目的，而内部数据状态由专门的data负责管理。 方法三：使用$parent 使用$parent可以访问父组件的数据。 非父子组件、兄弟组件之间的数据传递非父子组件通信，Vue官方推荐使用一个Vue实例作为中央事件总线。 Vue内部有一个事件机制，可以参考源码。 $on方法用来监听一个事件。 $emit用来触发一个事件。 /*新建一个Vue实例作为中央事件总嫌*/ let event = new Vue(); /*监听事件*/ event.$on(&#39;eventName&#39;, (val) =&gt; { //......do something }); /*触发事件*/ event.$emit(&#39;eventName&#39;, &#39;this is a message.&#39;); 多层级父子组件通信：在Vue1.0中实现了$broadcast与$dispatch两个方法用来向子组件（或父组件）广播（或派发），当子组件（或父组件）上监听了事件并返回true的时候会向爷孙级组件继续广播（或派发）事件。但是这个方法在Vue2.0里面已经被移除了。 之前在学习饿了么的开源组件库element的时候发现他们重新实现了broadcast以及dispatch的方法，以mixin的方式引入，具体可以参考《说说element组件库broadcast与dispatch》。但是跟Vue1.0的两个方法实现有略微的不同。这两个方法实现了向子孙组件事件广播以及向多层级父组件事件派发的功能。但是并非广义上的事件广播，它需要指定一个commentName进行向指定组件名组件定向广播（派发）事件。 其实这两个方法内部实现还是用到的还是$parent以及$children，用以遍历子节点或是逐级向上查询父节点，访问到指定组件名的时候，调用$emit触发指定事件。 复杂的单页应用数据管理当应用足够复杂情况下，请使用vuex进行数据管理。]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[keep-alive组件的使用及其实现原理]]></title>
    <url>%2F2019%2F01%2F13%2FVue%2Fkeep-alive%E7%BB%84%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%B6%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[keep-alivekeep-alive是Vue.js的一个内置组件。它能够不活动的组件实例保存在内存中，而不是直接将其销毁，它是一个抽象组件，不会被渲染到真实DOM中，也不会出现在父组件链中。 它提供了include与exclude两个属性，允许组件有条件地进行缓存。 具体内容可以参考官网。 用法&lt;keep-alive&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt; 这里的component组件会被缓存起来。 举个栗子 &lt;keep-alive&gt; &lt;coma v-if=&quot;test&quot;&gt;&lt;/coma&gt; &lt;comb v-else&gt;&lt;/comb&gt; &lt;keep-alive/&gt; &lt;button @click=&quot;test=handleClick&quot;&gt;请点击&lt;/button&gt; export default { data () { return { test: true } }, methods: { handleClick () { this.test = !this.test; } } } 在点击button时候，coma与comb两个组件会发生切换，但是这时候这两个组件的状态会被缓存起来，比如说coma与comb组件中都有一个input标签，那么input标签中的内容不会因为组件的切换而消失。 propskeep-alive组件提供了include与exclude两个属性来允许组件有条件地进行缓存，二者都可以用逗号分隔字符串、正则表达式或一个数组来表示。 &lt;keep-alive include=&quot;a&quot;&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt; 将缓存name为a的组件。 &lt;keep-alive exclude=&quot;a&quot;&gt; &lt;component&gt;&lt;/component&gt; &lt;/keep-alive&gt; name为a的组件将不会被缓存。 生命钩子keep-alive提供了两个生命钩子，分别是activated与deactivated。 因为keep-alive会将组件保存在内存中，并不会销毁以及重新创建，所以不会重新调用组件的created等方法，需要用activated与deactivated这两个生命钩子来得知当前组件是否处于活动状态。 深入keep-alive组件实现说完了keep-alive组件的使用，我们从源码角度看一下keep-alive组件究竟是如何实现组件的缓存的呢？ created与destroyed钩子created钩子会创建一个cache对象，用来作为缓存容器，保存vnode节点。 created () { /* 缓存对象 */ this.cache = Object.create(null) }, destroyed钩子则在组件被销毁的时候清除cache缓存中的所有组件实例。 /* destroyed钩子中销毁所有cache中的组件实例 */ destroyed () { for (const key in this.cache) { pruneCacheEntry(this.cache[key]) } }, render接下来是render函数。 render () { /* 得到slot插槽中的第一个组件 */ const vnode: VNode = getFirstComponentChild(this.$slots.default) const componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions if (componentOptions) { // check pattern /* 获取组件名称，优先获取组件的name字段，否则是组件的tag */ const name: ?string = getComponentName(componentOptions) /* name不在inlcude中或者在exlude中则直接返回vnode（没有取缓存） */ if (name &amp;&amp; ( (this.include &amp;&amp; !matches(this.include, name)) || (this.exclude &amp;&amp; matches(this.exclude, name)) )) { return vnode } const key: ?string = vnode.key == null // same constructor may get registered as different local components // so cid alone is not enough (#3269) ? componentOptions.Ctor.cid + (componentOptions.tag ? `::${componentOptions.tag}` : &#39;&#39;) : vnode.key /* 如果已经做过缓存了则直接从缓存中获取组件实例给vnode，还未缓存过则进行缓存 */ if (this.cache[key]) { vnode.componentInstance = this.cache[key].componentInstance } else { this.cache[key] = vnode } /* keepAlive标记位 */ vnode.data.keepAlive = true } return vnode } 首先通过getFirstComponentChild获取第一个子组件，获取该组件的name（存在组件名则直接使用组件名，否则会使用tag）。接下来会将这个name通过include与exclude属性进行匹配，匹配不成功（说明不需要进行缓存）则不进行任何操作直接返回vnode，vnode是一个VNode类型的对象，不了解VNode的同学可以参考笔者的另一篇文章《VNode节点》 . /* 检测name是否匹配 */ function matches (pattern: string | RegExp, name: string): boolean { if (typeof pattern === &#39;string&#39;) { /* 字符串情况，如a,b,c */ return pattern.split(&#39;,&#39;).indexOf(name) &gt; -1 } else if (isRegExp(pattern)) { /* 正则 */ return pattern.test(name) } /* istanbul ignore next */ return false } 检测include与exclude属性匹配的函数很简单，include与exclude属性支持字符串如”a,b,c”这样组件名以逗号隔开的情况以及正则表达式。matches通过这两种方式分别检测是否匹配当前组件。 if (this.cache[key]) { vnode.componentInstance = this.cache[key].componentInstance } else { this.cache[key] = vnode } 接下来的事情很简单，根据key在this.cache中查找，如果存在则说明之前已经缓存过了，直接将缓存的vnode的componentInstance（组件实例）覆盖到目前的vnode上面。否则将vnode存储在cache中。 最后返回vnode（有缓存时该vnode的componentInstance已经被替换成缓存中的了）。 watch用watch来监听pruneCache与pruneCache这两个属性的改变，在改变的时候修改cache缓存中的缓存数据。 watch: { /* 监视include以及exclude，在被修改的时候对cache进行修正 */ include (val: string | RegExp) { pruneCache(this.cache, this._vnode, name =&gt; matches(val, name)) }, exclude (val: string | RegExp) { pruneCache(this.cache, this._vnode, name =&gt; !matches(val, name)) } }, 来看一下pruneCache的实现。 /* 修正cache */ function pruneCache (cache: VNodeCache, current: VNode, filter: Function) { for (const key in cache) { /* 取出cache中的vnode */ const cachedNode: ?VNode = cache[key] if (cachedNode) { const name: ?string = getComponentName(cachedNode.componentOptions) /* name不符合filter条件的，同时不是目前渲染的vnode时，销毁vnode对应的组件实例（Vue实例），并从cache中移除 */ if (name &amp;&amp; !filter(name)) { if (cachedNode !== current) { pruneCacheEntry(cachedNode) } cache[key] = null } } } } /* 销毁vnode对应的组件实例（Vue实例） */ function pruneCacheEntry (vnode: ?VNode) { if (vnode) { vnode.componentInstance.$destroy() } } 遍历cache中的所有项，如果不符合filter指定的规则的话，则会执行pruneCacheEntry。pruneCacheEntry则会调用组件实例的$destroy方法来将组件销毁。 最后Vue.js内部将DOM节点抽象成了一个个的VNode节点，keep-alive组件的缓存也是基于VNode节点的而不是直接存储DOM结构。它将满足条件（pruneCache与pruneCache）的组件在cache对象中缓存起来，在需要重新渲染的时候再将vnode节点从cache对象中取出并渲染。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vuex源码解析]]></title>
    <url>%2F2019%2F01%2F06%2FVue%2FVuex%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言我们在使用Vue.js开发复杂的应用时，经常会遇到多个组件共享同一个状态，亦或是多个组件会去更新同一个状态，在应用代码量较少的时候，我们可以组件间通信去维护修改数据，或者是通过事件总线来进行数据的传递以及修改。但是当应用逐渐庞大以后，代码就会变得难以维护，从父组件开始通过prop传递多层嵌套的数据由于层级过深而显得异常脆弱，而事件总线也会因为组件的增多、代码量的增大而显得交互错综复杂，难以捋清其中的传递关系。 那么为什么我们不能将数据层与组件层抽离开来呢？把数据层放到全局形成一个单一的Store，组件层变得更薄，专门用来进行数据的展示及操作。所有数据的变更都需要经过全局的Store来进行，形成一个单向数据流，使数据变化变得“可预测”。 Vuex是一个专门为Vue.js框架设计的、用于对Vue.js应用程序进行状态管理的库，它借鉴了Flux、redux的基本思想，将共享的数据抽离到全局，以一个单例存放，同时利用Vue.js的响应式机制来进行高效的状态管理与更新。正是因为Vuex使用了Vue.js内部的“响应式机制”，所以Vuex是一个专门为Vue.js设计并与之高度契合的框架（优点是更加简洁高效，缺点是只能跟Vue.js搭配使用）。具体使用方法及API可以参考Vuex的官网。 Vuex实现了一个单向数据流，在全局拥有一个State存放数据，所有修改State的操作必须通过Mutation进行，Mutation的同时提供了订阅者模式供外部插件调用获取State数据的更新。所有异步接口需要走Action，常见于调用后端接口异步获取更新数据，而Action也是无法直接修改State的，还是需要通过Mutation来修改State的数据。最后，根据State的变化，渲染到视图上。Vuex运行依赖Vue内部数据双向绑定机制，需要new一个Vue对象来实现“响应式化”，所以Vuex是一个专门为Vue.js设计的状态管理库。 安装使用过Vuex的朋友一定知道，Vuex的安装十分简单，只需要提供一个store，然后执行下面两句代码即完成的Vuex的引入。 Vue.use(Vuex); /*将store放入Vue创建时的option中*/ new Vue({ el: &#39;#app&#39;, store }); 那么问题来了，Vuex是怎样把store注入到Vue实例中去的呢？ Vue.js提供了Vue.use方法用来给Vue.js安装插件，内部通过调用插件的install方法(当插件是一个对象的时候)来进行插件的安装。 我们来看一下Vuex的install实现。 /*暴露给外部的插件install方法，供Vue.use调用安装插件*/ export function install (_Vue) { if (Vue) { /*避免重复安装（Vue.use内部也会检测一次是否重复安装同一个插件）*/ if (process.env.NODE_ENV !== &#39;production&#39;) { console.error( &#39;[vuex] already installed. Vue.use(Vuex) should be called only once.&#39; ) } return } /*保存Vue，同时用于检测是否重复安装*/ Vue = _Vue /*将vuexInit混淆进Vue的beforeCreate(Vue2.0)或_init方法(Vue1.0)*/ applyMixin(Vue) } 这段install代码做了两件事情，一件是防止Vuex被重复安装，另一件是执行applyMixin，目的是执行vuexInit方法初始化Vuex。Vuex针对Vue1.0与2.0分别进行了不同的处理，如果是Vue1.0，Vuex会将vuexInit方法放入Vue的_init方法中，而对于Vue2.0，则会将vuexinit混淆进Vue的beforeCreacte钩子中。来看一下vuexInit的代码。 /*Vuex的init钩子，会存入每一个Vue实例等钩子列表*/ function vuexInit () { const options = this.$options // store injection if (options.store) { /*存在store其实代表的就是Root节点，直接执行store（function时）或者使用store（非function）*/ this.$store = typeof options.store === &#39;function&#39; ? options.store() : options.store } else if (options.parent &amp;&amp; options.parent.$store) { /*子组件直接从父组件中获取$store，这样就保证了所有组件都公用了全局的同一份store*/ this.$store = options.parent.$store } } vuexInit会尝试从options中获取store，如果当前组件是根组件（Root节点），则options中会存在store，直接获取赋值给$store即可。如果当前组件非根组件，则通过options中的parent获取父组件的$store引用。这样一来，所有的组件都获取到了同一份内存地址的Store实例，于是我们可以在每一个组件中通过this.$store愉快地访问全局的Store实例了。 那么，什么是Store实例？ Store我们传入到根组件到store，就是Store实例，用Vuex提供到Store方法构造。 export default new Vuex.Store({ strict: true, modules: { moduleA, moduleB } }); 我们来看一下Store的实现。首先是构造函数。 constructor (options = {}) { // Auto install if it is not done yet and `window` has `Vue`. // To allow users to avoid auto-installation in some cases, // this code should be placed here. See #731 /* 在浏览器环境下，如果插件还未安装（!Vue即判断是否未安装），则它会自动安装。 它允许用户在某些情况下避免自动安装。 */ if (!Vue &amp;&amp; typeof window !== &#39;undefined&#39; &amp;&amp; window.Vue) { install(window.Vue) } if (process.env.NODE_ENV !== &#39;production&#39;) { assert(Vue, `must call Vue.use(Vuex) before creating a store instance.`) assert(typeof Promise !== &#39;undefined&#39;, `vuex requires a Promise polyfill in this browser.`) assert(this instanceof Store, `Store must be called with the new operator.`) } const { /*一个数组，包含应用在 store 上的插件方法。这些插件直接接收 store 作为唯一参数，可以监听 mutation（用于外部地数据持久化、记录或调试）或者提交 mutation （用于内部数据，例如 websocket 或 某些观察者）*/ plugins = [], /*使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误。*/ strict = false } = options /*从option中取出state，如果state是function则执行，最终得到一个对象*/ let { state = {} } = options if (typeof state === &#39;function&#39;) { state = state() } // store internal state /* 用来判断严格模式下是否是用mutation修改state的 */ this._committing = false /* 存放action */ this._actions = Object.create(null) /* 存放mutation */ this._mutations = Object.create(null) /* 存放getter */ this._wrappedGetters = Object.create(null) /* module收集器 */ this._modules = new ModuleCollection(options) /* 根据namespace存放module */ this._modulesNamespaceMap = Object.create(null) /* 存放订阅者 */ this._subscribers = [] /* 用以实现Watch的Vue实例 */ this._watcherVM = new Vue() // bind commit and dispatch to self /*将dispatch与commit调用的this绑定为store对象本身，否则在组件内部this.dispatch时的this会指向组件的vm*/ const store = this const { dispatch, commit } = this /* 为dispatch与commit绑定this（Store实例本身） */ this.dispatch = function boundDispatch (type, payload) { return dispatch.call(store, type, payload) } this.commit = function boundCommit (type, payload, options) { return commit.call(store, type, payload, options) } // strict mode /*严格模式(使 Vuex store 进入严格模式，在严格模式下，任何 mutation 处理函数以外修改 Vuex state 都会抛出错误)*/ this.strict = strict // init root module. // this also recursively registers all sub-modules // and collects all module getters inside this._wrappedGetters /*初始化根module，这也同时递归注册了所有子modle，收集所有module的getter到_wrappedGetters中去，this._modules.root代表根module才独有保存的Module对象*/ installModule(this, state, [], this._modules.root) // initialize the store vm, which is responsible for the reactivity // (also registers _wrappedGetters as computed properties) /* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */ resetStoreVM(this, state) // apply plugins /* 调用插件 */ plugins.forEach(plugin =&gt; plugin(this)) /* devtool插件 */ if (Vue.config.devtools) { devtoolPlugin(this) } } Store的构造类除了初始化一些内部变量以外，主要执行了installModule（初始化module）以及resetStoreVM（通过VM使store“响应式”）。 installModuleinstallModule的作用主要是用为module加上namespace名字空间（如果有）后，注册mutation、action以及getter，同时递归安装所有子module。 /*初始化module*/ function installModule (store, rootState, path, module, hot) { /* 是否是根module */ const isRoot = !path.length /* 获取module的namespace */ const namespace = store._modules.getNamespace(path) // register in namespace map /* 如果有namespace则在_modulesNamespaceMap中注册 */ if (module.namespaced) { store._modulesNamespaceMap[namespace] = module } // set state if (!isRoot &amp;&amp; !hot) { /* 获取父级的state */ const parentState = getNestedState(rootState, path.slice(0, -1)) /* module的name */ const moduleName = path[path.length - 1] store.`_withCommit`(() =&gt; { /* 将子module设置称响应式的 */ Vue.set(parentState, moduleName, module.state) }) } const local = module.context = makeLocalContext(store, namespace, path) /* 遍历注册mutation */ module.forEachMutation((mutation, key) =&gt; { const namespacedType = namespace + key registerMutation(store, namespacedType, mutation, local) }) /* 遍历注册action */ module.forEachAction((action, key) =&gt; { const namespacedType = namespace + key registerAction(store, namespacedType, action, local) }) /* 遍历注册getter */ module.forEachGetter((getter, key) =&gt; { const namespacedType = namespace + key registerGetter(store, namespacedType, getter, local) }) /* 递归安装mudule */ module.forEachChild((child, key) =&gt; { installModule(store, rootState, path.concat(key), child, hot) }) } resetStoreVM在说resetStoreVM之前，先来看一个小demo。 let globalData = { d: &#39;hello world&#39; }; new Vue({ data () { return { $$state: { globalData } } } }); /* modify */ setTimeout(() =&gt; { globalData.d = &#39;hi~&#39;; }, 1000); Vue.prototype.globalData = globalData; /* 任意模板中 */ &lt;div&gt;{{globalData.d}}&lt;/div&gt; 上述代码在全局有一个globalData，它被传入一个Vue对象的data中，之后在任意Vue模板中对该变量进行展示，因为此时globalData已经在Vue的prototype上了所以直接通过this.prototype访问，也就是在模板中的。此时，setTimeout在1s之后将globalData.d进行修改，我们发现模板中的globalData.d发生了变化。其实上述部分就是Vuex依赖Vue核心实现数据的“响应式化”。 接着来看代码。 /* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */ function resetStoreVM (store, state, hot) { /* 存放之前的vm对象 */ const oldVm = store._vm // bind store public getters store.getters = {} const wrappedGetters = store._wrappedGetters const computed = {} /* 通过Object.defineProperty为每一个getter方法设置get方法，比如获取this.$store.getters.test的时候获取的是store._vm.test，也就是Vue对象的computed属性 */ forEachValue(wrappedGetters, (fn, key) =&gt; { // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, { get: () =&gt; store._vm[key], enumerable: true // for local getters }) }) // use a Vue instance to store the state tree // suppress warnings just in case the user has added // some funky global mixins const silent = Vue.config.silent /* Vue.config.silent暂时设置为true的目的是在new一个Vue实例的过程中不会报出一切警告 */ Vue.config.silent = true /* 这里new了一个Vue对象，运用Vue内部的响应式实现注册state以及computed*/ store._vm = new Vue({ data: { $$state: state }, computed }) Vue.config.silent = silent // enable strict mode for new vm /* 使能严格模式，保证修改store只能通过mutation */ if (store.strict) { enableStrictMode(store) } if (oldVm) { /* 解除旧vm的state的引用，以及销毁旧的Vue对象 */ if (hot) { // dispatch changes in all subscribed watchers // to force getter re-evaluation for hot reloading. store._withCommit(() =&gt; { oldVm._data.$$state = null }) } Vue.nextTick(() =&gt; oldVm.$destroy()) } } resetStoreVM首先会遍历wrappedGetters，使用Object.defineProperty方法为每一个getter绑定上get方法，这样我们就可以在组件里访问this.$store.getter.test就等同于访问store._vm.test。 forEachValue(wrappedGetters, (fn, key) =&gt; { // use computed to leverage its lazy-caching mechanism computed[key] = () =&gt; fn(store) Object.defineProperty(store.getters, key, { get: () =&gt; store._vm[key], enumerable: true // for local getters }) }) 之后Vuex采用了new一个Vue对象来实现数据的“响应式化”，运用Vue.js内部提供的数据双向绑定功能来实现store的数据与视图的同步更新。 store._vm = new Vue({ data: { $$state: state }, computed }) 这时候我们访问store._vm.test也就访问了Vue实例中的属性。 这两步执行完以后，我们就可以通过this.$store.getter.test访问vm中的test属性了。 严格模式Vuex的Store构造类的option有一个strict的参数，可以控制Vuex执行严格模式，严格模式下，所有修改state的操作必须通过mutation实现，否则会抛出错误。 /* 使能严格模式 */ function enableStrictMode (store) { store._vm.$watch(function () { return this._data.$$state }, () =&gt; { if (process.env.NODE_ENV !== &#39;production&#39;) { /* 检测store中的_committing的值，如果是true代表不是通过mutation的方法修改的 */ assert(store._committing, `Do not mutate vuex store state outside mutation handlers.`) } }, { deep: true, sync: true }) } 首先，在严格模式下，Vuex会利用vm的$watch方法来观察$$state，也就是Store的state，在它被修改的时候进入回调。我们发现，回调中只有一句话，用assert断言来检测store._committing，当store._committing为false的时候会触发断言，抛出异常。 我们发现，Store的commit方法中，执行mutation的语句是这样的。 this._withCommit(() =&gt; { entry.forEach(function commitIterator (handler) { handler(payload) }) }) 再来看看_withCommit的实现。 _withCommit (fn) { /* 调用withCommit修改state的值时会将store的committing值置为true，内部会有断言检查该值，在严格模式下只允许使用mutation来修改store中的值，而不允许直接修改store的数值 */ const committing = this._committing this._committing = true fn() this._committing = committing } 我们发现，通过commit（mutation）修改state数据的时候，会再调用mutation方法之前将committing置为true，接下来再通过mutation函数修改state中的数据，这时候触发$watch中的回调断言committing是不会抛出异常的（此时committing为true）。而当我们直接修改state的数据时，触发$watch的回调执行断言，这时committing为false，则会抛出异常。这就是Vuex的严格模式的实现。 接下来我们来看看Store提供的一些API。 commit（mutation）/* 调用mutation的commit方法 */ commit (_type, _payload, _options) { // check object-style commit /* 校验参数 */ const { type, payload, options } = unifyObjectStyle(_type, _payload, _options) const mutation = { type, payload } /* 取出type对应的mutation的方法 */ const entry = this._mutations[type] if (!entry) { if (process.env.NODE_ENV !== &#39;production&#39;) { console.error(`[vuex] unknown mutation type: ${type}`) } return } /* 执行mutation中的所有方法 */ this._withCommit(() =&gt; { entry.forEach(function commitIterator (handler) { handler(payload) }) }) /* 通知所有订阅者 */ this._subscribers.forEach(sub =&gt; sub(mutation, this.state)) if ( process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; options &amp;&amp; options.silent ) { console.warn( `[vuex] mutation type: ${type}. Silent option has been removed. ` + &#39;Use the filter functionality in the vue-devtools&#39; ) } } commit方法会根据type找到并调用_mutations中的所有type对应的mutation方法，所以当没有namespace的时候，commit方法会触发所有module中的mutation方法。再执行完所有的mutation之后会执行_subscribers中的所有订阅者。我们来看一下_subscribers是什么。 Store给外部提供了一个subscribe方法，用以注册一个订阅函数，会push到Store实例的_subscribers中，同时返回一个从_subscribers中注销该订阅者的方法。 /* 注册一个订阅函数，返回取消订阅的函数 */ subscribe (fn) { const subs = this._subscribers if (subs.indexOf(fn) &lt; 0) { subs.push(fn) } return () =&gt; { const i = subs.indexOf(fn) if (i &gt; -1) { subs.splice(i, 1) } } } 在commit结束以后则会调用这些_subscribers中的订阅者，这个订阅者模式提供给外部一个监视state变化的可能。state通过mutation改变时，可以有效补获这些变化。 dispatch（action）来看一下dispatch的实现。 /* 调用action的dispatch方法 */ dispatch (_type, _payload) { // check object-style dispatch const { type, payload } = unifyObjectStyle(_type, _payload) /* actions中取出type对应的ation */ const entry = this._actions[type] if (!entry) { if (process.env.NODE_ENV !== &#39;production&#39;) { console.error(`[vuex] unknown action type: ${type}`) } return } /* 是数组则包装Promise形成一个新的Promise，只有一个则直接返回第0个 */ return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload) } 以及registerAction时候做的事情。 /* 遍历注册action */ function registerAction (store, type, handler, local) { /* 取出type对应的action */ const entry = store._actions[type] || (store._actions[type] = []) entry.push(function wrappedActionHandler (payload, cb) { let res = handler.call(store, { dispatch: local.dispatch, commit: local.commit, getters: local.getters, state: local.state, rootGetters: store.getters, rootState: store.state }, payload, cb) /* 判断是否是Promise */ if (!isPromise(res)) { /* 不是Promise对象的时候转化称Promise对象 */ res = Promise.resolve(res) } if (store._devtoolHook) { /* 存在devtool插件的时候触发vuex的error给devtool */ return res.catch(err =&gt; { store._devtoolHook.emit(&#39;vuex:error&#39;, err) throw err }) } else { return res } }) } 因为registerAction的时候将push进_actions的action进行了一层封装（wrappedActionHandler），所以我们在进行dispatch的第一个参数中获取state、commit等方法。之后，执行结果res会被进行判断是否是Promise，不是则会进行一层封装，将其转化成Promise对象。dispatch时则从_actions中取出，只有一个的时候直接返回，否则用Promise.all处理再返回。 watch/* 观察一个getter方法 */ watch (getter, cb, options) { if (process.env.NODE_ENV !== &#39;production&#39;) { assert(typeof getter === &#39;function&#39;, `store.watch only accepts a function.`) } return this._watcherVM.$watch(() =&gt; getter(this.state, this.getters), cb, options) } 熟悉Vue的朋友应该很熟悉watch这个方法。这里采用了比较巧妙的设计，_watcherVM是一个Vue的实例，所以watch就可以直接采用了Vue内部的watch特性提供了一种观察数据getter变动的方法。 registerModule/* 注册一个动态module，当业务进行异步加载的时候，可以通过该接口进行注册动态module */ registerModule (path, rawModule) { /* 转化称Array */ if (typeof path === &#39;string&#39;) path = [path] if (process.env.NODE_ENV !== &#39;production&#39;) { assert(Array.isArray(path), `module path must be a string or an Array.`) assert(path.length &gt; 0, &#39;cannot register the root module by using registerModule.&#39;) } /*注册*/ this._modules.register(path, rawModule) /*初始化module*/ installModule(this, this.state, path, this._modules.get(path)) // reset store to update getters... /* 通过vm重设store，新建Vue对象使用Vue内部的响应式实现注册state以及computed */ resetStoreVM(this, this.state) } registerModule用以注册一个动态模块，也就是在store创建以后再注册模块的时候用该接口。内部实现实际上也只有installModule与resetStoreVM两个步骤，前面已经讲过，这里不再累述。 unregisterModule /* 注销一个动态module */ unregisterModule (path) { /* 转化称Array */ if (typeof path === &#39;string&#39;) path = [path] if (process.env.NODE_ENV !== &#39;production&#39;) { assert(Array.isArray(path), `module path must be a string or an Array.`) } /*注销*/ this._modules.unregister(path) this._withCommit(() =&gt; { /* 获取父级的state */ const parentState = getNestedState(this.state, path.slice(0, -1)) /* 从父级中删除 */ Vue.delete(parentState, path[path.length - 1]) }) /* 重制store */ resetStore(this) } 同样，与registerModule对应的方法unregisterModule，动态注销模块。实现方法是先从state中删除模块，然后用resetStore来重制store。 resetStore/* 重制store */ function resetStore (store, hot) { store._actions = Object.create(null) store._mutations = Object.create(null) store._wrappedGetters = Object.create(null) store._modulesNamespaceMap = Object.create(null) const state = store.state // init all modules installModule(store, state, [], store._modules.root, true) // reset vm resetStoreVM(store, state, hot) } 这里的resetStore其实也就是将store中的_actions等进行初始化以后，重新执行installModule与resetStoreVM来初始化module以及用Vue特性使其“响应式化”，这跟构造函数中的是一致的。 插件Vue提供了一个非常好用的插件Vue.js devtools /* 从window对象的__VUE_DEVTOOLS_GLOBAL_HOOK__中获取devtool插件 */ const devtoolHook = typeof window !== &#39;undefined&#39; &amp;&amp; window.__VUE_DEVTOOLS_GLOBAL_HOOK__ export default function devtoolPlugin (store) { if (!devtoolHook) return /* devtoll插件实例存储在store的_devtoolHook上 */ store._devtoolHook = devtoolHook /* 出发vuex的初始化事件，并将store的引用地址传给deltool插件，使插件获取store的实例 */ devtoolHook.emit(&#39;vuex:init&#39;, store) /* 监听travel-to-state事件 */ devtoolHook.on(&#39;vuex:travel-to-state&#39;, targetState =&gt; { /* 重制state */ store.replaceState(targetState) }) /* 订阅store的变化 */ store.subscribe((mutation, state) =&gt; { devtoolHook.emit(&#39;vuex:mutation&#39;, mutation, state) }) } 如果已经安装了该插件，则会在windows对象上暴露一个VUE_DEVTOOLS_GLOBAL_HOOK。devtoolHook用在初始化的时候会触发“vuex:init”事件通知插件，然后通过on方法监听“vuex:travel-to-state”事件来重置state。最后通过Store的subscribe方法来添加一个订阅者，在触发commit方法修改mutation数据以后，该订阅者会被通知，从而触发“vuex:mutation”事件。 最后Vuex是一个非常优秀的库，代码量不多且结构清晰，非常适合研究学习其内部实现。最近的一系列源码阅读也使我自己受益匪浅，写这篇文章也希望可以帮助到更多想要学习探索Vuex内部实现原理的同学。 原文地址]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vuex</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js异步更新DOM策略及nextTick]]></title>
    <url>%2F2019%2F01%2F01%2FVue%2FVue-js%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0DOM%E7%AD%96%E7%95%A5%E5%8F%8AnextTick%2F</url>
    <content type="text"><![CDATA[操作DOM在使用vue.js的时候，有时候因为一些特定的业务场景，不得不去操作DOM，比如这样： &lt;template&gt; &lt;div&gt; &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { test: &#39;begin&#39; }; }, methods () { handleClick () { this.test = &#39;end&#39;; console.log(this.$refs.test.innerText);//打印“begin” } } } 打印的结果是begin，为什么我们明明已经将test设置成了“end”，获取真实DOM节点的innerText却没有得到我们预期中的“end”，而是得到之前的值“begin”呢？ Watcher队列带着疑问，我们找到了Vue.js源码的Watch实现。当某个响应式数据发生变化的时候，它的setter函数会通知闭包中的Dep，Dep则会调用它管理的所有Watch对象。触发Watch对象的update实现。我们来看一下update的实现。 update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { /*同步则执行run直接渲染视图*/ this.run() } else { /*异步推送到观察者队列中，下一个tick时调用。*/ queueWatcher(this) } } 我们发现Vue.js默认是使用异步执行DOM更新。 当异步执行update的时候，会调用queueWatcher函数。 //将一个观察者对象push进观察者队列，在队列中已经存在相同的id则该观察者对象将被跳过，除非它是在队列被刷新时推送*/ export function queueWatcher (watcher: Watcher) { /*获取watcher的id*/ const id = watcher.id /*检验id是否存在，已经存在则直接跳过，不存在则标记哈希表has，用于下次检验*/ if (has[id] == null) { has[id] = true if (!flushing) { /*如果没有flush掉，直接push到队列中即可*/ queue.push(watcher) } else { // if already flushing, splice the watcher based on its id // if already past its id, it will be run next immediately. let i = queue.length - 1 while (i &gt;= 0 &amp;&amp; queue[i].id &gt; watcher.id) { i-- } queue.splice(Math.max(i, index) + 1, 0, watcher) } // queue the flush if (!waiting) { waiting = true nextTick(flushSchedulerQueue) } } } 查看queueWatcher的源码我们发现，Watch对象并不是立即更新视图，而是被push进了一个队列queue，此时状态处于waiting的状态，这时候会继续会有Watch对象被push进这个队列queue，等到下一个tick运行时，这些Watch对象才会被遍历取出，更新视图。同时，id重复的Watcher不会被多次加入到queue中去，因为在最终渲染时，我们只需要关心数据的最终结果。 那么，什么是下一个tick？ nextTickvue.js提供了一个nextTick函数，其实也就是上面调用的nextTick。 nextTick的实现比较简单，执行的目的是在microtask或者task中推入一个funtion，在当前栈执行完毕（也行还会有一些排在前面的需要执行的任务）以后执行nextTick传入的funtion，看一下源码 /** * Defer a task to execute it asynchronously. */ /* 延迟一个任务使其异步执行，在下一个tick时执行，一个立即执行函数，返回一个function 这个函数的作用是在task或者microtask中推入一个timerFunc，在当前调用栈执行完以后以此执行直到执行到timerFunc 目的是延迟到当前调用栈执行完以后执行 */ export const nextTick = (function () { /*存放异步执行的回调*/ const callbacks = [] /*一个标记位，如果已经有timerFunc被推送到任务队列中去则不需要重复推送*/ let pending = false /*一个函数指针，指向函数将被推送到任务队列中，等到主线程任务执行完时，任务队列中的timerFunc被调用*/ let timerFunc /*下一个tick时的回调*/ function nextTickHandler () { /*一个标记位，标记等待状态（即函数已经被推入任务队列或者主线程，已经在等待当前栈执行完毕去执行），这样就不需要在push多个回调到callbacks时将timerFunc多次推入任务队列或者主线程*/ pending = false /*执行所有callback*/ const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { copies[i]() } } // the nextTick behavior leverages the microtask queue, which can be accessed // via either native Promise.then or MutationObserver. // MutationObserver has wider support, however it is seriously bugged in // UIWebView in iOS &gt;= 9.3.3 when triggered in touch event handlers. It // completely stops working after triggering a few times... so, if native // Promise is available, we will use it: /* istanbul ignore if */ /* 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法都会在microtask中执行，会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 参考：https://www.zhihu.com/question/55364497 */ if (typeof Promise !== &#39;undefined&#39; &amp;&amp; isNative(Promise)) { /*使用Promise*/ var p = Promise.resolve() var logError = err =&gt; { console.error(err) } timerFunc = () =&gt; { p.then(nextTickHandler).catch(logError) // in problematic UIWebViews, Promise.then doesn&#39;t completely break, but // it can get stuck in a weird state where callbacks are pushed into the // microtask queue but the queue isn&#39;t being flushed, until the browser // needs to do some other work, e.g. handle a timer. Therefore we can // &quot;force&quot; the microtask queue to be flushed by adding an empty timer. if (isIOS) setTimeout(noop) } } else if (typeof MutationObserver !== &#39;undefined&#39; &amp;&amp; ( isNative(MutationObserver) || // PhantomJS and iOS 7.x MutationObserver.toString() === &#39;[object MutationObserverConstructor]&#39; )) { // use MutationObserver where native Promise is not available, // e.g. PhantomJS IE11, iOS7, Android 4.4 /*新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入主线程（比任务队列优先执行），即textNode.data = String(counter)时便会触发回调*/ var counter = 1 var observer = new MutationObserver(nextTickHandler) var textNode = document.createTextNode(String(counter)) observer.observe(textNode, { characterData: true }) timerFunc = () =&gt; { counter = (counter + 1) % 2 textNode.data = String(counter) } } else { // fallback to setTimeout /* istanbul ignore next */ /*使用setTimeout将回调推入任务队列尾部*/ timerFunc = () =&gt; { setTimeout(nextTickHandler, 0) } } /* 推送到队列中下一个tick时执行 cb 回调函数 ctx 上下文 */ return function queueNextTick (cb?: Function, ctx?: Object) { let _resolve /*cb存到callbacks中*/ callbacks.push(() =&gt; { if (cb) { try { cb.call(ctx) } catch (e) { handleError(e, ctx, &#39;nextTick&#39;) } } else if (_resolve) { _resolve(ctx) } }) if (!pending) { pending = true timerFunc() } if (!cb &amp;&amp; typeof Promise !== &#39;undefined&#39;) { return new Promise((resolve, reject) =&gt; { _resolve = resolve }) } } })() 它是一个立即执行函数,返回一个queueNextTick接口。 传入的cb会被push进callbacks中存放起来，然后执行timerFunc（pending是一个状态标记，保证timerFunc在下一个tick之前只执行一次）。 timerFunc是什么？ 看了源码发现timerFunc会检测当前环境而不同实现，其实就是按照Promise，MutationObserver，setTimeout优先级，哪个存在使用哪个，最不济的环境下使用setTimeout。 这里解释一下，一共有Promise、MutationObserver以及setTimeout三种尝试得到timerFunc的方法。 优先使用Promise，在Promise不存在的情况下使用MutationObserver，这两个方法的回调函数都会在microtask中执行，它们会比setTimeout更早执行，所以优先使用。 如果上述两种方法都不支持的环境则会使用setTimeout，在task尾部推入这个函数，等待调用执行。 为什么要优先使用microtask？我在顾轶灵在知乎的回答中学习到： JS 的 event loop 执行时会区分 task 和 microtask，引擎在每个 task 执行完毕，从队列中取下一个 task 来执行之前，会先执行完所有 microtask 队列中的 microtask。setTimeout 回调会被分配到一个新的 task 中执行，而 Promise 的 resolver、MutationObserver 的回调都会被安排到一个新的 microtask 中执行，会比 setTimeout 产生的 task 先执行。要创建一个新的 microtask，优先使用 Promise，如果浏览器不支持，再尝试 MutationObserver。实在不行，只能用 setTimeout 创建 task 了。为啥要用 microtask？根据 HTML Standard，在每个 task 运行完以后，UI 都会重渲染，那么在 microtask 中就完成数据更新，当前 task 结束就可以得到最新的 UI 了。反之如果新建一个 task 来做数据更新，那么渲染就会进行两次。参考顾轶灵知乎的回答：[https://www.zhihu.com/question/55364497/answer/144215284] 首先是Promise，(Promise.resolve()).then()可以在microtask中加入它的回调， MutationObserver新建一个textNode的DOM对象，用MutationObserver绑定该DOM并指定回调函数，在DOM变化的时候则会触发回调,该回调会进入microtask，即textNode.data = String(counter)时便会加入该回调。 setTimeout是最后的一种备选方案，它会将回调函数加入task中，等到执行。 综上，nextTick的目的就是产生一个回调函数加入task或者microtask中，当前栈执行完以后（可能中间还有别的排在前面的函数）调用该回调函数，起到了异步触发（即下一个tick时触发）的目的。 flushSchedulerQueue/*Github:https://github.com/answershuto*/ /** * Flush both queues and run the watchers. */ /*nextTick的回调函数，在下一个tick时flush掉两个队列同时运行watchers*/ function flushSchedulerQueue () { flushing = true let watcher, id // Sort queue before flush. // This ensures that: // 1. Components are updated from parent to child. (because parent is always // created before the child) // 2. A component&#39;s user watchers are run before its render watcher (because // user watchers are created before the render watcher) // 3. If a component is destroyed during a parent component&#39;s watcher run, // its watchers can be skipped. /* 给queue排序，这样做可以保证： 1.组件更新的顺序是从父组件到子组件的顺序，因为父组件总是比子组件先创建。 2.一个组件的user watchers比render watcher先运行，因为user watchers往往比render watcher更早创建 3.如果一个组件在父组件watcher运行期间被销毁，它的watcher执行将被跳过。 */ queue.sort((a, b) =&gt; a.id - b.id) // do not cache length because more watchers might be pushed // as we run existing watchers /*这里不用index = queue.length;index &gt; 0; index--的方式写是因为不要将length进行缓存，因为在执行处理现有watcher对象期间，更多的watcher对象可能会被push进queue*/ for (index = 0; index &lt; queue.length; index++) { watcher = queue[index] id = watcher.id /*将has的标记删除*/ has[id] = null /*执行watcher*/ watcher.run() // in dev build, check and stop circular updates. /* 在测试环境中，检测watch是否在死循环中 比如这样一种情况 watch: { test () { this.test++; } } 持续执行了一百次watch代表可能存在死循环 */ if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; has[id] != null) { circular[id] = (circular[id] || 0) + 1 if (circular[id] &gt; MAX_UPDATE_COUNT) { warn( &#39;You may have an infinite update loop &#39; + ( watcher.user ? `in watcher with expression &quot;${watcher.expression}&quot;` : `in a component render function.` ), watcher.vm ) break } } } // keep copies of post queues before resetting state /**/ /*得到队列的拷贝*/ const activatedQueue = activatedChildren.slice() const updatedQueue = queue.slice() /*重置调度者的状态*/ resetSchedulerState() // call component updated and activated hooks /*使子组件状态都改编成active同时调用activated钩子*/ callActivatedHooks(activatedQueue) /*调用updated钩子*/ callUpdateHooks(updatedQueue) // devtool hook /* istanbul ignore if */ if (devtools &amp;&amp; config.devtools) { devtools.emit(&#39;flush&#39;) } } flushSchedulerQueue是下一个tick时的回调函数，主要目的是执行Watcher的run函数，用来更新视图 为什么要异步更新视图来看一下下面这一段代码 &lt;template&gt; &lt;div&gt; &lt;div&gt;{{test}}&lt;/div&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { test: 0 }; }, mounted () { for(let i = 0; i &lt; 1000; i++) { this.test++; } } } 现在有这样的一种情况，mounted的时候test的值会被++循环执行1000次。 每次++时，都会根据响应式触发setter-&gt;Dep-&gt;Watcher-&gt;update-&gt;patch。 如果这时候没有异步更新视图，那么每次++都会直接操作DOM更新视图，这是非常消耗性能的。 所以Vue.js实现了一个queue队列，在下一个tick的时候会统一执行queue中Watcher的run。同时，拥有相同id的Watcher不会被重复加入到该queue中去，所以不会执行1000次Watcher的run。最终更新视图只会直接将test对应的DOM的0变成1000。 保证更新视图操作DOM的动作是在当前栈执行完以后下一个tick的时候调用，大大优化了性能。 访问真实DOM节点更新后的数据所以我们需要在修改data中的数据后访问真实的DOM节点更新后的数据，只需要这样，我们把文章第一个例子进行修改。 &lt;template&gt; &lt;div&gt; &lt;div ref=&quot;test&quot;&gt;{{test}}&lt;/div&gt; &lt;button @click=&quot;handleClick&quot;&gt;tet&lt;/button&gt; &lt;/div&gt; &lt;/template&gt; export default { data () { return { test: &#39;begin&#39; }; }, methods () { handleClick () { this.test = &#39;end&#39;; this.$nextTick(() =&gt; { console.log(this.$refs.test.innerText);//打印&quot;end&quot; }); console.log(this.$refs.test.innerText);//打印“begin” } } } 使用Vue.js的global API的$nextTick方法，即可在回调中获取已经更新好的DOM实例了。 原文地址]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue事件API]]></title>
    <url>%2F2018%2F12%2F16%2FVue%2FVue%E4%BA%8B%E4%BB%B6API%2F</url>
    <content type="text"><![CDATA[Vue事件API众所周知，Vue.js为我们提供了四个事件API，分别是$on，$once，$off，$emit。 初始化事件初始化事件在vm上创建一个_events对象，用来存放事件。_events的内容如下： { eventName: [func1, func2, func3] } 存放事件名以及对应执行方法。 /*初始化事件*/ export function initEvents (vm: Component) { /*在vm上创建一个_events对象，用来存放事件。*/ vm._events = Object.create(null) /*这个bool标志位来表明是否存在钩子，而不需要通过哈希表的方法来查找是否有钩子，这样做可以减少不必要的开销，优化性能。*/ vm._hasHookEvent = false // init parent attached events /*初始化父组件attach的事件*/ const listeners = vm.$options._parentListeners if (listeners) { updateComponentListeners(vm, listeners) } } $on$on方法用来在vm实例上监听一个自定义事件，该事件可用$emit触发。 Vue.prototype.$on = function (event: string | Array&lt;string&gt;, fn: Function): Component { const vm: Component = this /*如果是数组的时候，则递归$on，为每一个成员都绑定上方法*/ if (Array.isArray(event)) { for (let i = 0, l = event.length; i &lt; l; i++) { this.$on(event[i], fn) } } else { (vm._events[event] || (vm._events[event] = [])).push(fn) // optimize hook:event cost by using a boolean flag marked at registration // instead of a hash lookup /*这里在注册事件的时候标记bool值也就是个标志位来表明存在钩子，而不需要通过哈希表的方法来查找是否有钩子，这样做可以减少不必要的开销，优化性能。*/ if (hookRE.test(event)) { vm._hasHookEvent = true } } return vm } $once$once监听一个只能触发一次的事件，在触发以后会自动移除该事件。 Vue.prototype.$once = function (event: string, fn: Function): Component { const vm: Component = this function on () { /*在第一次执行的时候将该事件销毁*/ vm.$off(event, on) /*执行注册的方法*/ fn.apply(vm, arguments) } on.fn = fn vm.$on(event, on) return vm } $off$off用来移除自定义事件 Vue.prototype.$off = function (event?: string | Array&lt;string&gt;, fn?: Function): Component { const vm: Component = this // all /*如果不传参数则注销所有事件*/ if (!arguments.length) { vm._events = Object.create(null) return vm } // array of events /*如果event是数组则递归注销事件*/ if (Array.isArray(event)) { for (let i = 0, l = event.length; i &lt; l; i++) { this.$off(event[i], fn) } return vm } // specific event const cbs = vm._events[event] /*Github:https://github.com/answershuto*/ /*本身不存在该事件则直接返回*/ if (!cbs) { return vm } /*如果只传了event参数则注销该event方法下的所有方法*/ if (arguments.length === 1) { vm._events[event] = null return vm } // specific handler /*遍历寻找对应方法并删除*/ let cb let i = cbs.length while (i--) { cb = cbs[i] if (cb === fn || cb.fn === fn) { cbs.splice(i, 1) break } } return vm } $emit$emit用来触发指定的自定义事件。 Vue.prototype.$emit = function (event: string): Component { const vm: Component = this if (process.env.NODE_ENV !== &#39;production&#39;) { const lowerCaseEvent = event.toLowerCase() if (lowerCaseEvent !== event &amp;&amp; vm._events[lowerCaseEvent]) { tip( `Event &quot;${lowerCaseEvent}&quot; is emitted in component ` + `${formatComponentName(vm)} but the handler is registered for &quot;${event}&quot;. ` + `Note that HTML attributes are case-insensitive and you cannot use ` + `v-on to listen to camelCase events when using in-DOM templates. ` + `You should probably use &quot;${hyphenate(event)}&quot; instead of &quot;${event}&quot;.` ) } } let cbs = vm._events[event] if (cbs) { /*将类数组的对象转换成数组*/ cbs = cbs.length &gt; 1 ? toArray(cbs) : cbs const args = toArray(arguments, 1) /*遍历执行*/ for (let i = 0, l = cbs.length; i &lt; l; i++) { cbs[i].apply(vm, args) } } return vm }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue源码之从源码角度再看数据绑定]]></title>
    <url>%2F2018%2F12%2F09%2FVue%2Fvue%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BB%8E%E6%BA%90%E7%A0%81%E8%A7%92%E5%BA%A6%E5%86%8D%E7%9C%8B%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[原文地址 前文前面已经讲过Vue数据绑定的原理了，现在从源码来看一下数据绑定在Vue中是如何实现的。 首先看一下Vue.js官网介绍响应式原理的这张图。 这张图比较清晰地展示了整个流程，首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。 Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。 initData这里来讲一下initData，可以参考源码instance下的state.js文件，下面所有的中文注释都是我加的，英文注释是尤大加的，请不要忽略英文注释，英文注释都讲到了比较关键或者晦涩难懂的点。 加注释版的vue源码也可以直接通过传送门查看，这些是我在阅读Vue源码过程中加的注释，持续更新中。 initData主要是初始化data中的数据，将数据进行Observer，监听数据的变化，其他的监视原理一致，这里以data为例。 function initData (vm: Component) { /*得到data数据*/ let data = vm.$options.data data = vm._data = typeof data === &#39;function&#39; ? getData(data, vm) : data || {} /*判断是否是对象*/ if (!isPlainObject(data)) { data = {} process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn( &#39;data functions should return an object:\n&#39; + &#39;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#39;, vm ) } // proxy data on instance /*遍历data对象*/ const keys = Object.keys(data) const props = vm.$options.props let i = keys.length //遍历data中的数据 while (i--) { /*保证data中的key不与props中的key重复，props优先，如果有冲突会产生warning*/ if (props &amp;&amp; hasOwn(props, keys[i])) { process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn( `The data property &quot;${keys[i]}&quot; is already declared as a prop. ` + `Use prop default value instead.`, vm ) } else if (!isReserved(keys[i])) { /*判断是否是保留字段*/ /*这里是我们前面讲过的代理，将data上面的属性代理到了vm实例上*/ proxy(vm, `_data`, keys[i]) } } /*Github:https://github.com/answershuto*/ // observe data /*从这里开始我们要observe了，开始对数据进行绑定，这里有尤大大的注释asRootData，这步作为根数据，下面会进行递归observe进行对深层对象的绑定。*/ observe(data, true /* asRootData */) } 其实这段代码主要做了两件事，一是将_data上面的数据代理到vm上，另一件事通过observe将所有数据变成observable。 proxy接下来看一下proxy代理。 /*添加代理*/ export function proxy (target: Object, sourceKey: string, key: string) { sharedPropertyDefinition.get = function proxyGetter () { return this[sourceKey][key] } sharedPropertyDefinition.set = function proxySetter (val) { this[sourceKey][key] = val } Object.defineProperty(target, key, sharedPropertyDefinition) } 这里比较好理解，通过proxy函数将data上面的数据代理到vm上，这样就可以用app.text代替app._data.text了。 observe接下来是observe，这个函数定义在core文件下observer的index.js文件中。 /** * Attempt to create an observer instance for a value, * returns the new observer if successfully observed, * or the existing observer if the value already has one. */ /* 尝试创建一个Observer实例（__ob__），如果成功创建Observer实例则返回新的Observer实例，如果已有Observer实例则返回现有的Observer实例。 */ export function observe (value: any, asRootData: ?boolean): Observer | void { /*判断是否是一个对象*/ if (!isObject(value)) { return } let ob: Observer | void /*这里用__ob__这个属性来判断是否已经有Observer实例，如果没有Observer实例则会新建一个Observer实例并赋值给__ob__这个属性，如果已有Observer实例则直接返回该Observer实例*/ if (hasOwn(value, &#39;__ob__&#39;) &amp;&amp; value.__ob__ instanceof Observer) { ob = value.__ob__ } else if ( /*这里的判断是为了确保value是单纯的对象，而不是函数或者是Regexp等情况。*/ observerState.shouldConvert &amp;&amp; !isServerRendering() &amp;&amp; (Array.isArray(value) || isPlainObject(value)) &amp;&amp; Object.isExtensible(value) &amp;&amp; !value._isVue ) { ob = new Observer(value) } if (asRootData &amp;&amp; ob) { /*如果是根数据则计数，后面Observer中的observe的asRootData非true*/ ob.vmCount++ } return ob } Vue的响应式数据都会有一个ob的属性作为标记，里面存放了该属性的观察器，也就是Observer的实例，防止重复绑定。 Observer接下来看一下新建的Observer。Observer的作用就是遍历对象的所有属性将其进行双向绑定。 /** * Observer class that are attached to each observed * object. Once attached, the observer converts target * object&#39;s property keys into getter/setters that * collect dependencies and dispatches updates. */ export class { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { this.value = value this.dep = new Dep() this.vmCount = 0 /* 将Observer实例绑定到data的__ob__属性上面去，之前说过observe的时候会先检测是否已经有__ob__对象存放Observer实例了，def方法定义可以参考https://github.com/vuejs/vue/blob/dev/src/core/util/lang.js#L16 */ def(value, &#39;__ob__&#39;, this) if (Array.isArray(value)) { /* 如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。 这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。 */ const augment = hasProto ? protoAugment /*直接覆盖原型的方法来修改目标对象*/ : copyAugment /*定义（覆盖）目标对象或数组的某一个方法*/ augment(value, arrayMethods, arrayKeys) /*Github:https://github.com/answershuto*/ /*如果是数组则需要遍历数组的每一个成员进行observe*/ this.observeArray(value) } else { /*如果是对象则直接walk进行绑定*/ this.walk(value) } } /** * Walk through each property and convert them into * getter/setters. This method should only be called when * value type is Object. */ walk (obj: Object) { const keys = Object.keys(obj) /*walk方法会遍历对象的每一个属性进行defineReactive绑定*/ for (let i = 0; i &lt; keys.length; i++) { defineReactive(obj, keys[i], obj[keys[i]]) } } /** * Observe a list of Array items. */ observeArray (items: Array&lt;any&gt;) { /*数组需要便利每一个成员进行observe*/ for (let i = 0, l = items.length; i &lt; l; i++) { observe(items[i]) } } } Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。 如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。但这时候出现了一个问题，？如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？ Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。修改数组原型方法的代码可以参考observer/array.js以及observer/index.js。 export class Observer { value: any; dep: Dep; vmCount: number; // number of vms that has this object as root $data constructor (value: any) { //....... if (Array.isArray(value)) { /* 如果是数组，将修改后可以截获响应的数组方法替换掉该数组的原型中的原生方法，达到监听数组数据变化响应的效果。 这里如果当前浏览器支持__proto__属性，则直接覆盖当前数组对象原型上的原生数组方法，如果不支持该属性，则直接覆盖数组对象的原型。 */ const augment = hasProto ? protoAugment /*直接覆盖原型的方法来修改目标对象*/ : copyAugment /*定义（覆盖）目标对象或数组的某一个方法*/ augment(value, arrayMethods, arrayKeys) /*如果是数组则需要遍历数组的每一个成员进行observe*/ this.observeArray(value) } else { /*如果是对象则直接walk进行绑定*/ this.walk(value) } } } /** * Augment an target Object or Array by intercepting * the prototype chain using __proto__ */ /*直接覆盖原型的方法来修改目标对象或数组*/ function protoAugment (target, src: Object) { /* eslint-disable no-proto */ target.__proto__ = src /* eslint-enable no-proto */ } /** * Augment an target Object or Array by defining * hidden properties. */ /* istanbul ignore next */ /*定义（覆盖）目标对象或数组的某一个方法*/ function copyAugment (target: Object, src: Object, keys: Array&lt;string&gt;) { for (let i = 0, l = keys.length; i &lt; l; i++) { const key = keys[i] def(target, key, src[key]) } } /* * not type checking this file because flow doesn&#39;t play well with * dynamically accessing methods on Array prototype */ import { def } from &#39;../util/index&#39; /*取得原生数组的原型*/ const arrayProto = Array.prototype /*创建一个新的数组对象，修改该对象上的数组的七个方法，防止污染原生数组方法*/ export const arrayMethods = Object.create(arrayProto) /** * Intercept mutating methods and emit events */ /*这里重写了数组的这些方法，在保证不污染原生数组原型的情况下重写数组的这些方法，截获数组的成员发生的变化，执行原生数组操作的同时dep通知关联的所有观察者进行响应式处理*/ ;[ &#39;push&#39;, &#39;pop&#39;, &#39;shift&#39;, &#39;unshift&#39;, &#39;splice&#39;, &#39;sort&#39;, &#39;reverse&#39; ] .forEach(function (method) { // cache original method /*将数组的原生方法缓存起来，后面要调用*/ const original = arrayProto[method] def(arrayMethods, method, function mutator () { // avoid leaking arguments: // http://jsperf.com/closure-with-arguments let i = arguments.length const args = new Array(i) while (i--) { args[i] = arguments[i] } /*调用原生的数组方法*/ const result = original.apply(this, args) /*数组新插入的元素需要重新进行observe才能响应式*/ const ob = this.__ob__ let inserted switch (method) { case &#39;push&#39;: inserted = args break case &#39;unshift&#39;: inserted = args break case &#39;splice&#39;: inserted = args.slice(2) break } if (inserted) ob.observeArray(inserted) // notify change /*dep通知所有注册的观察者进行响应式处理*/ ob.dep.notify() return result }) }) 从数组的原型新建一个Object.create(arrayProto)对象，通过修改此原型可以保证原生数组方法不被污染。如果当前浏览器支持__proto__这个属性的话就可以直接覆盖该属性则使数组对象具有了重写后的数组方法。如果没有该属性的浏览器，则必须通过遍历def所有需要重写的数组方法，这种方法效率较低，所以优先使用第一种。 在保证不污染不覆盖数组原生方法添加监听，主要做了两个操作，第一是通知所有注册的观察者进行响应式处理，第二是如果是添加成员的操作，需要对新成员进行observe。 但是修改了数组的原生方法以后我们还是没法像原生数组一样直接通过数组的下标或者设置length来修改数组，可以通过Vue.set以及splice方法。 WatcherWatcher是一个观察者对象。依赖收集以后Watcher对象会被保存在Deps中，数据变动的时候会由Deps通知Watcher实例，然后由Watcher实例回调cb进行视图的更新 export default class Watcher { vm: Component; expression: string; cb: Function; id: number; deep: boolean; user: boolean; lazy: boolean; sync: boolean; dirty: boolean; active: boolean; deps: Array&lt;Dep&gt;; newDeps: Array&lt;Dep&gt;; depIds: ISet; newDepIds: ISet; getter: Function; value: any; constructor ( vm: Component, expOrFn: string | Function, cb: Function, options?: Object ) { this.vm = vm /*_watchers存放订阅者实例*/ vm._watchers.push(this) // options if (options) { this.deep = !!options.deep this.user = !!options.user this.lazy = !!options.lazy this.sync = !!options.sync } else { this.deep = this.user = this.lazy = this.sync = false } this.cb = cb this.id = ++uid // uid for batching this.active = true this.dirty = this.lazy // for lazy watchers this.deps = [] this.newDeps = [] this.depIds = new Set() this.newDepIds = new Set() this.expression = process.env.NODE_ENV !== &#39;production&#39; ? expOrFn.toString() : &#39;&#39; // parse expression for getter /*把表达式expOrFn解析成getter*/ if (typeof expOrFn === &#39;function&#39;) { this.getter = expOrFn } else { this.getter = parsePath(expOrFn) if (!this.getter) { this.getter = function () {} process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; warn( `Failed watching path: &quot;${expOrFn}&quot; ` + &#39;Watcher only accepts simple dot-delimited paths. &#39; + &#39;For full control, use a function instead.&#39;, vm ) } } this.value = this.lazy ? undefined : this.get() } /** * Evaluate the getter, and re-collect dependencies. */ /*获得getter的值并且重新进行依赖收集*/ get () { /*将自身watcher观察者实例设置给Dep.target，用以依赖收集。*/ pushTarget(this) let value const vm = this.vm /* 执行了getter操作，看似执行了渲染操作，其实是执行了依赖收集。 在将Dep.target设置为自生观察者实例以后，执行getter操作。 譬如说现在的的data中可能有a、b、c三个数据，getter渲染需要依赖a跟c， 那么在执行getter的时候就会触发a跟c两个数据的getter函数， 在getter函数中即可判断Dep.target是否存在然后完成依赖收集， 将该观察者对象放入闭包中的Dep的subs中去。 */ if (this.user) { try { value = this.getter.call(vm, vm) } catch (e) { handleError(e, vm, `getter for watcher &quot;${this.expression}&quot;`) } } else { value = this.getter.call(vm, vm) } // &quot;touch&quot; every property so they are all tracked as // dependencies for deep watching /*如果存在deep，则触发每个深层对象的依赖，追踪其变化*/ if (this.deep) { /*递归每一个对象或者数组，触发它们的getter，使得对象或数组的每一个成员都被依赖收集，形成一个“深（deep）”依赖关系*/ traverse(value) } /*将观察者实例从target栈中取出并设置给Dep.target*/ popTarget() this.cleanupDeps() return value } /** * Add a dependency to this directive. */ /*添加一个依赖关系到Deps集合中*/ addDep (dep: Dep) { const id = dep.id if (!this.newDepIds.has(id)) { this.newDepIds.add(id) this.newDeps.push(dep) if (!this.depIds.has(id)) { dep.addSub(this) } } } /** * Clean up for dependency collection. */ /*清理依赖收集*/ cleanupDeps () { /*移除所有观察者对象*/ let i = this.deps.length while (i--) { const dep = this.deps[i] if (!this.newDepIds.has(dep.id)) { dep.removeSub(this) } } let tmp = this.depIds this.depIds = this.newDepIds this.newDepIds = tmp this.newDepIds.clear() tmp = this.deps this.deps = this.newDeps this.newDeps = tmp this.newDeps.length = 0 } /** * Subscriber interface. * Will be called when a dependency changes. */ /* 调度者接口，当依赖发生改变的时候进行回调。 */ update () { /* istanbul ignore else */ if (this.lazy) { this.dirty = true } else if (this.sync) { /*同步则执行run直接渲染视图*/ this.run() } else { /*异步推送到观察者队列中，由调度者调用。*/ queueWatcher(this) } } /** * Scheduler job interface. * Will be called by the scheduler. */ /* 调度者工作接口，将被调度者回调。 */ run () { if (this.active) { const value = this.get() if ( value !== this.value || // Deep watchers and watchers on Object/Arrays should fire even // when the value is the same, because the value may // have mutated. /* 即便值相同，拥有Deep属性的观察者以及在对象／数组上的观察者应该被触发更新，因为它们的值可能发生改变。 */ isObject(value) || this.deep ) { // set new value const oldValue = this.value /*设置新的值*/ this.value = value /*触发回调渲染视图*/ if (this.user) { try { this.cb.call(this.vm, value, oldValue) } catch (e) { handleError(e, this.vm, `callback for watcher &quot;${this.expression}&quot;`) } } else { this.cb.call(this.vm, value, oldValue) } } } } /** * Evaluate the value of the watcher. * This only gets called for lazy watchers. */ /*获取观察者的值*/ evaluate () { this.value = this.get() this.dirty = false } /** * Depend on all deps collected by this watcher. */ /*收集该watcher的所有deps依赖*/ depend () { let i = this.deps.length while (i--) { this.deps[i].depend() } } /** * Remove self from all dependencies&#39; subscriber list. */ /*将自身从所有依赖收集订阅列表删除*/ teardown () { if (this.active) { // remove self from vm&#39;s watcher list // this is a somewhat expensive operation so we skip it // if the vm is being destroyed. /*从vm实例的观察者列表中将自身移除，由于该操作比较耗费资源，所以如果vm实例正在被销毁则跳过该步骤。*/ if (!this.vm._isBeingDestroyed) { remove(this.vm._watchers, this) } let i = this.deps.length while (i--) { this.deps[i].removeSub(this) } this.active = false } } } Dep来看看Dep类。其实Dep就是一个发布者，可以订阅多个观察者，依赖收集之后Deps中会存在一个或多个Watcher对象，在数据变更的时候通知所有的Watcher。 /** * A dep is an observable that can have multiple * directives subscribing to it. */ export default class Dep { static target: ?Watcher; id: number; subs: Array&lt;Watcher&gt;; constructor () { this.id = uid++ this.subs = [] } /*添加一个观察者对象*/ addSub (sub: Watcher) { this.subs.push(sub) } /*移除一个观察者对象*/ removeSub (sub: Watcher) { remove(this.subs, sub) } /*依赖收集，当存在Dep.target的时候添加观察者对象*/ depend () { if (Dep.target) { Dep.target.addDep(this) } } /*通知所有订阅者*/ notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } } } // the current target watcher being evaluated. // this is globally unique because there could be only one // watcher being evaluated at any time. Dep.target = null /*依赖收集完需要将Dep.target设为null，防止后面重复添加依赖。*/ defineReactive接下来是defineReactive。defineReactive的作用是通过Object.defineProperty为数据定义上getter\setter方法，进行依赖收集后闭包中的Deps会存放Watcher对象。触发setter改变数据的时候会通知Deps订阅者通知所有的Watcher观察者对象进行试图的更新。 /** * Define a reactive property on an Object. */ export function defineReactive ( obj: Object, key: string, val: any, customSetter?: Function ) { /*在闭包中定义一个dep对象*/ const dep = new Dep() const property = Object.getOwnPropertyDescriptor(obj, key) if (property &amp;&amp; property.configurable === false) { return } /*如果之前该对象已经预设了getter以及setter函数则将其取出来，新定义的getter/setter中会将其执行，保证不会覆盖之前已经定义的getter/setter。*/ // cater for pre-defined getter/setters const getter = property &amp;&amp; property.get const setter = property &amp;&amp; property.set /*对象的子对象递归进行observe并返回子节点的Observer对象*/ let childOb = observe(val) Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: function reactiveGetter () { /*如果原本对象拥有getter方法则执行*/ const value = getter ? getter.call(obj) : val if (Dep.target) { /*进行依赖收集*/ dep.depend() if (childOb) { /*子对象进行依赖收集，其实就是将同一个watcher观察者实例放进了两个depend中，一个是正在本身闭包中的depend，另一个是子元素的depend*/ childOb.dep.depend() } if (Array.isArray(value)) { /*是数组则需要对每一个成员都进行依赖收集，如果数组的成员还是数组，则递归。*/ dependArray(value) } } return value }, set: function reactiveSetter (newVal) { /*通过getter方法获取当前值，与新值进行比较，一致则不需要执行下面的操作*/ const value = getter ? getter.call(obj) : val /* eslint-disable no-self-compare */ if (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) { return } /* eslint-enable no-self-compare */ if (process.env.NODE_ENV !== &#39;production&#39; &amp;&amp; customSetter) { customSetter() } if (setter) { /*如果原本对象拥有setter方法则执行setter*/ setter.call(obj, newVal) } else { val = newVal } /*新的值需要重新进行observe，保证数据响应式*/ childOb = observe(newVal) /*dep对象通知所有的观察者*/ dep.notify() } }) }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vu源码之依赖收集]]></title>
    <url>%2F2018%2F12%2F02%2FVue%2FVu%E6%BA%90%E7%A0%81%E4%B9%8B%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%2F</url>
    <content type="text"><![CDATA[为什么要依赖收集？先看这段代码 new Vue({ template: `&lt;div&gt; &lt;span&gt;text1:&lt;/span&gt; {{text1}} &lt;span&gt;text2:&lt;/span&gt; {{text2}} &lt;div&gt;`, data: { text1: &#39;text1&#39;, text2: &#39;text2&#39;, text3: &#39;text3&#39; } }); 按照之前《响应式原理》中的方法绑定则会出现一个问题——text3在实际模板中并没有被用到，然而当text3的数据被修改的时候（this.text3 = ‘test’）的时候，同样会触发text3的setter导致重新执行渲染，这显然不正确。 先说说Dep当对data上的对象进行修改值的时候会触发它的setter，那么取值的时候自然就会触发getter事件，所以我们只要在最开始进行一次render，那么所有被渲染所依赖的data中的数据就会被getter收集到Dep的subs中去。在对data中的数据进行修改的时候setter只会触发Dep的subs的函数。 定义一个依赖收集类Dep。 class Dep { constructor () { this.subs = []; } addSub (sub: Watcher) { this.subs.push(sub) } removeSub (sub: Watcher) { remove(this.subs, sub) } /*Github:https://github.com/answershuto*/ notify () { // stabilize the subscriber list first const subs = this.subs.slice() for (let i = 0, l = subs.length; i &lt; l; i++) { subs[i].update() } } } function remove (arr, item) { if (arr.length) { const index = arr.indexOf(item) if (index &gt; -1) { return arr.splice(index, 1) } } Watcher订阅者，当依赖收集的时候会addSub到sub中，在修改data中数据的时候会触发dep对象的notify，通知所有Watcher对象去修改对应视图。 class Watcher { constructor (vm, expOrFn, cb, options) { this.cb = cb; this.vm = vm; /*在这里将观察者本身赋值给全局的target，只有被target标记过的才会进行依赖收集*/ Dep.target = this; /*Github:https://github.com/answershuto*/ /*触发渲染操作进行依赖收集*/ this.cb.call(this.vm); } update () { this.cb.call(this.vm); } } 开始依赖收集class Vue { constructor(options) { this._data = options.data; observer(this._data, options.render); let watcher = new Watcher(this, ); } } function defineReactive (obj, key, val, cb) { /*在闭包内存储一个Dep对象*/ const dep = new Dep(); Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: ()=&gt;{ if (Dep.target) { /*Watcher对象存在全局的Dep.target中*/ dep.addSub(Dep.target); } }, set:newVal=&gt; { /*只有之前addSub中的函数才会触发*/ dep.notify(); } }) } Dep.target = null; 将观察者Watcher实例赋值给全局的Dep.target，然后触发render操作只有被Dep.target标记过的才会进行依赖收集。有Dep.target的对象会将Watcher的实例push到subs中，在对象被修改出发setter操作的时候dep会调用subs中的Watcher实例的update方法进行渲染。 原文地址]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue 源码分析之响应式原理]]></title>
    <url>%2F2018%2F11%2F25%2FVue%2Fvue-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E4%B9%8B%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[原文地址 关于Vue.jsVue.js是一款MVVM框架，上手快速简单易用，通过响应式在修改数据的时候更新视图。Vue.js的响应式原理依赖于Object.defineProperty，尤大大在Vue.js文档中就已经提到过，这也是Vue.js不支持IE8 以及更低版本浏览器的原因。Vue通过设定对象属性的 setter/getter 方法来监听数据的变化，通过getter进行依赖收集，而每个setter方法就是一个观察者，在数据变更的时候通知订阅者更新视图。 将数据data变成可观察（observable）的那么Vue是如何将所有data下面的所有属性变成可观察的（observable）呢？ function observable(value,cb){ Object.keys(value).forEach((key)=&gt; defineReactive(value, key, value[key] , cb)); } function defineReactive (obj, key, val, cb) { Object.defineProperty(obj, key, { enumerable: true, configurable: true, get: ()=&gt;{ /*....依赖收集等....*/ /*Github:https://github.com/answershuto*/ return val }, set:newVal=&gt; { val = newVal; cb();/*订阅者收到消息的回调*/ } }) } class Vue(){ constructor(options){ this._data = options.data; observe(this._data, options.render) } } let app = new Vue({ el: &#39;#app&#39;, data: { text: &#39;text&#39;, text2: &#39;text2&#39; }, render(){ console.log(&quot;render&quot;); } }) 为了便于理解，首先考虑一种最简单的情况，不考虑数组等情况，代码如上所示。在initData中会调用observe这个函数将Vue的数据设置成observable的。当_data数据发生改变的时候就会触发set，对订阅者进行回调（在这里是render）。 那么问题来了，需要对app._data.text操作才会触发set。为了偷懒，我们需要一种方便的方法通过app.text直接设置就能触发set对视图进行重绘。那么就需要用到代理。 代理我们可以在Vue的构造函数constructor中为data执行一个代理proxy。这样我们就把data上面的属性代理到了vm实例上。 _proxy.call(this, options.data);/*构造函数中*/ /*代理*/ function _proxy (data) { const that = this; Object.keys(data).forEach(key =&gt; { Object.defineProperty(that, key, { configurable: true, enumerable: true, get: function proxyGetter () { return that._data[key]; }, set: function proxySetter (val) { that._data[key] = val; } }) }); } 我们可以使用app.text代替app._data.text了。]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 复杂判断的更优雅写法]]></title>
    <url>%2F2018%2F11%2F18%2FJs%2FJavaScript-%E5%A4%8D%E6%9D%82%E5%88%A4%E6%96%AD%E7%9A%84%E6%9B%B4%E4%BC%98%E9%9B%85%E5%86%99%E6%B3%95%2F</url>
    <content type="text"><![CDATA[原文地址 前言我们编写js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂，那么如何更优雅的写判断逻辑，本文带你试一下。 举个例子/** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ if(status == 1){ sendLog(&#39;processing&#39;) jumpTo(&#39;IndexPage&#39;) }else if(status == 2){ sendLog(&#39;fail&#39;) jumpTo(&#39;FailPage&#39;) }else if(status == 3){ sendLog(&#39;fail&#39;) jumpTo(&#39;FailPage&#39;) }else if(status == 4){ sendLog(&#39;success&#39;) jumpTo(&#39;SuccessPage&#39;) }else if(status == 5){ sendLog(&#39;cancel&#39;) jumpTo(&#39;CancelPage&#39;) }else { sendLog(&#39;other&#39;) jumpTo(&#39;Index&#39;) } } 通过代码可以看到这个按钮的点击逻辑：根据不同活动状态做两件事情，发送日志埋点和跳转到对应页面，大家可以很轻易的提出这段代码的改写方案，switch出场： /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ switch (status){ case 1: sendLog(&#39;processing&#39;) jumpTo(&#39;IndexPage&#39;) break case 2: case 3: sendLog(&#39;fail&#39;) jumpTo(&#39;FailPage&#39;) break case 4: sendLog(&#39;success&#39;) jumpTo(&#39;SuccessPage&#39;) break case 5: sendLog(&#39;cancel&#39;) jumpTo(&#39;CancelPage&#39;) break default: sendLog(&#39;other&#39;) jumpTo(&#39;Index&#39;) break } } 嗯，这样看起来比if/else清晰多了，细心的同学也发现了小技巧，case 2和case 3逻辑一样的时候，可以省去执行语句和break，则case 2的情况自动执行case 3的逻辑。 这时有同学会说，还有更简单的写法：（表驱动编程） const actions = { &#39;1&#39;: [&#39;processing&#39;,&#39;IndexPage&#39;], &#39;2&#39;: [&#39;fail&#39;,&#39;FailPage&#39;], &#39;3&#39;: [&#39;fail&#39;,&#39;FailPage&#39;], &#39;4&#39;: [&#39;success&#39;,&#39;SuccessPage&#39;], &#39;5&#39;: [&#39;cancel&#39;,&#39;CancelPage&#39;], &#39;default&#39;: [&#39;other&#39;,&#39;Index&#39;], } /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ let action = actions[status] || actions[&#39;default&#39;], logName = action[0], pageName = action[1] sendLog(logName) jumpTo(pageName) } 上面代码确实看起来更清爽了，这种方法的聪明之处在于：将判断条件作为对象的属性名，将处理逻辑作为对象的属性值，在按钮点击的时候，通过对象属性查找的方式来进行逻辑判断，这种写法特别适合一元条件判断的情况。 是不是还有其他写法呢？ const actions = new Map([ [1, [&#39;processing&#39;,&#39;IndexPage&#39;]], [2, [&#39;fail&#39;,&#39;FailPage&#39;]], [3, [&#39;fail&#39;,&#39;FailPage&#39;]], [4, [&#39;success&#39;,&#39;SuccessPage&#39;]], [5, [&#39;cancel&#39;,&#39;CancelPage&#39;]], [&#39;default&#39;, [&#39;other&#39;,&#39;Index&#39;]] ]) /** * 按钮点击事件 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status)=&gt;{ let action = actions.get(status) || actions.get(&#39;default&#39;) sendLog(action[0]) jumpTo(action[1]) } 这样写用到了es6里的Map对象，是不是更爽了？Map对象和Object对象有什么区别呢？ 一个对象通常都有自己的原型，所以一个对象总有一个”prototype”键。一个对象的键只能是字符串或者Symbols，但一个Map的键可以是任意值。你可以通过size属性很容易地得到一个Map的键值对个数，而对象的键值对个数只能手动确认。 我们需要把问题升级一下，以前按钮点击时候只需要判断status，现在还需要判断用户的身份： /** * 按钮点击事件 * @param {number} status 活动状态：1开团进行中 2开团失败 3 开团成功 4 商品售罄 5 有库存未开团 * @param {string} identity 身份标识：guest客态 master主态 */ const onButtonClick = (status,identity)=&gt;{ if(identity == &#39;guest&#39;){ if(status == 1){ //do sth }else if(status == 2){ //do sth }else if(status == 3){ //do sth }else if(status == 4){ //do sth }else if(status == 5){ //do sth }else { //do sth } }else if(identity == &#39;master&#39;) { if(status == 1){ //do sth }else if(status == 2){ //do sth }else if(status == 3){ //do sth }else if(status == 4){ //do sth }else if(status == 5){ //do sth }else { //do sth } } } 原谅我不写每个判断里的具体逻辑了，因为代码太冗长了。原谅我又用了if/else，因为我看到很多人依然在用if/else写这种大段的逻辑判断。从上面的例子我们可以看到，当你的逻辑升级为二元判断时，你的判断量会加倍，你的代码量也会加倍，这时怎么写更清爽呢？ const actions = new Map([ [&#39;guest_1&#39;, ()=&gt;{/*do sth*/}], [&#39;guest_2&#39;, ()=&gt;{/*do sth*/}], [&#39;guest_3&#39;, ()=&gt;{/*do sth*/}], [&#39;guest_4&#39;, ()=&gt;{/*do sth*/}], [&#39;guest_5&#39;, ()=&gt;{/*do sth*/}], [&#39;master_1&#39;, ()=&gt;{/*do sth*/}], [&#39;master_2&#39;, ()=&gt;{/*do sth*/}], [&#39;master_3&#39;, ()=&gt;{/*do sth*/}], [&#39;master_4&#39;, ()=&gt;{/*do sth*/}], [&#39;master_5&#39;, ()=&gt;{/*do sth*/}], [&#39;default&#39;, ()=&gt;{/*do sth*/}], ]) /** * 按钮点击事件 * @param {string} identity 身份标识：guest客态 master主态 * @param {number} status 活动状态：1 开团进行中 2 开团失败 3 开团成功 4 商品售罄 5 有库存未开团 */ const onButtonClick = (identity,status)=&gt;{ let action = actions.get(`${identity}_${status}`) || actions.get(&#39;default&#39;) action.call(this) } 上述代码核心逻辑是：把两个条件拼接成字符串，并通过以条件拼接字符串作为键，以处理函数作为值的Map对象进行查找并执行，这种写法在多元条件判断时候尤其好用。 当然上述代码如果用Object对象来实现也是类似的： const actions = { &#39;guest_1&#39;:()=&gt;{/*do sth*/}, &#39;guest_2&#39;:()=&gt;{/*do sth*/}, //.... } const onButtonClick = (identity,status)=&gt;{ let action = actions[`${identity}_${status}`] || actions[&#39;default&#39;] action.call(this) } 如果有些同学觉得把查询条件拼成字符串有点别扭，那还有一种方案，就是用Map对象，以Object对象作为key： const actions = new Map([ [{identity:&#39;guest&#39;,status:1},()=&gt;{/*do sth*/}], [{identity:&#39;guest&#39;,status:2},()=&gt;{/*do sth*/}], //... ]) const onButtonClick = (identity,status)=&gt;{ let action = [...actions].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this)) } 是不是又高级了一点点？ 这里也看出来Map与Object的区别，Map可以用任何类型的数据作为key。 我们现在再将难度升级一点点，假如guest情况下，status1-4的处理逻辑都一样怎么办，最差的情况是这样： const actions = new Map([ [{identity:&#39;guest&#39;,status:1},()=&gt;{/* functionA */}], [{identity:&#39;guest&#39;,status:2},()=&gt;{/* functionA */}], [{identity:&#39;guest&#39;,status:3},()=&gt;{/* functionA */}], [{identity:&#39;guest&#39;,status:4},()=&gt;{/* functionA */}], [{identity:&#39;guest&#39;,status:5},()=&gt;{/* functionB */}], //... ]) 好一点的写法是将处理逻辑函数进行缓存： const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} return new Map([ [{identity:&#39;guest&#39;,status:1},functionA], [{identity:&#39;guest&#39;,status:2},functionA], [{identity:&#39;guest&#39;,status:3},functionA], [{identity:&#39;guest&#39;,status:4},functionA], [{identity:&#39;guest&#39;,status:5},functionB], //... ]) } const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.identity == identity &amp;&amp; key.status == status)) action.forEach(([key,value])=&gt;value.call(this)) } 这样写已经能满足日常需求了，但认真一点讲，上面重写了4次functionA还是有点不爽，假如判断条件变得特别复杂，比如identity有3种状态，status有10种状态，那你需要定义30条处理逻辑，而往往这些逻辑里面很多都是相同的，这似乎也是笔者不想接受的，那可以这样实现: const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], //... ]) } const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`))) action.forEach(([key,value])=&gt;value.call(this)) } 这里Map的优势更加凸显，可以用正则类型作为key了，这样就有了无限可能，假如需求变成，凡是guest情况都要发送一个日志埋点，不同status情况也需要单独的逻辑处理，那我们可以这样写: const actions = ()=&gt;{ const functionA = ()=&gt;{/*do sth*/} const functionB = ()=&gt;{/*do sth*/} const functionC = ()=&gt;{/*send log*/} return new Map([ [/^guest_[1-4]$/,functionA], [/^guest_5$/,functionB], [/^guest_.*$/,functionC], //... ]) } const onButtonClick = (identity,status)=&gt;{ let action = [...actions()].filter(([key,value])=&gt;(key.test(`${identity}_${status}`))) action.forEach(([key,value])=&gt;value.call(this)) } 也就是说利用数组循环的特性，符合正则条件的逻辑都会被执行，那就可以同时执行公共逻辑和单独逻辑，因为正则的存在，你可以打开想象力解锁更多的玩法，本文就不赘述了。 总结本文已经教你了8种逻辑判断写法，包括： if/else switch 一元判断时：存到Object里 一元判断时：存到Map里 多元判断时：将condition拼接成字符串存到Object里 多元判断时：将condition拼接成字符串存到Map里 多元判断时：将condition存为Object存到Map里 多元判断时：将condition写作正则存到Map里 至此，本文也将告一段落，愿你未来的人生里，不只是有if/else/switch。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[websocket通信了解]]></title>
    <url>%2F2018%2F11%2F04%2FHTTP%2Fwebsocket%E9%80%9A%E4%BF%A1%E4%BA%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[websocketwebsocket是HTML5出的协议，他是一个持久化的协议。 websocket是什么样的协议，有什么与优点？首先websocket是一个持久化的协议，在HTTP中一个request只能有一个response,而且这个response也是被动的，不能主动发起。 下面是用websocket请求的header头 GET /chat HTTP/1.1 Host: server.example.com //告知服务器是使用websocket的协议 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== //是一个Base64 encode的值，这个是浏览器随机生成的，验证服务器 Sec-WebSocket-Protocol: chat, superchat // 是一个用户定义的字符串，用来区分同URL下，不同的服务所需要的协议 Sec-WebSocket-Version: 13 // 是告诉服务器所使用的Websocket Draft（协议版本） Origin: http://example.com 下面是服务器的返回头 HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat 下面是HTTP告诉客户端，已经切换协议了 Upgrade: websocket Connection: Upgrade ## websocket的作用 ajax轮询的原理很简单，每隔几秒发送一次请求，询问服务器是否有信息。 http long poll的原理与ajax轮询差不多，不过 采用的是阻塞模型（一直打电话，没收到就不挂电话） 这两者共同的地方都是在不断地建立HTTP连接，等待服务端处理，上面这两种都是非常消耗资源的。可以体现出HTTP的另外一个特点：被动性 其实我们所用的程序是要经过两层代理的，即HTTP协议在Nginx等服务器的解析下，然后再传送给相应的Handler（PHP等）来处理。简单地说，我们有一个非常快速的接线员（Nginx），他负责把问题转交给相应的客服（Handler）。 Websocket 只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议，还要查看identity info的信息。]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[call stack]]></title>
    <url>%2F2018%2F11%2F04%2FJs%2Fcall-stack%2F</url>
    <content type="text"><![CDATA[Call Stack(调用堆栈)MDN(解释call Stack) A call stack is a mechanism for an interpreter (like the JavaScript interpreter in a web browser) to keep track of its place in a script that calls multiple functions — what function is currently being run, what functions are called from within that function and should be called next, etc.(调用堆栈是一种机制，用于解释器（如Web浏览器中的JavaScript解释器）跟踪其在调用多个函数的脚本中的位置——当前正在运行什么函数、在该函数中调用什么函数以及接下来应该调用什么函数，等等。) When a script calls a function, the interpreter adds it to the call stack and then starts carrying out the function. Any functions that are called by that function are added to the call stack further up, and run where their calls are reached. When the current function is finished, the interpreter takes it off the stack and resumes execution where it left off in the last code listing. If the stack takes up more space than it had assigned to it, it results in a “stack overflow” error. 调用栈调用栈是一种数据结构。他记录了我们在程序中的位置；如果我们调用一个函数时，他就会将这个函数推入栈顶，当执行完这个函数后，就会从栈顶弹出，这就是调用栈所做的事情； function multiply(x,y){ return x * y; } function printSquare(x){ var s = multiply(x,x); console.log(s) } printSquare(5); 每一个进入调用栈的称为调用帧。“堆栈溢出”，当你达到调用栈的最大的大小的时候就会发生这种情况；而且这相当容易发生，特别是在你写递归的时候却没有全方位的测试它。我们来看看下面的代码： function foo(){ foo(); } foo() 什么是执行上下文？简而言之，执行上下文就是评估和执行JavaScript代码环境的抽象概念。每当JavaScript代码在运行时，他都是在执行上下文中运行的； 执行上下文的类型 全局执行上下文 这是默认或者说基础的上下文，任何不在函数内部的代码都在全局上下文中。它会执行两件事：创建一个全局的 window 对象（浏览器的情况下），并且设置 this 的值等于这个全局对象。一个程序中只会有一个全局执行上下文。 函数执行上下文 每当一个函数被调用时, 都会为该函数创建一个新的上下文。每个函数都有它自己的执行上下文，不过是在函数被调用时创建的。函数上下文可以有任意多个。每当一个新的执行上下文被创建，它会按定义的顺序（将在后文讨论）执行一系列步骤 eval函数执行上下文 执行在 eval 函数内部的代码也会有它属于自己的执行上下文，但由于 JavaScript 开发者并不经常使用 eval，所以在这里我不会讨论它 执行栈执行栈，也就是在其它编程语言中所说的“调用栈”，是一种拥有 LIFO（后进先出）数据结构的栈，被用来存储代码运行时创建的所有执行上下文。当 JavaScript 引擎第一次遇到你的脚本时，它会创建一个全局的执行上下文并且压入当前执行栈。每当引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部。引擎会执行那些执行上下文位于栈顶的函数。当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文。 怎么创建执行上下文？ 在 JavaScript 代码执行前，执行上下文将经历创建阶段。在创建阶段会发生三件事： 1.this 值的决定，即我们所熟知的 This 绑定。2.创建词法环境组件。3.创建变量环境组件。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初学者可能不知道的vue技巧]]></title>
    <url>%2F2018%2F10%2F21%2FVue%2F%E5%88%9D%E5%AD%A6%E8%80%85%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84vue%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[技巧/坑点setTimeout/ setInterval 场景一 ：this指向改变无法用this访问vue实例 mounted(){ setTimeout( function () { //setInterval同理 console.log(this); //此时this指向Window对象 }，1000) ; } 解决方法 :使用箭头函数或者缓存this //箭头函数访问this实例因为箭头函数本身没有绑定this setTimeout(() =&gt; { console. log(this);}, 500) ; //使用变量访问this实例let self=this; },1000); setTimeout (function () { console. log(self);//使用self变量访问this实例 }, 1000) ; ​ setInterval路由跳转继续运行并没有销毁 场景一 :比如一些弹幕，走马灯文字，这类需要定时调用的，路由跳转之后，因为组件已经销毁了，但是setlnterval还没有销毁，还在继续后台调用，控制台会不断报错，如果运算量大的话，无法及时清除，会导致严重的页面卡顿。 解决方法 :在组件生命周期beforeDestroy停止setInterval created() { this.intervalid = setInterval(() =&gt; { this.layerError = &quot;&quot;; this.Timer = null; }, 100000); } beforeDestroy( ){ //我通常是把setInterval( )定时器赋值给this实例，然后就可以像下面这么暂停。 clearInterval(this.intervalid); } Vue路由拦截浏览器后退实现草稿保存类似需求 场景一 :为了防止用户突然离开，没有保存已输入的信息 解决方法 : ​ //在路由组件中:mounted(){}， beforeRouteLeave (to, from, next) { if(用户已经输入信息){ //出现弹窗提醒保存草稿，或者自动后台为其保存 }else{ next(true);//用户离开 } } ​ 自定义组件添加click等事件不生效 场景一 :一些自定义组件，需要额外添加一些事件来实现一些特定需求 &lt;template&gt; &lt;el-progress type=&quot;circle&quot; :percentage=“0&quot; @click=“stopProgress”&gt;&lt;/elprogress&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ stopProgress() { console.log(&#39;停止&#39;) } } } &lt;/script&gt; 解决方法:使用.native修饰符 &lt;template&gt; &lt;el-progress type=&quot;circle&quot; :percentage=“0&quot; @click.native=“stopProgress”&gt;&lt;/el-progress&gt; &lt;/template&gt; &lt;script&gt; export default { methods:{ stopProgress() { console.log(&#39;停止&#39;) } } } &lt;/script&gt; 手动操控自定义组件 场景一 :一些自定义组件，需要去获取组件对象进行一些其他的Dom操作 解决方法 :使用ref属性暴露组件获取句柄 ​ &lt;template&gt; &lt;el-progress type=&quot;circle&quot; :percentage=&quot;O&quot; ref=&quot;progress&quot;&gt;&lt;/el-progress&gt;&lt;/template&gt; &lt;script&gt; this.$refs.progress //组件对象实例， 可以手动调用组件的内置方法和属性 this.$refs.progress.$el //组件 对象的最外层dom元素 &lt;/script&gt; ​ 深度作用选择器 场景一 : scoped的样式，希望影响到子组件的默认样式 在样式中设置完scoped在浏览器解析为如下图这样，a是个div，a div里面包含一个组件里面解析完了div的样式名字为b，想在父组件影响到子组件的默认样式。 解决方法： ​ &lt;style scoped&gt; .a &gt;&gt;&gt; .b { /* ... */ } &lt;/style&gt; //有些像Sass之类的预处理器无法正确解析&gt;&gt;&gt;。这种情况下你可以使用/deep/操作符取而代之- - - -这是一个&gt;&gt;&gt;的别名，同样可以正常工作。 &lt;style scoped lang=“scss”&gt; .a /deep/ .b { /* ... */ } &lt;/style&gt; Vue数组/对象更新视图不更新 场景一 :很多时候我们习惯于这样操作数组和对象 ​ data() { return { arr: [1,2,3], obj:{ a: 1, b: 2 } }; }, ​ // 数组更新视图不更新 this.arr[0] = &#39;OBKoro1&#39;; this.arr.length = 1; console.log(arr);// [&#39;OBKoro1&#39;]; // 数据更新，对象视图不更新 this.obj.c = &#39;OBKoro1&#39;; delete this.obj.a; console.log(obj); // {b:2,c:&#39;OBKoro1&#39;} 解决方法 ： this. $set(你要改变的数组/对象，你要改变的位置/key,你要改成什么value) 数组原生方法触发视图更新（ vue官网可查）: 整体替换数组/对象 Vue Filters过滤器的使用 场景一 :常见的数据文本的格式化 // 在双花括号中 &lt;div&gt;{{ message | DateFormat }}&lt;/div&gt; //展示正确时间 // 在&#39;v-bind&#39;中 &lt;div v-bind:id=&quot;rawId | formatId&quot;&gt;&lt;/div&gt; ​ // Demo:一个日期过滤器返回yyyy- MM-ddhh:mm:ss的样式 // 引入一个提前写好日期格式化的js import dayjs from &#39;dayjs&#39;; export default { data() { return { //时间毫秒 message:18324798324789 } }, filters: { //传入进行日期格式化 DateFormat(value) { return dayjs(value).format(“YYYY-MM-DD HH:mm:ss&quot;) } } } Vue深度watch与watch立即触发回调 场景一 :在watch里面监测对象里面对应的值是监测不到的，可以用如下方法。 选项: deep 在选项参数中指定deep:true,可以监听对象中子属性的变化。 选项: immediate 在选项参数中指定immediate:true,将立即以表达式的当前值触发回调，也就是默认触发一次。 watch: { obj: { handler(val, oldVal) { console.log(&#39;属性变化触发这个回调&#39;,val, oldVal); }, deep: true // 监测这个对象中每一个属性的变化 }, step: { // 属性 //watch handler(val, oldVal) { console.log(&quot;默认触发一次&quot;, val, oldVal); }, immediate: true // 默认触发一次 } }]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS对比 JavaScript动画]]></title>
    <url>%2F2018%2F08%2F26%2F%E6%9D%82%E6%96%87%2FCSS%E5%AF%B9%E6%AF%94-JavaScript%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[前言在网页上创建动画有两种主要方法：使用 CSS 和使用 JavaScript。您选择哪种方法实际上取决于项目的其他依赖关系，以及您尝试实现什么类型的效果。 TL;DR 使用 CSS 动画来实现较简单的“一次性”转换，例如切换 UI 元素状态。 当您需要高级效果（例如弹跳、停止、暂停、倒退或减速）时，请使用 JavaScript 动画。 如果选择使用 JavaScript 来编写动画，可选用 Web Animations API 或用起来顺手的现代框架。 大多数基本动画可以使用 CSS 或 JavaScript 来创建，但工作量和时间将有所不同（另请参考 CSS 对比 JavaScript 的性能）。每一种方法都有其优点和缺点，但以下内容是很好的指导原则： 当您为 UI 元素采用较小的独立状态时，使用 CSS。 CSS 变换和动画非常适合于从侧面引入导航菜单，或显示工具提示。最后，可以使用 JavaScript 来控制状态，但动画本身是采用 CSS。 在需要对动画进行大量控制时，使用 JavaScript。 Web Animations API 是一个基于标准的方*法，现已在 Chrome 和 Opera 中提供。该方法可提供实际对象，非常适合复杂的对象导向型应用。在需要停止、暂停、减速或倒退时，JavaScript 也非常有用。 如果您需要手动协调整个场景，可直接使用 requestAnimationFrame。这属于高级 JavaScript 方法，但如果您构建游戏或绘制到 HTML 画布，则该方法非常有用。 或者，如果您已使用包括动画功能的 JavaScript 框架，比如通过 jQuery 的 .animate() 方法或 GreenSock 的 TweenMax，则可能发现继续使用该方法实现动画在总体上更方便。 使用 CSS 编写动画使用 CSS 编写动画是使内容在屏幕上移动的最简单方式。此方法被称为声明式，因为您可以指定您想要的结果。 以下是一些 CSS 代码，让一个元素同时在 X 轴和 Y 轴上移动 100px。其实现方法是使用 CSS 变换，用时设置为 500 毫秒。当添加了 move 类时，transform 值被改变并且变换开始。 .box { -webkit-transform: translate(0, 0); -webkit-transition: -webkit-transform 500ms; transform: translate(0, 0); transition: transform 500ms; } .box.move { -webkit-transform: translate(100px, 100px); transform: translate(100px, 100px); } 除了变换的持续时间之外，还有针对缓动的选项，缓动基本上是动画表现的方式 如果在上述代码段中，您创建单独的 CSS 类来管理动画，则可以使用 JavaScript 来打开和关闭每个动画： box.classList.add(&#39;move&#39;)； 此操作将给您的应用带来良好的平衡。您可以侧重于使用 JavaScript 来管理状态，只需在目标元素上设置相应的类，让浏览器去处理动画。如果您按照这种方法，则可以侦听元素的 transitionend 事件，但前提是您能够放弃对 Internet Explorer 较旧版本的支持；IE 10 是支持这些事件的首个版本。所有其他浏览器均已支持此事件有一段时间了。 侦听变换结束所需的 JavaScript 如下所示： var box = document.querySelector(&#39;.box&#39;); box.addEventListener(&#39;transitionend&#39;, onTransitionEnd, false); function onTransitionEnd() { // Handle the transition finishing. } 除了使用 CSS 变换之外，还可以使用 CSS 动画，这允许您对单个动画关键帧、持续时间和迭代进行更多控制。 例如，可以使用与变换相同的方式为方框设置动画，但是设置动画时没有任何用户交互（例如点击），而是采用无限重复。还可以同时更改多个属性： /** * This is a simplified version without * vendor prefixes.With them included * (which you will need), things get far * more verbose! */ .box { /* Choose the animation */ animation-name: movingBox; /* The animation’s duration */ animation-duration: 1300ms; /* The number of times we want the animation to run */ animation-iteration-count: infinite; /* Causes the animation to reverse on every odd iteration */ animation-direction: alternate; } @keyframes movingBox { 0% { transform: translate(0, 0); opacity: 0.3; } 25% { opacity: 0.9; } 50% { transform: translate(100px, 100px); opacity: 0.2; } 100% { transform: translate(30px, 30px); opacity: 0.8; } } 借助 CSS 动画，可独立于目标元素来定义动画本身，并且使用 animation-name 属性来选择所需的动画。 CSS 动画在某种程度上仍采用供应商前缀，在 Safari、Safari Mobile 和 Android 浏览器中使用-webkit-。Chrome、Opera、Internet Explorer 和 Firefox 均不采用前缀。许多工具可帮助您创建所需的 CSS 前缀版本，使您能够在源文件中编写无前缀的版本。 使用 JavaScript 和 Web Animations API 编写动画比较而言，使用 JavaScript 创建动画比编写 CSS 变换或动画更复杂，但它一般可为开发者提供更多功能。您可以使用 Web Animations API 给特定的 CSS 属性设置动画，或构建可组合的效果对象。 JavaScript 动画是命令式，因为您将它们作为代码的一部分嵌入代码中。您还可以将它们封装在其他对象内。以下是在重新创建我们之前所讨论的 CSS 变换时需要编写的 JavaScript： var target = document.querySelector(&#39;.box&#39;); var player = target.animate([ {transform: &#39;translate(0)&#39;}, {transform: &#39;translate(100px, 100px)&#39;} ], 500); player.addEventListener(&#39;finish&#39;, function() { target.style.transform = &#39;translate(100px, 100px)&#39;; }); 默认情况下，Web Animations 仅修改元素的呈现形式。如果您想让您的对象保持在它已移动到的位置，则应在动画完成时，按照我们的示例修改其底层样式。 Web Animations API 是来自 W3C 的新标准，在 Chrome 和 Opera 中受原生支持，且正在进行针对 Firefox 的开发。对于其他的现代浏览器，提供 polyfill。 使用 JavaScript 动画，您可以完全控制元素在每个步骤的样式。这意味着您可以在您认为合适时减慢动画、暂停动画、停止动画、倒退动画和操纵元素。如果您正在构建复杂的对象导向型应用，则此方法特别有用，因为您可以正确封装您的行为。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Redux-Saga 管理 React 应用中的异步 action （上）]]></title>
    <url>%2F2018%2F08%2F21%2FReact%2FReact-saga%2F%E4%BD%BF%E7%94%A8-Redux-Saga-%E7%AE%A1%E7%90%86-React-%E5%BA%94%E7%94%A8%E4%B8%AD%E7%9A%84%E5%BC%82%E6%AD%A5-action-%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言可以用Don’t call me, I’ll call you这句话来比喻react-saga。 Generators 先行！为了理解 Sagas，我们首先要理解什么是 Generator。下面是 MDN 对 Generator 的描述： Generator 是在执行时能暂停，后面又能从暂停处继续执行的函数。它的上下文会在继续执行时保存。 你可以把 Generator 理解成一种遍历器对象生成函数，（译注：Generator 执行后返回的遍历器对象）提供一个 next 方法。执行这个方法就会返回下一个状态，或者返回遍历结束的状态。这就需要 Generator 能够维护内部状态。 下面是一个基本的 Generator 示例，它生成的遍历器对象会返回几个字符串： function * helloWorld(){ yield hello; yield world; return helloWorld; } var f = helloWorld(); f.next() // {value:&#39;hello&#39;,done:false} f.next() // {value:&#39;world&#39;,done:false} f.next() // {value:&#39;helloWorld&#39;,done:true} next 方法的返回值结构非常简单 — 只要我们通过 yield/return 返回值，这个返回值就是 value 属性的值。如果我们没有返回值，value 属性的值就是 undefined，done 属性的值就是 true。还有一点值的注意的是，执行 helloWorld 后，函数会在调用 yield 的地方停下来。当我们调用 next 方法后，函数会继续执行，直到遇到下一个 yield。如果我们调用了 return 语句或者函数执行完毕，done 属性就会为真。 如果状态序列的长度不确定时，我们可以用下面的方法来写： var results = generator.next(); while(!results.done){ console.log(results.value); results = generator.next(); } console.log(results.value); 什么是 Sagas？Sagas 是通过 Generator 函数来创建的。官方文档 的解释如下： Saga 就像应用中的一个独立线程，完全负责管理异步 action。 你可以把 Saga 想象成一个以最快速度不断地调用 next 方法并尝试获取所有 yield 表达式值的线程。你可能会问这和 React 有什么关系，为什么要使用它，所以首先来看看如何在 React &amp; Redux 应用使用 Saga：在 React &amp; Redux 应用中，一个常见的用法从调用一个 action 开始。被分配用来处理这个 action 的 reducer 会使用新的 state 更新 store，随后视图就会被更新渲染。 如果一个 Saga 被分配用来处理这个 action — 这个 action 通常就是个异步 action（比如一个对服务端的请求），一旦这个 action 完成后，Saga 会调用另一个 action 让 reducer 进行处理。 常见用例我们可以通过一个常见流程来说明：用户与页面进行交互，这个交互动作会触发一个从服务端请求数据的动作(此时页面显示 loading 提示)，最终我们用请求回来的数据去渲染页面的内容。让我们为每步创建一个 action，然后用 Redux-Saga 实现一个简化的版本如下： // saga.js import { take } from &#39;redux-saga/effects&#39; function* mySaga(){ yield take(USER_INTERACTED_WITH_UI_ACTION); } 这个 Saga 的函数名叫做 mySaga。它调用了 Redux-Saga effect 的 take 方法，这个方法会阻塞 Saga 的执行，直到有人调用了作为参数的那个 action，Saga 的执行也会结束，就像我们前面看到的 Generator 一样（done 变为 true）。 现在我们要让页面展示 loading 提示来响应这个 action。可以通过 put 方法调用另一个 action，然后分配 reducer 来处理，从而完成上述功能。如下： // saga.js import { take, put } from &#39;redux-saga/effects&#39; function* mySaga(){ yield take(USER_INTERACTED_WITH_UI_ACTION); yield put(SHOW_LOADING_ACTION, {isLoading: true}); } // reducer.js ... case SHOW_LOADING_ACTION: (state, isLoading) =&gt; { return Object.assign({}, state, {showLoading: isLoading}); } ... 下一步是调用 call 方法，它接收一个函数和一组参数，使用这些参数来执行这个函数。我们给 call 方法传递一个请求服务端并返回一个 Promise 的 GET 函数，它会保存请求结果： // saga.js import { take, put, call } from &#39;redux-saga/effects&#39; function* mySaga(){ yield take(USER_INTERACTED_WITH_UI_ACTION); yield put(SHOW_LOADING_ACTION, {isLoading: true}); const data = yield call(GET, &#39;https://my.server.com/getdata&#39;); yield put(SHOW_DATA_ACTION, {data: data}); } // reducer.js ... case SHOW_DATA_ACTION: (state, data) =&gt; { return Object.assign({}, state, {data: data, showLoading: false}; } ... 通过调用 SHOW_DATA_ACTION 来用接收的数据更新页面。 刚刚发生了什么？应用启动后，所有的 Sagas 都会被执行，你可以认为一直在调用 next 方法直到结束。take 方法类似于线程挂起的作用，一旦调用了USER_INTERACTED_WITH_UI_ACTION，线程就会恢复执行。 然后，我们继续调用 SHOW_LOADING_ACTION，reducer 会处理这个 action。由于 Saga 还在继续运行，call 方法会发起对服务端的请求，Saga 会在再次挂起，直到请求结束。 每次都使用在上面的例子中，Saga 只处理了一个用户交互的 action，因为我们用 put 方法执行了 SHOW_DATA_ACTION 这个 action，然后后面就没有 yield 了（done 就是 true 了对吧？）。如果我们希望在每次调用 USER_INTERACTED_WITH_UI_ACTION 这个 action 的时候，都会执行这一系列的 actions，我们可以用 while(true) 语句来包裹 Saga 内部的逻辑代码。完整代码如下： // saga.js import { take, put, call } from &#39;redux-saga/effects&#39; 1. function* mySaga(){ 2. while (true){ 3. yield take(USER_INTERACTED_WITH_UI_ACTION); 4. yield put(SHOW_LOADING_ACTION, {isLoading: true}); 5. const data = yield call(GET, &#39;https://my.server.com/getdata&#39;); 6. yield put(SHOW_DATA_ACTION, {data: data}); 7. } 8. } // reducer.js ... case SHOW_LOADING_ACTION: (state, isLoading) =&gt; { return Object.assign({}, state, {showLoading: isLoading}); }, case SHOW_DATA_ACTION: (state, data) =&gt; { return Object.assign({}, state, {data: data, showLoading: false}; } ... 这个无限循环不会造成堆栈溢出，也不会使你的应用崩溃！因为 take 方法就像线程挂起一样，mySaga 执行后会一直保持 pending 状态，直到那个 action 被触发。下次重新进入循环后，也会重复上述过程。 让我们一步步地看一下上面的过程： 1.应用启动，执行所有 Sagas。2.mySaga 运行，进入 while(true) 循环，在第 3 行挂起。3.USER_INTERACTED_WITH_UI_ACTION 这个 action 被触发。4.Saga 的线程激活，执行第 4 行，触发 SHOW_LOADING_ACTION 这个 action，然后分配的 reducer 进行处理（reducer 处理后，页面就会显示 loading 提示）。5.发送一个请求到服务端（第 5 行），然后会再次挂起，直到请求的 Promise 变为 resolved，请求结果的数据会赋值给 data 变量。6.SHOW_DATA_ACTION 接收 data 作为参数被触发，然后 reducer 就可以使用这些数据来更新页面。再次进入循环，回到第 2 步。 接下来在这篇文章中，我们介绍了 Redux-Saga 相关的基本概念，展示了如何在 React 应用中使用它。下篇文章中，我会展示在实际应用中使用它获得的价值。 原文地址]]></content>
      <categories>
        <category>React-saga</category>
      </categories>
      <tags>
        <tag>React-saga</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript异步编程(generator和async)]]></title>
    <url>%2F2018%2F08%2F20%2FJs%2FJavascript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%EF%BC%88generator%E5%92%8Casync%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前言从Promise开始，JavaScript就在引入新功能，来帮助更简单的方法来处理异步编程，帮助我们远离回调地狱。Promise是下边要讲的Generator/yield与async/await的基础，希望你已经提前了解了它。 在大概ES6的时代，推出了Generator/yield两个关键字，使用Generator可以很方便的帮助我们建立一个处理Promise的解释器。 然后，在ES7左右，我们又得到了async/await这样的语法，可以让我们以接近编写同步代码的方式来编写异步代码（无需使用.then()或者回调函数）。 两者都能够帮助我们很方便的进行异步编程，但同样，这两者之间也是有不少区别的。 generatorGenerator是一个函数，可以在函数内部通过yield返回一个值（此时，Generator函数的执行会暂定，直到下次触发.next()）创建一个Generator函数的方法是在function关键字后添加*标识。 在调用一个Generator函数后，并不会立即执行其中的代码，函数会返回一个Generator对象，通过调用对象的next函数，可以获得yield/return的返回值。无论是触发了yield还是return，next()函数总会返回一个带有value和done属性的对象。 value为返回值，done则是一个Boolean对象，用来标识Generator是否还能继续提供返回值。 PS: generator()函数的执行是惰性的，yield后的代码只在触发next()后执行 function * oddGenerator () { yield 1 yield 3 return 5 } let iterator = oddGenerator() let first = iterator.next() // { value: 1, done: false } let second = iterator.next() // { value: 3, done: false } let third = iterator.next() // { value: 5, done: true } next()的参数传递我们可以在调用next()的时候传递一个参数，可以在上次yield前接收到这个参数： function * outputGenerator () { let ret1 = yield 1 console.log(`got ret1: ${ret1}`) let ret2 = yield 2 console.log(`got ret2: ${ret2}`) } let iterator = outputGenerator() iterator.next(1) iterator.next(2) // got ret1: 2 iterator.next(3) // got ret2: 3 第一眼看上去可能会有些诡异，为什么第一条log是在第二次调用next时才进行输出的 这就又要说到上边的Generator的实现了，上边说到了，yield与return都是用来返回值的语法。函数在执行时遇到这两个关键字后就会暂停执行，等待下次激活。 然后let ret1 = yield 1，这是一个赋值表达式，也就是说会先执行=右边的部分，在=右边执行的过程中遇到了yield关键字，函数也就在此处暂停了，在下次触发next()时才被激活，此时，我们继续进行上次未完成的赋值语句let ret1 = XXX，并在再次遇到yield时暂停。 这也就解释了为什么第二次调用next()的参数会被第一次yield赋值的变量接收到 用作迭代器使用因为Generator对象是一个迭代器，所以我们可以直接用于for...of循环： 但是要注意的是，用作迭代器中的使用，则只会作用于yield,return的返回值不计入迭代 function * oddGenerator () { yield 1 yield 3 yield 5 return &#39;won\&#39;t be iterate&#39; } for (let value of oddGenerator()) { console.log(value) } // &gt; 1 // &gt; 3 // &gt; 5 Generator函数内部的Generator除了yield语法以外，其实还有一个yield*语法，可以粗略的理解为是 Generator函数版的[…]用来展开Generator迭代器的。 function * gen1 () { yield 1 yield* gen2() yield 5 } function * gen2 () { yield 2 yield 3 yield 4 return &#39;won\&#39;t be iterate&#39; } for (let value of gen1()) { console.log(value) } // &gt; 1 // &gt; 2 // &gt; 3 // &gt; 4 // &gt; 5 模拟实现Promise执行器然后我们结合着Promise，来实现一个简易的执行器。 最受欢迎的类似的库是： co function run (gen) { gen = gen() return next(gen.next()) function next ({done, value}) { return new Promise(resolve =&gt; { if (done) { // finish resolve(value) } else { // not yet value.then(data =&gt; { next(gen.next(data)).then(resolve) }) } }) } } function getRandom () { return new Promise(resolve =&gt; { setTimeout(_ =&gt; resolve(Math.random() * 10 | 0), 1000) }) } function * main () { let num1 = yield getRandom() let num2 = yield getRandom() return num1 + num2 } run(main).then(data =&gt; { console.log(`got data: ${data}`); }) 一个简单的解释器的模拟（仅作举例说明） 在例子中，我们约定yield后边的必然是一个Promise函数我们只看main()函数的代码，使用Generator确实能够让我们让近似同步的方式来编写异步代码但是，这样写就意味着我们必须有一个外部函数负责帮我们执行main()函数这个Generator，并处理其中生成的Promise，然后在then回调中将结果返回到Generator函数，以便可以执行下边的代码。 async我们用作async/awiat重写上面generator的例子： function getRandom () { return new Promise(resolve =&gt; { setTimeout(_ =&gt; resolve(Math.random() * 10 | 0), 1000) }) } async function main () { let num1 = await getRandom() let num2 = await getRandom() return num1 + num2 } console.log(`got data: ${await main()}`) 这样看上去，好像我们从Generator/yield换到async/await只需要把*都改为async，yield都改为await就可以了。 所以很多人都直接拿Generator/yield来解释async/await的行为，但这会带来如下几个问题： Generator有其他的用途，而不仅仅是用来帮助你处理Promise 这样的解释让那些不熟悉这两者的人理解起来更困难（因为你还要去解释那些类似co的库） async/await是 处理Promise的一个极其方便的方法，但如果使用不当的话，也会造成一些令人头疼的问题 Async函数始终返回一个Promise一个async函数，无论你return 1或者throw new Error()。在调用方来讲，接收到的始终是一个Promise对象： async function throwError () { throw new Error() } async function returnNumber () { return 1 } console.log(returnNumber() instanceof Promise) // true console.log(throwError() instanceof Promise) // true 也就是说，无论函数是做什么用的，你都要按照Promise的方式来处理它。 Await是按照顺序执行的，并不能并行执行JavaScript是单线程的，这就意味着await一只能一次处理一个，如果你有多个Promise需要处理，则就意味着，你要等到前一个Promise处理完成才能进行下一个的处理，这就意味着，如果我们同时发送大量的请求，这样处理就会非常慢，one by one： const bannerImages = []; async function getImageInfo(){ return bannerImages.map(async banner =&gt; await getImageInfo(banner)); } 就像这样的四个定时器，我们需要等待4s才能执行完毕： function delay () { return new Promise(resolve =&gt; setTimeout(resolve, 1000)) } let tasks = [1, 2, 3, 4] async function runner (tasks) { for (let task of tasks) { await delay() } } console.time(&#39;runner&#39;) await runner(tasks) console.timeEnd(&#39;runner&#39;) 像这种情况，我们可以通过Promise.all()进行如下优化： function delay () { return new Promise(resolve =&gt; setTimeout(resolve, 1000)) } let tasks = [1, 2, 3, 4] async function runner (tasks) { tasks = tasks.map(delay) await Promise.all(tasks) } console.time(&#39;runner&#39;) await runner(tasks) console.timeEnd(&#39;runner&#39;) 草案中提到过await*，但现在貌似还不是标准，所以还是采用Promise.all包裹一层的方法来实现 我们知道，Promise对象在创建时就会执行函数内部的代码，也就意味着，在我们使用map创建这个数组时，所有的Promise代码都会执行，也就是说，所有的请求都会同时发出去，然后我们通过await Promise.all来监听所有Promise的响应。 结论Generator与async function都是返回一个特定类型的对象： Generator: 一个类似{ value: XXX, done: true }这样结构的ObjectAsync: 始终返回一个Promise，使用await或者.then()来获取返回值Generator是属于生成器，一种特殊的迭代器，用来解决异步回调问题感觉有些不务正业了。。 而async则是为了更简洁的使用Promise而提出的语法，相比Generator + co这种的实现方式，更为专注，生来就是为了处理异步编程。 现在已经是2018年了，async也是用了好久，就让Generator去做他该做的事情吧。。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我对React v16.4生命周期的理解]]></title>
    <url>%2F2018%2F08%2F13%2FReact%2F%E6%88%91%E5%AF%B9React-v16-4%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[react v16.3生命周期 react v16.4生命周期 React v16要废除的三个生命周期函数 componentWillMount componentWillReceiveProps componentWillUpdate 注：目前在16版本中componentWillMount，componentWillReceiveProps，componentWillUpdate并未完全删除这三个生命周期函数，而且新增了UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps，UNSAFE_componentWillUpdate三个函数，官方计划在17版本完全删除这三个函数，只保留UNSAVE_前缀的三个函数，目的是为了向下兼容，但是对于开发者而言应该尽量避免使用他们，而是使用新增的生命周期函数替代它们 取而代之的生命周期 static getDerivedStateFromProps getSnapshotBeforeUpdate 我们将React的生命周期分为三个阶段，然后详细讲解每个阶段具体调用了什么函数，这三个阶段是： 挂载阶段 更新阶段 卸载阶段 挂载阶段 挂载阶段，也可以理解为组件的初始化阶段，就是将我们的组件插入到DOM中，只会发生一次 这个阶段的生命周期函数调用如下 constructor getDerviedStateFromProps componentWillMount/UNSAVE_componentWillMount render componentDidMount constructor组件构造函数，第一个被执行 如果没有显示定义它，我们会拥有一个默认的构造函数 如果显示定义了构造函数，我们必须在构造函数第一行执行super(props)，否则我们无法在构造函数里拿到this对象，这些都属于ES6的知识 在构造函数里我们一般会做两件事： 初始化state对象 给自定义方法绑定this class App extends React.Component{ constructor(props){ super(props); this.state = { select, height: &#39;atuo&#39;, externalClass, externalClassText } this.handleClick = this.handleClick.bind(this); } } 禁止在构造函数中调用setState，可以直接给state设置初始值 getDerivedStateFromPropsstatic getDerivedStateFromProps(nextProps,prevState) 一个静态方法，所以不能在这个函数里面使用this，这个函数有两个参数props和state，分别指接收到的新参数和当前的state对象，这个函数会返回一个对象用来更新当前的state对象，如果不需要更新可以返回null 该函数会在挂载时，接收到新的props，调用了setState和forceUpdate时被调用 在React v16.3时只有在挂载时和接收到新的props被调用，据说这是官方的失误，后来修复了 这个方法就是为了取代之前的componentWillMount、componentWillReceiveProps和componentWillUpdate 当我们接收到新的属性想去修改我们state，可以使用getDerivedStateFromProps class ExampleComponent extends React.Component { state = { isScrollingDown: false, lastRow: null } static getDerivedStateFromProps(nextProps,prevState){ if(nextProps.currentRow !== prevState.lastRow){ return { isScrollingDown: nextProps.currentRow &gt; prevState.lastRow, lastRow: nextProps.currentRow } } return null; } } componentWillMount/UNSAFE_componentWillMount在16版本这两个方法并存，但是在17版本中componentWillMount被删除，只保留UNSAFE_componentWillMount，目的是为了做向下兼容，对于新的应用，用getDerivedStateFromProps代替它们由于componentWillMount/ UNSAFE_componentWillMount是在render之前调用，所以就算在这个方法中调用setState也不会触发重新渲染（re-render） renderrender方法是react中最核心的方法，一个组件中必须要这个方法： 返回的类型有以下几种 原生DOM，如div Fragment（片段） React组件 Portals（插槽） 字符串和数字，被渲染成text节点 Boolean和null，不会渲染任何东西 关于Fragment和Portals是React16新增的，如果大家不清楚可以去阅读官方文档，在这里就不展开了 render函数是纯函数，里面只做一件事，就是返回需要渲染的东西，不应该包含其它的业务逻辑，如数据请求，对于这些业务逻辑请移到componentDidMount和componentDidUpdate中 componentDidMount组件卸载之后调用，此时我们可以获取到DOM节点并操作，比如对canvas，svg的操作，服务器请求，订阅都可以写在这个里面，但是记得在componentWillUnmount中取消订阅 componentDidMount() { const { progressCanvas, progressSVG } = this const canvas = progressCanvas.current const ctx = canvas.getContext(&#39;2d&#39;) canvas.width = canvas.getBoundingClientRect().width canvas.height = canvas.getBoundingClientRect().height const svg = progressSVG.current const rect = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;rect&#39;) rect.setAttribute(&#39;x&#39;, 0) rect.setAttribute(&#39;y&#39;, 0) rect.setAttribute(&#39;width&#39;, 0) rect.setAttribute(&#39;height&#39;, svg.getBoundingClientRect().height) rect.setAttribute(&#39;style&#39;, &#39;fill:red&#39;) const animate = document.createElementNS(&#39;http://www.w3.org/2000/svg&#39;, &#39;animate&#39;) animate.setAttribute(&#39;attributeName&#39;, &#39;width&#39;) animate.setAttribute(&#39;from&#39;, 0) animate.setAttribute(&#39;to&#39;, svg.getBoundingClientRect().width) animate.setAttribute(&#39;begin&#39;, &#39;0ms&#39;) animate.setAttribute(&#39;dur&#39;, &#39;1684ms&#39;) animate.setAttribute(&#39;repeatCount&#39;, &#39;indefinite&#39;) animate.setAttribute(&#39;calcMode&#39;, &#39;linear&#39;) rect.appendChild(animate) svg.appendChild(rect) svg.pauseAnimations() this.canvas = canvas this.svg = svg this.ctx = ctx } 在componentDidMount中调用setState会触发一次额外的渲染，多调用了一次render函数，但是用户对此没有感知，因为它是在浏览器刷新屏幕前执行的，但是我们应该在开发中避免它，因为它会带来一定的性能问题，我们应该在constructor中初始化我们的state对象，而不应该在componentDidMount调用state方法 更新阶段更新阶段，当组件的props改变了，或组件内部调用了setState或者forceUpdate发生，会发生多次 这个阶段生命周期函数如下： componentWillReceiveProps/UNSAFE_componentWillReceiveProps getRerviedStateFromProps shouldComponentUpdate componentWillUpdate/UNSAFE_componentWillUpdate render getSnapshotBeforeUpdate componentDidUpdate componentWillReceiveProps/UNSAFE_componentWillReceivePropscomponentWillReceiveProps(nextProps, prevState)UNSAFE_componentWillReceiveProps(nextProps, prevState) 在16版本这两个方法并存，但是在17版本中componentWillReceiveProps被删除，UNSAFE_componentWillReceiveProps，目的是为了做向下兼容，对于新的应用，用getDerivedStateFromProps代替它们 注意，当我们父组件重新渲染的时候，也会导致我们的子组件调用componentWillReceiveProps/UNSAFE_componentWillReceiveProps，即使我们的属性和之前的一样，所以需要我们在这个方法里面去进行判断，如果前后属性不一致才去调用setState 在装载阶段这两个函数不会被触发，在组件内部调用了setState和forceUpdate也不会触发这两个函数 `getDerivedStateFromProps这个方法在装载阶段已经讲过了，这里不再赘述，记住在更新阶段，无论我们接收到新的属性，调用了setState还是调用了forceUpdate，这个方法都会被调用 shouldComponentUpdateshouldComponentUpdate(nextProps,nextState) 有两个参数nextProps和nextState，表示新的属性和变化之后的state，返回一个布尔值，true表示会触发重新渲染，false表示不会触发重新渲染，默认返回true 注意当我们调用forceUpdate并不会触发此方法 因为默认是返回true，也就是只要接收到新的属性和调用了setState都会触发重新的渲染，这会带来一定的性能问题，所以我们需要将this.props与nextProps以及this.state与nextState进行比较来决定是否返回false，来减少重新渲染 但是官方提倡我们使用PureComponent来减少重新渲染的次数而不是手工编写shouldComponentUpdate代码，具体该怎么选择，全凭开发者自己选择 在未来的版本，shouldComponentUpdate返回false，仍然可能导致组件重新的渲染，这是官方自己说的 Currently, if shouldComponentUpdate() returns false, then UNSAFE_componentWillUpdate(), render(), and componentDidUpdate() will not be invoked. In the future React may treat shouldComponentUpdate() as a hint rather than a strict directive, and returning false may still result in a re-rendering of the component. componentWillUpdate/UNSAFE_componentWillUpdatecomponentWillUpdate(nextProps, nextState)UNSAFE_componentWillUpdate(nextProps, nextState) 在16版本这两个方法并存，但是在17版本中componentWillUpdate被删除，UNSAFE_componentWillUpdate，目的是为了做向下兼容 在这个方法里，你不能调用setState，因为能走到这个方法，说明shouldComponentUpdate返回true，此时下一个state状态已经被确定，马上就要执行render重新渲染了，否则会导致整个生命周期混乱，在这里也不能请求一些网络数据，因为在异步渲染中，可能会导致网络请求多次，引起一些性能问题 如果你在这个方法里保存了滚动位置，也是不准确的，还是因为异步渲染的问题，如果你非要获取滚动位置的话，请在getSnapshotBeforeUpdate调用 `render更新阶段也会触发，装载阶段已经讲过了，不再赘述 getSnapshotBeforeUpdategetSnapshotBeforeUpdate(prevProps, prevState) 这个方法在render之后，componentDidUpdate之前调用，有两个参数prevProps和prevState，表示之前的属性和之前的state，这个函数有一个返回值，会作为第三个参数传给componentDidUpdate，如果你不想要返回值，请返回null，不写的话控制台会有警告 还有这个方法一定要和componentDidUpdate一起使用，否则控制台也会有警告 前面说过这个方法时用来代替componentWillUpdate/UNSAVE_componentWillUpdate，下面举个例子说明下： class ScrollingList extends React.Component { constructor(props) { super(props); this.listRef = React.createRef(); } getSnapshotBeforeUpdate(prevProps, prevState) { // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) { const list = this.listRef.current; return list.scrollHeight - list.scrollTop; } return null; } componentDidUpdate(prevProps, prevState, snapshot) { // If we have a snapshot value, we&#39;ve just added new items. // Adjust scroll so these new items don&#39;t push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) { const list = this.listRef.current; list.scrollTop = list.scrollHeight - snapshot; } } render() { return ( &lt;div ref={this.listRef}&gt;{/* ...contents... */}&lt;/div&gt; ); } } componentDidUpdatecomponentDidUpdate(prevProps, prevState, snapshot) 该方法在getSnapshotBeforeUpdate方法之后被调用，有三个参数prevProps，prevState，snapshot，表示之前的props，之前的state，和snapshot。第三个参数是getSnapshotBeforeUpdate返回的 卸载阶段卸载阶段，当我们的组件被卸载或者销毁了 这个阶段的生命周期函数只有一个 componentWillUnmount componentWillUnmount当我们的组件被卸载或者销毁了就会调用，我们可以在这个函数里去清除一些定时器，取消网络请求，清理无效的DOM元素等垃圾清理工作 注意不要在这个函数里去调用setState，因为组件不会重新渲染了 原文链接]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端常见算法Js实现]]></title>
    <url>%2F2018%2F08%2F10%2FHTTP%2F%E5%89%8D%E7%AB%AF%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95Js%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[快速排序var arr = [2,53,53.2,1,1223,5,2,675,967,2,1231,9344,3855,1]; 冒泡排序原理：比较相邻的两个元素，比较大的放置右端 function bubbleSort(arr){ var i = j =0 for(var i = 1;i &lt; arr.length;i++){ for(var j = 0;j &lt;= arr.length - i;j++){ var temp = 0 if(arr[j] &gt; arr[j+1]){ temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; } } } } // bubbleSort(arr); // console.log(arr) 快排原理：根据基数将分为两部分，一部分的数据要比另一部分的所有数据都要小，然后进行递归调用，直到最后一个元素 function quickSort(arr){ if (arr.length &lt;= 1) { return arr; } var pivotIndex = Math.floor(arr.length / 2) ; var pivot = arr.splice(pivotIndex, 1)[0]; var left = []; var right = []; for (var i = 0; i &lt; arr.length; i++){ if (arr[i] &lt; pivot) { left.push(arr[i]); } else { right.push(arr[i]); } } return quickSort(left).concat([pivot], quickSort(right)); } // console.log(quickSort(arr)); 插入排序原理1） 从第一个元素开始，该元素可以认为已经被排序 2） 取出下一个元素，在已经排序的元素序列中从后向前扫描 3） 如果该元素（已排序）大于新元素，将该元素移到下一位置 4） 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 5）将新元素插入到下一位置中 6） 重复步骤2 function insertSort(arr){ // 假设第0个元素开始是有序排序，第1个元素之后是无序排序 // 所以从第1个元素将无需数列的元素插入有序数列中 for(var i = 1; i &lt; arr.length; i++){ // 升序 if(arr[i] &lt; arr[i - 1]){ // 取出无序数组中弟i个元素作为被插入元素 var guard = arr[i]; // 记住有序数列的最后一个元素位置，并将数列位置扩大一个 var j = i - 1; arr[i] = arr[j]; // 比大小找到被插入元素的位置 while (j &gt;= 0 &amp;&amp; guard &lt; arr[j]) { arr[j + 1] = arr[j]; j--; } arr[j + 1] = guard; // 插入 } } } insertSort(arr); console.log(arr) 二分查找原理二分查找，也为折半查找。首先要找到一个中间值，通过与中间值比较，大的放又，小的放在左边。再在两边中寻找中间值，持续以上操作，直到找到所在位置为止。 function binarySort(left,right){ var result = [], il = 0, ir = 0; while (il &lt; left.length &amp;&amp; ir &lt; right.length) { if (left[il] &lt; right[ir]) { result.push(left[il++]); } else { result.push(right[ir++]); } } while(left[il]){ result.push(left[il++]); } while(right[ir]){ result.push(right[ir++]); } return result; } console.log(binarySort(arr,1))]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用canvas压缩上传的图片]]></title>
    <url>%2F2018%2F08%2F07%2FJs%2F%E7%94%A8canvas%E5%8E%8B%E7%BC%A9%E4%B8%8A%E4%BC%A0%E7%9A%84%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[前言现在摄像头已经是手机的标配了，移动网站也做得越来越像APP。然而拍照上传这件事情的体验似乎仍然不如APP，主要原因是现在手机拍摄的照片太大，上传非常消耗流量也非常耗时。APP都会在上传前缩小要上传的照片尺寸，以期更节省流量和时间。在HTML5时代，利用文件API和Canvas技术，Web上也可以做到图片压缩上传。 过滤文件类型首先我们希望用户能直接选择手机照片，而不是在各种类型的文件中选择。只需要在input标签中加入accept属性就可以实现这一点： &lt;div id=&quot;preview&quot;&gt;&lt;/div&gt; &lt;form&gt; &lt;input type=&quot;file&quot; accept=&quot;image/*&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;form&gt; 在Android4以上，iOS7以上设备实测，当用户点击这个文件选择器的时候，手机会自动调出图片库，并带有拍照选择。 读文件生成预览用户选择了图片之后，需要读取文件内容，读出的内容可供生成预览图，也可以供后面压缩使用。使用HTML5的FileReader API可以达成这一目的。 var file = document.querySeletor(&quot;[type=file]&quot;); file.addEventListener(&#39;change&#39;,function(e){ for(var i = 0,f; f &lt; e.target.file[i]; i++){ if(f.type.indexOf(&#39;image&#39;) != 0) continue; var render = new FileReader(); render.onload = function(e){ var img = document.createElement(&#39;img&#39;); img.src = e.targte.result; document.getElementById(&#39;preview&#39;).appendChild(img); } render.readAsDataURL(f) } },false) 如果不需要预览图，可以不把img对象添加到DOM上。 压缩利用Canvas渲染上下文的drawImage接口，可以把一张图片绘制到Canvas上，在这个过程中可以重新定义图片尺寸，然后再用Canvas的toDataURL接口可以生成出压缩后的图片。 var images = document.querySeletorAll(&#39;#preview img&#39;); var iWidth = 400,iHeight = 300; var compressedImages = []; [].forEach.call(images,function(image){ var canvas = document.createElement(&#39;canvas&#39;); canvas.width = iWidth; canvas.height = iHeight; canvas.getContent(&#39;2d&#39;).drawImage(image); var compressed = canvas.toDataURL(&quot;imgae/jepg&quot;,0.7); compressedImages.push(compressed); }) 上传上面一步骤生成的压缩后图片是Data URL形式的，上传前需要把开头部分的data:image/jpeg;base64,截掉才是图片的Base64编码形式。 可以直接把Base64的字符串上传到服务器，然后由服务端解码为JPG图片，也可以在前端解码上传。如果要在前端解码并以文件方式上传，先要用atob函数把Base64解开，然后转换为ArrayBuffer，再用它创建一个Blob对象。文件方式上传需要用multipart/form-data格式，可以利用FormData对象组装生成好的Blob对象来实现。 function b64toBlob(b64Data,contentType,sliceSize){ contentType = contentType || &#39;&#39;; sliceSize = sliceSize || 512; var byteCharacters = atob(b64Data); var byteData = []; for(var offset = 0; offset &lt; byteCharacters.length; offset += sliceSize){ var slice = byteCharacters.slice(offset, offset + sliceSize); var byteNumbers = new Array(slice.length); for (var i = 0; i &lt; slice.length; i++) { byteNumbers[i] = slice.charCodeAt(i); } var byteArray = new Uint8Array(byteNumbers); byteArrays.push(byteArray); } var blob = new Blob(byteArray,{type:content}) return blob; } var fileBlob = b64toBlob(compressed.substr(23),&#39;images/jepg&#39;); var formData = new FormData(); formData.append(&#39;file&#39;,fileBlob); var xhr = new XMLHttpRequest(); xhr.open(&#39;POST&#39;,&#39;upload.php&#39;); xhr.send(formData); 安全最后，请不要忘记在服务端对用户上传的文件数据进行合法性检查，毕竟黑客也可能用非浏览器上传垃圾文件或者恶意脚本。 Demo]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中的“this”是什么？]]></title>
    <url>%2F2018%2F08%2F05%2FJs%2FJavaScript%E4%B8%AD%E7%9A%84%E2%80%9Cthis%E2%80%9D%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[原文：What is “this” in JavaScript? 前言如果你曾使用JavaScript库做过开发，那么你可能已经注意到一个名为 this的特定关键字。虽然 this在JavaScript中非常常见，但是完全理解this关键字的原理以及在代码中如何使用对相当一部分的开发者来说着实不易。在这篇文章中，我将帮你深入理解 this及其工作机制。在开始之前，请确保已安装 Node。然后，打开命令行终端并运行 node 命令。 全局环境中的“this”this的工作机制理解起来并不是很容易。我们通过将 this置于不同环境下，分别来理解 this是如何工作的。首先看一下 global环境。 在全局环境中， this相当于全局对象 global。 this === global; true; 但这只在 node中才有效。如果我们将相同的代码放在js文件中运行，得到的输出为false。 如果想测试效果，可以创建一个名为 index.js的文件，包含以下代码： console.log(this === global); 然后使用 node命令运行此文件： $ node index.js false 原因是在JavaScript文件中， this等同于 module.exports而不是 global 。 函数中的“this”函数中的 this值通常是由函数的调用方来定义。因此，每次执行函数，函数内的 this值可能都不一样。 在 index.js文件中，编写一个非常简单的函数，来检查 this是否等于global对象。 function rajat() { console.log(this === global) } rajat() 如果我们使用 node运行此代码，得到的输出为 true 。如果在文件的顶部添加 “use strict”，并再次运行它，将会得到一个 false输出，因为现在的 this值为 undefined 。为了进一步解释这一点，让我们创建一个简单的函数来定义超级英雄的真实姓名和英雄名字 function Hero(heroName, realName) { this.realName = realName; this.heroName = heroName; } const superman= Hero(&quot;Superman&quot;, &quot;Clark Kent&quot;); console.log(superman); 请注意，这个函数并不是以严格模式编写的。 node运行此代码，并不会得到我们预期的“Superman”和“Clark Kent”，但它只会给我们一个 undefined 。 背后的原因是，由于函数不是以严格模式编写的， this指向global对象。如果在严格模式下运行此代码，我们会收到报错，因为JavaScript不允许将属性 realName和 heroName赋给 undefined 。其实这是一件好事，因为它阻止我们创建全局变量。 另外，以大写形式书写函数名意味着我们需要将它视为构造函数，使用 new运算符来调用。用下面的代码替换上面代码段的最后两行 onst superman = new Hero(&quot;Superman&quot;, &quot;Clark Kent&quot;); console.log(superman); 再次运行 node index.js命令，现在会得到你预期的输出。 构造函数中的“this”JavaScript没有特定的构造函数。我们所能做的就是使用 new运算符将函数调用转换为构造函数调用，如上一节所示。构造函数被调用时，会创建一个新对象并将其设置为函数的 this参数。构造函数会隐式的返回这个对象，除非我们明确的返回了另外一个对象。在 hero函数内部添加下面的 return语句： return { heroName: &quot;Batman&quot;, realName: &quot;Bruce Wayne&quot;, }; 如果我们再次运行 node命令，我们会看到 上面的 return语句覆盖了构造函数调用。 return语句不会覆盖构造函数调用的唯一情形是，return语句返回的不是一个对象。在这种情况下，对象将包含原始值。 方法中的“this”当函数作为对象的方法被调用时， this指向的是该对象，也称为函数调用的接收器(receiver)。假设 hero对象有一个 dialogue方法 ，那么 dialogue中的 this值指向 hero本身。此时的 hero也被称为 dialogue方法调用的接收者。 const hero = { heroName: &quot;Batman&quot;, dialogue() { console.log(`I am ${this.heroName}!`); } }; hero.dialogue(); 这个例子非常简单，但在实际情况中，我们的方法很难跟踪接收器。在 index.js的末尾添加以下代码段。 const saying = hero.dialogue; saying(); 如果我将 dialogue的引用存储在另一个变量中，并将该变量作为函数调用。 node运行代码 ， this将返回 undefined ，因为该方法已经丢失了接收器。 this此时指向 global ，而不是 hero 。 当我们将一个方法作为回调传递给另一个方法时，通常会丢失接收器。我们可以通过添加包装函数或使用 bind方法将 this与特定对象绑定来解决这个问题。 call() 和 apply()虽然函数的 this值是隐式设置的，我们在调用函数时也可以使用 call()和 apply()明确设置 this参数。 我们重构一下前面章节的代码片段，如下所示： function dialogue () { console.log (`I am ${this.heroName}`); } const hero = { heroName: &#39;Batman&#39;, }; 如果要将 hero对象作为 dialogue函数的接收器，我们可以这样使用 call()或 apply() ： dialogue.call(hero) // or dialogue.apply(hero) 如果你是在非严格模式下使用 call或 apply ，JavaScript引擎会忽略传递给 call或 apply的 null或 undefined （译者注：被替换为global）。这也是为什么建议始终以严格模式编写代码的原因之一。 bind()当我们将一个方法作为回调函数传递给另一个函数时，总是存在丢失方法的原有接收器的风险，使得 this参数指向全局对象。 bind()方法可以将 this参数固定的绑定到一个值上。下面的代码片段， bind会创建一个新的 dialogue函数，并将 this值设置为 hero 。（译者注：bind()方法会创建一个新函数，称为绑定函数-bound function-BF，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind()方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数。） const hero = { heroName: &quot;Batman&quot;, dialogue() { console.log(`I am ${this.heroName}`); } }; setTimeOut(hero.dialogue.bind(hero), 1000); 这样的话，即使使用 call或 apply方法也无法改变 this的值 。 箭头函数中的“this”箭头函数内的 this与其他类型的JavaScript函数有很大的不同。An arrow function uses the this value from its enclosing execution context, since it does have one of its own. 箭头函数会永久地捕获 this值，阻止 apply或 call后续更改它。 为了解释箭头函数中的 this是如何工作的，我们来写一个箭头函数： const batman = this; const bruce = () =&gt; { console.log(this === batman); }; bruce(); // true 这里，我们将 this值存储在变量中，然后将该值与箭头函数内的 this值进行比较。在终端中运行 node index.js，输出应该为 true 。 箭头函数内的 this值无法明确设置。此外，使用 call 、 apply或 bind等方法给 this传值，箭头函数会忽略。箭头函数引用的是箭头函数在创建时设置的 this值。（译者注：箭头函数中没有this绑定，必须通过查找作用域链来决定它的值，如果箭头函数被非箭头函数包裹，那么this值由外围最近一层非箭头函数决定，否则为undefined。） 箭头函数也不能用作构造函数。因此，我们也不能在箭头函数内给 this设置属性。 那么箭头函数对 this 可以做什么呢？ 箭头函数 可以使我们在回调函数中访问this 。通过下面的 counter对象来看看如何做到的： const counter = { count: 0, increase() { setInterval(function() { console.log(++this.count); }, 1000); } } counter.increase(); 使用 node index.js运行此代码，只会得到一个 NaN的列表。这是因为 this.count已经不是指向 counter对象了。它实际上指向的为 global对象。 如果想让计数器正常工作，可以使用箭头函数重写它。 回调函数使用 this与 increase方法绑定， counter现在可以正常工作了。 注意 ：不要将 ++this.count 写成 this.count + 1。后者只会增加count的值一次，每次迭代都会返回相同的值。 Class中的“this”类是JavaScript应用程序中最重要的一部分。让我们看看类中的this有何不同。 类通常包含一个 constructor ， this可以指向任何新创建的对象。 不过在作为方法时，如果该方法作为普通函数被调用， this也可以指向任何其他值。与方法一样，类也可能失去对接收器的跟踪。 我们将之前创建的 Hero函数改造为类。该类包含一个构造函数和一个 dialogue()方法。最后，创建一个类的实例并调用 dialogue方法。 class Hero { constructor(heroName) { this.heroName = heroName; } dialogue() { console.log(`I am ${this.heroName}`) } } const batman = new Hero(&quot;Batman&quot;); batman.dialogue(); 构造函数里的 this指向新创建的 类实例。当我们调用 batman.dialogue()时， dialogue()作为方法被调用， batman是它的接收器。 但是如果我们将 dialogue()方法的引用存储起来，并稍后将其作为函数调用，我们会丢失该方法的接收器，此时 this参数指向 undefined const say = batman.dialogue; say(); 出现错误的原因是JavaScript 类是隐式的运行在严格模式下的。我们是在没有任何自动绑定的情况下调用 say()函数的。要解决这个问题，我们需要手动使用 bind()将 dialogue()函数与 batman绑定在一起。 const say = batman.dialogue.bind(batman); say(); 我们也可以在 构造函数方法中做这个绑定。 总结我们需要在JavaScript中使用 this ，就像我们需要在英语中使用代词一样。以这两句话为例： Rajat loves DC Comics. Rajat also loves Marvel movies. 我们可以使用代词将这两个句子组合在一起，所以这两句话现在成了： Rajat loves DC Comics, and he also loves Marvel Comics 这个简短的语法课完美地解释了 this在JavaScript中的重要性。就像代词 he将两个句子连接在一起一样， this可以作为再次引用相同内容的捷径。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>This</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个plugin]]></title>
    <url>%2F2018%2F08%2F03%2FTools%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAplugin%2F</url>
    <content type="text"><![CDATA[前言Webpack 通过 Plugin 机制让其更加灵活，以适应各种应用场景。 在 Webpack 运行的生命周期中会广播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。 最基础的 Plugin一个最基础的 Plugin 的代码是这样的： class BasicPlugin{ // 在构造函数中获取用户给该插件传入的配置 construcor(options){ } apply(compiler){ // Webpack 会调用 BasicPlugin 实例的 apply 方法给插件实例传入 compiler 对象 compiler.plugin(&#39;compilatio&#39;,function(compilatio){ }) } } // 导出 Plugin module.exports = BasicPlugin; 在使用这个 Plugin 时，相关配置代码如下： const BasicPlugin = require(&#39;./BasicPlugin.js&#39;); module.export = { plugins:[ new BasicPlugin(options), ] } plugin工作原理Webpack 启动后，在读取配置的过程中会先执行 new BasicPlugin(options) 初始化一个 BasicPlugin 获得其实例。 在初始化 compiler 对象后，再调用 basicPlugin.apply(compiler) 给插件实例传入 compiler 对象。 插件实例在获取到 compiler 对象后，就可以通过 compiler.plugin(事件名称, 回调函数) 监听到 Webpack 广播出来的事件。 并且可以通过 compiler 对象去操作 Webpack。 通过以上最简单的 Plugin 相信你大概明白了 Plugin 的工作原理，但实际开发中还有很多细节需要注意，下面来详细介绍。 在开发 Plugin 时最常用的两个对象就是 Compiler 和 Compilation，它们是 Plugin 和 Webpack 之间的桥梁。 Compiler 和 Compilation 的含义如下： Compiler 对象包含了 Webpack 环境所有的的配置信息，包含 options，loaders，plugins 这些信息，这个对象在 Webpack 启动时候被实例化，它是全局唯一的，可以简单地把它理解为 Webpack 实例； Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。当 Webpack 以开发模式运行时，每当检测到一个文件变化，一次新的 Compilation 将被创建。Compilation 对象也提供了很多事件回调供插件做扩展。通过 Compilation 也能读取到 Compiler 对象。 Compiler 和 Compilation 的区别在于：Compiler 代表了整个 Webpack 从启动到关闭的生命周期，而 Compilation 只是代表了一次新的编译。 事件流Webpack 就像一条生产线，要经过一系列处理流程后才能将源文件转换成输出结果。 这条生产线上的每个处理流程的职责都是单一的，多个流程之间有存在依赖关系，只有完成当前处理后才能交给下一个流程去处理。 插件就像是一个插入到生产线中的一个功能，在特定的时机对生产线上的资源做处理。 Webpack 通过 Tapable 来组织这条复杂的生产线。 Webpack 在运行过程中会广播事件，插件只需要监听它所关心的事件，就能加入到这条生产线中，去改变生产线的运作。 Webpack 的事件流机制保证了插件的有序性，使得整个系统扩展性很好。 Webpack 的事件流机制应用了观察者模式，和 Node.js 中的 EventEmitter 非常相似。 Compiler 和 Compilation 都继承自 Tapable，可以直接在 Compiler 和 Compilation 对象上广播和监听事件，方法如下： /** * 广播出事件 * event-name 为事件名称，注意不要和现有的事件重名 * params 为附带的参数 */ compiler.apply(&#39;event-name&#39;,params); /** * 监听名称为 event-name 的事件，当 event-name 事件发生时，函数就会被执行。 * 同时函数中的 params 参数为广播事件时附带的参数。 */ compiler.plugin(&#39;event-name&#39;,function(params) { }); 同理，compilation.apply 和 compilation.plugin 使用方法和上面一致。 在开发插件时，你可能会不知道该如何下手，因为你不知道该监听哪个事件才能完成任务。 在开发插件时，还需要注意以下两点： 只要能拿到 Compiler 或 Compilation 对象，就能广播出新的事件，所以在新开发的插件中也能广播出事件，给其它插件监听使用。 传给每个插件的 Compiler 和 Compilation 对象都是同一个引用。也就是说在一个插件中修改了 Compiler 或 Compilation 对象上的属性，会影响到后面的插件。 有些事件是异步的，这些异步的事件会附带两个参数，第二个参数为回调函数，在插件处理完任务时需要调用回调函数通知 Webpack，才会进入下一处理流程。例如： compiler.plugin(&#39;emit&#39;,function(compilation, callback) { // 支持处理逻辑 // 处理完毕后执行 callback 以通知 Webpack // 如果不执行 callback，运行流程将会一直卡在这不往下执行 callback(); }); 常用 API读取输出资源、代码块、模块及其依赖有些插件可能需要读取 Webpack 的处理结果，例如输出资源、代码块、模块及其依赖，以便做下一步处理。 在 emit 事件发生时，代表源文件的转换和组装已经完成，在这里可以读取到最终将输出的资源、代码块、模块及其依赖，并且可以修改输出资源的内容。 插件代码如下： class Plugin { apply(compiler) { compiler.plugin(&#39;emit&#39;, function (compilation, callback) { // compilation.chunks 存放所有代码块，是一个数组 compilation.chunks.forEach(function (chunk) { // chunk 代表一个代码块 // 代码块由多个模块组成，通过 chunk.forEachModule 能读取组成代码块的每个模块 chunk.forEachModule(function (module) { // module 代表一个模块 // module.fileDependencies 存放当前模块的所有依赖的文件路径，是一个数组 module.fileDependencies.forEach(function (filepath) { }); }); // Webpack 会根据 Chunk 去生成输出的文件资源，每个 Chunk 都对应一个及其以上的输出文件 // 例如在 Chunk 中包含了 CSS 模块并且使用了 ExtractTextPlugin 时， // 该 Chunk 就会生成 .js 和 .css 两个文件 chunk.files.forEach(function (filename) { // compilation.assets 存放当前所有即将输出的资源 // 调用一个输出资源的 source() 方法能获取到输出资源的内容 let source = compilation.assets[filename].source(); }); }); // 这是一个异步事件，要记得调用 callback 通知 Webpack 本次事件监听处理结束。 // 如果忘记了调用 callback，Webpack 将一直卡在这里而不会往后执行。 callback(); }) } } 监听文件的变化在开发插件时经常需要知道是哪个文件发生变化导致了新的 Compilation，为此可以使用如下代码： // 当依赖的文件发生变化时会触发 watch-run 事件 compiler.plugin(&#39;watch-run&#39;, (watching, callback) =&gt; { // 获取发生变化的文件列表 const changedFiles = watching.compiler.watchFileSystem.watcher.mtimes; // changedFiles 格式为键值对，键为发生变化的文件路径。 if (changedFiles[filePath] !== undefined) { // filePath 对应的文件发生了变化 } callback(); }); 默认情况下 Webpack 只会监视入口和其依赖的模块是否发生变化，在有些情况下项目可能需要引入新的文件，例如引入一个 HTML 文件。 由于 JavaScript 文件不会去导入 HTML 文件，Webpack 就不会监听 HTML 文件的变化，编辑 HTML 文件时就不会重新触发新的 Compilation。 为了监听 HTML 文件的变化，我们需要把 HTML 文件加入到依赖列表中，为此可以使用如下代码： compiler.plugin(&#39;after-compile&#39;, (compilation, callback) =&gt; { // 把 HTML 文件添加到文件依赖列表，好让 Webpack 去监听 HTML 模块文件，在 HTML 模版文件发生变化时重新启动一次编译 compilation.fileDependencies.push(filePath); callback(); }) 修改输出资源有些场景下插件需要修改、增加、删除输出的资源，要做到这点需要监听 emit 事件，因为发生 emit 事件时所有模块的转换和代码块对应的文件已经生成好， 需要输出的资源即将输出，因此 emit 事件是修改 Webpack 输出资源的最后时机。 所有需要输出的资源会存放在 compilation.assets 中，compilation.assets 是一个键值对，键为需要输出的文件名称，值为文件对应的内容。 设置 compilation.assets 的代码如下： compiler.plugin(&#39;emit&#39;, (compilation, callback) =&gt; { // 设置名称为 fileName 的输出资源 compilation.assets[fileName] = { // 返回文件内容 source: () =&gt; { // fileContent 既可以是代表文本文件的字符串，也可以是代表二进制文件的 Buffer return fileContent; }, // 返回文件大小 size: () =&gt; { return Buffer.byteLength(fileContent, &#39;utf8&#39;); } }; callback(); }); 读取 compilation.assets 的代码如下： compiler.plugin(&#39;emit&#39;, (compilation, callback) =&gt; { // 读取名称为 fileName 的输出资源 const asset = compilation.assets[fileName]; // 获取输出资源的内容 asset.source(); // 获取输出资源的文件大小 asset.size(); callback(); }); 判断 Webpack 使用了哪些插件在开发一个插件时可能需要根据当前配置是否使用了其它某个插件而做下一步决定，因此需要读取 Webpack 当前的插件配置情况。 以判断当前是否使用了 ExtractTextPlugin 为例，可以使用如下代码： // 判断当前配置使用使用了 ExtractTextPlugin， // compiler 参数即为 Webpack 在 apply(compiler) 中传入的参数 function hasExtractTextPlugin(compiler) { // 当前配置所有使用的插件列表 const plugins = compiler.options.plugins; // 去 plugins 中寻找有没有 ExtractTextPlugin 的实例 return plugins.find(plugin=&gt;plugin.__proto__.constructor === ExtractTextPlugin) != null; } 实战下面我们举一个实际的例子，带你一步步去实现一个插件。 该插件的名称取名叫 EndWebpackPlugin，作用是在 Webpack 即将退出时再附加一些额外的操作，例如在 Webpack 成功编译和输出了文件后执行发布操作把输出的文件上传到服务器。 同时该插件还能区分 Webpack 构建是否执行成功。使用该插件时方法如下： module.exports = { plugins:[ // 在初始化 EndWebpackPlugin 时传入了两个参数，分别是在成功时的回调函数和失败时的回调函数； new EndWebpackPlugin(() =&gt; { // Webpack 构建成功，并且文件输出了后会执行到这里，在这里可以做发布文件操作 }, (err) =&gt; { // Webpack 构建失败，err 是导致错误的原因 console.error(err); }) ] } 要实现该插件，需要借助两个事件： done：在成功构建并且输出了文件后，Webpack 即将退出时发生； failed：在构建出现异常导致构建失败，Webpack 即将退出时发生； 实现该插件非常简单，完整代码如下： class EndWebpackPlugin { constructor(doneCallback, failCallback) { // 存下在构造函数中传入的回调函数 this.doneCallback = doneCallback; this.failCallback = failCallback; } apply(compiler) { compiler.plugin(&#39;done&#39;, (stats) =&gt; { // 在 done 事件中回调 doneCallback this.doneCallback(stats); }); compiler.plugin(&#39;failed&#39;, (err) =&gt; { // 在 failed 事件中回调 failCallback this.failCallback(err); }); } } // 导出插件 module.exports = EndWebpackPlugin; 从开发这个插件可以看出，找到合适的事件点去完成功能在开发插件时显得尤为重要。 在 5-1工作原理概括 中详细介绍过 Webpack 在运行过程中广播出常用事件，你可以从中找到你需要的事件。]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编写一个loader]]></title>
    <url>%2F2018%2F08%2F03%2FTools%2F%E7%BC%96%E5%86%99%E4%B8%80%E4%B8%AAloader%2F</url>
    <content type="text"><![CDATA[前言Loader 就像是一个翻译员，能把源文件经过转化后输出新的结果，并且一个文件还可以链式的经过多个翻译员翻译。 以处理 SCSS 文件为例： SCSS 源代码会先交给 sass-loader 把 SCSS 转换成 CSS；把 sass-loader 输出的 CSS 交给 css-loader 处理，找出 CSS 中依赖的资源、压缩 CSS 等；把 css-loader 输出的 CSS 交给 style-loader 处理，转换成通过脚本加载的 JavaScript 代码； module.exports = { module:{ rules:[ // 增加对 SCSS 文件的支持 test: /\.scss/, // SCSS 文件的处理顺序为先 sass-loader 再 css-loader 再 style-loader use:[ &#39;style.loader&#39;, { loader:&#39;css-loader&#39;, options:{ minimize:true, } }, &#39;scss-loader&#39; ], ] } } Loader 的职责由上面的例子可以看出：一个 Loader 的职责是单一的，只需要完成一种转换。 如果一个源文件需要经历多步转换才能正常使用，就通过多个 Loader 去转换。 在调用多个 Loader 去转换一个文件时，每个 Loader 会链式的顺序执行， 第一个 Loader 将会拿到需处理的原内容，上一个 Loader 处理后的结果会传给下一个接着处理，最后的 Loader 将处理后的最终结果返回给 Webpack。 所以，在你开发一个 Loader 时，请 保持其职责的单一性，你只需 关心输入和输出。由于 Webpack 是运行在 Node.js 之上的，一个 Loader 其实就是一个 Node.js 模块，这个模块需要导出一个函数。 这个导出的函数的工作就是获得处理前的原内容，对原内容执行处理后，返回处理后的内容。 一个简单的loader源码 module.exports = function(source){ // source 为 compiler 传递给 Loader 的一个文件的原内容 // 该函数需要返回处理后的内容，这里简单起见，直接把原内容返回了，相当于该 Loader 没有做任何转换 return source; } 由于 Loader 运行在 Node.js 中，你可以调用任何 Node.js 自带的 API，或者安装第三方模块进行调用： const sass = require(&#39;node-sass&#39;); module.exports = function(source) { return sass(source); }; Loader 进阶以上只是个最简单的 Loader，Webpack 还提供一些 API 供 Loader 调用，下面来一一介绍。 获得 Loader 的 options**在最上面处理 SCSS 文件的 Webpack 配置中，给 css-loader 传了 options 参数，以控制 css-loader。 如何在自己编写的 Loader 中获取到用户传入的 options 呢？需要这样做： const loaderUtils = require(&#39;loader-utils&#39;); module.exports = function(source) { // 获取到用户给当前 Loader 传入的 options const options = loaderUtils.getOptions(this); return source; }; 返回其它结果上面的 Loader 都只是返回了原内容转换后的内容，但有些场景下还需要返回除了内容之外的东西。 例如以用 babel-loader 转换 ES6 代码为例，它还需要输出转换后的 ES5 代码对应的 Source Map，以方便调试源码。 为了把 Source Map 也一起随着 ES5 代码返回给 Webpack，可以这样写： module.exports = function(source) { // 通过 this.callback 告诉 Webpack 返回的结果 this.callback(null, source, sourceMaps); // 当你使用 this.callback 返回内容时，该 Loader 必须返回 undefined， // 以让 Webpack 知道该 Loader 返回的结果在 this.callback 中，而不是 return 中 return; }; 其中的 this.callback 是 Webpack 给 Loader 注入的 API，以方便 Loader 和 Webpack 之间通信。 this.callback 的详细使用方法如下： this.callback( // 当无法转换原内容时，给 Webpack 返回一个 Error err: Error | null, // 原内容转换后的内容 content: string | Buffer, // 用于把转换后的内容得出原内容的 Source Map，方便调试 sourceMap?: SourceMap, // 如果本次转换为原内容生成了 AST 语法树，可以把这个 AST 返回， // 以方便之后需要 AST 的 Loader 复用该 AST，以避免重复生成 AST，提升性能 abstractSyntaxTree?: AST ); Source Map 的生成很耗时，通常在开发环境下才会生成 Source Map，其它环境下不用生成，以加速构建。 为此 Webpack 为 Loader 提供了 this.sourceMap API 去告诉 Loader 当前构建环境下用户是否需要 Source Map。 如果你编写的 Loader 会生成 Source Map，请考虑到这点。 同步与异步Loader 有同步和异步之分，上面介绍的 Loader 都是同步的 Loader，因为它们的转换流程都是同步的，转换完成后再返回结果。 但在有些场景下转换的步骤只能是异步完成的，例如你需要通过网络请求才能得出结果，如果采用同步的方式网络请求就会阻塞整个构建，导致构建非常缓慢。 在转换步骤是异步时，你可以这样： module.exports = function(source) { // 告诉 Webpack 本次转换是异步的，Loader 会在 callback 中回调结果 var callback = this.async(); someAsyncOperation(source, function(err, result, sourceMaps, ast) { // 通过 callback 返回异步执行后的结果 callback(err, result, sourceMaps, ast); }); }; 处理二进制数据在默认的情况下，Webpack 传给 Loader 的原内容都是 UTF-8 格式编码的字符串。 但有些场景下 Loader 不是处理文本文件，而是处理二进制文件，例如 file-loader，就需要 Webpack 给 Loader 传入二进制格式的数据。 为此，你需要这样编写 Loader： module.exports = function(source) { // 在 exports.raw === true 时，Webpack 传给 Loader 的 source 是 Buffer 类型的 source instanceof Buffer === true; // Loader 返回的类型也可以是 Buffer 类型的 // 在 exports.raw !== true 时，Loader 也可以返回 Buffer 类型的结果 return source; }; // 通过 exports.raw 属性告诉 Webpack 该 Loader 是否需要二进制数据 module.exports.raw = true; 缓存加速在有些情况下，有些转换操作需要大量计算非常耗时，如果每次构建都重新执行重复的转换操作，构建将会变得非常缓慢。 为此，Webpack 会默认缓存所有 Loader 的处理结果，也就是说在需要被处理的文件或者其依赖的文件没有发生变化时， 是不会重新调用对应的 Loader 去执行转换操作的。 如果你想让 Webpack 不缓存该 Loader 的处理结果，可以这样： module.exports = function(source) { // 关闭该 Loader 的缓存功能 this.cacheable(false); return source; }; 其它 Loader API除了以上提到的在 Loader 中能调用的 Webpack API 外，还存在以下常用 API： this.context：当前处理文件的所在目录，假如当前 Loader 处理的文件是 /src/main.js，则 this.context 就等于 /src。 this.resource：当前处理文件的完整请求路径，包括 querystring，例如 /src/main.js?name=1。 this.resourcePath：当前处理文件的路径，例如 /src/main.js。 this.resourceQuery：当前处理文件的 querystring。 this.target：等于 Webpack 配置中的 Target，详情见 2-7其它配置项-Target。 this.loadModule：当 Loader 在处理一个文件时，如果依赖其它文件的处理结果才能得出当前文件的结果时， 就可以通过 this.loadModule(request: string, callback: function(err, source, sourceMap, module)) 去获得 request 对应文件的处理结果。 this.resolve：像 require 语句一样获得指定文件的完整路径，使用方法为 resolve(context: string, &gt; * request: string, callback: function(err, result: string))。 this.addDependency：给当前处理文件添加其依赖的文件，以便再其依赖的文件发生变化时，会重新调用 Loader 处理该文件。使用方法为 addDependency(file: string)。 this.addContextDependency：和 addDependency 类似，但 addContextDependency 是把整个目录加入到当前正在处理文件的依赖中。使用方法为 addContextDependency(directory: string)。 this.clearDependencies：清除当前正在处理文件的所有依赖，使用方法为 clearDependencies()。 this.emitFile：输出一个文件，使用方法为 emitFile(name: string, content: Buffer|string, sourceMap: {…})。 加载本地 Loader在开发 Loader 的过程中，为了测试编写的 Loader 是否能正常工作，需要把它配置到 Webpack 中后，才可能会调用该 Loader。 在前面的章节中，使用的 Loader 都是通过 Npm 安装的，要使用 Loader 时会直接使用 Loader 的名称，代码如下： module.exports = { module: { rules: [ { test: /\.css/, use: [&#39;style-loader&#39;], }, ] }, }; 如果还采取以上的方法去使用本地开发的 Loader 将会很麻烦，因为你需要确保编写的 Loader 的源码是在 node_modules 目录下。 为此你需要先把编写的 Loader 发布到 Npm 仓库后再安装到本地项目使用。 Npm linkNpm link 专门用于开发和调试本地 Npm 模块，能做到在不发布模块的情况下，把本地的一个正在开发的模块的源码链接到项目的 node_modules 目录下，让项目可以直接使用本地的 Npm 模块。 由于是通过软链接的方式实现的，编辑了本地的 Npm 模块代码，在项目中也能使用到编辑后的代码。 完成 Npm link 的步骤如下： 确保正在开发的本地 Npm 模块（也就是正在开发的 Loader）的 package.json 已经正确配置好；在本地 Npm 模块根目录下执行 npm link，把本地模块注册到全局；在项目根目录下执行 npm link loader-name，把第2步注册到全局的本地 Npm 模块链接到项目的 node_moduels 下，其中的 loader-name 是指在第1步中的 package.json 文件中配置的模块名称。链接好 Loader 到项目后你就可以像使用一个真正的 Npm 模块一样使用本地的 Loader 了。 ResolveLoader曾介绍过 ResolveLoader 用于配置 Webpack 如何寻找 Loader。 默认情况下只会去 node_modules 目录下寻找，为了让 Webpack 加载放在本地项目中的 Loader 需要修改 resolveLoader.modules。 假如本地的 Loader 在项目目录中的 ./loaders/loader-name 中，则需要如下配置： module.exports = { resolveLoader:{ // 去哪些目录下寻找 Loader，有先后顺序之分 modules: [&#39;node_modules&#39;,&#39;./loaders/&#39;], } } 加上以上配置后， Webpack 会先去 node_modules 项目下寻找 Loader，如果找不到，会再去 ./loaders/ 目录下寻找。 实战上面讲了许多理论，接下来从实际出发，来编写一个解决实际问题的 Loader。 该 Loader 名叫comment-require-loader，作用是把 JavaScript 代码中的注释语法 // @require &#39;../style/index.css&#39; 转换成 require(&#39;../style/index.css&#39;); 该 Loader 的使用场景是去正确加载针对 Fis3编写的 JavaScript，这些 JavaScript 中存在通过注释的方式加载依赖的 CSS 文件。 该 Loader 的使用方法如下： module.exports = { module: { rules: [ { test: /\.js$/, use: [&#39;comment-require-loader&#39;], // 针对采用了 fis3 CSS 导入语法的 JavaScript 文件通过 comment-require-loader 去转换 include: [path.resolve(__dirname, &#39;node_modules/imui&#39;)] } ] } }; 该 Loader 的实现非常简单，完整代码如下： function replace(source) { // 使用正则把 // @require &#39;../style/index.css&#39; 转换成 require(&#39;../style/index.css&#39;); return source.replace(/(\/\/ *@require) +((&#39;|&quot;).+(&#39;|&quot;)).*/, &#39;require($2);&#39;); } module.exports = function (content) { return replace(content); };]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack原理及实现]]></title>
    <url>%2F2018%2F08%2F03%2F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2Fwebpack%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[工作原理概括Webpack 以其使用简单著称，在使用它的过程中，使用者只需把它当作一个黑盒，需要关心的只有它暴露出来的配置。 本节将带你走进这个黑盒，看看 Webpack 是如何运行的。 基本概念 在了解 Webpack 原理前，需要掌握以下几个核心概念，以方便后面的理解： entry: 入口，Webpack 执行构建的第一步将从 Entry 开始，可抽象成输入。 module: 模块，在 Webpack 里一切皆模块，一个模块对应着一个文件。Webpack 会从配置的 Entry 开始递归找出所有依赖的模块。 chunk: 代码块，一个 Chunk 由多个模块组合而成，用于代码合并与分割。 loader: 模块转换器，用于把模块原内容按照需求转换成新内容。 plugins: 扩展插件，在 Webpack 构建流程中的特定时机会广播出对应的事件，插件可以监听这些事件的发生，在特定时机做对应的事情。 流程概括 Webpack 的运行流程是一个串行的过程，从启动到结束会依次执行以下流程： 1.初始化参数：从配置文件和 Shell 语句中读取与合并参数，得出最终的参数；2.开始编译：用上一步得到的参数初始化 Compiler 对象，加载所有配置的插件，执行对象的 run 方法开始执行编译；3.确定入口：根据配置中的 entry 找出所有的入口文件；4.编译模块：从入口文件出发，调用所有配置的 Loader 对模块进行翻译，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；5.完成模块编译：在经过第4步使用 Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系；6.输出资源：根据入口和模块之间的依赖关系，组装成一个个包含多个模块的 Chunk，再把每个 Chunk 转换成一个单独的文件加入到输出列表，这步是可以修改输出内容的最后机会；7.输出完成：在确定好输出内容后，根据配置确定输出的路径和文件名，把文件内容写入到文件系统。 在以上过程中，Webpack 会在特定的时间点广播出特定的事件，插件在监听到感兴趣的事件后会执行特定的逻辑，并且插件可以调用 Webpack 提供的 API 改变 Webpack 的运行结果 流程细节 Webpack 的构建流程可以分为以下三大阶段： 1.初始化：启动构建，读取与合并配置参数，加载 Plugin，实例化 Compiler。2.编译：从 Entry 发出，针对每个 Module 串行调用对应的 Loader 去翻译文件内容，再找到该 Module 依赖的 Module，递归地进行编译处理。3.输出：对编译后的 Module 组合成 Chunk，把 Chunk 转换成文件，输出到文件系统。 如果只执行一次构建，以上阶段将会按照顺序各执行一次。但在开启监听模式下，流程将变为如下： 在每个大阶段中又会发生很多事件，Webpack 会把这些事件广播出来供给 Plugin 使用，下面来一一介绍。 初始化阶段 事件名 解释 初始化参数 从配置文件和 Shell 语句中读取与合并参数，得出最终的参数。 这个过程中还会执行配置文件中的插件实例化语句 new Plugin()。 实例化 Compiler用上一步得到的参数初始化 Compiler 实例，Compiler 负责文件监听和启动编译。Compiler 实例中包含了完整的 Webpack 配置，全局只有一个 Compiler 实例。 加载插件 依次调用插件的 apply 方法，让插件可以监听后续的所有事件节点。同时给插件传入 compiler 实例的引用，以方便插件通过 compiler 调用 Webpack 提供的 API。 environment 开始应用 Node.js 风格的文件系统到 compiler 对象，以方便后续的文件寻找和读取。 entry-option 读取配置的 Entrys，为每个 Entry 实例化一个对应的 EntryPlugin，为后面该 Entry 的递归解析工作做准备。 after-plugins 调用完所有内置的和配置的插件的 apply 方法。 after-resolvers 根据配置初始化完 resolver，resolver 负责在文件系统中寻找指定路径的文件。 编译阶段 事件名 解释 run 启动一次新的编译。 watch-run 和 run 类似，区别在于它是在监听模式下启动的编译，在这个事件中可以获取到是哪些文件发生了变化导致重新启动一次新的编译。 compile 该事件是为了告诉插件一次新的编译将要启动，同时会给插件带上 compiler 对象。 compilation 当 Webpack 以开发模式运行时，每当检测到文件变化，一次新的 Compilation 将被创建。一个 Compilation 对象包含了当前的模块资源、编译生成资源、变化的文件等。Compilation 对象也提供了很多事件回调供插件做扩展。 make 一个新的 Compilation 创建完毕，即将从 Entry 开始读取文件，根据文件类型和配置的 Loader 对文件进行编译，编译完后再找出该文件依赖的文件，递归的编译和解析。 after-compile 一次 Compilation 执行完成。 invalid 当遇到文件不存在、文件编译错误等异常时会触发该事件，该事件不会导致 Webpack 退出。 在编译阶段中，最重要的要数 compilation 事件了，因为在 compilation 阶段调用了 Loader 完成了每个模块的转换操作，在 compilation 阶段又包括很多小的事件，它们分别是： 事件名 解释 build-module 使用对应的 Loader 去转换一个模块。 normal-module-loader 在用 Loader 对一个模块转换完后，使用 acorn 解析转换后的内容，输出对应的抽象语法树（AST），以方便 Webpack 后面对代码的分析。 program 从配置的入口模块开始，分析其 AST，当遇到 require 等导入其它模块语句时，便将其加入到依赖的模块列表，同时对新找出的依赖模块递归分析，最终搞清所有模块的依赖关系。 seal 所有模块及其依赖的模块都通过 Loader 转换完成后，根据依赖关系开始生成 Chunk。 输出阶段 事件名 解释 should-emit 所有需要输出的文件已经生成好，询问插件哪些文件需要输出，哪些不需要。 emit 确定好要输出哪些文件后，执行文件输出，可以在这里获取和修改输出内容。 after-emit 文件输出完毕。 done 成功完成一次完成的编译和输出流程。 failed 如果在编译和输出流程中遇到异常导致 Webpack 退出时，就会直接跳转到本步骤，插件可以在本事件中获取到具体的错误原因。 在输出阶段已经得到了各个模块经过转换后的结果和其依赖关系，并且把相关模块组合在一起形成一个个 Chunk。 在输出阶段会根据 Chunk 的类型，使用对应的模版生成最终要要输出的文件内容。 原文地址]]></content>
      <categories>
        <category>原理及实现</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用 Intersection Observer 实现图片延迟加载]]></title>
    <url>%2F2018%2F08%2F01%2FHTTP%2F%E4%BD%BF%E7%94%A8-Intersection-Observer-%E5%AE%9E%E7%8E%B0%E5%9B%BE%E7%89%87%E5%BB%B6%E8%BF%9F%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[延迟加载有什么大不了的？延迟加载图片的目的在于，在发出对应的网络请求之前你要一直等到用户滚动页面让图片进入可见区域。如果你的网页包括了多张图片，但你只在每张图片滚动到视区时才加载，你将最终会节省带宽并确保你的网页加载的更快。 为了让你在实际中了解这一点，让我们想象下面这个页面，他有三张图片。 如果用户访问页面时仅看到了第一张图，我们并不想加载网页底部的比萨图片，除非用户向下滚动直到图片真正进入视区。如果我们延迟加载图片，这意味着用户只在他们需要时下载他们需要的东西，这让你的网页更加精简。 对于更有经验的开发者，你也许很熟悉延迟加载图片，毕竟这个概念已经有了一段时间。那么有什么新东西呢？！现在有很多延迟加载库可以完成这项工作. 问题在于，几乎所有这些库都是利用滚动事件或者使用定时器来检查一个元素是否在视区内。这个方法的问题是它强制浏览器重新布局整个页面，而且在特定条件下会导致你的网站卡顿（jank）。我们可以做的更好！ 救星 Intersection Observer！这就是 Intersection Observer 的用武之地。Intersection Observer 内置于大多数现代浏览器，可以让你知道一个被观察元素何时进入或离开了浏览器视口。这使得它很理想，因为它可以异步传输数据，并且不会影响主线程，这让它成为一个提供反馈的有效手段。 在 Paul 的示例中，它展示了如何使用Intersection Observer 来实现当图片进入视口时延迟加载。我使用了他的初始代码，并稍作修改让它更容易理解。在这篇文章中，我将过一遍 Intersection Observer 的基础知识并向你展示你该如何用一个超级高效的方法来延迟加载图片。 入门想象一个有三张图片的基本的 HTML 页面，就像上面那个一样，在这个网页上，你将有如下代码的图片元素： &lt;img class=&quot;js-lazy-image&quot; data-src=&quot;burger.png&quot;&gt; 你也许注意到上面的代码中，图片文件没有 src 属性么。这是因为它使用了称为 data-src 的 data 属性来指向图片源。我们将使用这来加载图片，当它们进入视口时。你也许还注意到图片元素还有一个称为 js-lazy-image 的 class —— 我们将很快在 JavaScript 代码中用它来确定我们想延迟加载的元素。 接下来，我们需要创建延迟加载页面中图片的代码。在我们的 JavaScript 文件中（需要在页面中引用），我们需要创建一个新的 Intersection Observer。 上面的示例中看起来像是一堆代码，让我们一步一步来分解。首先，我选择了页面中所有包含 js-lazy-image 类的图片。然后我创建了一个新的 IntersectionObserver，并用它来观察所有我们已经选择的带有 js-lazy-image 类的图片。使用 IntersectionObserver 的默认选项，你的回调会在元素部分进入视区和完全离开视口时被调用。在这个例子中，我会传递一些额外的配置选项给 IntersectionObserver。使用 rootMargin 允许你指定根元素的 margin 值，让你可以扩展或者缩减 intersections 的使用区域。我们想确保如果图片进入了 Y 轴的 50px 内，我们将开始下载。 现在我们已经创建了一个 Intersection Observer 并且正在观察页面上的图片，我们现在来了解 intersection 事件，它将在元素进入视区时触发。 在上面的代码中，每当我们正在观察的元素进入到用户视口内，onIntersection 函数将被触发。此时，我们可以循环我们所观察的图片并确定哪一个在视口中。如果当前元素处在交叉比例（intersection ratio）之中，我们就知道这图片在用户视口之中并且我们可以加载它了。一旦图片加载完毕，我们不在需要观察它，使用 unobserve() 将它从 Intersection Observer 的观察列表中移除。 就是这样！一旦用户滚动并且图片进入视区，对应的图片将被加载。这个代码最棒的地方在于 Intersection Observer 比 Barry White 更加流畅。 浏览器支持Firefox、Chrome 和 Opera 支持，这是一个好消息。 然而，为了确保我们的代码不会在不支持它的浏览器中造成破坏，我们可以使用特性检测来确定我们应该如何来加载图片。让我们看看下面的代码。 在上面的代码中，我们检查了 IntersectionObserver 是否在当前浏览器中可用，如果不可用我们就立即加载这些图片，否则使用我们的默认行为。 如果你真的喜欢 Intersection Observer API 的易用性并想使用 polyfill 来替代。WICG 创建了一个放在了他们的 Github 仓库。唯一的缺点是你无法获取到原生实现给你带来的性能优势。 你甚至可以更进一步，像 Robin Osborne 建议的那样，为不启用 JavaScript 的用户添加支持。 总结在这篇文章汇总，我们使用 Intersection Observer 来延迟加载图片，但你可以用它来做的更多。它可以用于判断某人是否正在查看广告，或者甚至是 iFrame 中的元素是否在视区中。易于理解的 API 使它获得了更多的可能性。 如果你想学习更多关于 Intersection Observer 的信息，我推荐阅读 Google Developers 网站上 这篇内容丰富的文章。我也强烈推荐观看 Youtube 上 Paul Lewis 的视频系列，它包含了许多很棒的技巧，你绝对会学到些东西。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>懒加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fetch使用的常见问题及解决办法]]></title>
    <url>%2F2018%2F07%2F27%2Fstudy%2Ffetch%E4%BD%BF%E7%94%A8%E7%9A%84%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前言说道fetch就不得不提XMLHttpRequest了，XHR在发送web请求时需要开发者配置相关请求信息和成功后的回调，尽管开发者只关心请求成功后的业务处理，但是也要配置其他繁琐内容，导致配置和调用比较混乱，也不符合关注分离的原则；fetch的出现正是为了解决XHR存在的这些问题。例如下面代码： fetch(url).then(function(response){ return response.json(); }).then(function(data){ console.log(data) }).catch(function(e){ console.log(&quot;Oops,error&quot;) }) 上面这段代码让开发者只关注请求成功后的业务逻辑处理，其他的不用关心，相当简单；也比较符合现代Promise形式，比较友好。 fetch是基于Promise设计的，从上面代码也能看得出来，这就要求fetch要配合Promise一起使用。正是这种设计，fetch所带来的优点正如【传统 Ajax 已死，Fetch 永生总结】的一样： 语法简单，更加语义化 基于标准的Promise实现，支持async/await 使用isomorphic-fetch可以方便同构 不过话说回来，fetch虽然有很多优点，但是使用fetch来进行项目开发时，也是有一些常见问题的，下面就来说说fetch使用的常见问题。 fetch兼容性fetch是相对较新的技术，当然就会存在浏览器兼容性的问题，借用上面应用文章的一幅图加以说明fetch在各种浏览器的原生支持情况： 从上图可以看出，在各个浏览器低版本的情况下都是不被支持的。 那么问题来了，如何在所有浏览器中通用fetch呢，当然就要考虑fetch的polyfill了。上面说过，fetch是基于Promise来实现的，所以在低版本浏览器中Promise可能也未被原生支持，所以还需要Promise的polyfill；大多数情况下，实现fetch的polyfill需要涉及到的： promise的polyfill，例如es6-promise、babel-polyfill提供的promise实现。 fetch的polyfill实现，例如isomorphic-fetch和whatwg-fetch 这样是否就可以安全的使用fetch来进行前后端通信了？上面说了在大多数情况下是这样，但是IE8/9则比较特殊：IE8它使用的是ES3，而IE9则对ES5部分支持。这种情况下还需要ES5的polyfill es5-shim支持了。 上述有关promise的polyfill实现，需要说明的是： babel-runtime是不能作为Promise的polyfill的实现的，否则在IE8/9下使用fetch会报Promise未定义。为什么？我想大家猜到了，因为babel-runtime实现的polyfill是局部实现而不是全局实现，fetch底层实现用到Promise就是从全局中去取的，拿不到这报上述错误。 另外，顺便补充一下fetch的polyfill实现思路是： 首先判断浏览器是否原生支持fetch，否则结合Promise使用XMLHttpRequest的方式来实现；这正是whatwg-fetch的实现思路，而同构应用中使用的isomorphic-fetch，其客户端fetch的实现是直接require whatwg-fetch来实现的。 fetch默认不携带cookiefetch发送请求默认是不发送cookie的，不管是同域还是跨域；那么问题就来了，对于那些需要权限验证的请求就可能无法正常获取数据，这时可以配置其credentials项，其有3个值： omit: 默认值，忽略cookie的发送 same-origin: 表示cookie只能同域发送，不能跨域发送 include: cookie既可以同域发送，也可以跨域发送 credentials所表达的含义，其实与XHR2中的withCredentials属性类似，表示请求是否携带cookie；具体可以参考阮一峰老师的跨域资源共享 CORS 详解中withCredentials一节的介绍； 这样，若要fetch请求携带cookie信息，只需设置一下credentials选项即可，例如 fetch(url, {credentials: &#39;include&#39;}); 另外补充一点： fetch默认对服务端通过Set-Cookie头设置的cookie也会忽略，若想选择接受来自服务端的cookie信息，也必须要配置credentials选项； fetch请求对某些错误http状态不会reject主要是由fetch返回promise导致的，因为fetch返回的promise在某些错误的http状态下如 400、500等不会reject，相反它会被resolve；只有网络错误会导致请求不能完成时，fetch 才会被 reject；所以一般会对fetch请求做一层封装，例如下面代码所示： function checkStatus(response) { if (response.status &gt;= 200 &amp;&amp; response.status &lt; 300) { return response; } const error = new Error(response.statusText); error.response = response; throw error; } function parseJSON(response) { return response.json(); } export default function request(url, options) { let opt = options||{}; return fetch(url, {credentials: &#39;include&#39;, ...opt}) .then(checkStatus) .then(parseJSON) .then((data) =&gt; ( data )) .catch((err) =&gt; ( err )); } fetch不支持超时timeout处理用过fetch的都知道，fetch不像大多数ajax库那样对请求设置超时timeout，它没有有关请求超时的feature，这一点比较蛋疼。所以在fetch标准添加超时feature之前，都需要polyfill该特性。 实际上，我们真正需要的是abort(), timeout可以通过timeout+abort方式来实现，起到真正超时丢弃当前的请求。 而在目前的fetch指导规范中，fetch并不是一个具体实例，而只是一个方法；其返回的promise实例根据Promise指导规范标准是不能abort的，也不能手动改变promise实例的状态，只能由内部来根据请求结果来改变promise的状态。 既然不能手动控制fetch方法执行后返回的promise实例状态，那么是不是可以创建一个可以手动控制状态的新Promise实例呢。所以： 实现fetch的timeout功能，其思想就是新创建一个可以手动控制promise状态的实例，根据不同情况来对新promise实例进行resolve或者reject，从而达到实现timeout的功能； 目前可以有两种不同的解决方法： 第一种：单纯setTimeout方式 var oldFetchfn = fetch; //拦截原始的fetch方法 window.fetch = function(input, opts){//定义新的fetch方法，封装原有的fetch方法 return new Promise(function(resolve, reject){ var timeoutId = setTimeout(function(){ reject(new Error(&quot;fetch timeout&quot;)) }, opts.timeout); oldFetchfn(input, opts).then( res=&gt;{ clearTimeout(timeoutId); resolve(res) }, err=&gt;{ clearTimeout(timeoutId); reject(err) } ) }) } 上面方法可以模拟xhr的abort()功能 var oldFetch = fetch; window.fetch = function(input, opts){ return new promise(function(resolve,reject){ var abort_promise = function(){ reject(new Error(&quot;fetch abort&quot;)); } var p = oldFetchfn(input, opts).then(resolve, reject); p.abort = abort_promise; return p; }) } 方法二：利用Promise.race方法 Promise.race方法接受一个promise实例数组参数，表示多个promise实例中任何一个最先改变状态，那么race方法返回的promise实例状态就跟着改变，具体可以参考这里。 var oldFetchfn = fetch; //拦截原始的fetch方法 window.fetch = function(input, opts){//定义新的fetch方法，封装原有的fetch方法 var fetchPromise = oldFetchfn(input, opts); var timeoutPromise = new Promise(function(resolve, reject){ setTimeout(()=&gt;{ reject(new Error(&quot;fetch timeout&quot;)) }, opts.timeout) }); retrun Promise.race([fetchPromise, timeoutPromise]) } 最后，对fetch的timeout的上述实现方式补充几点： timeout不是请求连接超时的含义，它表示请求的response时间，包括请求的连接、服务器处理及服务器响应回来的时间； fetch的timeout即使超时发生了，本次请求也不会被abort丢弃掉，它在后台仍然会发送到服务器端，只是本次请求的响应内容被丢弃而已； fetch不支持jsonpfetch是与服务器端进行异步交互的，而JSONP是 外链一个javascript资源，并不是真正ajax，所以fetch与JSONP没有什么直接关联，当然至少目前是不支持JSONP的。 这里我们把JSONP与fetch关联在一起有点差强人意，fetch只是一个ajax库，我们不可能使fetch支持JSONP；只是我们要实现一个JSONP，只不过这个JSONP的实现要与fetch的实现类似，即基于Promise来实现一个JSONP；而其外在表现给人感觉是fetch支持JSONP一样； 目前比较成熟的开源JSONP实现fetch-jsonp给我们提供了解决方案，想了解可以自行前往。不过再次想唠叨一下其JSONP的实现步骤，因为在本人面试的前端候选人中大部分人对JSONP的实现语焉不详； 使用它非常简单，首先需要用npm安装fetch-jsonp npm install fetch-jsonp --save-dev 然后在像下面一样使用： fetchJsonp(fetchJsonp(&#39;/users.jsonp&#39;, { timeout: 3000, jsonpCallback: &#39;custom_callback&#39; }) .then(function(response) { return response.json() }).catch(function(ex) { console.log(&#39;parsing failed&#39;, ex) }) fetch不支持progress事件XHR是原生支持progress事件的，例如下面代码这样： var xhr = new XMLHttpRequest() xhr.open(&#39;POST&#39;, &#39;/uploads&#39;) xhr.onload = function() {} xhr.onerror = function() {} function updateProgress (event) { if (event.lengthComputable) { var percent = Math.round((event.loaded / event.total) * 100) console.log(percent) } xhr.upload.onprogress =updateProgress; //上传的progress事件 xhr.onprogress = updateProgress; //下载的progress事件 } xhr.send(); 但是fetch是不支持有关progress事件的；不过可喜的是，根据fetch的指导规范标准，其内部设计实现了Request和Response类；其中Response封装一些方法和属性，通过Response实例可以访问这些方法和属性，例如response.json()、response.body等等； 值得关注的地方是，response.body是一个可读字节流对象，其实现了一个getRender()方法，其具体作用是： getRender()方法用于读取响应的原始字节流，该字节流是可以循环读取的，直至body内容传输完成； 因此，利用到这点可以模拟出fetch的progress,代码实现如下 // fetch() returns a promise that resolves once headers have been received fetch(url).then(response =&gt; { // response.body is a readable stream. // Calling getReader() gives us exclusive access to the stream&#39;s content var reader = response.body.getReader(); var bytesReceived = 0; // read() returns a promise that resolves when a value has been received reader.read().then(function processResult(result) { // Result objects contain two properties: // done - true if the stream has already given you all its data. // value - some data. Always undefined when done is true. if (result.done) { console.log(&quot;Fetch complete&quot;); return; } // result.value for fetch streams is a Uint8Array bytesReceived += result.value.length; console.log(&#39;Received&#39;, bytesReceived, &#39;bytes of data so far&#39;); // Read some more, and call this function again return reader.read().then(processResult); }); }); 另外，github上也有使用Promise+XHR结合的方式实现类fetch的progress效果(当然这跟fetch完全不搭边）可以参考这里，具体代码如下： function fetchProgress(url, opts={}, onProgress){ return new Promise(funciton(resolve, reject){ var xhr = new XMLHttpRequest(); xhr.open(opts.method || &#39;get&#39;, url); for(var key in opts.headers || {}){ xhr.setRequestHeader(key, opts.headers[key]); } xhr.onload = e =&gt; resolve(e.target.responseText) xhr.onerror = reject; if (xhr.upload &amp;&amp; onProgress){ xhr.upload.onprogress = onProgress; //上传 } if (&#39;onprogerss&#39; in xhr &amp;&amp; onProgress){ xhr.onprogress = onProgress; //下载 } xhr.send(opts.body) }) } fetchProgress(&#39;/upload&#39;).then(console.log) fetch跨域问题既然是ajax库，就不可避免与跨域扯上关系；XHR2是支持跨域请求的，只不过要满足浏览器端支持CORS，服务器通过Access-Control-Allow-Origin来允许指定的源进行跨域，仅此一种方式。 与XHR2一样，fetch也是支持跨域请求的，只不过其跨域请求做法与XHR2一样，需要客户端与服务端支持；另外，fetch还支持一种跨域，不需要服务器支持的形式，具体可以通过其mode的配置项来说明。 fetch的mode配置项有3个值，如下： same-origin：该模式是不允许跨域的，它需要遵守同源策略，否则浏览器会返回一个error告知不能跨域；其对应的response type为basic。 cors: 该模式支持跨域请求，顾名思义它是以CORS的形式跨域；当然该模式也可以同域请求不需要后端额外的CORS支持；其对应的response type为cors。 no-cors: 该模式用于跨域请求但是服务器不带CORS响应头，也就是服务端不支持CORS；这也是fetch的特殊跨域请求方式；其对应的response type为opaque。 针对跨域请求，cors模式是常见跨域请求实现，但是fetch自带的no-cors跨域请求模式则较为陌生，该模式有一个比较明显的特点： 该模式允许浏览器发送本次跨域请求，但是不能访问响应返回的内容，这也是其response type为opaque透明的原因。 这与&lt;img/&gt;发送的请求类似，只是该模式不能访问响应的内容信息；但是它可以被其他APIs进行处理，例如ServiceWorker。另外，该模式返回的repsonse可以在Cache API中被存储起来以便后续的对它的使用，这点对script、css和图片的CDN资源是非常合适的，因为这些资源响应头中都没有CORS头。 总的来说，fetch的跨域请求是使用CORS方式，需要浏览器和服务端的支持。]]></content>
      <tags>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模块化 --- Commonjs、AMD、CMD、ES6 modules]]></title>
    <url>%2F2018%2F07%2F25%2Fstudy%2FJavaScript%E6%A8%A1%E5%9D%97%E5%8C%96-Commonjs%E3%80%81AMD%E3%80%81CMD%E3%80%81ES6-modules%2F</url>
    <content type="text"><![CDATA[前言随着前端js代码复杂度的提高，JavaScript模块化这个概念便被提出来，前端社区也不断地实现前端模块化，直到es6对其进行了规范，下面就介绍JavaScript模块化。 JavaScript模块化是如何一步一步地发展起来的，并且也会主要对这些模块化方式做一个简单的比较。 第一阶段：无模块化JavaScript最初的作用仅仅是验证表单，后来会添加一些动画，但是这些js代码很多在一个文件中就可以完成了，所以，我们只需要在html文件中添加一个script标签。 后来，随着前端复杂度提高，为了能够提高项目代码的可读性、可扩展性等，我们的js文件逐渐多了起来，不再是一个js文件就可以解决的了，而是把每一个js文件当做一个模块。那么，这时的js引入方式是怎样的呢？大概是下面这样： &lt;script src=&quot;jquery.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;jquery_scroller.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;main.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;other1.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;other2.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;other3.js&quot;&gt;&lt;/script&gt; 即简单的将所有的js文件统统放在一起。但是这些文件的顺序还不能出错，比如jquery需要先引入，才能引入jquery插件，才能在其他的文件中使用jquery。 优点 相比于使用一个js文件，这种多个js文件实现最简单的模块化的思想是进步的 缺点 污染全局作用域。 因为每一个模块都是暴露在全局的，简单的使用，会导致全局变量命名冲突，当然，我们也可以使用命名空间的方式来解决。对于大型项目，各种js很多，开发人员必须手动解决模块和代码库的依赖关系，后期维护成本较高。依赖关系不明显，不利于维护。 比如main.js需要使用jquery，但是，从上面的文件中，我们是看不出来的，如果jquery忘记了，那么就会报错。 第二阶段： CommonJS规范CommonJS就是一个JavaScript模块化的规范，该规范最初是用在服务器端的node的，前端的webpack也是对CommonJS原生支持的。 根据这个规范，每一个文件就是一个模块，其内部定义的变量是属于这个模块的，不会对外暴露，也就是说不会污染全局变量。 CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。如下所示 // a.js var x = 5; var addX = function (value) { return value + x; }; module.exports.x = x; module.exports.addX = addX; 这里的a.js就是一个CommonJS规范的模块了。 这里的module就代表了这个模块，module的exports属性就是对外暴露的接口，可以对外导出外部可以访问的变量，比如这里的x和addX。 exports 是对 module.exports 的引用。比如我们可以认为在一个模块的顶部有这句代码： export = export.Module; 所以，我们不能直接给exports赋值，比如number、function等。 然后我们就可以在其他模块中引入这个模块使用了： var a = require(&#39;./a.js&#39;); console.log(example.x); // 5 console.log(example.addX(1)); // 6 这里的require就会获取到a.js所暴露的module.exports变量，然后就可以使用其暴露的x和addX了。 优点： CommonJS规范在服务器端率先完成了JavaScript的模块化，解决了依赖、全局变量污染的问题，这也是js运行在服务器端的必要条件。 缺点： 此文主要是浏览器端js的模块化， 由于 CommonJS 是同步加载模块的，在服务器端，文件都是保存在硬盘上，所以同步加载没有问题，但是对于浏览器端，需要将文件从服务器端请求过来，那么同步加载就不适用了，所以，CommonJS是不适用于浏览器端的。 第三阶段： AMD规范之前提到: CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，所以CommonJS规范比较适用。但是，如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器端一般采用AMD规范。而AMD规范的实现，就是大名鼎鼎的require.js了 AMD标准中，定义了下面两个API： 1.require([module], callback) 2.define(id, [depends], callback) 即通过define来定义一个模块，然后使用require来加载一个模块。 并且，require还支持CommonJS的模块导出方式。 定义alert模块： define(function () { var alertName = function (str) { alert(&quot;I am &quot; + str); } var alertAge = function (num) { alert(&quot;I am &quot; + num + &quot; years old&quot;); } return { alertName: alertName, alertAge: alertAge }; }); 引入模块： require([&#39;alert&#39;], function (alert) { alert.alertName(&#39;JohnZhu&#39;); alert.alertAge(21); }); 但是，在使用require.js的时候，我们必须要 提前加载所有的依赖，然后才可以使用，而不是需要使用时再加载。 优点： 适合在浏览器环境中异步加载模块。可以并行加载多个模块。 缺点： 提高了开发成本，并且不能按需加载，而是必须提前加载所有的依赖。 第四阶段：CMD规范CMD规范是阿里的玉伯提出来的，实现js库为sea.js。 它和requirejs非常类似，即一个js文件就是一个模块，但是CMD的加载方式更加优秀，是通过按需加载的方式，而不是必须在模块开始就加载所有的依赖。如下： define(function(require, exports, module) { var $ = require(&#39;jquery&#39;); var Spinning = require(&#39;./spinning&#39;); exports.doSomething = ... module.exports = ... }) 优点： 同样实现了浏览器端的模块化加载。可以按需加载，依赖就近。 缺点： 依赖SPM打包，模块的加载逻辑偏重。 其实，这时我们就可以看出 AMD和CMD的区别了，前者是对于依赖的模块提前执行，而后者是延迟执行。 前者推崇依赖前置，而后者推崇依赖就近，即只在需要用到某个模块的时候再require。 如下： // AMD define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() //... }); // CMD define(function(require, exports, module) { var a = require(&#39;./a&#39;) a.doSomething() //此处略去100行 varb=require(&#39;./b&#39;) //依赖可以就近书写 b.doSomething() //... }); 第五阶段： ES6模块化之前的几种模块化方案都是前端社区自己实现的，只是得到了大家的认可和广泛使用，而ES6的模块化方案是真正的规范。 在ES6中，我们可以使用 import 关键字引入模块，通过 export 关键字导出模块，功能较之于前几个方案更为强大，也是我们所推崇的. 但是由于ES6目前无法在浏览器中执行，所以，我们只能通过babel将不被支持的import编译为当前受到广泛支持的 require。 虽然目前import和require的区别不大，但是还是推荐使用使用es6，因为未来es6必定是主流，对于代码的迁移成本还是非常容易的。 如： import store from &#39;../store/index&#39; import {mapState, mapMutations, mapActions} from &#39;vuex&#39; import axios from &#39;../assets/js/request&#39; import util from &#39;../utils/js/util.js&#39; export default { created () { this.getClassify(); this.RESET_VALUE(); console.log(&#39;created&#39; ,new Date().getTime()); } 第六阶段： UMD通过一层自执行函数来兼容各种模块化规范的写法，兼容 AMD / CMD / CommonJS 等模块化规范，贴上代码胜过千言万语，需要特别注意的是 ES Module 由于会对静态代码进行分析，故这种运行时的方案无法使用，此时通过 CommonJS 进行兼容； (function (global, factory) { if (typeof exports === &#39;object&#39;) { module.exports = factory(); } else if (typeof define === &#39;function&#39; &amp;&amp; define.amd) { define(factory); } else { this.eventUtil = factory(); } })(this, function (exports) { ​ // Define Module Object.defineProperty(exports, &quot;__esModule&quot;, { value: true }); exports.default = 42; }); 构建工具中的实现为了模块化在浏览器中实现，我们可以借助一些模块化打包工具进行打包(以webpack为例)，定义了项目入口之后，会先快速地进行依赖的分析，然后将所有依赖的模块转换成浏览器兼容的对应模块化规范的实现； 模块化的基础从上面的介绍中，我们已经对其规范和实现有了一定的了解；在浏览器中，要实现 CommonJS 规范，只需要实现 module / exports / require / global 这几个属性，由于浏览器中是无法访问文件系统的，因此 require 过程中的文件定位需要改造为加载对应的 JS 片段（webpack 采用的方式为通过函数传参实现依赖的引入）。 下面为webpack打包出来的代码快照如下： (function (modules) { // The module cache var installedModules = {}; // The require function function __webpack_require__(moduleId) {} return __webpack_require__(0); // ---&gt; 0 }) ({ 0: function (module, exports, __webpack_require__) { // Define module A var moduleB = __webpack_require__(1); // ---&gt; 1 }, 1: function (module, exports, __webpack_require__) { // Define module B exports = {}; // ---&gt; 2 } }); 实际上，ES Module 的处理同 CommonJS 相差无几，只是在定义模块和引入模块时会去处理 __esModule 标识，从而兼容其在语法上的差异。 异步和扩展1、浏览器环境下，网络资源受到较大的限制，因此打包出来的文件如果体积巨大，对页面性能的损耗极大，因此需要对构建的目标文件进行拆分，同时模块也需要支持动态加载； webpack 提供了两个方法 require.ensure() 和 import() （推荐使用）进行模块的动态加载，至于其中的原理，跟上面提及的 AMD &amp; CMD 所见略同，import() 执行后返回一个 Promise 对象，其中所做的工作无非也是动态新增 script 标签，然后通过 onload / onerror 事件进一步处理。 2、由于 require 函数是完全自定义的，我们可以在模块化中实现更多的特性，比如通过修改 require.resolve 或 Module._extensions 扩展支持的文件类型，使得 css / .jsx / .vue / 图片等文件也能为模块化所使用； 附录一：特性一览表 模块化规范 加载方式 加载时机 运行环境 备注 AMD 异步 运行时 浏览器 CMD 异步 运行时 浏览器 CommonJS 同步/异步 运行时 浏览器/node ES Module 同步/异步 编译阶段 浏览器/node]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>模块化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解BFC,IFC,GFC和FFC]]></title>
    <url>%2F2018%2F07%2F23%2FCSS3%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3BFC-IFC-GFC%E5%92%8CFFC%2F</url>
    <content type="text"><![CDATA[前言BFC,IFC,IFC,FFF是什么，主要解决的什么问题，哪些元素会生成BFC？本文主要针对这几个问题来了解。在解释之前，需要先介绍 Box、Formatting Context的概念。 Box: CSS布局的基本单位 Box 是 CSS 布局的对象和基本单位， 直观点来说，就是一个页面是由很多个 Box 组成的。元素的类型和 display 属性，决定了这个 Box 的类型。 不同类型的 Box， 会参与不同的 Formatting Context（一个决定如何渲染文档的容器），因此Box内的元素会以不同的方式渲染。让我们看看有哪些盒子： block-level box:display 属性为 block, list-item, table 的元素，会生成 block-level box。并且参与 block fomatting context； inline-level box:display 属性为 inline, inline-block, inline-table 的元素，会生成 inline-level box。并且参与 inline formatting context； run-in box: display 属性为flex,grid 如果 run-in box 包含 block box，那么这个 run-in box 也成为 block box 如果紧跟在 run-in box 之后的兄弟节点是 block box，那么这个 run-in box 就会做为此 block box 里的 inline box，run-in box 不能进入已经一个已经以 run-in box 开头的块内，也不能进入本身就是 display:run-in; 的块内 否则，run-in box 成为 block box Formatting contextormatting context 是 W3C CSS2.1 规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。最常见的 Formatting context 有 Block fomatting context (简称BFC)和 Inline formatting context (简称IFC)。 BFCBFC(Block formatting context)直译为”块级格式化上下文”。它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。 BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置。 Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。 BFC的区域不会与float box重叠。 BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。 计算BFC的高度时，浮动元素也参与计算 哪些元素会生成BFC 根元素 float属性不为none position为absolute或fixed display为inline-block, table-cell, table-caption, flex, inline-flex overflow不为visible BFC的作用及原理 自适应两栏布局 我们可以通过通过触发main生成BFC， 来实现自适应两栏布局。 .main { overflow: hidden; } 清除内部浮动 为达到清除内部浮动，我们可以触发par生成BFC，那么par在计算高度时，par内部的浮动元素child也会参与计算。 .par { overflow: hidden; } 防止垂直 margin 重叠 我们可以在p外面包裹一层容器，并触发该容器生成一个BFC。那么两个P便不属于同一个BFC，就不会发生margin重叠了。 &lt;style&gt; .wrap { overflow: hidden; } p { color: #f55; background: #fcc; width: 200px; line-height: 100px; text-align:center; margin: 100px; } &lt;/style&gt; &lt;body&gt; &lt;p&gt;Haha&lt;/p&gt; &lt;div class=&quot;wrap&quot;&gt; &lt;p&gt;Hehe&lt;/p&gt; &lt;/div&gt; &lt;/body&gt; 因为BFC内部的元素和外部的元素绝对不会互相影响，因此， 当BFC外部存在浮动时，它不应该影响BFC内部Box的布局，BFC会通过变窄，而不与浮动有重叠。同样的，当BFC内部有浮动时，为了不影响外部元素的布局，BFC计算高度时会包括浮动的高度。避免margin重叠也是这样的一个道理。 IFCIFC(Inline-Formatting-Contexts)即内联格式化上下文布局。一般都是行内元素比如：input a img span 以及display 属性值为inline-block的元素。 行内元素有哪些特点呢。？如下列举： 水平方向根据direction依次布局。 不会在元素前后换行。 受white-space属性的影响。 margin/padding 在竖直方向无效，水平方向有效的。 white/height 对非替换行内元素无效，宽度由元素内容决定。 非替换行内元素的行框高由line-height决定而替换行内元素的行框高则是由height，padding，border，margin决定 浮动或者绝对定位会转化为block vertical-align属性生效 IFC的布局规则如下： 框会从包含块的顶部开始，然后一个接一个的排列。 在放置这些框的时候，他们在水平方向上的外边距，边框和内边距所占的空间都会被考虑在内（这样就得到了一个一个的框）。然而在垂直方向上，这些框可能会以不同的方式来对齐，比如他们可以顶部对齐，或者底部对齐也有可能按照文本的基线对齐。而把这一行上的框都包含进去的一个大框我们称之为改行的行框。水平的padding,border,margin有效，竖直方向则无效。不能指定框高。 行宽的宽度由包含块和存在的浮动决定的。行框的高度至少会高到足以包含他内部的所有框。 当一行上的行级总宽度（某一个小框的宽度或者若干个小框的总宽度）小于行宽的时候，他们在行宽内的水平方向上的排布由text-align决定。 当一个行内框的宽度超过了该行的行宽的时候，就会被分成几个框。(ex.文字换行的时候 字都不在同一行了，那换行的时候自然就会多一份框，自然也就多了一份行宽)但是如果设置这个框就不能被分割的话（比如，文字强制不给换行white-space设置为nowrap）那么这时候该行内框就会溢出该行的行宽。 一般情况下行宽的左边紧贴在他的包含块的左边，同样他的右边也是紧贴在其包含块的右边。但是也不一定，比如出现浮动的话，浮动元素可能会插在包含块和行框之间。所以一般在同一个IFC中行框通常有相同的宽度（包含快的宽度）但是某一行的行宽的宽度也可能受浮动元素影响，减少了水平可用的宽度了。在同一个IFC中，行框的高度通常是变化的，不一定的，比如某一行的某个框是个很高的图片，而改行框中其他框只是文字。 计算行框内各个框的高度，对于非替换元素就是起line-height,而对于替换元素就是边界框的高度了。 行框的高是最顶端框的顶边到最底端框的底边的距离。 补充：包含块的概念：简单说就是定位参考框或者定位坐标参考系，元素一旦定义了定位显示（相对、绝对、固定）都具有包含块性质，它所包含的定位元素都将以该包含块为坐标系进行定位和调整。是视觉格式化模型的一个重要概念，它与框模型类似，也可以理解为一个矩形，而这个矩形的作用是为它里面包含的元素提供一个参考，元素的尺寸和位置的计算往往是由该元素所在的包含块决定的。 FFC弹性布局(FFC-Flex Formattig-Contexts 自适应格式化上下文)申明 display:flex; 或者display:inline-flex(行内弹性布局) 这个布局是我最爱的布局之一了，因为他可以非常轻松的实现元素的上下居中，左右居中；只需要justify-content:center（左右居中）align-items:center;(上下居中)就ok了.申明flex之后这个元素就会成为一个flex容器，而他的子元素就会自动成为这个容器的成员，简称为项目。而其中又会有两个轴线（类似于笛卡尔坐标系的两个轴吧）横的称之为主轴，竖着的称之为交叉轴，容器是一个相对独立的渲染区域，他对自己内部的项目有着自己的一套渲染规则，不受容器外部的影响，同样的，容器内部的规则也不会影响外面。 容器属性：六个属性分别为：flex-direction,flex-wrap,flex-flow,justify-content,align-items,align-content 项目属性：六个属性分别为：order，flex-grow，flex-shrink，flex-basis，flex，align-self GFCGFC（Grid Formatting Contexts）栅格格式化上下文 当为一个元素设置display值为grid的时候，此元素将会获得一个独立的渲染区域，我们可以通过在网格容器（grid container）上定义网格定义行（grid definition rows）和网格定义列（grid definition columns）属性各在网格项目（grid item）上定义网格行（grid row）和网格列（grid columns）为每一个网格项目（grid item）定义位置和空间。 那么GFC有什么用呢，和table又有什么区别呢？首先同样是一个二维的表格，但GridLayout会有更加丰富的属性来控制行列，控制对齐以及更为精细的渲染语义和控制。]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你真的了解setState吗？]]></title>
    <url>%2F2018%2F07%2F19%2FReact%2F%E4%BD%A0%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3setState%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[前言看之前，为了方便理解和简化流程，我们默认react内部代码执行到 performWork、performWorkOnRoot、performSyncWork、performAsyncWork 这四个方法的时候，就是react去update更新并且作用到UI上。 合成事件中的setState首先得了解一下什么是合成事件，react为了解决跨平台，兼容性问题，自己封装了一套事件机制，代理了原生的事件，像在jsx中常见的onClick、onChange这些都是合成事件。 class App extends Component { state = { val: 0 } increment = () =&gt; { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出的是更新前的val --&gt; 0 } render() { return ( &lt;div onClick={this.increment}&gt; {`Counter is: ${this.state.val}`} &lt;/div&gt; ) } } 合成事件中的setState写法比较常见，点击事件里去改变 this.state.val 的状态值，在 increment 事件中打个断点可以看到调用栈，这里我贴一张自己画的流程图： 从 dispatchInteractiveEvent 到 callCallBack 为止，都是对合成事件的处理和执行，从 setState 到 requestWork 是调用 this.setState 的逻辑，这边主要看下 requestWork 这个函数（从 dispatchEvent 到 requestWork 的调用栈是属于 interactiveUpdates$1 的 stry 代码块，下文会提到）。 function requestWork(root, expirationTime) { addRootToSchedule(root, expirationTime); if (isRendering) { // Prevent reentrancy. Remaining work will be scheduled at the end of // the currently rendering batch. return; } if (isBatchingUpdates) { // Flush work at the end of the batch. if (isUnbatchingUpdates) { // ...unless we&#39;re inside unbatchedUpdates, in which case we should // flush it now. nextFlushedRoot = root; nextFlushedExpirationTime = Sync; performWorkOnRoot(root, Sync, false); } return; } // TODO: Get rid of Sync and use current time? if (expirationTime === Sync) { performSyncWork(); } else { scheduleCallbackWithExpiration(expirationTime); } } 在 requestWork 中有三个if分支，三个分支中有两个方法 performWorkOnRoot 和 performSyncWork ，就是我们默认的update函数，但是在合成事件中，走的是第二个if分支，第二个分支中有两个标识 isBatchingUpdates 和 isUnbatchingUpdates 两个初始值都为 false ，但是在 interactiveUpdates$1 中会把 isBatchingUpdates 设为 true ，下面就是 interactiveUpdates$1 的代码： function interactiveUpdates$1(fn, a, b) { if (isBatchingInteractiveUpdates) { return fn(a, b); } // If there are any pending interactive updates, synchronously flush them. // This needs to happen before we read any handlers, because the effect of // the previous event may influence which handlers are called during // this event. if (!isBatchingUpdates &amp;&amp; !isRendering &amp;&amp; lowestPendingInteractiveExpirationTime !== NoWork) { // Synchronously flush pending interactive updates. performWork(lowestPendingInteractiveExpirationTime, false, null); lowestPendingInteractiveExpirationTime = NoWork; } var previousIsBatchingInteractiveUpdates = isBatchingInteractiveUpdates; var previousIsBatchingUpdates = isBatchingUpdates; isBatchingInteractiveUpdates = true; isBatchingUpdates = true; // 把requestWork中的isBatchingUpdates标识改为true try { return fn(a, b); } finally { isBatchingInteractiveUpdates = previousIsBatchingInteractiveUpdates; isBatchingUpdates = previousIsBatchingUpdates; if (!isBatchingUpdates &amp;&amp; !isRendering) { performSyncWork(); } } } 在这个方法中把 isBatchingUpdates 设为了 true ,导致在 requestWork 方法中， isBatchingUpdates 为 true ，但是 isUnbatchingUpdates 是 false ，而被直接return了。 那return完的逻辑回到哪里呢，最终正是回到了 interactiveUpdates 这个方法，仔细看一眼，这个方法里面有个 try finally语法，前端同学这个其实是用的比较少的，简单的说就是会先执行 try 代码块中的语句，然后再执行 finally 中的代码，而 fn(a, b) 是在try代码块中，刚才说到在 requestWork 中被return掉的也就是这个fn（上文提到的 从dispatchEvent 到 requestWork 的一整个调用栈）。 所以当你在 increment 中调用 setState 之后去console.log的时候，是属于 try 代码块中的执行，但是由于是合成事件，try代码块执行完state并没有更新，所以你输入的结果是更新前的 state 值，这就导致了所谓的”异步”，但是当你的try代码块执行完的时候（也就是你的increment合成事件），这个时候会去执行 finally 里的代码，在 finally 中执行了 performSyncWork 方法，这个时候才会去更新你的 state 并且渲染到UI上。 生命周期函数中的setStateclass App extends Component { state = { val: 0 } componentDidMount() { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出的还是更新前的值 --&gt; 0 } render() { return ( &lt;div&gt; {`Counter is: ${this.state.val}`} &lt;/div&gt; ) } } 钩子函数中setState的调用栈： 其实还是和合成事件一样，当 componentDidmount 执行的时候，react内部并没有更新，执行完componentDidmount 后才去 commitUpdateQueue 更新。这就导致你在 componentDidmount 中 setState 完去console.log拿的结果还是更新前的值。 原生事件中的setStateclass App extends Component { state = { val: 0 } changeValue = () =&gt; { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出的是更新后的值 --&gt; 1 } componentDidMount() { document.body.addEventListener(&#39;click&#39;, this.changeValue, false) } render() { return ( &lt;div&gt; {`Counter is: ${this.state.val}`} &lt;/div&gt; ) } } 原生事件是指非react合成事件，原生自带的事件监听 addEventListener ，或者也可以用原生js、jq直接 document.querySelector().onclick 这种绑定事件的形式都属于原生事件。 原生事件的调用栈就比较简单了，因为没有走合成事件的那一大堆，直接触发click事件，到 requestWork ,在requestWork里由于 expirationTime === Sync 的原因，直接走了 performSyncWork 去更新，并不像合成事件或钩子函数中被return，所以当你在原生事件中setState后，能同步拿到更新后的state值。 setTimeout中的setStateclass App extends Component { state = { val: 0 } componentDidMount() { setTimeout(_ =&gt; { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) // 输出更新后的值 --&gt; 1 }, 0) } render() { return ( &lt;div&gt; {`Counter is: ${this.state.val}`} &lt;/div&gt; ) } } 在 setTimeout 中去 setState 并不算是一个单独的场景，它是随着你外层去决定的，因为你可以在合成事件中 setTimeout ，可以在钩子函数中 setTimeout ，也可以在原生事件setTimeout，但是不管是哪个场景下，基于 event loop的模型下， setTimeout 中里去 setState 总能拿到最新的state值。 举个栗子，比如之前的合成事件，由于你是 setTimeout(_ =&gt; { this.setState()}, 0) 是在 try 代码块中,当你 try 代码块执行到 setTimeout 的时候，把它丢到列队里，并没有去执行，而是先执行的 finally 代码块，等 finally 执行完了， isBatchingUpdates 又变为了 false ，导致最后去执行队列里的 setState 时候， requestWork 走的是和原生事件一样的 expirationTime === Sync if分支，所以表现就会和原生事件一样，可以同步拿到最新的state值。 setState中的批量更新class App extends Component { state = { val: 0 } batchUpdates = () =&gt; { this.setState({ val: this.state.val + 1 }) this.setState({ val: this.state.val + 1 }) this.setState({ val: this.state.val + 1 }) } render() { return ( &lt;div onClick={this.batchUpdates}&gt; {`Counter is ${this.state.val}`} // 1 &lt;/div&gt; ) } } 上面的结果最终是1，在 setState 的时候react内部会创建一个 updateQueue ，通过 firstUpdate 、 lastUpdate 、 lastUpdate.next 去维护一个更新的队列，在最终的 performWork 中，相同的key会被覆盖，只会对最后一次的 setState 进行更新，下面是部分实现代码： function createUpdateQueue(baseState) { var queue = { expirationTime: NoWork, baseState: baseState, firstUpdate: null, lastUpdate: null, firstCapturedUpdate: null, lastCapturedUpdate: null, firstEffect: null, lastEffect: null, firstCapturedEffect: null, lastCapturedEffect: null }; return queue; } function appendUpdateToQueue(queue, update, expirationTime) { // Append the update to the end of the list. if (queue.lastUpdate === null) { // Queue is empty queue.firstUpdate = queue.lastUpdate = update; } else { queue.lastUpdate.next = update; queue.lastUpdate = update; } if (queue.expirationTime === NoWork || queue.expirationTime &gt; expirationTime) { // The incoming update has the earliest expiration of any update in the // queue. Update the queue&#39;s expiration time. queue.expirationTime = expirationTime; } } 看个🌰 class App extends React.Component { state = { val: 0 } componentDidMount() { this.setState({ val: this.state.val + 1 }) console.log(this.state.val) this.setState({ val: this.state.val + 1 }) console.log(this.state.val) setTimeout(_ =&gt; { this.setState({ val: this.state.val + 1 }) console.log(this.state.val); this.setState({ val: this.state.val + 1 }) console.log(this.state.val) }, 0) } render() { return &lt;div&gt;{this.state.val}&lt;/div&gt; } } 结合上面分析的，钩子函数中的 setState 无法立马拿到更新后的值，所以前两次都是输出0，当执行到 setTimeout 里的时候，前面两个state的值已经被更新，由于 setState 批量更新的策略， this.state.val 只对最后一次的生效，为1，而在 setTimmout 中 setState 是可以同步拿到更新结果，所以 setTimeout 中的两次输出2，3，最终结果就为 0, 0, 2, 3 。 总结 setState 只在合成事件和钩子函数中是“异步”的，在原生事件和 setTimeout 中都是同步的。 setState的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的callback拿到更新后的结果。 setState 的批量更新优化也是建立在“异步”（合成事件、钩子函数）之上的，在原生事件和setTimeout 中不会批量更新，在“异步”中如果对同一个值进行多次 setState ， setState 的批量更新策略会对其进行覆盖，取最后一次的执行，如果是同时 setState 多个不同的值，在更新时会对其进行合并批量更新。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax Fetch Axios之间的详细区别以及优缺点]]></title>
    <url>%2F2018%2F07%2F18%2Fstudy%2FAjax-Fetch-Axios%E4%B9%8B%E9%97%B4%E7%9A%84%E8%AF%A6%E7%BB%86%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[将jQuery的ajax、axios和fetch做个简单的比较，所谓仁者见仁智者见智，最终使用哪个还是自行斟酌 jQuery ajax$.ajax({ type: &#39;POST&#39;, url: url, data: data, dataType: dataType, success: function () {}, error: function () {} }) 优缺点： 本身是针对mvc模式的编程，不符合现在mvvm的浪潮 基于原生的XHR开发，XHR本身的架构不清晰，已经有了fetch的替代方案 JQuery整个项目太大，单纯使用ajax却要引入整个JQuery非常的不合理（采取个性化打包的方案又不能享受CDN服务） 尽管JQuery对我们前端的开发工作曾有着（现在也仍然有着）深远的影响，但是我们可以看到随着VUE，REACT新一代框架的兴起，以及ES规范的完善，更多API的更新，JQuery这种大而全的JS库，未来的路会越走越窄。 axiosaxios中文文档 axios({ method: &#39;POST&#39;, url: &#39;&#39; data:{ name:&#39;zhang&#39; } }).then(function (response){ console.log(response) }).then(function (error){ console.log(error) }) Vue2.0之后，尤雨溪推荐大家用axios替换JQuery ajax，想必让Axios进入了很多人的目光中。Axios本质上也是对原生XHR的封装，只不过它是Promise的实现版本，符合最新的ES规范，从它的官网上可以看到它有以下几条特性： 优缺点： 从 node.js 创建 http 请求 支持 Promise API 客户端支持防止CSRF 提供了一些并发请求的接口（重要，方便了很多的操作 这个支持防止CSRF其实挺好玩的，是怎么做到的呢，就是让你的每个请求都带一个从cookie中拿到的key, 根据浏览器同源策略，假冒的网站是拿不到你cookie中得key的，这样，后台就可以轻松辨别出这个请求是否是用户在假冒网站上的误导输入，从而采取正确的策略。 Axios既提供了并发的封装，也没有下文会提到的fetch的各种问题，而且体积也较小，当之无愧现在最应该选用的请求的方式。 fetchfetch号称是AJAX的替代品，它的好处在《传统 Ajax 已死，Fetch 永生》中提到有以下几点： 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里更好更方便的写法，诸如： try{ let response = await fetch(url); let data = response.json(); console.log(data); }catch (e){ console.log(&quot;Oops, error&quot;, e); } 优缺点： 符合关注分离，没有将输入、输出和用事件来跟踪的状态混杂在一个对象里 更好更方便的写法 更加底层，提供的API丰富（request, response） 脱离了XHR，是ES规范里新的实现方式 1）fetchtch只对网络请求报错，对400，500都当做成功的请求，需要封装去处理2）fetch默认不会带cookie，需要添加配置项3）fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了量的浪费4）fetch没有办法原生监测请求的进度，而XHR可以 PS: fetch的具体问题大家可以参考：《fetch没有你想象的那么美》《fetch使用的常见问题及解决方法》 看到这里，你心里一定有个疑问，这鬼东西就是个半拉子工程嘛，我还是回去用Jquery或者Axios算了——其实我就是这么打算的。但是，必须要提出的是，我发现fetch在前端的应用上有一项xhr怎么也比不上的能力：跨域的处理。 我们都知道因为同源策略的问题，浏览器的请求是可能随便跨域的——一定要有跨域头或者借助JSONP，但是，fetch中可以设置mode为”no-cors”（不跨域），如下所示： fetch(&#39;/users.json&#39;, { method: &#39;post&#39;, mode: &#39;no-cors&#39;, data: {} }).then(function() { /* handle response */ }); 为什么要用axios axios 是一个基于Promise 用于浏览器和 nodejs 的 HTTP 客户端，它本身具有以下特征： 从浏览器中创建 XMLHttpRequest 从 node.js 发出 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 取消请求 自动转换JSON数据 客户端支持防止CSRF/XSRF]]></content>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过示例来学习ES2016, 2017, 2018的新特性]]></title>
    <url>%2F2018%2F07%2F17%2FJs%2F%E9%80%9A%E8%BF%87%E7%A4%BA%E4%BE%8B%E6%9D%A5%E5%AD%A6%E4%B9%A0ES2016-2017-2018%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[前言本文会辅以有用的例子来讲述TC39中的18个特性，它们分别在ES2016, ES2017和ES2018中加入。鉴于本文内容很长，我们将分为两个部分来介绍，此为第一部分。 ES6Array.prototype.includesincludes是一个Array上很有用的函数，用于快速查找数组中是否包含某个元素。(包括NaN，所以和indexOf不一样)。 指数函数的中缀形式加/减法我们通常都是用其中缀形式，直观易懂。在ECMAScript2016中，我们可以使用**来替代Math.pow。 ES7Object.values()Object.values()函数和Object.keys()很相似，它返回一个对象中自己属性的所有值(通过原型链继承的不算)。 Object.entries()Object.entries()和Object.keys相关，不过entries()函数会将key和value以数组的形式都返回。这样，使用循环或则将对象转为Map就很方便了。 字符串追加提供了两个字符串追加的方法String.prototype.padStart和String.prototype.padEnd，方便我们将一个新的字符串追加到某个字符串的头尾。 &#39;someString&#39;.padStart(numberOfCharcters [,stringForPadding]); &#39;5&#39;.padStart(10) // &#39; 5&#39; &#39;5&#39;.padStart(10, &#39;=*&#39;) //&#39;=*=*=*=*=5&#39; &#39;5&#39;.padEnd(10) // &#39;5 &#39; &#39;5&#39;.padEnd(10, &#39;=*&#39;) //&#39;5=*=*=*=*=&#39; 这个对于格式化输出很有用！ padStart例子我们有一个不同长度元素的数组，我们可以往前面追加0来使得他们打印的长度都为10。 padEnd例子 const cars = { &#39;🚙BMW&#39;: &#39;10&#39;, &#39;🚘Tesla&#39;: &#39;5&#39;, &#39;🚖Lamborghini&#39;: &#39;0&#39; } Object.entries(cars).map(([name, count]) =&gt; { //padEnd appends &#39; -&#39; until the name becomes 20 characters //padStart prepends &#39;0&#39; until the count becomes 3 characters. console.log(`${name.padEnd(20, &#39; -&#39;)} Count: ${count.padStart(3, &#39;0&#39;)}`) }); //Prints.. // 🚙BMW - - - - - - - Count: 010 // 🚘Tesla - - - - - - Count: 005 // 🚖Lamborghini - - - Count: 000 使用padStart和padEnd来格式化Emojis和其他宽字符Emojis和宽字符使用多个字节来表示，因此可能使用padStart和padEnd的结果并非如你所愿。 比如：我们追加❤️到heart前面： //你会发现不仅没有5个桃心，有一个桃心还很奇怪。 &#39;heart&#39;.padStart(10, &quot;❤️&quot;); // prints.. &#39;❤️❤️❤heart&#39; 这是因为❤️占有2个字节(‘\u2764\uFE0F’)，而heart本身有5个字节，因此只有5个字节的余地。所以只是追加了2个半的桃心。最后追加的’\u2764’会显示为小黑桃心。 Object.getOwnPropertyDescriptors该函数返回一个对象所有的属性，甚至包括get/set函数。ES2017加入这个函数的主要动机在于方便将一个对象深度拷贝给另一个对象，同时可以将getter/setter拷贝。和Object.assign不同。 Object.assign将一个对象除了getter/setter以外的都深度拷贝了。 将原对象Car拷贝到ElectricCar，你就会发现Object.getOwnPropertyDescriptors拷贝了 getter和setter，而Object.assign没有。 允许在函数参数最后添加逗号这是一个很小的改动，方便git算法更加方便区分代码职责。我们用一个详细的例子来理解： 值得一提的是，在函数调用的时候，也可以在最后添加逗号。 Async/Await迄今为止，我介绍的特性中最有用的就属这个功能了。Async函数可以帮助我们摆脱“回调地狱”，并且整个代码会更加简洁。 async关键字告诉JavaScript编译器对于标定的函数要区别对待。当编译器遇到await函数的时候会暂停。它会等到await标定的函数返回的promise。该promise要么得到结果、要么reject。 在下面的例子中，getAmount函数调用getUser和getBankBalance两个异步函数。我们可以用promise来实现它，不过用async await更加简洁。 async函数返回Promise如果你想获取一个async函数的结果，你需要使用Promise的then语法。 在下面的例子中，我们想用console.log来打印doubleAndAdd的结果，可以使用then语法，将console.log函数作为参数传入。 并行处理在上面的例子中，我们显示地调用了await两次，因为每次都等待了1秒钟，因此总计两秒钟。现在，我们可以使用Promise.all函数来让他们并行处理。 async/await的错误处理有很多方法来处理错误。 方法1：在函数中使用try-catch 方法2：catch每一个await表达式 因为每一个await表达式都会返回Promise，你可以对一个进行catch操作。 方法3：catch整个async-await函数 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《图解HTTP学习》笔记]]></title>
    <url>%2F2018%2F07%2F13%2FHTTP%2F%E3%80%8A%E5%9B%BE%E8%A7%A3HTTP%E5%AD%A6%E4%B9%A0%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[从一道题引发的思考从输入网页到呈现网页页面这一过程经历了什么？ HTTP的诞生在深入了解HTTP之前，先介绍HTTP诞生的背景。cern的timbernersLee 提出一种能让远隔两地的研究者们共享知识点的设想。 网络基础 TCP/IP通常使用的网络（包括互联网）是在TCP/IP协议族的基础上运作的。而HTTP属于它内部的一个子集。 TCP/IP协议族按层次分为以下4层 应用层 应用层决定了向用户提供应用服务时通信的活动。 TCP/IP协议族预存了各类通用的应用服务，比如，FTP(file transfer protocol,文件传输协议)和DNS(Domain Name system)域名系统服务就是其中两类。 HTTP协议也处于该层。 传输层 传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。 在传输层中有两个性质不同的协议：TCP（传输控制协议）和UDP（用户数据报协议） 网络层（又名网络互联层） 网络层用来处理在网络上流动的数据包。与对方计算机之间通过多台计算机或网络设备进行传输时，网络层所起的作用就是在众多的选项内选择一条传输路线。 数据链路层（又名网络接口层） 用来处理连接网络的硬件部分。包括控制操作系统，硬件的设备驱动，NIC(网络适配器，即网卡)，及光纤等物理可见部分， 利用TCP/IP协议族进行网络通信时，会通过分层顺序与对方进行通信。发送端从应用层往下走，接收端则往应用层往下走。发送端每通过一层则增加首部，接收端每通过一层则删除首部。 TCP位于传输层，提供可靠的字节流服务 负责域名解析的DNS服务DNS和HTTP协议以一样位于应用的协议。它提供域名到IP地址之间的解析服务 URI和URL与URI（统一资源标识符）相比，我们更熟悉URL（统一资源定位符）。URI用字符串标识某一互联网资源，而URL表示资源的地点。可见URL是URI的子集。 简单的HTTP协议请求访问文本或图像资源等的一端称为客户端，而提供资源响应的一端称为服务端 请求报文由 请求方法，请求URI，协议版本，可选请求首部字段和内容实体构成的。 响应报文由协议版本，状态码（表示请求成功或失败的数字代码），用以解释状态码的原因短语，可选的响应首部字段以及实体主体构成。 HTTP是不保存状态的协议（即无状态协议）HTTP协议自身不对请求和响应之间的通信状态进行保存。也就是说在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。 这样是为了更快地处理大量事务，确保协议的可伸缩性，而特意把HTTP协议设计成如此简单的。 为了解决这种无状态的问题，于是引入了cookie技术。有了cookie再用HTTP协议通信，就可以管理状态了。 告知服务器意图的HTTP方法 GET 获取资源 POST 传输实体主体 PUT 传输文件 HEAD 获取报文头部 DELETE 删除文件 OPTIONS 询问支持的方法 TRACE 追踪路径 CONNECT 要求用隧道协议连接代理 因为PUT 和 DELETE方法一样不带验证机制，任何人都可以进行操作，所以存在安全性。不常用 持久连接节省通信量HTTP协议的初始版本中，每进行一次HTTP通信就要断开一次TCP链接，如果要请求一个包含很多图片资源的网站，会进行很多次TCP的连接和中断，增加通信量的开销。 为了解决上述问题，HTTP/1.1和一部分HTTP/1.0想出了持久连接（也成为HTTP keep-alive） 管道化持久连接使得多数请求以管道化（pipelining）方式发送成为可能。从前发送请求后需要等待并收到响应。管道化技术的出现解决了不用等待响应亦可直接发送下一个请求。 管道化技术要比持久连接还要快。 使用cookie的状态管理cookie技术通过在请求和响应报文中写入cookie信息来控制客户端的状态。 cookie会根据从服务器端发送的响应报文内的一个叫做Set-Cookie的首部字段信息，通知客户端保存Cookie。当下次客户端在往该服务器发送请求时，客户端会自动在请求报文中加入cookie值后发送出去 HTTP报文内的HTTP信息HTTP报文大致可分为报文首部和报文主体两块。 报文主体和实体主体的差异 报文（message）是HTTP通信的基本单位。由8位组字节流组成，通过HTTP通信传输。 实体（entity）作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成。 通常，报文主体等于实体主体，只有当传输过程中进行编码操作时，实体主体的内容发生变化，才导致它和报文主体产生差异。 压缩传输的内容编码 常见的内容编码有以下几种 gzip（GNU zip） compress（UNIX系统的标准压缩） deflate（zlib） identity（不进行编码） 分割发送的分块传输编码 这种把实体主体分块的功能称为分块传输编码 分块传输编码会将实体主体分为多个部分（块）。每一块都会用十六进制来标记块的大小，而实体主体的最后一块会使用“0（CR+LF）”来标记。 发送多种数据的多部分对象集合 多部分对象集合包含的对象如下 multipart/form-data 在web表单文件上传时使用 multipart/byteranges 状态码206响应报文包含了多个范围的内容时使用 获取部分内容的范围请求 要实现该功能需要指定下载的实体范围，像这样，指定范围发送的请求叫做范围请求。 内容协商返回最合适的内容 内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为适合的资源。内容协商会以响应资源的语言，字符集，编码方式等作为判断的基准。 包含在请求报文中的某些首部字段就是判断的基准。 Accept Accept-Charset Accept-Encoding Accept-Language Content-Language 内容协商技术有以下3中类型 服务器驱动协商 客户端驱动协商 透明协商 返回结果的HTTP状态码2XX 成功200 ok 表示从客户端发来的请求在服务器端已被正常处理 204 No Content 请求处理成功，但没有资源可返回 206 partial content 该状态码表示客户端进行了范围请求 而服务器成功执行了这部分的get请求 3XX 重定向301 moved permanently永久性重定向。该状态码表示请求的资源已被分配了新的URI，以后应使用资源现在所指的URI。 302 Found临时重定向。该状态码表示请求的资源已被分配了新的URI，希望用户（本次）能使用新的URI访问。 303 see other临时重定向。该状态码表示请求的资源存在着另一个URI，应使用get方法定向获取请求的资源。 304 Not Modified 该状态码表示客户端发送附带条件的请求时，服务器允许请求访问资源。 307 Temporary Redirect临时重定向。该状态码与302 Found有着相同的含义。 4XX 客户端错误400 Bad Request该状态码表示请求报文中存在语法错误。 401 Unauthorized该状态码表示发送的请求需要有HTTP认证的认证信息。 403 Forbidden该状态码表明对请求的资源的访问被服务器拒绝了 404 Not Found该状态码表示请求的资源无法再服务器上找到 5XX 服务器错误500 Internal Server Error 该状态码表示服务器端在执行请求时发生了错误。也可能是web应用存在的bug或某些临时的故障。 503 Service Unavailable 该状态码表明服务器暂时处于超负载或正在停机维护，现在无法处理请求。 与HTTP协作的web服务器HTTP/1.1允许一台HTTP服务器搭建多个web站点。即使物理层面只有一台服务器，但只要使用虚拟主机的功能，则可以假象已具有多台服务器。 在相同的IP地址下，由于虚拟主机可以寄存多个不同的主机名和域名的web网站，因此在发送HTTP请求时，必须在host首部内完整指定主机名或域名的URI 通信数据转发程序:代理、网关、隧道这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应再转发给客户端。 代理代理是一种有转发功能的应用程序，他扮演了位于服务器和客户端“中间人”的角色，接收有客户端发送的请求并转发给服务器，同时也接受服务器返回的响应并转发给客户端。 每一次通过代理服务器转发给请求或响应时，也会写入Via首部信息，用来标记经过的主机信息。 使用代理的理由有，利用缓存技术减少网络宽带的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的，等等。 代理有多种使用方法，按两种基准分类，一种是否使用缓存技术，另一种是否会修改报文。 网关网关是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求处理。 网关的工作机制和代理十分相似，而网关能使通信线路上的服务器提供非HTTP协议服务。利用网关可以提高通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。 隧道隧道是在相隔深远的客户端和服务器两者之间进行中转，并保持双方通信连接的应用程序。 隧道的目的是确保客户端能与服务器进行安全的通信。 保存资源的缓存缓存是指代理服务器或客户端本地磁盘内保存的资源副本，利用缓存可减少对源服务器的访问，因此也就节省了通信流量和通信时间。 即使存在缓存，也会因为客户端的要求，缓存的有效期等因素，向源服务器确认资源的有效性。若判断缓存失败，缓存服务器将会再次从源服务器上获取“新”资源。 HTTP首部HTTP协议的请求和响应报文中必定包含HTTP首部 HTTP报文首部HTTP请求报文由方法，URI，HTTP版本，HTTP首部字段等部分构成 HTTP响应报文由HTTP版本，状态码（数字和原因短语）HTTP首部字段等3部分构成。 HTTP首部字段HTTP首部字段是由字段名和字段值构成的，中间用冒号“：”分割； 首部字段名:字段值如Content-Type: text/html HTTP首部字段根据实际用途被分为以下4中类型。 通用首部字段 请求首部字段 响应首部字段 实体首部字段 HTTP首部字段将定义成缓存代理和非缓存代理的行为，分为2种类型 端到端首部（End-to-end Header） 逐跳首部（Hop-by-hop header） 下面列举了HTTP/1.1中的逐跳首部字段。除了这8个首部字段之外，其他所有字段都属于端到端首部字段。 Connection Keep-Alive Proxy-Authenticate Proxy-Authorization Trailer TE Transfer-Encoding Upgrade HTTP/1.1通用首部字段cache-control通过指定首部字段cache-control的指令，就能操作缓存的工作机制 connectionconnection首部字段具有如下两个作用 控制不再转发给代理的首部字段 管理持久连接 Date首部字段Date表明创建HTTP报文的日期和时间 Pragmapragma是HTTP/1.1之前的版本历史遗留字段，仅作为与HTTP/1.0的向后兼容而定义 Tralier首部字段会事先说明在报文主体后记录了哪些首部字段。 Transfer-Encoding规定了传输报文主体采用的编码方式 Upgrade用于检测HTTP协议及其他协议是否可使用更高的版本进行通信，其参数值可以用来指定一个完全不同的通信协议 Via为了追踪客户端与服务器之间的请求和响应报文的传输路径 Waring通常会告知用户一些与缓存相关的问题的警告 确保Web安全的HTTPS在HTTP协议中有可能存在信息窃听或身份伪装等安全问题，使用HTTPS通信机制可以有效地防止这些问题。 HTTP的缺点HTTP主要由以下不足： 通信食用明文（不加密），内容可能被窃听 不验证通信方的身份，因此有可能遭遇伪装 无法证明报文的完整性，所以有可能已遭篡改 这些问题不仅在HTTP上出现，其他未加密的协议中也会存在这类问题。 通过和SSL（secure socket layer 安全套接层）或TSL（安全层传输协议）的组合使用加密HTTP的通信内容。 HTTP+加密+认证+完整性保护 = HTTPS我们把添加了加密方式及认证机制的HTTP称为HTTPS（HTTP Secure） HTTPS是身披SSL外壳的HTTPSSL采用一种佳作公开密钥加密（public-key cryptography）的加密处理方式 这种加密方法中加密算法是公开的，而密钥却是保密的。 HTTPS采用混合加密机制HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。 证明公开密钥正确性的证书 HTTPS的安全通信机制 为什么不一直使用HTTPS 原因有，因为与纯文本通信相比，加密通信会消耗更多的CPU及内存资源。因此，如果是非敏感信息则使用HTTP通信。只有在包含个人信息等敏感数据时，才会利用HTTPS加密通信。 除此之外，想要节约购买证书的开销也是原因之一。 确定访问用户身份的认证为了认证使用者的信息，通常是指以下这些： 密码（只有本人才会知道的字符串信息） 动态令牌：仅限本人持有的设备内显示一次性密码 数字证书：仅限本人（终端）持有的信息 生物认证：指纹和虹膜等本人的生理信息 IC卡等：仅限本人持有的信息 HTTP使用的认证方式 HTTP/1.1使用的认证方式如下 BASIC认证（基本认证） DIGEST认证（摘要认证） SSL客户端认证 FormBase认证（基于表单认证） 为减轻跨站脚本攻击（XSS）造成的损失，建议事先在Cookie内加上httponly属性 基于HTTP的功能追加协议消除HTTP瓶颈的SPDY若想在现有的Web实现所需的功能，以下这些HTTP标准就会成为瓶颈 一条连接上只能发送一条请求 请求只能从客户端开始。客户端不可以接收除响应以外的指令。 请求/响应首部未经压缩就发送。首部信息越多延迟越大 发送冗长的首部。每次互相发送相同的首部造成的浪费较多 可热议选择数据压缩格式。非强制压缩发送。 Ajax的解决方法 Ajax是一种javascript和DOM的操作，以达到局部web页面替换加载的异步通信手段。而利用Ajax实时地从服务器获取内容，有可能会导致大量请求产生。 Comet的解决方法 一旦服务器端有内容更新了，comet不会让请求等待，而是直接给客户端返回响应。这是一种通过延迟应答，模拟实现服务器端向客户端推送（Server Push）的功能。 内容上虽然可以做到实时更新，但为了保留响应，一次连接的持续时间也变长了。期间，为了维持连接会消耗更多的资源。 SPDY的设计与功能 SPDY以会话层的形式加入，控制对数据的流动，但还是采用HTTP建立通信连接。 使用SPDY后，HTTP协议额外获得以下功能： 多路复用流 通过单一的TCP连接，可以无限制处理多个HTTP请求。 赋予请求优先级 压缩HTTP首部 推送功能 服务器提示功能 使用浏览器进行全双工通信的WebSocket一旦web服务器与客户端之间建立websocket协议的通信连接，之后所有的通信都依靠这个专用协议进行。通信过程中可互相发送JSON，XML，HTML或图片等任意格式的数据 WebSocket协议的特点 推送功能 减少通信量 为了实现Websocket，在HTTP连接建立之后，需要完成一次“握手”的步骤 期盼已久的HTTP/2.0HTTP/2.0的特点 SPDY HTTP Speed + Mobility Network-Friendly HTTP Upgrade HTTP/2.0 的7项技术及讨论 压缩 多路复用 TSL义务化 协商 客户端拉拽/服务器推送 流量控制 websocket Web服务器管理文件的WebDAVWebDAV（基于万维网的分布式创作和版本控制） 是一个可对Web服务器上的内容直接进行文件复制，编辑等操作的分布式文件系统。 除了创建、删除等基本功能外，他还具备文件创建者管理，文件编辑过程中禁止其他用户内容覆盖的加锁功能，以及对文件内容修改的版本控制功能。 构建Web内容的技术HTMLCSSJAVASCRIPT 与Web服务器及程序协作的CGI CGI（通用网关接口）是指Web服务器在接收到客户端发送过来的请求后转发给程序的一组机制。在CGI的作用下，程序会对请求内容做出相应的动作。 针对web的攻击技术对Web应用的攻击模式有以下两种 主动攻击 具有代表性的攻击是SQL注入攻击和OS命令注入攻击 被动攻击 具有代表性的攻击是跨站脚本攻击(XSS)和跨站点请求伪造(CORS) 实施web应用的安全对策可大致分为以下两部分。 客户端的验证 web应用端（服务器端）的验证 输入值验证 输出值转义]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入url到页面展示到底发生了什么]]></title>
    <url>%2F2018%2F07%2F10%2FHTTP%2F%E4%BB%8E%E8%BE%93%E5%85%A5url%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[前言刚开始写这篇文章还是挺纠结的，因为网上搜索“从输入url到页面展示到底发生了什么”，你可以搜到一大堆的资料。而且面试这道题基本是必考题，二月份面试的时候，虽然知道这个过程发生了什么，不过当面试官一步步追问下去的，很多细节就不太清楚了。 最近刚好也在看http协议相关的东西，所以想对这个话题来个深入的总结，本文的目的是 通过输入url之后发生的事情来做知识的总结和扩展。所以文章可能会很杂。 总的过程大概如下: 输入地址当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得 url 了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的 url，然后给出智能提示，让你可以补全url地址。对于 google的chrome 的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下 enter，页面就出来了。 浏览器查找域名的ip地址 1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的 hosts 文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用 hosts 文件里面的 ip 地址。 2、如果在本地的 hosts 文件没有能够找到对应的 ip 地址，浏览器会发出一个 DNS请求到本地DNS服务器 。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。 3、查询你输入的网址的DNS请求到达本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果，此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。 4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址。这种过程是迭代的过程。 5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。 6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。 下面一图完美解释了上面所述 知识扩展：什么是DNSDNS（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。 通俗的讲，我们更习惯于记住一个网站的名字，比如www.baidu.com,而不是记住它的`ip地址`，比如：167.23.10.2。而计算机更擅长记住`网站的ip地址`，而不是像www.baidu.com等链接。因为，DNS就相当于一个电话本，比如你要找www.baidu.com这个域名，那我翻一翻我的电话本，我就知道，哦，它的电话（ip）是167.23.10.2。 DNS查询的两种方式：递归查询和迭代查询1、递归解析 当局部DNS服务器自己不能回答客户机的DNS查询时，它就需要向其他DNS服务器进行查询。此时有两种方式，如图所示的是递归方式。局部DNS服务器自己负责向其他DNS服务器进行查询，一般是先向该域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。 2、迭代解析 当局部DNS服务器自己不能回答客户机的DNS查询时，也可以通过迭代查询的方式进行解析，如图所示。局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DNS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。比如说：baidu.com的服务器ip地址在192.168.4.5这里，你自己去查吧，本人比较忙，只能帮你到这里了。 3、DNS域名称空间的组织方式 我们在前面有说到根DNS服务器，域DNS服务器，这些都是DNS域名称空间的组织方式。按其功能命名空间中用来描述 DNS 域名称的五个类别的介绍详见下表中，以及与每个名称类型的示例 4、DNS负载均衡 当一个网站有足够多的用户的时候，假如每次请求的资源都位于同一台机器上面，那么这台机器随时可能会蹦掉。处理办法就是用DNS负载均衡技术，它的原理是在DNS服务器中为同一个主机名配置多个IP地址,在应答DNS查询时,DNS服务器对每个查询将以DNS文件中主机记录的IP地址按顺序返回不同的解析结果,将客户端的访问引导到不同的机器上去,使得不同的客户端访问不同的服务器,从而达到负载均衡的目的｡例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等。 浏览器向web服务器发送一个HTTP请求拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535）向服务器的WEB程序（常用的有httpd,nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外），进入到网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核的模块）的过滤，最终到达WEB程序，最终建立了TCP/IP的连接。 建立了TCP连接之后，发起一个http请求。一个典型的 http request header 一般需要包括请求的方法，例如 GET 或者 POST 等，不常用的还有 PUT 和 DELETE 、HEAD、OPTION以及 TRACE 方法，一般的浏览器只能发起 GET 或者 POST 请求。 客户端向服务器发起http请求的时候，会有一些请求信息，请求信息包含三个部分： 请求方法URI协议/版本 请求头(Request Header) 请求正文： 下面是一个完整的HTTP请求例子： GET/sample.jspHTTP/1.1 Accept:image/gif.image/jpeg,*/* Accept-Language:zh-cn Connection:Keep-Alive Host:localhost User-Agent:Mozila/4.0(compatible;MSIE5.01;Window NT5.0) Accept-Encoding:gzip,deflate username=jinqiao&amp;password=1234 注意：最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。 （1）请求的第一行是“方法URL议/版本”：GET/sample.jsp HTTP/1.1 （2）请求头(Request Header) 请求头包含许多有关的客户端环境和请求正文的有用信息。例如，请求头可以声明浏览器所用的语言，请求正文的长度等。 （3）请求正文 请求头和请求正文之间是一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：username=jinqiao&amp;password=1234 知识扩展TCP的三次握手第一次握手：客户端A将标志位SYN置为1,随机产生一个值为seq=J（J的取值范围为=1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认； 第二次握手：服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。 第三次握手：客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A与服务端B之间可以开始传输数据了。 如图所示 为什需要三次握手？《计算机网络》第四版中讲“三次握手”的目的是 “为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误” 书中的例子是这样的，“已失效的连接请求报文段”的产生在这样一种情况下：client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。于是就向client发出确认报文段，同意建立连接。 假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。 采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”。主要目的 防止server端一直等待，浪费资源。 TCP四次挥手第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。 如图所示: 为什么建立连接是三次握手，而关闭连接却是四次挥手呢？这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即close，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。 浏览器的永久重定向响应服务器给浏览器响应一个301永久重定向响应，这样浏览器就会访问“http://www.google.com/” 而非“http://google.com/”。 为什么服务器一定要重定向而不是直接发送用户想看的网页内容呢？其中一个原因跟搜索引擎排名有关。如果一个页面有两个地址，就像http://www.yy.com/和http://yy.com/，搜索引擎会认为它们是两个网站，结果造成每个搜索链接都减少从而降低排名。而搜索引擎知道301永久重定向是什么意思，这样就会把访问带www的和不带www的地址归到同一个网站排名下。还有就是用不同的地址会造成缓存友好性变差，当一个页面有好几个名字时，它可能会在缓存里出现好几次。 知识扩展301和302的区别。301和302状态码都表示重定向，就是说浏览器在拿到服务器返回的这个状态码后会自动跳转到一个新的URL地址，这个地址可以从响应的Location首部中获取（用户看到的效果就是他输入的地址A瞬间变成了另一个地址B）——这是它们的共同点。 他们的不同在于。301表示旧地址A的资源已经被永久地移除了（这个资源不可访问了），搜索引擎在抓取新内容的同时也将旧的网址交换为重定向之后的网址； 302表示 旧地址A的资源还在（仍然可以访问），这个重定向只是临时地从旧地址A跳转到地址B，搜索引擎会抓取新的内容而保存旧的网址。 SEO302好于301 重定向原因：（1）网站调整（如改变网页目录结构）； （2）网页被移到一个新地址； （3）网页扩展名改变(如应用需要把.php改成.Html或.shtml)。 这种情况下，如果不做重定向，则用户收藏夹或搜索引擎数据库中旧地址只能让访问客户得到一个404页面错误信息，访问流量白白丧失；再者某些注册了多个域名的网站，也需要通过重定向让访问这些域名的用户自动跳转到主站点等。 什么时候进行301或者302跳转呢？当一个网站或者网页24—48小时内临时移动到一个新的位置，这时候就要进行302跳转，而使用301跳转的场景就是之前的网站因为某种原因需要移除掉，然后要到新的地址访问，是永久性的。 清晰明确而言：使用301跳转的大概场景如下： 1、域名到期不想续费（或者发现了更适合网站的域名），想换个域名。 2、在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。 3、空间服务器不稳定，换空间的时候。 浏览器跟踪重定向地址现在浏览器知道了 “http://www.google.com/“才是要访问的正确地址，所以它会发送另一个http请求。这里没有啥好说的 服务器处理请求经过前面的重重步骤，我们终于将我们的http请求发送到了服务器这里，其实前面的重定向已经是到达服务器了，那么，服务器是如何处理我们的请求的呢？ 后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。 一些大一点的网站会将你的请求到反向代理服务器中，因为当网站访问量非常大，网站越来越慢，一台服务器已经不够用了。于是将同一个应用部署在多台服务器上，将大量用户的请求分配给多台机器处理。此时，客户端不是直接通过HTTP协议访问某网站应用服务器，而是先请求到Nginx，Nginx再请求应用服务器，然后将结果返回给客户端，这里Nginx的作用是反向代理服务器。同时也带来了一个好处，其中一台服务器万一挂了，只要还有其他服务器正常运行，就不会影响用户使用。 如图所示 通过Nginx的反向代理，我们到达了web服务器，服务端脚本处理我们的请求，访问我们的数据库，获取需要获取的内容等等，当然，这个过程涉及很多后端脚本的复杂操作。由于对这一块不熟，所以这一块只能介绍这么多了。 扩展阅读：什么是反向代理？客户端本来可以直接通过HTTP协议访问某网站应用服务器，网站管理员可以在中间加上一个Nginx，客户端请求Nginx，Nginx请求应用服务器，然后将结果返回给客户端，此时Nginx就是反向代理服务器。 服务器返回一个HTTP响应经过前面的6个步骤，服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。HTTP响应与HTTP请求相似， HTTP响应也由3个部分构成，分别是： 状态行 响应头(Response Header) 响应正文 HTTP/1.1 200 OK Date: Sat, 31 Dec 2005 23:59:59 GMT Content-Type: text/html;charset=ISO-8859-1 Content-Length: 122 ＜html＞ ＜head＞ ＜title＞http＜/title＞ ＜/head＞ ＜body＞ ＜!-- body goes here --＞ ＜/body＞ ＜/html＞ 状态行： 状态行由协议版本、数字形式的状态代码、及相应的状态描述，各元素之间以空格分隔。格式: HTTP-Version Status-Code Reason-Phrase CRLF 例如: HTTP/1.1 200 OK \r\n – 协议版本：是用http1.0还是其他版本 – 状态描述：状态描述给出了关于状态代码的简短的文字描述。比如状态代码为200时的描述为 ok – 状态代码：状态代码由三位数字组成，第一个数字定义了响应的类别，且有五种可能取值。如下 1xx：信息性状态码，表示服务器已接收了客户端请求，客户端可继续发送请求。 100 Continue 101 Switching Protocols 2xx：成功状态码，表示服务器已成功接收到请求并进行处理。 200 OK 表示客户端请求成功 204 No Content 成功，但不返回任何实体的主体部分 206 Partial Content 成功执行了一个范围（Range）请求 3xx：重定向状态码，表示服务器要求客户端重定向。 301 Moved Permanently 永久性重定向，响应报文的Location首部应该有该资源的新URL 302 Found 临时性重定向，响应报文的Location首部给出的URL用来临时定位资源 303 See Other 请求的资源存在着另一个URI，客户端应使用GET方法定向获取请求的资源 304 Not Modified 服务器内容没有更新，可以直接读取浏览器缓存 307 Temporary Redirect 临时重定向。与302 Found含义一样。302禁止POST变换为GET，但实际使用时并不一定，307则更多浏览器可能会遵循这一标准，但也依赖于浏览器具体实现 4xx：客户端错误状态码，表示客户端的请求有非法内容。 400 Bad Request 表示客户端请求有语法错误，不能被服务器所理解 401 Unauthonzed 表示请求未经授权，该状态代码必须与 WWW-Authenticate 报头域一起使用 403 Forbidden 表示服务器收到请求，但是拒绝提供服务，通常会在响应正文中给出不提供服务的原因 404 Not Found 请求的资源不存在，例如，输入了错误的URL 5xx：服务器错误状态码，表示服务器未能正常处理客户端的请求而出现意外错误。 500 Internel Server Error 表示服务器发生不可预期的错误，导致无法完成客户端的请求 503 Service Unavailable 表示服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常 响应头： 响应头部：由关键字/值对组成，每行一对，关键字和值用英文冒号”:”分隔，典型的响应头有： 响应正文 包含着我们需要的一些具体信息，比如cookie，html,image，后端返回的请求数据等等。这里需要注意，响应正文和响应头之间有一行空格，表示响应头的信息到空格为止，下图是fiddler抓到的请求正文，红色框中的：响应正文： 浏览器显示HTML在浏览器没有完整接受全部HTML文档时，它就已经开始显示这个页面了，浏览器是如何把页面呈现在屏幕上的呢？不同浏览器可能解析的过程不太一样，这里我们只介绍webkit的渲染过程，下图对应的就是WebKit渲染的过程，这个过程包括： 解析html以构建dom树 -&gt; 构建render树 -&gt; 布局render树 -&gt; 绘制render树 浏览器在解析html文件时，会自上而下加载，并在加载过程中进行解析渲染。在解析过程中，如果遇到请求外部资源时，如图片、外链的CSS、iconfont等，请求过程是异步的，并不会影响html文档进行加载。 解析过程中，浏览器首先会解析HTML文件构建DOM树，然后解析CSS文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。这个过程比较复杂，涉及到两个概念: reflow(回流)和repain(重绘)。 DOM节点中的各个元素都是以盒模型的形式存在，这些都需要浏览器去计算其位置和大小等，这个过程称为relow;当盒模型的位置,大小以及其他属性，如颜色,字体,等确定下来之后，浏览器便开始绘制内容，这个过程称为repain。 页面在首次加载时必然会经历reflow和repain。reflow和repain过程是非常消耗性能的，尤其是在移动设备上，它会破坏用户体验，有时会造成页面卡顿。所以我们应该尽可能少的减少reflow和repain。 当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程s，不仅要等待文档中js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。因为JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。所以我明平时的代码中，js是放在html文档末尾的。 JS的解析是由浏览器中的JS解析引擎完成的，比如谷歌的是V8。JS是单线程运行，也就是说，在同一个时间内只能做一件事，所有的任务都需要排队，前一个任务结束，后一个任务才能开始。但是又存在某些任务比较耗时，如IO读写等，所以需要一种机制可以先执行排在后面的任务，这就是：同步任务(synchronous)和异步任务(asynchronous)。 JS的执行机制就可以看做是一个主线程加上一个任务队列(task queue)。同步任务就是放在主线程上执行的任务，异步任务是放在任务队列中的任务。所有的同步任务在主线程上执行，形成一个执行栈;异步任务有了运行结果就会在任务队列中放置一个事件；脚本运行时先依次运行执行栈，然后会从任务队列里提取事件，运行任务队列中的任务，这个过程是不断重复的，所以又叫做事件循环(Event loop)。 浏览器发送请求嵌入HTML中的资源（如图片，音频，视频，css,js等）其实这个步骤可以并列在步骤8中，在浏览器显示HTML时，它会注意到需要获取其他地址内容的标签。这时，浏览器会发送一个获取请求来重新获得这些文件。比如我要获取外图片，CSS，JS文件等，类似于下面的链接： 图片：http://static.ak.fbcdn.net/rsrc.php/z12E0/hash/8q2anwu7.gif CSS式样表：http://static.ak.fbcdn.net/rsrc.php/z448Z/hash/2plh8s4n.css JavaScript 文件：http://static.ak.fbcdn.net/rsrc.php/zEMOA/hash/c8yzb6ub.js 这些地址都要经历一个和HTML读取类似的过程。所以浏览器会在DNS中查找这些域名，发送请求，重定向等等… 不像动态页面，静态文件会允许浏览器对其进行缓存。有的文件可能会不需要与服务器通讯，而从缓存中直接读取，或者可以放到CDN中\ 原文地址]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封闭了内心却包容了天下，闭包你并不孤独]]></title>
    <url>%2F2018%2F07%2F06%2FJs%2F%E5%B0%81%E9%97%AD%E4%BA%86%E5%86%85%E5%BF%83%E5%8D%B4%E5%8C%85%E5%AE%B9%E4%BA%86%E5%A4%A9%E4%B8%8B%EF%BC%8C%E9%97%AD%E5%8C%85%E4%BD%A0%E5%B9%B6%E4%B8%8D%E5%AD%A4%E7%8B%AC%2F</url>
    <content type="text"><![CDATA[前言本文之所以会写这种老生常谈的文章，是为了接下来的设计模式做铺垫。既然已经提笔了，就打算不改了，继续写下去，相信也一定有很多人对闭包这样的概念有些模糊，那就瞧一瞧、看一看 毕竟闭包和高阶函数这两种概念，在开发中是非常有分量的。好处多多，妙处多多，那么我们就不再兜圈子了，直接开始今天的主题，闭包&amp;高阶函数 变量作用域首先变量作用域分为两类：全局作用域和局部作用域，这个没话说大家都懂。我们常说的变量作用域其实也主要是在函数中声明的作用域 在函数中声明变量时没有var关键字，就代表是 全局变量 在函数中声明变量带有var关键字的即是 局部变量，局部变量只能&lt;在函数内才能访问到&gt; function fn() { var a = 110; // a为局部变量 console.log(a); // 110 } fn(); console.log(a); // a is not defined 外部访问不到内部的变量 上面代码展示了在函数中声明的局部变量a在函数外部确实无法拿到。小样儿的还挺嚣张，对于迎难而上的coder来说，还不信拿不下a了 函数可以创造函数作用域，在函数作用域中如果要查找一个变量的时候，如果在该函数内没有声明这个变量，就会向该函数的外层继续查找，一直查到全局变量为止 所以变量的查找是由内而外的，这也形成了所谓的作用域链 var a = 7; function outer() { var b = 9; function inner() { var c = 8; alert(b); alert(a); } inner(); alert(c); // c is not defined } outer(); // 调用函数 利用作用域链，我们试着去拿到a，改造一下 fn函数 function fn() { var a = 110; // a为局部变量 return function() { console.log(a); } console.log(a); // 110 } var fn2 = fn(); fn2(); // 110 如此这般，这般如此，轻而易举，小case的事，就可以从外面访问到局部变量a了 那么到此为止，我们已经发现了闭包的其中一个意义：闭包就是能够读取其他函数内部变量的函数，嗯，没毛病，继续往下看 变量声明周期 在解决了上面如何拿到小样儿a的问题，我们不妨再把变量生命周期这个概念先简单地过一遍。 对于全局变量来说，它的生命周期自然是永久的(forever)，除非我们不高兴，主动干掉它，报销它。 而对于在函数中通过var声明的局部变量来说，就没那么幸运了，当函数执行完毕，局部变量们就失去了价值，就被垃圾回收机制给当成垃圾处理掉了 比如像下面这样的代码就很可怜 function fn() { var a = 123; // fn执行完毕后，变量a就将被销毁了 console.log(a); } fn(); 虽然以上垃圾回收的过程我们无法亲眼看见，但是听者伤心闻者流泪啊。可不可以不要如此残忍，我愿倾其所有，换你三生三世。 悲伤的到来，我们无法拒绝，那就让我们想办法去改变这一切。现在再让我们来看下这段代码： function add() { var a = 1; return function() { a++; console.log(a); } } var fn = add(); fn(); // 2 fn(); // 3 fn(); // 4 这段代码最神奇的地方就是，当add函数执行完后，局部变量a并没有被销毁，而是依然存在，这其中到底发生了什么？让我们慢慢分析一下： 当fn = add()时，fn返回了一个函数的引用，这个函数里有局部变量a 既然这个局部变量还能被外部访问fn()，就没有必要把它给销毁了，于是就保留了下来 闭包是个好东西，可以完成很多工作，其中就包括一道网上常考的经典题目 &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; var aLi = document.getElementsByTagName(&#39;li&#39;); for (var i = 0; i &lt; aLi.length; i++) { aLi[i].onclick = function() { console.log(i); // ? }; } &lt;/script&gt; 过这道题的观众请举手，确实这道题的目的就是为了考对闭包的理解。上面的答案无论怎么点结果都是4。 这是因为li节点的onclick事件属于异步的，在click被触发的时候，for循环以迅雷不及掩耳盗铃的速度就执行完毕了，此时变量i的值已经是4了 因此在li的click事件函数顺着作用域链从内向外开始找i的时候，发现i的值已经全是4了 解决方法就需要通过闭包，把每次循环的i值都存下来。然后当click事件继续顺着作用域链查找的时候，会先找到被存下来的i，这样每一个li点击都可以找到对应的i值了 &lt;script&gt; var aLi = document.getElementsByTagName(&#39;li&#39;); for (var i = 0; i &lt; aLi.length; i++) { (function(n) { // n为对应的索引值 aLi[i].onclick = function() { console.log(n); // 0, 1, 2, 3 }; })(i); // 这里i每循环一次都存一下，然后把0,1,2,3传给上面的形参n } &lt;/script&gt; 其他作用闭包应用非常广泛，我们这里就说一下大家熟知的，比如可以 封装私有变量，可以把一些不需要暴露在全局的变量封装成私有变量，这样可以防止造成变量的全局污染 var sum = (function() { var cache = {}; // 将cache放入函数内部，避免被其他地方修改 return function() { var args = Array.prototype.join.call(arguments, &#39;,&#39;); if (args in cache) { return cache[args]; } var a = 0; for (var i = 0; i &lt; arguments.length; i++) { a += arguments[i]; } return cache[args] = a; } })(); 除此之外相信很多人都见过一些库如jQuery,underscore他们的最外层都是类似如下样子的代码 (function(win, undefined) { var a = 1; var obj = {}; obj.fn = function() {}; // 最后把想要暴露出去的内容可以挂载到window上 win.obj = obj; })(window); 是的，没错，利用闭包也可以做到模块化。另外还可以将变量的使用延长，再来看一个例子 var monitor = (function() { var imgs = []; return function(src){ var img = new Image(); imgs.push(img); img.src = src; } })(); monitor(&#39;http://dd.com/srp.gif&#39;); 上面的代码是用于打点进行统计数据的情形，在之前的一些浏览器中，会出现打点丢失的情况，因为img是函数内的局部变量，当函数执行完后img就被销毁了，而此时可能http请求还没有发出。 所以遇到这种情况的时候，把img变量用闭包封装起来，就可以解决了 内存管理很多人都听过一个版本，就是闭包会造成内存泄漏，所以要尽量减少闭包的使用 Just now就来为闭包来正名，不是你想象那样的： 局部变量本来应该随着函数的执行完毕被销毁，但如果局部变量被封装在闭包形成的环境中，那这个局部变量就一直能存在。从我们上面实践得出的结果来看，这话说的没毛病 But之所以使用闭包是因为我们想要把一些变量存起来方便以后使用，这和放到全局下，对内存的影响是一致的，并不算是内存泄漏。如果在将来想回收这些变量，直接把变量设为null即可了 还有就是在使用闭包的同时比较容易形成循环引用，如果闭包的作用域链中保存着一些DOM节点，此时就有可能造成内存泄漏。但这本身并非闭包的问题，也并非js的问题 要怪就怪老版本的IE同志吧，它内部实现的垃圾回收机制采用的是引用计数策略。在老同志IE中，如果两个对象之间形成了循环引用，那么这两个对象都不能被回收，但循环引用造成的内存泄漏其本质也不是闭包的错 同样要解决循环引用代理的内存泄漏问题，只需把循环引用中的变量设为null就好 上面就是我们替闭包的正名，闭包也不容易，被人用还不讨好。它明白，不是它的锅，它是不需要背的！ 这不是终点虽然不是终点，但还是要搞个总结性发炎的，不然怎么对得起扁桃体兄 闭包： 是一个能够读取其他函数内部变量的函数，实质上是变量的解析过程(由内而外) 可以用来封装私有变量，实现模块化 可以保存变量到内存中 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你需要了解的23种javascript设计模式]]></title>
    <url>%2F2018%2F07%2F02%2FJs%2F%E4%BD%A0%E9%9C%80%E8%A6%81%E4%BA%86%E8%A7%A3%E7%9A%8423%E7%A7%8Djavascript%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为什么要学习设计模式？在许多访谈中，你可能会遇到很多面向对象编程中的接口，抽象类，代理和以及其他与设计模式相关的问题。 一旦了解了设计模式，它会让你轻松应对任何访谈，并可以在你的项目中应用这些特性。在应用程序中实现设计模式已经得到验证和测试。 为了使应用程序具有可扩展性，可靠性和易维护性，应该编写符合设计模式的代码。 什么是设计模式 设计模式是我们每天编程遇到的可重用解决方案。 设计模式主要是为了解决对象的生成和整合问题。 换句话说，设计模式可以作为可应用于现实世界编程问题的模板。 设计模式的发展历史设计模式的概念是由四人帮（《设计模式（可复用面向对象软件的基础）》的四位作者）提出。 四人帮把这本书分成两部分： 第一部分解释面向对象编程的优缺点。 第二部分是关于 23 个经典设计模式的演变。 自提出设计模式概念后，四人帮设计模式在软件开发生命周期中发挥了重要作用。 设计模式分类根据实际应用中遇到的不同问题，四人帮将设计模式分为三种类型。 创建型模式 结构型模式 行为型模式 接下来将概述属于这三种类型的 23 种设计模式的主要概念。 创建型模式这类模式用于对象的生成和生命周期的管理。 创建模式可以决定生成哪些对象，提高了程序的灵活性，模式如下： 抽象工厂模式 生成器模式 工厂方法模式 单例模式 原型模式 JavaScript 抽象工厂模式 抽象工厂模式究竟是什么？ 它就像一个工厂，但一切被封锁起来： 提供对象的方法 构建对象的工厂 最终的对象 最终对象包含使用策略模式的对象 策略模式只是使用组合的方式，换句话说，它的类字段实际上是对象本身。 抽象工厂模式的用处？ 抽象工厂模式可以创建类簇类的对象，而不需要指定具体的类，这使得抽象工厂很灵活。 通过抽象工厂模式可以对任何类簇对象进行建模并通过统一的接口供外部对象使用。 抽象工厂唯一不好的地方是它可能变得非常复杂 JavaScript 的生成器模式（Builder 模式） Builder 模式是什么？ Builder 模式是一种用于创建由其他对象组合构成的对象的模式。创建部件的方法应该独立于主对象。另外，为了从业务方隐藏部件的创建细节，两者是相互独立的。 在使用生成器模式时，生成器知道所有的细节，且创建细节完全对其他相关类屏蔽。 JavaScript 工厂方法模式 什么是工厂方法模式？ 根据定义，只要想一个方法返回公共超类的几个可能的类中的一个，就可以使用工厂模式。 假设我想随机向屏幕上射击敌人。那么如果所有东西都硬编码好了，并且不知道敌人的具体类型会让处理变得很困难。 但是，假设我创建了一个随机数生成器，每个可能的敌人类都由一个数字代替，并可以由该随机数生成器返回。 然后可以将这个数字发送给工厂对象，这样可以返回一个动态创建的敌人。 所以，MOL 的主要概念非常重要，我们希望能够在运行时选择类，这就是工厂模式能够提供的。 何时使用工厂模式 当不知道需要何种类型的对象时可以使用工厂方法模式。 但是，有一点需要注意，确保所有潜在的类都具有相同的子类层次结构，这意味着在继承路径上有相同的父类。 可以使用工厂模式来集中类别选择的代码。或是不希望用户知道每一个可能的子类时。 JavaScript 单例模式 什么是单例模式？ 当想要避免实例化多个对象时使用单例模式。单例使得只能从类实例化一个对象。 现在你可能会问自己，我什么时候会想要这样做？ 其实，有很多场景。 我们已经演示过拼字游戏里使用一个类容纳所有可能的字母，并且拼字游戏是一款非常常见的棋盘游戏，这里使用单例模式是很明智的选择。 这个单例类包含所有可能的拼字游戏字母，以便玩家可以使用这个单例类取得所有字母，不同玩家可以同时请求获取。 单例使得每个玩家都共享相同的字母列表，每个玩家可以根据这个字母列表来拼接自己的单词。 Javascript 原型模式 什么是原型模式？ 当想要通过克隆或拷贝对象来生成对象时，这就是原型模式。 通过原型模式可以在运行时添加已知父类的子类实例。 当有许多类只在运行时需要使用时可以使用原型模式。原型模式的好处之一是减少了创建多个子类。 结构型模式 这类模式描述了向现有对象添加功能的不同方式简单地说，这个模式着重于解耦对象的接口实现模式如下： 适配器模式 桥接模式 组合模式 装饰者模式 外观模式 享元模式 代理模式 JavaScript 适配器设计模式 适配器模式的作用 适配器设计模式允许使用两个完全不兼容的接口一起工作，正如其名字一样，适配不同接口。 假设你墙上的插座只有两座插头，但是你想连接一个三座的插头，这时就需要适配器了。 当客户期望使用目标接口是两座插头，但是你只有三座插头，这就是适配器将要执行的操作 把三座转换成两座。 适配器模式允许使用任何现有接口适配为目标接口。 从另一个角度看任何类都可以协同工作只要适配器解决了所有类都必须实现相同接口的问题。 Javascript 桥接模式 什么是桥接模式 官方定义是将抽象与其实现分离开来，因此两者可以独立变化。 该模式用于将抽象与其实现分开，以便两者都可以独立修改。该模式包含一个用于桥接抽象类和实现类的接口。通过桥接模式，两种类型都可以修改而不会相互影响。 桥接模式实现指南 当想要避免抽象与其实现之间的永久绑定时可以使用桥接模式。 抽象和它们的实现都应该可以通过子类进行扩展。当抽象的实现有变化时不应该影响到调用方，及调用方不需要重新编译。 当需要在多个对象之间共享一个实现时，可以选择这种模式。 最后我们希望完全对调用方隐藏抽象的实现。 JavaScript 组合模式组合模式从定义上看起来很复杂，一旦用起来就会感觉很合理。 它允许统一处理单个对象和对象组合，这是组合设计模式的典型定义。 组合模式可以表示为部分 - 整体的层次结构。该结构的组件又可以划分为更小的组件。 一个更合乎逻辑的定义是组合设计模式是用来结构化数据或单独表示整个对象的每个部分的互相操作。 JavaScript 装饰模式 什么是装饰模式？ 动态的为一个对象附加额外的功能，装饰模式可以不通过继承来实现功能扩展。 这种模式属于结构设计模式类别，也被称为包装模式，装饰设计模式解决了在不改变对象现有结构的情况下添加附加功能的问题。 另外，该模式创建了一个装饰器类，它包装原始类并在运行时向对象添加新的行为或操作。 装饰模式的实现指南 当选择这种模式时，需要动态地向单个对象添加新的功能，并且而不会影响其他对象。 例如，在有些情况下，为原有代码添加新的功能可能会很困难，用修饰器修改代码会更容易些。 通过继承来实现功能扩展会产生大量的子类，并且有可能这些子类还不足以覆盖所有需要扩展的功能。 当无法查看类定义或无法继承时，需要选择装饰模式。 例如，尽管类被封装起来无法修改，通过装饰模式仍然可以进行扩展，并且，我相信你肯定也遇到过无法通过继承来实现功能扩展的情况，在这些情况下，选择装饰模式。 Javascript 外观模式 什么是外观模式？ 为子系统中的一组接口提供统一接口。外观模式定义了一个更高层次的接口，使子系统更易于使用。术语外观来自法语 façade，意思是正面或脸。 简单来说是外观模式隐藏了子系统的实现复杂性，为我们提供了一个简洁的接口。该接口负责调用现有子系统的功能 外观模式实现指南 当我们想为子系统提供一个简单的接口时需要使用外观模式。随着子系统的发展，子系统往往会变得更加复杂。 当我们在应用一些模式时，大多数模式会导致更多的类创建出来，这使得子系统可用性更好，更容易自定义需要的功能，但对于不太需要自定义的业务方而言，它也变得更加困难。 外观模式将子系统包装成一个简单默认的接口，足以应付大多数情况的使用。 另外，当业务方和子系统的实现存在过多依赖时也可以选择外观模式。 在这种情况下，外观模式将子系统从业务方和其他子系统中分离出来，从而提高子系统的独立性和可移植性。 到目前为止，如果子系统过于耦合，那么可以通过外观模式提供的接口来简化子系统之间的依赖。 JavaScript 享元模式当需要创建大量相似对象时需要使用享元模式，这里的大量是上万的量级而不是平时接触的上百。 享元模式通过 共享对象的相似部分，避免重复创建，来达到减小内存的使用。 JavaScript 代理模式 什么是代理设计模式？ 代理是一个 将被用来限制访问另一个类的类。 这可能是出于安全的考虑，通过代理来决定需要代理的对象哪些方法是可用的。 行为型模式这类模式描述了对象如何相互作用，模式如下： 责任链模式 命令模式 解释器模式 迭代器模式 中介者模式 备忘录模式 观察者模式 状态模式 策略模式 模板方法模式 访问者模式 JavaScript 责任链模式责任链模式有一组对象，期望它们之间能够解决问题，如果第一个对象无法解决它，则将数据传递给责任链中的下一个数据。 通过多个接收者对象来处理请求，避免将请求的发送者耦合到其接收者。将接收对象串联起来，传递请求直到被其中一个处理掉。 责任链模式为 请求创建一系列接收者对象。 在这种模式下，通常每个接收器都包含对另一个接收器的引用。 如果一个接收者不能处理该请求，则它将请求传递给下一个接受者。 JavaScript 命令模式 什么是命令模式？ 命令设计模式是一种行为设计模式，其对象用于表示和封装稍后调用某个方法所需的所有信息。该信息包括方法名称，拥有方法的对象和方法参数的值。 基本上，它允许你做的是存储代码清单，在稍后或多次执行，并且通常使用命令模式可以撤销命令。 当这些封装的对象调用 execute() 方法，业务方或程序会执行指定命令或一段代码。 然后，调用者对象在调用时会传递命令给命令接收者，命令接收者拥有实际想要执行的代码，一旦从调用者接收到命令就立马执行。 例如有个”TurnTVOn”的命令对象，然后一个“DeviceButton”的对象，一旦”DeviceButton”对象被调用就会发送”TurnTVOn”命令。所有这些之间的接口可以使用多态，所以无论何时调用 TurnTVOn，该方法将由命令接收者执行。 JavaScript 解释器模式 什么是解释器模式 解释器模式很容易被忽略，并且网上很少有使用这种模式。 但是，如果与 JavaScript 反射技术结合使用，会变得非常有用。它用于将数据的一种表示转换为另一种表示。 JavaScript 迭代器模式 什么是迭代器模式？ 迭代器模式提供一种统一的方式来访问不同类型的对象集合。 例如，Array，ArrayList 和 HashTable，这三个集合包含相同类型的对象，通过迭代器可以取到集合里的每一个元素，并做相同的处理。 迭代器模式做的是提供统一的方式来循环遍历这些不同类型的集合。 JavaScript 中介者计模式 什么是中介者模式？ 用于处理相关对象之间的通信。所有通信由中介者完成，通信双方不需要了解对方的任何信息。 更严格的定义是，中介者模式允许通过封装不同对象之间相互作用和相互通信的方式来实现松耦合，并且中介者模式允许每个对象的行为彼此独立地变化。 Javascript 备忘录模式 什么是备忘录模式？ 用于存储对象以前状态的模式，首先，备忘录模式需要一个备忘录对象用于存储对象的不同状态，不同的状态及一些字段拥有不同的值。 然后，用于从当前目标备忘录对象读写值的初始对象，创建新的备忘录对象并赋值给当前备忘录对象。 最后，内部是一个 ArrayList 对象用于持有之前所有的备忘录对象，该 ArrayList 对象同时用于存储和检索备忘录对象 Javascript 观察者模式 什么时候使用观察者模式？ 当另一个对象更改时需要其他对象接收更新。例如，假设我们有一个对象或发布者代表股票市场中的数千个股票，当需要将更新发送给多个订阅者时，可以使用观察者模式来完成。 观察者模式的好处 松耦合。 对象或发布者完全不用知道观察者或订阅者的存在，我把这分为两种不同的概念，因为我觉得发布 - 订阅更有意义，但 OLP 的基本术语使用的是对象 - 观察者。 坏处 观察者模式唯一的缺点是对象或发布者可能发送对观察者，订阅者无关紧要的更新。 JavaScript 状态模式 什么是状态模式？ 它允许对象在其内部状态改变时改变其行为，这样让对象看起来改变了它所属的类。 状态模式主要分为三个部分： 首先，将拥有所谓的“上下文”或“账户”，它将要做的是维护一个将定义当前状态的 ConcreteState 子类的实例。 然后，拥有“状态”，该状态定义了一个用于封装与上下文特定状态关联的行为接口。 最后是具体的状态，每个子类将实现与上下文状态相关的行为 Javascript 策略模式 何时使用策略模式？ 如果要定义一个类，该类将具有与列表中的所有其他行为相似的行为，可以使用策略模式。 例如，有的动物可以飞，有的动物不能飞，这里的相似行为就是飞行，不论该动物是否能飞行。 可以从以下类中选择类对象： 1.不会飞行2.用翅膀飞翔3.飞得快 通过策略模式可以动态的创建全新的不同类型的飞行类动物。 当需要动态决定需要使用的行为时可以使用策略模式。 使用策略模式的其他好处 它通常会减少很长的条件列表，所以如果你看到使用许多不同类型的条件时，策略模式会很有帮助。当然，还避免了重复的代码。 策略模式可以防止其他类的变化影响到当前类。也可以向业务方隐藏复杂和敏感代码。 坏处：策略模式会增加对象和类的数量。 JavaScript 模板方法模式 什么是模板方法模式？ 用于创建一组执行类似方法的子类。 要实现它，需要创建一个抽象类，它将包含一个名为模板方法的方法。 创建包含称为模板方法的抽象类，并且模板方法包含每个子类对象将调用的一系列方法调用。在某些情况下子类也会重载一些不合适的方法调用。 Javascript 访问者模式 什么是访问者模式 访问者模式允许将方法添加到不同类型的类中 - 但它们不必是不同的类型 - 只会让复杂度有所增加，并不会对类有太多修改。 这可以根据所使用的类制作完全不同的方法。 也可以说访问者模式可以为现有类创建外部类来进行扩展以避免对原有类做修改。 注意：掌握抽象，继承，多态，封装，接口，类和抽象类等面向对象概念的基本知识对于更好地理解设计模式非常重要。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Airbnb React/JSX 编码规范]]></title>
    <url>%2F2018%2F06%2F28%2Fstudy%2FAirbnb-React-JSX-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%2F</url>
    <content type="text"><![CDATA[前言算是最合理的React/JSX编码规范之一了 此编码规范主要基于目前流行的JavaScript标准，尽管某些其他约定(如async/await，静态class属性)可能在不同的项目中被引入或者被禁用。目前的状态是任何stage-3之前的规范都不包括也不推荐使用。 Basic Rules 基本规范每个文件只写一个模块.但是多个无状态模块可以放在单个文件中. eslint: react/no-multi-comp.推荐使用JSX语法.不要使用 React.createElement，除非从一个非JSX的文件中初始化你的app. 创建模块class vs React.createClass vs stateless 如果你的模块有内部状态或者是refs, 推荐使用 class extends React.Component 而不是 React.createClass. eslint: const Listing = React.createClass({ // ... render() { return &lt;div&gt;{this.state.hello}&lt;/div&gt;; } }); // good class Listing extends React.Component { // ... render() { return &lt;div&gt;{this.state.hello}&lt;/div&gt;; } } 如果你的模块没有状态或是没有引用refs， 推荐使用普通函数（非箭头函数）而不是类: // bad class Listing extends React.Component { render() { return &lt;div&gt;{this.props.hello}&lt;/div&gt;; } } // bad (relying on function name inference is discouraged) const Listing = ({ hello }) =&gt; ( &lt;div&gt;{hello}&lt;/div&gt; ); // good function Listing({ hello }) { return &lt;div&gt;{hello}&lt;/div&gt;; } Mixins不要使用Mixins Naming 命名 扩展名：React模块使用.jsx扩展名。 文件名：文件名使用帕斯卡命名。如，ReservationCard.jsx。 引用命名: React模块名使用帕斯卡命名，实例使用骆驼式命名. eslint: react/jsx-pascal-case // bad import reservationCard from &#39;./ReservationCard&#39;; // good import ReservationCard from &#39;./ReservationCard&#39;; // bad const ReservationItem = &lt;ReservationCard /&gt;; // good const reservationItem = &lt;ReservationCard /&gt;; 模块命名: 模块使用当前文件名一样的名称. 比如 ReservationCard.jsx 应该包含名为 ReservationCard的模块. 但是，如果整个文件夹是一个模块，使用 index.js作为入口文件，然后直接使用 index.js 或者文件夹名作为模块的名称: // bad import Footer from &#39;./Footer/Footer&#39;; // bad import Footer from &#39;./Footer/index&#39;; // good import Footer from &#39;./Footer&#39;; 高阶模块命名: 对于生成一个新的模块，其中的模块名 displayName 应该为高阶模块名和传入模块名的组合. 例如, 高阶模块 withFoo(), 当传入一个 Bar 模块的时候， 生成的模块名 displayName 应该为 withFoo(Bar). 为什么？一个模块的 displayName 可能会在开发者工具或者错误信息中使用到，因此有一个能清楚的表达这层关系的值能帮助我们更好的理解模块发生了什么，更好的Debug. // bad export default function withFoo(WrappedComponent) { return function WithFoo(props) { return &lt;WrappedComponent {...props} foo /&gt;; } } // good export default function withFoo(WrappedComponent) { function WithFoo(props) { return &lt;WrappedComponent {...props} foo /&gt;; } const wrappedComponentName = WrappedComponent.displayName || WrappedComponent.name || &#39;Component&#39;; WithFoo.displayName = `withFoo(${wrappedComponentName})`; return WithFoo; } 属性命名: 避免使用DOM相关的属性来用作其他的用途。 为什么？对于style 和 className这样的属性名，我们都会默认它们代表一些特殊的含义，如元素的样式，CSS class的名称。在你的应用中使用这些属性来表示其他的含义会使你的代码更难阅读，更难维护，并且可能会引起bug。 // bad &lt;MyComponent style=&quot;fancy&quot; /&gt; // good &lt;MyComponent variant=&quot;fancy&quot; /&gt; Declaration 声明模块 不要使用 displayName 来命名React模块，而是使用引用来命名模块， 如 class 名称. // bad export default React.createClass({ displayName: &#39;ReservationCard&#39;, // stuff goes here }); // good export default class ReservationCard extends React.Component { } Alignment 代码对齐遵循以下的JSX语法缩进/格式. // bad &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; // good, 有多行属性的话, 新建一行关闭标签 &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; /&gt; // 若能在一行中显示, 直接写成一行 &lt;Foo bar=&quot;bar&quot; /&gt; // 子元素按照常规方式缩进 &lt;Foo superLongParam=&quot;bar&quot; anotherSuperLongParam=&quot;baz&quot; &gt; &lt;Quux /&gt; &lt;/Foo&gt; Quotes 单引号还是双引号 对于JSX属性值总是使用双引号(“), 其他均使用单引号(‘). eslint: jsx-quotes 为什么? HTML属性也是用双引号, 因此JSX的属性也遵循此约定. // bad &lt;Foo bar=&#39;bar&#39; /&gt; // good &lt;Foo bar=&quot;bar&quot; /&gt; // bad &lt;Foo style={{ left: "20px" }} /&gt; // good &lt;Foo style={{ left: '20px' }} /&gt; Spacing 空格 总是在自动关闭的标签前加一个空格，正常情况下也不需要换行. // bad &lt;Foo/&gt; // very bad &lt;Foo /&gt; // bad &lt;Foo /&gt; // good &lt;Foo /&gt; 不要在JSX {} 引用括号里两边加空格 // bad &lt;Foo bar={ baz } /&gt; // good &lt;Foo bar={baz} /&gt; Props 属性 JSX属性名使用骆驼式风格camelCase. // bad &lt;Foo UserName=&quot;hello&quot; phone_number={12345678} /&gt; // good &lt;Foo userName=&quot;hello&quot; phoneNumber={12345678} /&gt; 如果属性值为 true, 可以直接省略. // bad &lt;Foo hidden={true} /&gt; // good &lt;Foo hidden /&gt; // good &lt;Foo hidden /&gt; &lt;img&gt; 标签总是添加 alt 属性. 如果图片以presentation(感觉是以类似PPT方式显示?)方式显示，alt 可为空, 或者&lt;img&gt; 要包含role=”presentation”. // bad &lt;img src=&quot;hello.jpg&quot; /&gt; // good &lt;img src=&quot;hello.jpg&quot; alt=&quot;Me waving hello&quot; /&gt; // good &lt;img src=&quot;hello.jpg&quot; alt=&quot;&quot; /&gt; // good &lt;img src=&quot;hello.jpg&quot; role=&quot;presentation&quot; /&gt; 不要在 alt 值里使用如 “image”, “photo”, or “picture”包括图片含义这样的词， 中文也一样. 为什么? 屏幕助读器已经把 img 标签标注为图片了, 所以没有必要再在 alt 里说明了. // bad &lt;img src=&quot;hello.jpg&quot; alt=&quot;Picture of me waving hello&quot; /&gt; // good &lt;img src=&quot;hello.jpg&quot; alt=&quot;Me waving hello&quot; /&gt; 使用有效正确的 aria role属性值 ARIA roles. // bad - not an ARIA role &lt;div role=&quot;datepicker&quot; /&gt; // bad - abstract ARIA role &lt;div role=&quot;range&quot; /&gt; // good &lt;div role=&quot;button&quot; /&gt; 不要在标签上使用 accessKey 属性. 为什么? 屏幕助读器在键盘快捷键与键盘命令时造成的不统一性会导致阅读性更加复杂. // bad &lt;div accessKey=&quot;h&quot; /&gt; // good &lt;div /&gt; 避免使用数组的index来作为属性key的值，推荐使用唯一ID. // bad {todos.map((todo, index) =&gt; &lt;Todo {...todo} key={index} /&gt; )} // good {todos.map(todo =&gt; ( &lt;Todo {...todo} key={todo.id} /&gt; ))} 对于所有非必须的属性，总是手动去定义defaultProps属性. 为什么? propTypes 可以作为模块的文档说明, 并且声明 defaultProps 的话意味着阅读代码的人不需要去假设一些默认值。更重要的是, 显示的声明默认属性可以让你的模块跳过属性类型的检查. // bad function SFC({ foo, bar, children }) { return &lt;div&gt;{foo}{bar}{children}&lt;/div&gt;; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; // good function SFC({ foo, bar, children }) { return &lt;div&gt;{foo}{bar}{children}&lt;/div&gt;; } SFC.propTypes = { foo: PropTypes.number.isRequired, bar: PropTypes.string, children: PropTypes.node, }; SFC.defaultProps = { bar: &#39;&#39;, children: null, }; 尽可能少地使用扩展运算符 为什么? 除非你很想传递一些不必要的属性 例外情况: 使用了变量提升的高阶组件 function HOC(WrappedComponent) { return class Proxy extends React.Component { Proxy.propTypes = { text: PropTypes.string, isLoading: PropTypes.bool }; render() { return &lt;WrappedComponent {...this.props} /&gt; } } } 只有在清楚明白扩展对象时才使用扩展运算符。这非常有用尤其是在使用Mocha测试组件的时候。 export default function Foo { const props = { text: &#39;&#39;, isPublished: false } return (&lt;div {...props} /&gt;); } 特别提醒：尽可能地筛选出不必要的属性。同时，使用prop-types-exact来预防问题出现。 //good render() { const { irrelevantProp, ...relevantProps } = this.props; return &lt;WrappedComponent {...relevantProps} /&gt; } //bad render() { const { irrelevantProp, ...relevantProps } = this.props; return &lt;WrappedComponent {...this.props} /&gt; } Refs总是在Refs里使用回调函数. // bad &lt;Foo ref=&quot;myRef&quot; /&gt; // good &lt;Foo ref={(ref) =&gt; { this.myRef = ref; }} /&gt; Parentheses 括号 将多行的JSX标签写在()里 // bad render() { return &lt;MyComponent className=&quot;long body&quot; foo=&quot;bar&quot;&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt;; } // good render() { return ( &lt;MyComponent className=&quot;long body&quot; foo=&quot;bar&quot;&gt; &lt;MyChild /&gt; &lt;/MyComponent&gt; ); } // good, 单行可以不需要 render() { const body = &lt;div&gt;hello&lt;/div&gt;; return &lt;MyComponent&gt;{body}&lt;/MyComponent&gt;; } Tags 标签 没有子元素标签总是自己闭合 // bad &lt;foo className=&quot;stuff&quot;&gt;&lt;/foo&gt; //good &lt;foo className=&quot;stuff&quot;/&gt; 如果模块有多行的属性， 关闭标签时新建一行. // bad &lt;Foo bar=&quot;bar&quot; baz=&quot;baz&quot; /&gt; // good &lt;Foo bar=&quot;bar&quot; baz=&quot;baz&quot; /&gt; Methods函数 使用箭头函数来获取本地变量. function ItemList(props) { return ( &lt;ul&gt; {props.items.map((item, index) =&gt; ( &lt;Item key={item.key} onClick={() =&gt; doSomethingWith(item.name, index)} /&gt; ))} &lt;/ul&gt; ); } 当在 render() 里使用事件处理方法时，提前在构造函数里把 this 绑定上去. 为什么? 在每次 render 过程中， 再调用 bind 都会新建一个新的函数，浪费资源. // bad class extends React.Component { onClickDiv() { // do stuff } render() { return &lt;div onClick={this.onClickDiv.bind(this)} /&gt;; } } // good class extends React.Component { constructor(props) { super(props); this.onClickDiv = this.onClickDiv.bind(this); } onClickDiv() { // do stuff } render() { return &lt;div onClick={this.onClickDiv} /&gt;; } } 在React模块中，不要给所谓的私有函数添加 _ 前缀，本质上它并不是私有的. 为什么？_ 下划线前缀在某些语言中通常被用来表示私有变量或者函数。但是不像其他的一些语言，在JS中没有原生支持所谓的私有变量，所有的变量函数都是共有的。尽管你的意图是使它私有化，在之前加上下划线并不会使这些变量私有化，并且所有的属性（包括有下划线前缀及没有前缀的）都应该被视为是共有的。了解更多详情请查看Issue #1024, 和 #490 。 // bad React.createClass({ _onClickSubmit() { // do stuff }, // other stuff }); // good class extends React.Component { onClickSubmit() { // do stuff } // other stuff } 在 render 方法中总是确保 return 返回值. // bad render() { (&lt;div /&gt;); } // good render() { return (&lt;div /&gt;); } Ordering React 模块生命周期 class extends React.Component 的生命周期函数: 1.可选的 static 方法2.constructor 构造函数3.getChildContext 获取子元素内容4.componentWillMount 模块渲染前5.componentDidMount 模块渲染后6.componentWillReceiveProps 模块将接受新的数据7.shouldComponentUpdate 判断模块需不需要重新渲染8.componentWillUpdate 上面的方法返回 true， 模块将重新渲染9.componentDidUpdate 模块渲染结束10.componentWillUnmount 模块将从DOM中清除, 做一些清理任务11.点击回调或者事件处理器 如 onClickSubmit() 或 onChangeDescription()12.render 里的 getter 方法 如 getSelectReason() 或 getFooterContent()13.可选的 render 方法 如 renderNavigation() 或 renderProfilePicture()14.render render() 方法 如何定义 propTypes, defaultProps, contextTypes, 等等其他属性… import React from &#39;react&#39;; import PropTypes from &#39;prop-types&#39;; const propTypes = { id: PropTypes.number.isRequired, url: PropTypes.string.isRequired, text: PropTypes.string, }; const defaultProps = { text: &#39;Hello World&#39;, }; class Link extends React.Component { static methodsAreOk() { return true; } render() { return &lt;a href={this.props.url} data-id={this.props.id}&gt;{this.props.text}&lt;/a&gt;; } } Link.propTypes = propTypes; Link.defaultProps = defaultProps; export default Link; React.createClass 的生命周期函数，与使用class稍有不同: 1.displayName 设定模块名称2.propTypes 设置属性的类型3.contextTypes 设置上下文类型4.childContextTypes 设置子元素上下文类型5.mixins 添加一些mixins6.statics7.defaultProps 设置默认的属性值8.getDefaultProps 获取默认属性值9.getInitialState 或者初始状态10.getChildContext11.componentWillMount12.componentDidMount13.componentWillReceiveProps14.shouldComponentUpdate15.componentWillUpdate16.componentDidUpdate17.componentWillUnmount18.clickHandlers or eventHandlers like onClickSubmit() or onChangeDescription()19.getter methods for render like getSelectReason() or getFooterContent()20.Optional render methods like renderNavigation() or renderProfilePicture()21.render isMounted 为什么? isMounted 反人类设计模式:(), 在 ES6 classes 中无法使用， 官方将在未来的版本里删除此方法. 更多编码规范javascriptvue 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>编码风格</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端路由实现与react-router源码分析]]></title>
    <url>%2F2018%2F06%2F21%2Fstudy%2F%E5%89%8D%E7%AB%AF%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E4%B8%8Ereact-router%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[前言在单页应用上，前端路由并不陌生。很多前端框架也会有独立开发或推荐配套使用的路由系统。那么，当我们在谈前端路由的时候，还可以谈些什么？本文将简要分析并实现一个的前端路由，并对 react-router 进行分析。 一个极简前端路由实现谈一下前端路由的简要原理，以hash形式（也可以使用History API做处理）为例，当url的hash发生变化时，触发hashchange注册的回调，在回调中进行不同的操作，展示不同的页面。直接看代码比较直观。 function Router(){ this.routes = {}; this.currentUrl = &#39;&#39;; } // 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新 Router.prototype.route = function(path,callback) { this.routes[path] = callback || function(){}; } // 路由执行当前url对应的回调函数，更新页面 Router.prototype.refresh = function(){ this.currentUrl = location.hash.slice(1) || &#39;/&#39;; this.routes[this.currentUrl]() } // 路由监听 Router.prototype.init = function(){ window.addEventListener(&#39;load&#39;,this.refresh.bind(this),false); window.addEventListener(&#39;hashChange&#39;,this.refresh.bind(this),false); } window.Router = new Router(); window.Router.init(); 上面路由系统Router对象实现，主要提供三个方法 route 存储路由更新时的回调到回调数组routes中，回调函数将负责对页面的更新 refresh 执行当前url对应的回调函数，更新页面 init 监听浏览器 url hash 更新事件 Router调用方法以及呈现效果如下，点击对应的url，背景色发生不同的变化 &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;turn white&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/blue&quot;&gt;turn bule&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#/green&quot;&gt;&lt;/a&gt;turn green&lt;/li&gt; &lt;ul&gt; var content = document.quserSelecotor(&#39;body&#39;); // change page anything function changebBgColor(color){ content.style.backgroundColor = color; } Router(&#39;/&#39;,function(){ changeBgColor(&#39;white&#39;); }) Router(&#39;/blue&#39;,function(){ changeBgColor(&#39;blue&#39;); }) Router(&#39;/green&#39;,function(){ changeBgColor(&#39;green&#39;); }) 以上为一个前端路由的简单实现，虽然简单，但实际上很多路由系统的根基都立于此，其他路由系统主要是对自身使用的框架机制的进行配套及优化，如与 react 配套的 react-router。 react-router 分析react-router 与 history 结合形式react-router是基于history模块提供的api进行开发的，结合的形式本文记为包装形式。所以在开始对其分析之前，先举一个简单的例子来说明如何进行对象的包装。 //原对象 var historyModule = { listener: [], listen: function(listener){ this.listener.push(listener); console.log(&#39;historyModule listen&#39;); }, updateLocation: funcion(){ this.listener.forEach(function(listener){ listener(&#39;new location&#39;); }) } } //Router将用historyModule对象将其包装 var Router = { source:{}, init: function(source){ this.source = source; }, listen: function(listener){ return this.source.listen(function(location){ console.log(&#39;Router listen tirgger&#39;); listener(location); }) } } //将historyModule注入到Router中 Router.init(historyModule); //Router 注册监听 Router.listen(function(location){ console.log(loaction + &#39;-&gt; router setstate&#39;); }) // historyModule 触发回调 historyModule.updateLocation() 返回： 可看到 historyModule 中含有机制：historyModule.updateLocation() -&gt; listener( )，Router 通过对其进行包装开发，针对 historyModule 的机制对 Router 也起到了作用，即historyModule.updateLocation() 将触发 Router.listen 中的回调函数 。点击查看完整代码这种包装形式能够充分利用原对象（historyModule ）的内部机制，减少开发成本，也更好的分离包装函数（Router）的逻辑，减少对原对象的影响。 react-router 使用方式react-router 以 react component 的组件方式提供 API， 包含 Router，Route，Redirect，Link 等等，这样能够充分利用 react component 提供的生命周期特性，同时也让定义路由跟写 react component 达到统一，如下 render(( &lt;Router history={browserHistory}&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;about&quot; component={About}/&gt; &lt;Route path=&quot;users&quot; component={Users}&gt; &lt;Route path=&quot;/user/:userId&quot; component={User}/&gt; &lt;/Route&gt; &lt;Route path=&quot;*&quot; component={NoMatch}/&gt; &lt;/Route&gt; &lt;/Router&gt; ), document.body) 就这样，声明了一份含有 path to component 的各个映射的路由表。 react-router 还提供的 Link 组件（如下），作为提供更新 url 的途径，触发 Link 后最终将通过如上面定义的路由表进行匹配，并拿到对应的 component 及 state 进行 render 渲染页面。 &lt;Link to={`/user/89757`}&gt;&#39;joey&#39;&lt;/Link&gt; 这里不细讲 react-router 的使用，详情可见：https://github.com/reactjs/react-router 从点击 Link 到 render 对应 component ，路由中发生了什么为何能够触发 render component ？主要是因为触发了 react setState 的方法从而能够触发 render component。 从顶层组件 Router 出发（下面代码从 react-router/Router 中摘取），可看到 Router 在 react component 生命周期之组件被挂载前 componentWillMount 中使用 this.history.listen 去注册了 url 更新的回调函数。回调函数将在 url 更新时触发，回调中的 setState 起到 render 了新的 component 的作用。 React.prototype.componentWillMount = function componentWillMount(){ var createHistory = this.props.history; this.history = _useRoutes2[&#39;default&#39;](createHistory)({ routes: _RouteUtils.createRoutes(routes || children), parseQueryString: parseQueryString, stringifyQuery: stringifyQuery }); this._unlisten = this.history.listen(function (error, state) { _this.setState(state, _this.props.onUpdate); }); } 上面的 _useRoutes2 对 history 操作便是对其做一层包装，所以调用的 this.history 实际为包装以后的对象，该对象含有 _useRoutes2 中的 listen 方法，如下 function listen(listener){ rerurn listen(function(location){ // .. 省略其他 match(location, function (error, redirectLocation, nextState) { listener(null, nextState); }); }) } 可看到，上面代码中，主要分为两部分 使用了 history 模块的 listen 注册了一个含有 setState 的回调函数（这样就能使用 history 模块中的机制） 回调中的 match 方法为 react-router 所特有，match 函数根据当前 location 以及前面写的 Route 路由表匹配出对应的路由子集得到新的路由状态值 state，具体实现可见 react-router/matchRoutes ，再根据 state 得到对应的 component ，最终执行了 match 中的回调 listener(null, nextState) ，即执行了 Router 中的监听回调（setState），从而更新了展示。 以上，为起始注册的监听，及回调的作用。 如何触发监听的回调函数的执行？这里还得从如何更新 url 说起。一般来说，url 更新主要有两种方式：简单的 hash 更新或使用 history api 进行地址更新。 在 react-router 中，其提供了 Link 组件，该组件能在 render 中使用，最终会表现为 a 标签，并将 Link 中的各个参数组合放它的 href 属性中。可以从 react-router/ Link 中看到，对该组件的点击事件进行了阻止了浏览器的默认跳转行为，而改用 history 模块的 pushState 方法去触发 url 更新。 Link.prototype.render = function render() { // .. 省略其他 props.onClick = function (e) { return _this.handleClick(e); }; if (history) { // .. 省略其他 props.href = history.createHref(to, query); } return _react2[&#39;default&#39;].createElement(&#39;a&#39;, props); }; Link.prototype.handleClick = function handleClick(event) { // .. 省略其他 event.preventDefault(); this.context.history.pushState(this.props.state, this.props.to, this.props.query); }; 对 history 模块的 pushState 方法对 url 的更新形式，同样分为两种，分别在 history/createBrowserHistory 及 history/createHashHistory 各自的 finishTransition 中，如 history/createBrowserHistory 中使用的是 window.history.replaceState(historyState, null, path);而 history/createHashHistory 则使用 window.location.hash = url，调用哪个是根据我们一开始创建 history 的方式。 更新 url 的显示是一部分，另一部分是根据 url 去更新展示，也就是触发前面的监听。这是在前面 finishTransition 更新 url 之后实现的，调用的是 history/createHistory 中的 updateLocation 方法，changeListeners 中为 history/createHistory 中的 listen 中所添加的，如下 function updateLocation(newLocation) { // 示意代码 location = newLocation; changeListeners.forEach(function (listener) { listener(location); }); } function listen(listener) { // 示意代码 changeListeners.push(listener); } 总结 可以将以上 react-router 的整个包装闭环总结为 回调函数：含有能够更新 react UI 的 react setState 方法。 注册回调：在 Router componentWillMount 中使用 history.listen 注册的回调函数，最终放在 history 模块的 回调函数数组 changeListeners 中。 触发回调：Link 点击触发 history 中回调函数数组 changeListeners 的执行，从而触发原来 listen 中的 setState 方法，更新了页面 至于前进与后退的实现，是通过监听 popstate 以及 hashchange 的事件，当前进或后退 url 更新时，触发这两个事件的回调函数，回调的执行方式 Link 大致相同，最终同样更新了 UI ，这里就不再说明。 react-router 主要是利用底层 history 模块的机制，通过结合 react 的架构机制做一层包装，实际自身的内容并不多，但其包装的思想笔者认为很值得学习，有兴趣的建议阅读下源码，相信会有其他收获。 原文地址]]></content>
      <tags>
        <tag>路由</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[移动端常见Bug汇总]]></title>
    <url>%2F2018%2F06%2F08%2FMobile%2F%E7%A7%BB%E5%8A%A8%E7%AB%AF%E5%B8%B8%E8%A7%81Bug%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[前言本文是摘录整理了移动端常见的一些bug以及解决方案 点击样式闪烁Q: 当你点击一个链接或者通过Javascript定义的可点击元素的时候，它就会出现一个半透明的灰色背景。 A:根本原因是-webkit-tap-highlight-color，这个属性是用于设定元素在移动设备（如Adnroid、iOS）上被触发点击事件时，响应的背景框的颜色。建议写在样式初始化中以避免所以问题：div,input(selector) {-webkit-tap-highlight-color: rgba(0,0,0,0);}另外出现蓝色边框：outline:none； -webkit-tap-highlight-color : rgba (255, 255, 255, 0) ; // i.e . Nexus5/Chrome and Kindle Fire HD 7 &#39;&#39; -webkit-tap-highlight-color : transparent ; 屏蔽用户选择Q: 禁止用户选择页面中的文字或者图片 A:代码如下 -webkit-touch-callout: none; -webkit-user-select: none; -khtml-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; 移动端如何清除输入框内阴影Q: 在iOS上，输入框默认有内部阴影，但无法使用 box-shadow 来清除，如果不需要阴影，可以这样关闭： A:代码如下 -webkit-appearance: none; 禁止文本缩放Q: 禁止文本缩放 A:代码如下 -webkit-text-size-adjust: 100%; 如何禁止保存或拷贝图像Q: 如何禁止保存或拷贝图像 A:代码如下 img{ -webkit-touch-callout: none;} 解决字体在移动端比例缩小后出现锯齿的问题Q: 解决字体在移动端比例缩小后出现锯齿的问题 A:代码如下 -webkit-font-smoothing: antialiased; 设置input里面placeholder字体的大小Q: 设置input里面placeholder字体的大小 A:代码如下 ::-webkit-input-placeholder{ font-size:10pt;} audio元素和video元素在ios和andriod中无法自动播放Q: audio元素和video元素在ios和andriod中无法自动播放 A:代码如下,触屏及播放 $(&#39;html&#39;).on(&#39;touchstart&#39;,function(){ audio.play() }) 手机拍照和上传图片Q: 针对file类型增加不同的accept字段 A:代码如下 &lt;input type=&quot;file&quot;&gt;的accept 属性 &lt;!-- 选择照片 --&gt; &lt;input type=file accept=&quot;image/*&quot;&gt; &lt;!-- 选择视频 --&gt; &lt;input type=file accept=&quot;video/*&quot;&gt; 输入框自动填充颜色Q: 针对input标签已经输入过的，会针对曾经输入的内容填充黄色背景，这是webkit内核自动添加的，对应的属性是autocomplete,默认是on,另对应的样式是input:-webkit-autofill 且是不可更改的。 A:方案如下 1 设置标签的autocomplete=”off”,亲测无效可能 2 设置盒子的内阴影为你常态的颜色（下面以白色为例） box-shadow:0 0 0 1000px #fff inset ; -webkit-box-shadow: 0 0 0px 1000px #fff inset; 开启硬件加速Q: 优化渲染性能 A:代码如下 -webkit-transform: translate3d(0, 0, 0); -moz-transform: translate3d(0, 0, 0); -ms-transform: translate3d(0, 0, 0); transform: translate3d(0, 0, 0); 用户设置字号放大或者缩小导致页面布局错误body { -webkit-text-size-adjust: 100% !important; text-size-adjust: 100% !important; -moz-text-size-adjust: 100% !important; } 移动端去除type为number的箭头 input::-webkit-outer-spin-button,input::-webkit-inner-spin-button{ -webkit-appearance: none !important; margin: 0; } 实现横屏竖屏的方案css 用 css3媒体查询，缺点是宽度和高度不好控制@media screen and (orientation: portrait) { .main { -webkit-transform:rotate(-90deg); -moz-transform: rotate(-90deg); -ms-transform: rotate(-90deg); transform: rotate(-90deg); width: 100vh; height: 100vh; /*去掉overflow 微信显示正常，但是浏览器有问题，竖屏时强制横屏缩小*/ overflow: hidden; } } @media screen and (orientation: landscape) { .main { -webkit-transform:rotate(0); -moz-transform: rotate(0); -ms-transform: rotate(0); transform: rotate(0) } } js 判断屏幕的方向或者resize事件var evt = &quot;onorientationchange&quot; in window ? &quot;orientationchange&quot; : &quot;resize&quot;; window.addEventListener(evt, function() { var width = document.documentElement.clientWidth; var height = document.documentElement.clientHeight; $print = $(&#39;#print&#39;); if( width &gt; height ){ $print.width(width); $print.height(height); $print.css(&#39;top&#39;, 0 ); $print.css(&#39;left&#39;, 0 ); $print.css(&#39;transform&#39; , &#39;none&#39;); $print.css(&#39;transform-origin&#39; , &#39;50% 50%&#39;); } else{ $print.width(height); $print.height(width); $print.css(&#39;top&#39;, (height-width)/2 ); $print.css(&#39;left&#39;, 0-(height-width)/2 ); $print.css(&#39;transform&#39; , &#39;rotate(90deg)&#39;); $print.css(&#39;transform-origin&#39; , &#39;50% 50%&#39;); } }, false); 原文地址]]></content>
      <categories>
        <category>Bug</category>
      </categories>
      <tags>
        <tag>Mobile</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教科书式的正则匹配]]></title>
    <url>%2F2018%2F06%2F03%2Fstudy%2F%E6%95%99%E7%A7%91%E4%B9%A6%E5%BC%8F%E7%9A%84%E6%AD%A3%E5%88%99%E5%8C%B9%E9%85%8D%2F</url>
    <content type="text"><![CDATA[前言 正则在js中是一类比较特殊的对象，它可以匹配各个场景需要的格式验证，例如邮箱、手机号、用户登录名、密码等等，似乎无处不在，在常见的字符串检索或替换中，我们需要提供一种模式表示检索或替换的规则，来匹配一系列符合某个句法规则的字符串。 以下是正则的较为官方的解释： 正则表达式是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。这些模式被用于 RegExp 的 exec 和 test 方法, 以及 String 的 match、replace、search 和 split 方法。 创建正则表达式（以下有两种方式来参考）：使用正则表达式的构造函数（new 的方式来创建)let regex = new RegExp(&quot;a&quot;) let regex = new RegExp(&quot;^[a-zA-Z]&quot;,&#39;g&#39;) ; //当使用引号时不必再加反斜杠’／’ let regex = new RegExp(/^[a-zA-Z]/,&#39;gi&#39;); //当有斜杠时就 不用再加引号 创建字面量（由两个斜杠’／／’包裹需要匹配的内容)let regex = /ab/ ; let regex=/^[a-zA-Z]/ ; 这两种方式都可以来创建一个正则表达式，但是相对来说第二种方式更加常用一些。 正则表达式的参数，写在//后面，可混合使用 g 全局匹配;找到所有匹配，而不是在第一个匹配后停止 i 匹配全部大小写 m 多行; 将开始和结束字符（^和$）视为在多行上工作（也就是，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。 s 与m相反，单行匹配 let regex=/^[a-zA-Z]/gim ; 正则中常用方法以及字符串中与正则相关的方法test()方法检索字符串中的值是否匹配给出的正则规则,返回布尔值 true或false。检索”ab”是否匹配前面的正则表达式 /../，正确返回true，不匹配返回false /../.test(&quot;ab&quot;); // true exec()方法检索字符串中的指定值，如果找到匹配的文本，则返回一个结果的数组，反之返回null检索正则表达式/abc/是否有在字符串中defaabc有匹配到，返回匹配到内容，索引值，以及检索的字符串 /abc/.exec(&quot;defaabc&quot;) // [&quot;abc&quot;, index: 4, input: &quot;defaabc&quot;] // 检索/qqq/是否在abcdefaabc中匹配到，返回 null /qqq/.exec(&quot;abcdefaabc&quot;) // null compile()方法用于改变正则匹配内容将/abc/的匹配内容改成后面的字符串的内容 /abc/.compile(&#39;def’) // /def/ split()将字符串分割成字符串数组将字符串abcd以/b/中的b分割成字符串数组 &quot;abcd&quot;.split(/b/); // [&quot;a&quot;, &quot;cd&quot;] replace()方法用于在字符串中用一些字符替换另一些字符或者替换一个与正则表达式匹配的字符串//用正则内容/\d\d\d/去匹配字符串12345abcde，将匹配的内容替换成*，并返回替换完成的字符串 &#39;12345abcde&#39;.replace(/\d\d\d/g,&#39;*&#39;); // &quot;*45abcde&quot; // 去掉字符串的引号，全局检索&#39;，替换成&#39;&#39;空 &#39;12345abcde&#39;.replace(/&#39;/g,&#39;&#39;); //12345abcde // 去掉字符串中所有的空格，tab,换页符，换行符 &#39; 12 345ab cd e &#39;.replace(/\s/g,&#39;&#39;); // &quot;12345abcde&quot; search() 用于检索字符串中指定的字符串或与正则表达式相匹配的字符串，返回匹配的字符串的起始位置的索引，反之返回-1&#39;abcdedfasdfs&#39;.search(/d/); // 3 // 即使是全局匹配，也只会匹配到第一个的位置 &#39;abcdedfasdfs&#39;.search(/d/g); // 3 // 如果没有匹配到，返回-1 &#39;abcdedfasdfs&#39;.search(/o/g); // -1 match()方法可在字符串内检索指定的值，或找到一个或多个正则表达式的匹配// 检索指定的值，并返回,b+指多个 &quot;aabbbbccbbaab&quot;.match(/b+/g); // [&quot;bbbb&quot;, &quot;bb&quot;, &quot;b&quot;] 正则规则（常用)字符类规则 范围符号匹配规则 分组匹配规则 重复匹配规则 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>RegExp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新一代的前端存储方案--indexedDB]]></title>
    <url>%2F2018%2F05%2F27%2Fstudy%2F%E6%96%B0%E4%B8%80%E4%BB%A3%E7%9A%84%E5%89%8D%E7%AB%AF%E5%AD%98%E5%82%A8%E6%96%B9%E6%A1%88-indexedDB%2F</url>
    <content type="text"><![CDATA[前端存储 我们都知道在前端开发当中,有时会因为某些需求,要将一些数据存储在前端本地当中.比如说:为了优化性能,将一些常用的数据存在本地,这样以后需要的时候直接从本地拿,不需要再向后端进行请求.还有就是为了防止CSRF攻击,后端给前端一个token,前端就需要将这个token存在本地.之后每次请求都需要带上这个token.等等不一而足. 而这些需求就不油避免的造就一个前端的发展方向–前端存储 在前端的’上古时代’里,我们前端想要存储数据,只有一种方式,那就是Cookie.但是Cookie虽然可以做前端存储方案,但是却也有着很多局限性.首先它的存储空间大小只有4K,其次它的存储有效时间有限制,然后存在Cookie中的数据,在你每次进行请求的时候都会将它带上.使得每次的请求数据都会无意义的增大. 最后,也是最重要的一点.Cookie设计之初就不是就是让我们前端存数据用的.它只是为了让网站验证用户身份用的.至于Cookie的本地存储功能只是它的一个手段而已.关于这点你们可以看下我的另外一篇文章—在HTML5的时代,重新认识Cookie 综上所述,使用Cookie作为前端存储有这许多缺点,所以经过前端社区的不断努力,在HTML5中有了真正的前端存储方案Web Storage.它分为两种,一种是永久存储的localStorage,一种是会话期间存储的sessionStorage.对比Cookie,Web Storage的优势很明显: 存储空间更大,有5M大小 在浏览器发送请求是不会带上web Storage里的数据 更加友好的API 可以做永久存储(localStorage). 这一切看起来很完美,但是随着前端的不断发展,web Storage也有了一些不太合适的地方: 随着web应用程序的不断发展,5M的存储大小对于一些大型的web应用程序来说有些不够 web Storage只能存储string类型的数据.对于Object类型的数据只能先用JSON.stringify()转换一下在存储. 基于上述原因,前端社区又提出了浏览器数据库存储这个概念.而Web SQL Database和indexedDB(索引数据库)是对这个概念的实现.其中Web SQL Database在目前来说基本已经被放弃.所以目前主流的浏览器数据库的实现就是indexedDB(索引数据库).也就是我们要介绍的 新一代的前端存储方案–indexedDB 什么是indexedDBindexedDB的介绍 IndexedDB 是一种使用浏览器存储大量数据的方法.它创造的数据可以被查询，并且可以离线使用. IndexedDB对于那些需要存储大量数据，或者是需要离线使用的程序是非常有效的解决方法. — MDN indexedDB的概念 使用IndexedDB，你可以存储或者获取数据，使用一个key索引的。 你可以在事务(transaction)中完成对数据的修改。和大多数web存储解决方案相同，indexedDB也遵从同源协议(same-origin policy). 所以你只能访问同域中存储的数据，而不能访问其他域的。API包含异步(asynchronous) API 和同步(synchronous)API两种。 异步API适合大多数情况, 同步API必须同 WebWorkers一同使用. 目前，没有主流浏览器支持同步API。 即使同步API被支持了，你也会在大多数的情况使用异步API。IndexedDB 是 WebSQL 数据库的取代品, W3C组织在2010年11月18日废弃了webSql. IndexedDB 和WebSQL的不同点在于WebSQL 是关系型数据库（复杂）IndexedDB 是key-value型数据库（简单好使）. 上面是MDN上对于IndexedDB的介绍.其简单而言,indexedDB就是一个基于事务操作的key-value型数前端数据库.其API大多是异步的 indexedDB的使用创建一个indexedDB数据库const request = indexedDB.open(&#39;myDatabase&#39;,1); request.addEventListener(&#39;success&#39;, e =&gt; { console.log(&quot;连接数据库成功&quot;); }); request.addEventListener(&#39;error&#39;, e =&gt; { console.log(&quot;连接数据库失败&quot;); }); 在上面代码中我们使用indexedDB.open()创建一个indexedDB数据库.open()方法接受可以接受两个参数. 第一个是数据库名,第二个是数据库的版本号.同时返回一个IDBOpenDBRequest对象用于操作数据库.其中对于open()的第一个参数数据库名,open()会先去查找本地是否已有这个数据库,如果有则直接将这个数据库返回,如果没有,则先创建这个数据库,再返回.对于第二个参数版本号,则是一个可选参数,如果不传,默认为1.但如果传入就必须是一个整数. 在通过对indexedDB.open()方法拿到一个数据库对象IDBOpenDBRequest我们可以通过监听这个对象的success事件和error事件来执行相应的操作. 创建一个对象仓库再有了一个数据库之后,我们获取就想要去存储数据了,但是单只有数据库还不够,我们还需要有对象仓库(object store).对象仓库(object store)是indexedDB数据库的基础,其类似于MySQL中表的概念. 要创建一个对象仓库必须在upgradeneeded事件中,而upgradeneeded事件只会在版本号更新的时候触发.这是因为indexedDB API中不允许数据库中的数据仓库在同一版本中发生变化 const request = indexedDB.open(&#39;myDatabase&#39;,2); request.addEventListener(&#39;upgradeneeded&#39;,e =&gt; { const db = e.target.result; const store = db.createObjectStore(&#39;User&#39;,{keyPath: &#39;userId&#39;,autoIncrement: false}); console.log(&#39;创建对象仓库成功&#39;); }) 在上述代码中我们监听upgradeneeded事件,并在这个事件触发时使用createObjectStore()方法创建了一个对象仓库. createObjectStore()方法接受两个参数,第一个是对象仓库的名字,在同一数据库中,仓库名不能重复.第二个是可选参数.用于指定数据的主键,以及是否自增主键. 创建事务 OK现在我们有了数据库和对象仓库了,我们是否就可以存储数据了了.很抱歉,还是不行.我们还差最后一样东西—-事务. 什么是事务 一个数据库事务通常包含了一个序列的对数据库的读/写操作。它的存在包含有以下两个目的 为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。 当多个应用程序在并发访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。 并非任意的对数据库的操作序列都是数据库事务。数据库事务拥有以下四个特性，习惯上被称之为ACID特性。 原子性（Atomicity）：事务作为一个整体被执行，包含在其中的对数据库的操作要么全部被执行，要么都不执行 一致性（Consistency）：事务应确保数据库的状态从一个一致状态转变为另一个一致状态。一致状态的含义是数据库中的数据应满足完整性约束 隔离性（Isolation）：多个事务并发执行时，一个事务的执行不应影响其他事务的执行 持久性（Durability）：已被提交的事务对数据库的修改应该永久保存在数据库中 上面是维基百科上对数据库事务的解释.简单来说事务就是用来保证数据库操作要么全部成功,要么全部失败的一个限制.比如,在修改多条数据时,前面几条已经成功了.,在中间的某一条是失败了.那么在这时,如果是基于事务的数据库操作,那么这时数据库就应该重置前面数据的修改,放弃后面的数据修改.直接返回错误,一条数据也不修改. const request = indexedDB.open(&#39;myDatabase&#39;, 3); request.addEventListener(&#39;success&#39;, e =&gt; { const db = e.target.result; const tx = db.transaction(&#39;Users&#39;,&#39;readwrite&#39;); }); 上述代码中我们使用transaction()来创建一个事务. transaction()接受两个参数,第一个是你要操作的对象仓库名称,第二个是你创建的事务模式.传入 readonly时只能对对象仓库进行读操作,无法写操作.可以传入readwrite进行读写操作. 操作数据 好了现在有了数据库,对象仓库,事务之后我们终于可以存储数据了. add() : 增加数据。接收一个参数，为需要保存到对象仓库中的对象。 put() : 增加或修改数据。接收一个参数，为需要保存到对象仓库中的对象。 get() : 获取数据。接收一个参数，为需要获取数据的主键值。 delete() : 删除数据。接收一个参数，为需要获取数据的主键值。 add 和 put 的作用类似，区别在于 put 保存数据时，如果该数据的主键在数据库中已经有相同主键的时候，则会修改数据库中对应主键的对象，而使用 add 保存数据，如果该主键已经存在，则保存失败。 添加数据const request = indexedDB.open(&#39;myDatabase&#39;, 3); request.addEventListener(&#39;success&#39;, e =&gt; { const db = e.target.result; const tx = db.transaction(&#39;Users&#39;,&#39;readwrite&#39;); const store = tx.objectStore(&#39;Users&#39;); // 保存数据 const reqAdd = store.add({&#39;userId&#39;: 1, &#39;userName&#39;: &#39;李白&#39;, &#39;age&#39;: 24}); reqAdd.addEventListener(&#39;success&#39;, e =&gt; { console.log(&#39;保存成功&#39;) }) // 获取数据 const reqGet = store.get(1); reqGet.addEventListener(&#39;success&#39;, e =&gt; { console.log(this.result.userName); // 李白 }) //删除数据 const reqDelete = store.delete(1); reqDelete.addEventListener(&#39;success&#39;, e =&gt; { console.log(&#39;删除数据成功&#39;); // 李白 }) }); 使用游标 在上面当中我们使用get()方法传入一个主键来获取数据,但是这样只能够获取到一条数据.如果我们想要获取多条数据了怎么办.我们可以使用游标,来获取一个区间内的数据. 要使用游标,我们需要使用对象仓库上的openCursor()方法创建币打开.openCursor()方法接受两个参数. openCursor(range?: IDBKeyRange | number | string | Date | IDBArrayKey, direction?: IDBCursorDirection): IDBRequest; 第一个是范围,范围可以是一个IDBKeyRange对象.用以下方式创建. // boundRange 表示主键值从1到10(包含1和10)的集合。 // 如果第三个参数为true，则表示不包含最小键值1，如果第四参数为true，则表示不包含最大键值10，默认都为false var boundRange = IDBKeyRange.bound(1, 10, false, false); // onlyRange 表示由一个主键值的集合。only() 参数则为主键值，整数类型。 var onlyRange = IDBKeyRange.only(1); // lowerRaneg 表示大于等于1的主键值的集合。 // 第二个参数可选，为true则表示不包含最小主键1，false则包含，默认为false var lowerRange = IDBKeyRange.lowerBound(1, false); // upperRange 表示小于等于10的主键值的集合。 // 第二个参数可选，为true则表示不包含最大主键10，false则包含，默认为false var upperRange = IDBKeyRange.upperBound(10, false); 第二个参数是方向.主要有一下几种 next : 游标中的数据按主键值升序排列，主键值相等的数据都被读取 nextunique : 游标中的数据按主键值升序排列，主键值相等只读取第一条数据 prev : 游标中的数据按主键值降序排列，主键值相等的数据都被读取 prevunique : 游标中的数据按主键值降序排列，主键值相等只读取第一条数据 下面让我们来看一个完整的例子 const request = indexedDB.open(&#39;myDatabase&#39;, 4); request.addEventListener(&#39;success&#39;, e =&gt; { const db = e.target.result; const tx = db.transaction(&#39;Users&#39;,&#39;readwrite&#39;); const store = tx.objectStore(&#39;Users&#39;); const range = IDBKeyRange.bound(1,10); const req = store.openCursor(range, &#39;next&#39;); req.addEventListener(&#39;success&#39;, e =&gt; { const cursor = this.result; if(cursor){ console.log(cursor.value.userName); cursor.continue(); }else{ console.log(&#39;检索结束&#39;); } }) }); 在上面的代码中如果检索到符合条件的数据时,我们可以: 使用cursor.value拿到数据.使用cursor.updata()更新数据.使用cursor.delete()删除数据.使用cursor.continue()读取下一条数据. 索引 在上面代码中我们获取数据都是用的主键.但是,在很多情况下我们并不知道我们需要数据的主键是什么,我们知道一个大概的条件.比如说年龄大于20岁的用户.这个时候我们就需要用到索引.以便有条件的查找. 创建索引 我们使用对象仓库的createIndex()方法来创建一个索引. createIndex(name: string, keyPath: string | string[], optionalParameters?: IDBIndexParameters): IDBIndex; createIndex()方法接收三个参数: 第一个参数name是索引名,不能重复. 第二个参数keyPath是你要在存储对象上的那个属性上建立索引,可以是一个单个的key值,也可以是一个包含key值集合的数组. 第三个参数optionalParameters是一个可选的对象参数{unique, multiEntry} 1.unique: 用来指定索引值是否可以重复,为true代表不能相同,为false时代表可以相同2.multiEntry: 当第二个参数keyPath为一个数组时.如果multiEntry是true,则会以数组中的每个元素建立一条索引.如果是false,则以整个数组为keyPath值,添加一条索引. const request = indexedDB.open(&#39;myDatabase&#39;, 5); request.addEventListener(&#39;upgradeneeded&#39;, e =&gt; { const db = e.target.result; const store = db.createObjectStore(&#39;Users&#39;, {keyPath: &#39;userId&#39;, autoIncrement: false}); const idx = store.createIndex(&#39;ageIndex&#39;,&#39;age&#39;,{unique: false}) }); 这样我们就创建了一条索引. 使用索引 这在创建了一条索引之后我们就可以来使用它了.我们使用对象仓库上的index方法,通过传入一个索引名.来拿到一个索引对象. const index = store.index(&#39;ageIndex&#39;); 然后我们就可以使用这个索引了.比如说我们要拿到年龄在20岁以上的数据,升序排列. const request = indexedDB.open(&#39;myDatabase&#39;, 4); request.addEventListener(&#39;success&#39;, e =&gt; { const db = e.target.result; const tx = db.transaction(&#39;Users&#39;,&#39;readwrite&#39;); const store = tx.objectStore(&#39;Users&#39;); const index = store.index(&#39;ageIndex&#39;); const req = index.openCursor(IDBKeyRange.lowerBound(20), &#39;next&#39;);//20岁以上的数据,升序排列 req.addEventListener(&#39;success&#39;, e =&gt; { const cursor = e.target.result; if(cursor){ console.log(cursor.value.age); cursor.continue(); }else{ console.log(&#39;检索结束&#39;); } }) }); indexedDB的兼容性 原文地址]]></content>
      <tags>
        <tag>indexedDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Token：服务端身份验证的流行方案]]></title>
    <url>%2F2018%2F05%2F23%2Fstudy%2FToken%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81%E7%9A%84%E6%B5%81%E8%A1%8C%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[身份认证服务端提供资源给客户端，但是某些资源是有条件的。所以服务端要能够识别请求者的身份，然后再判断所请求的资源是否可以给请求者。 token是一种身份验证的机制，初始时用户提交账号数据给服务端，服务端采用一定的策略生成一个字符串（token），token字符串中包含了少量的用户信息，并且有一定的期限。服务端会把token字符串传给客户端，客户端保存token字符串，并在接下来的请求中带上这个字符串。 它的工作流程大概是这样 Token机制 在这样的流程下，我们需要考虑下面几个问题： 如何根据token获取用户的信息？ 确保识别伪造的token？ 这里是指token不是经过服务端来生成的。 如何应付冒充的情况？ 非法客户端拦截了合法客户端的token，然后使用这个token向服务端发送请求，冒充合法客户端。 用户匹配服务端在生成token时，加入少量的用户信息，比如用户的id。服务端接收到token之后，可以解析出这些数据，从而将token和用户关联了起来。 防伪造一般情况下，建议放入token的数据是不敏感的数据，这样只要服务端使用私钥对数据生成签名，然后和数据拼接起来，作为token的一部分即可。比如JWT，参考JSON Web Token - 在Web应用间安全地传递信息。 在我知道JWT之前，我先了解的是另一种模式。基于加密的算法，对数据进行加密，把加密的结果作为token（http://blog.leapoahead.com/2015/09/06/understanding-jwt/）。 本文主要讨论后一种模式。 防冒充加干扰码服务端在生成token时，使用了客户端的UA作为干扰码对数据加密，客户端进行请求时，会同时传入token、UA，服务端使用UA对token解密，从而验证用户的身份。如果只是把token拷贝到另一个客户端使用，不同的UA会导致在服务端解析token失败，从而实现了一定程度的防冒充。但是攻击者如果猜到服务端使用UA作为加密钥，他可以修改自己的UA。 有效期给token加上有效期，即使被冒充也只是在一定的时间段内有效。这不是完美的防御措施，只是尽量减少损失。 服务端在生成token时，加入有效期。每次服务端接收到请求，解析token之后，判断是否已过期，如果过期就拒绝服务。 token刷新如果token过期了，客户端应该对token续期或者重新生成token。 这取决于token的过期机制。服务器缓存token及对应的过期时间这个时候就可以采用续期的方式，服务器更新过期时间，token再次有效。token中含有过期时间这个时候需要重新生成token。 在token续期或者重新生成token的时候，需要额外加入数据来验证身份。因为token已经过期了，即token已经不能用来验证用户的身份了。这个时候可以请求用户重新输入账号和密码，但是用户体验稍差。 另一种方式是使用摘要。服务端生成token，同时生成token的摘要，然后一起返回给客户端。客户端保存摘要，一般请求只需要用到token，在刷新token时，才需要用到摘要。服务端验证摘要，来验证用户的身份。因为摘要不会频繁的在客户端和服务端之间传输，所以被截取的概率较小。 Token工作流程生成token一般在登录的时候生成token。Token管理者负责根据用户的数据生成token和摘要，摘要用来给APP端刷新token用，类似于微信登录中的refresh_token。 生成token的过程中，ua的充作干扰码。没有相同的ua，就无法解析生成的token字符串。如果客户端是混合开发的模式，生成token和使用token的代理可能不同（比如一个是h5，一个是原生），ua就会不同，token就无法成功的使用。可以选择其他的客户端数据作为干扰码， 注意考虑下面的问题： 不同的客户端，干扰码应该不同 干扰码的很大一个作用是防冒充，如果选择的充当干扰码的客户端数据没有区分性，就达不到效果。选择充当干扰码的数据，在哪些情况下会变化？这些情况是否合理？ 比如干扰码数据中含有app的版本号，那么app版本升级就会导致干扰码变化。服务端根据新的干扰码，无法解析旧的token，此时用户必须重新登录。这种情况是合理的吗？如果不合理，干扰码中就不应该含有app的版本号。 拦截验证客户端的每一次请求，都必须携带token、ua，拦截器会对敏感资源的访问进行拦截，然后根据ua解析token，解析不成功，表示token和ua不匹配。解析成功之后，判断token是否已过期，如果是，拒绝服务。所有都ok的情况下，拦截器放行，请求传达到业务服务者。 Token刷新当token过期，用户需要刷新token。刷新token本质上是这样的： 客户端需要把token、摘要、ua都传给服务端，服务端对token重新生成摘要，通过判断两个摘要是否相同来验证这次请求刷新token的客户端，是不是上次请求生成token的客户端。验证通过，服务端需要使用用户数据重新生成token，用户数据则来自用ua解析token的结果。 HTML&amp;JS等前端知识系列之Ajax post请求带有token向Django请求我们 在母板上写入这段代码： &lt;script type=&quot;text/javascript&quot;&gt; // 个人定义大函数，不是重点，可以忽略 $(document).ready(function(){ get_sys_load(); var csrftoken = getCookie(&#39;csrftoken&#39;); var active_node = $(&quot;#mainnav-menu a[href=&#39;{{ request.path }}&#39;]&quot;); active_node.parent().addClass(&quot;active-link&quot;); if (active_node.parent().parent().hasClass(&quot;collapse&quot;)){ active_node.parent().parent().addClass(&quot;in&quot;); } });//end doc ready // 个人定义大函数，不是重点，可以忽略 function get_sys_load(){ $.ajax({ url: &quot;{% url 'get_server_host_status' %}&quot;, type: &quot;GET&quot;, dataType: &quot;json&quot;, success: function(callback){ for( i in callback){ console.log(i,callback[i]); $(&#39;#&#39;+ i +&#39;_display&#39;).text(callback[i]); $(&#39;#&#39;+ i +&#39;_width&#39;).text(callback[i]); $(&#39;#&#39;+ i +&#39;_attr&#39;).css(&#39;width&#39;,callback[i]+&#39;%&#39;) }// end for },// end sucess func error: function(callback){ alert(callback) }// end error func }) } // 这个才是重点的代码，必须写 function getCookie(name) { var cookieValue = null; if (document.cookie &amp;&amp; document.cookie !== &#39;&#39;) { var cookies = document.cookie.split(&#39;;&#39;); for (var i = 0; i &lt; cookies.length; i++) { var cookie = jQuery.trim(cookies[i]); // Does this cookie string begin with the name we want? if (cookie.substring(0, name.length + 1) === (name + &#39;=&#39;)) { cookieValue = decodeURIComponent(cookie.substring(name.length + 1)); break; } } } return cookieValue; } // 这个才是重点的代码，必须写 function csrfSafeMethod(method) { // these HTTP methods do not require CSRF protection return (/^(GET|HEAD|OPTIONS|TRACE)$/.test(method)); } $.ajaxSetup({ beforeSend: function(xhr, settings) { if (!csrfSafeMethod(settings.type) &amp;&amp; !this.crossDomain) { xhr.setRequestHeader(&quot;X-CSRFToken&quot;, csrftoken); } } }); &lt;/script&gt; {% block bottom-js %} {% endblock %} 我们在子板上调用这端js代码，调用的前提是子板的html页面必须嵌套了这个 csrf_token, 代码如下 html页面的代码： ================== &lt;span&gt;{% csrf_token %}&lt;/span&gt; ================== ======JQuery代码 ======= {% block bottom-js %} function run_cmd(){ var csrftoken = getCookie('csrftoken'); // 调用获取token的方法来获取token，getCookie是前面定义好的函数。 var input_cmd = $('textarea').val(); $.ajax({ url:"{% url 'put_cmd' %}", type:'POST', dataType:'json', token: csrftoken, // 把token塞入头部 data:{'host_id':$('#host_id').text(),'minion_name':$('#minion_id').text(),'cmd':input_cmd}, success: function(callback){ console.log(callback) }, // end success error: function (callback) { console.log(callback); $('code').append(callback) } }) } function show_result(content){ } {% endblock %} 此时，我们在提交post请求，就能够正常提交了，可以参考官网的信息：ajax token。 登录后保存token到cookie中// 1.引入相应JS &lt;script src=&quot;web/js/jquery-1.9.1.min.js&quot;&gt;&lt;/script&gt; &lt;script src=&quot;web/js/jquery.cookie.js&quot;&gt;&lt;/script&gt; // 2.保存cookie $.cookie(&quot;名称&quot;,&quot;值&quot;) //$.cookie(&#39;cookieName&#39;, &#39;cookieValue&#39;); $.cookie(&quot;名称&quot;,&quot;值&quot;,{expires:失效时间}) // 3.获取cookie $.cookie(&quot;名称&quot;) //$.cookie(&#39;cookieName&#39;); // 4.删除cookie $.cookie(&quot;名称&quot;,null) Token机制相比Cookie机制的优点 支持跨域访问:cookie是不允许跨域访问的，这一点对token机制是不存在的，前提是传输的用户认证信息通过HTTP头传输. 无状态(也称：服务端可扩展行):Token机制在服务端不需要存储session信息，因为Token 自身包含了所有登录用户的信息，只需要在客户端的cookie或本地介质存储状态信息. 更适用于cdn: 可以通过内容分发网络请求你服务端的所有资料（如：javascript，HTML,图片等），而你的服务端只要提供API即可 去耦: 不需要绑定到一个特定的身份验证方案。Token可以在任何地方生成，只要在你的API被调用的时候，你可以进行Token生成调用即可. 更适用于移动应用: 当你的客户端是一个原生平台（iOS, Android，Windows 8等）时，Cookie是不被支持的（你需要通过Cookie容器进行处理），这时采用Token认证机制就会简单得多。 CSRF:因为不再依赖于Cookie，所以你就不需要考虑对CSRF（跨站请求伪造）的防范。 性能: 一次网络往返时间（通过数据库查询session信息）总比做一次HMACSHA256计算 的Token验证和解析要费时得多.不需要为登录页面做特殊处理: 如果你使用Protractor 做功能测试的时候，不再需要为登录页面做特殊处理. 基于标准化:你的API可以采用标准化的 JSON Web Token (JWT). 这个标准已经存在多个后端库（.NET, Ruby, Java,Python, PHP）和多家公司的支持（如：Firebase,Google, Microsoft）.]]></content>
      <tags>
        <tag>Token</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[promise的原理]]></title>
    <url>%2F2018%2F05%2F21%2F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2Fpromise%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言先上一图! 本文的promise源码是按照Promise/A+规范来编写的（不想看英文版的移步Promise/A+规范中文翻译） 引子为了让大家更容易理解，我们从一个场景开始讲解，让大家一步一步跟着思路思考，相信你一定会更容易看懂。 考虑下面一种获取用户id的请求处理 function getUrlId() { return new Promise(function(resolve) { //异步请求 http.get(url,function(results) { resolve(results.id); }) }) } getUrlId().then(function(id){ //一些处理 }) getUserId方法返回一个promise，可以通过它的then方法注册(注意注册这个词)在promise异步操作成功时执行的回调。这种执行方式，使得异步调用变得十分顺手。 原理剖析那么类似这种功能的Promise怎么实现呢？其实按照上面一句话，实现一个最基础的雏形还是很easy的。 极简promise雏形function Promise(fn) { var value = null, callbacks = []; //callbacks为数组，因为可能同时有很多个回调 this.then = function (onFulfilled) { callbacks.push(onFulfilled); }; function resolve(value) { callbacks.forEach(function (callback) { callback(value); }); } fn(resolve); } 上述代码很简单，大致的逻辑是这样的： 调用then方法，将想要在Promise异步操作成功时执行的回调放入callbacks队列，其实也就是注册回调函数，可以向观察者模式方向思考； 创建Promise实例时传入的函数会被赋予一个函数类型的参数，即resolve，它接收一个参数value，代表异步操作返回的结果，当一步操作执行成功后，用户会调用resolve方法，这时候其实真正执行的操作是将callbacks队列中的回调一一执行； 可以结合例1中的代码来看，首先new Promise时，传给promise的函数发送异步请求，接着调用promise对象的then属性，注册请求成功的回调函数，然后当异步请求发送成功时，调用resolve(results.id)方法, 该方法执行then方法注册的回调数组。 相信仔细的人应该可以看出来，then方法应该能够链式调用，但是上面的最基础简单的版本显然无法支持链式调用。想让then方法支持链式调用，其实也是很简单的： this.then = function (onFulfilled) { callbacks.push(onFulfilled); return this; }; see?只要简单一句话就可以实现类似下面的链式调用： // 例2 getUserId().then(function (id) { // 一些处理 }).then(function (id) { // 一些处理 }); 加入延时机制细心的同学应该发现，上述代码可能还存在一个问题：如果在then方法注册回调之前，resolve函数就执行了，怎么办？比如promise内部的函数是同步函数： // 例3 function getUserId() { return new Promise(function (resolve) { resolve(9876); }); } getUserId().then(function (id) { // 一些处理 }); 这显然是不允许的，Promises/A+规范明确要求回调需要通过异步方式执行，用以保证一致可靠的执行顺序。因此我们要加入一些处理，保证在resolve执行之前，then方法已经注册完所有的回调。我们可以这样改造下resolve函数: function resolve(value) { setTimeout(function() { callbacks.forEach(function (callback) { callback(value); }); }, 0) } 上述代码的思路也很简单，就是通过setTimeout机制，将resolve中执行回调的逻辑放置到JS任务队列末尾，以保证在resolve执行时，then方法的回调函数已经注册完成. 但是，这样好像还存在一个问题，可以细想一下：如果Promise异步操作已经成功，这时，在异步操作成功之前注册的回调都会执行，但是在Promise异步操作成功这之后调用的then注册的回调就再也不会执行了，这显然不是我们想要的。 加入状态恩，为了解决上一节抛出的问题，我们必须加入状态机制，也就是大家熟知的pending、fulfilled、rejected。 Promises/A+规范中的2.1Promise States中明确规定了，pending可以转化为fulfilled或rejected并且只能转化一次，也就是说如果pending转化到fulfilled状态，那么就不能再转化到rejected。并且fulfilled和rejected状态只能由pending转化而来，两者之间不能互相转换。一图胜千言 改进后的代码是这样的： function Promise(fn) { var state = &#39;pending&#39;, value = null, callbacks = []; this.then = function (onFulfilled) { if (state === &#39;pending&#39;) { callbacks.push(onFulfilled); return this; } onFulfilled(value); return this; }; function resolve(newValue) { value = newValue; state = &#39;fulfilled&#39;; setTimeout(function () { callbacks.forEach(function (callback) { callback(value); }); }, 0); } fn(resolve); } 上述代码的思路是这样的：resolve执行时，会将状态设置为fulfilled，在此之后调用then添加的新回调，都会立即执行。 这里没有任何地方将state设为rejected，为了让大家聚焦在核心代码上，这个问题后面会有一小节专门加入。 链式Promise那么这里问题又来了，如果用户再then函数里面注册的仍然是一个Promise，该如何解决？比如下面的例4： // 例4 getUserId() .then(getUserJobById) .then(function (job) { // 对job的处理 }); function getUserJobById(id) { return new Promise(function (resolve) { http.get(baseUrl + id, function(job) { resolve(job); }); }); } 这种场景相信用过promise的人都知道会有很多，那么类似这种就是所谓的链式Promise。 链式Promise是指在当前promise达到fulfilled状态后，即开始进行下一个promise（后邻promise）。那么我们如何衔接当前promise和后邻promise呢？（这是这里的难点）。 其实也不是辣么难，只要在then方法里面return一个promise就好啦。Promises/A+规范中的2.2.7就是这么说哒(微笑脸)~ 下面来看看这段暗藏玄机的then方法和resolve方法改造代码： function Promise(fn) { var state = &#39;pending&#39;, value = null, callbacks = []; this.then = function (onFulfilled) { return new Promise(function (resolve) { handle({ onFulfilled: onFulfilled || null, resolve: resolve }); }); }; function handle(callback) { if (state === &#39;pending&#39;) { callbacks.push(callback); return; } //如果then中没有传递任何东西 if(!callback.onFulfilled) { callback.resolve(value); return; } var ret = callback.onFulfilled(value); callback.resolve(ret); } function resolve(newValue) { if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) { var then = newValue.then; if (typeof then === &#39;function&#39;) { then.call(newValue, resolve); return; } } state = &#39;fulfilled&#39;; value = newValue; setTimeout(function () { callbacks.forEach(function (callback) { handle(callback); }); }, 0); } fn(resolve); } 我们结合例4的代码，分析下上面的代码逻辑，为了方便阅读，我把例4的代码贴在这里： // 例4 getUserId() .then(getUserJobById) .then(function (job) { // 对job的处理 }); function getUserJobById(id) { return new Promise(function (resolve) { http.get(baseUrl + id, function(job) { resolve(job); }); }); } then方法中，创建并返回了新的Promise实例，这是串行Promise的基础，并且支持链式调用。 handle方法是promise内部的方法。then方法传入的形参onFulfilled以及创建新Promise实例时传入的resolve均被push到当前promise的callbacks队列中，这是衔接当前promise和后邻promise的关键所在（这里一定要好好的分析下handle的作用）。 getUserId生成的promise（简称getUserId promise）异步操作成功，执行其内部方法resolve，传入的参数正是异步操作的结果id 调用handle方法处理callbacks队列中的回调：getUserJobById方法，生成新的promise（getUserJobById promise） 执行之前由getUserId promise的then方法生成的新promise(称为bridge promise)的resolve方法，传入参数为getUserJobById promise。这种情况下，会将该resolve方法传入getUserJobById promise的then方法中，并直接返回。 在getUserJobById promise异步操作成功时，执行其callbacks中的回调：getUserId bridge promise中的resolve方法 最后执行getUserId bridge promise的后邻promise的callbacks中的回调。 失败处理在异步操作失败时，标记其状态为rejected，并执行注册的失败回调: //例5 function getUserId() { return new Promise(function(resolve) { //异步请求 http.get(url, function(error, results) { if (error) { reject(error); } resolve(results.id) }) }) } getUserId().then(function(id) { //一些处理 }, function(error) { console.log(error) }) 有了之前处理fulfilled状态的经验，支持错误处理变得很容易,只需要在注册回调、处理状态变更上都要加入新的逻辑： function Promise(fn) { var state = &#39;pending&#39;, value = null, callbacks = []; this.then = function (onFulfilled, onRejected) { return new Promise(function (resolve, reject) { handle({ onFulfilled: onFulfilled || null, onRejected: onRejected || null, resolve: resolve, reject: reject }); }); }; function handle(callback) { if (state === &#39;pending&#39;) { callbacks.push(callback); return; } var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected, ret; if (cb === null) { cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject; cb(value); return; } ret = cb(value); callback.resolve(ret); } function resolve(newValue) { if (newValue &amp;&amp; (typeof newValue === &#39;object&#39; || typeof newValue === &#39;function&#39;)) { var then = newValue.then; if (typeof then === &#39;function&#39;) { then.call(newValue, resolve, reject); return; } } state = &#39;fulfilled&#39;; value = newValue; execute(); } function reject(reason) { state = &#39;rejected&#39;; value = reason; execute(); } function execute() { setTimeout(function () { callbacks.forEach(function (callback) { handle(callback); }); }, 0); } fn(resolve, reject); } 上述代码增加了新的reject方法，供异步操作失败时调用，同时抽出了resolve和reject共用的部分，形成execute方法。 错误冒泡是上述代码已经支持，且非常实用的一个特性。在handle中发现没有指定异步操作失败的回调时，会直接将bridge promise(then函数返回的promise，后同)设为rejected状态，如此达成执行后续失败回调的效果。这有利于简化串行Promise的失败处理成本，因为一组异步操作往往会对应一个实际功能，失败处理方法通常是一致的： //例6 getUserId() .then(getUserJobById) .then(function (job) { // 处理job }, function (error) { // getUserId或者getUerJobById时出现的错误 console.log(error); }); 异常处理细心的同学会想到：如果在执行成功回调、失败回调时代码出错怎么办？对于这类异常，可以使用try-catch捕获错误，并将bridge promise设为rejected状态。handle方法改造如下： function handle(callback) { if (state === &#39;pending&#39;) { callbacks.push(callback); return; } var cb = state === &#39;fulfilled&#39; ? callback.onFulfilled : callback.onRejected, ret; if (cb === null) { cb = state === &#39;fulfilled&#39; ? callback.resolve : callback.reject; cb(value); return; } try { ret = cb(value); callback.resolve(ret); } catch (e) { callback.reject(e); } } 如果在异步操作中，多次执行resolve或者reject会重复处理后续回调，可以通过内置一个标志位解决。 总结刚开始看promise源码的时候总不能很好的理解then和resolve函数的运行机理，但是如果你静下心来，反过来根据执行promise时的逻辑来推演，就不难理解了。这里一定要注意的点是：promise里面的then函数仅仅是注册了后续需要执行的代码，真正的执行是在resolve方法里面执行的，理清了这层，再来分析源码会省力的多。 现在回顾下Promise的实现过程，其主要使用了设计模式中的观察者模式： 通过Promise.prototype.then和Promise.prototype.catch方法将观察者方法注册到被观察者Promise对象中，同时返回一个新的Promise对象，以便可以链式调用。 被观察者管理内部pending、fulfilled和rejected的状态转变，同时通过构造函数中传递的resolve和reject方法以主动触发状态转变和通知观察者。 原文地址]]></content>
      <categories>
        <category>原理与实现</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八段代码彻底掌握 Promise]]></title>
    <url>%2F2018%2F05%2F20%2FJs%2F%E5%85%AB%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%BD%BB%E5%BA%95%E6%8E%8C%E6%8F%A1-Promise%2F</url>
    <content type="text"><![CDATA[PromisePromise的立即执行性//1 var p = new Promise(function(resolve, reject){ console.log(&quot;create a promise&quot;); resolve(&quot;success&quot;); }); //2 console.log(&quot;after new Promise&quot;); //3 p.then(function(value){ console.log(value); }); 控制台输出： &quot;create a promise&quot; &quot;after new Promise&quot; &quot;success&quot; Promise对象表示未来某个将要发生的事件，但在创建（new）Promise时，作为Promise参数传入的函数是会被立即执行的，只是其中执行的代码可以是异步代码。有些同学会认为，当Promise对象调用then方法时，Promise接收的函数才会执行，这是错误的。因此，代码中”create a promise”先于”after new Promise”输出。 Promise 三种状态var p1 = new Promise(function(resolve,reject){ resolve(1); }); var p2 = new Promise(function(resolve,reject){ setTimeout(function(){ resolve(2); }, 500); }); var p3 = new Promise(function(resolve,reject){ setTimeout(function(){ reject(3); }, 500); }); console.log(p1); console.log(p2); console.log(p3); setTimeout(function(){ console.log(p2); }, 1000); setTimeout(function(){ console.log(p3); }, 1000); p1.then(function(value){ console.log(value); }); p2.then(function(value){ console.log(value); }); p3.catch(function(err){ console.log(err); }); 控制台输出： Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 1} Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined} Promise {[[PromiseStatus]]: &quot;pending&quot;, [[PromiseValue]]: undefined} 1 2 3 Promise {[[PromiseStatus]]: &quot;resolved&quot;, [[PromiseValue]]: 2} Promise {[[PromiseStatus]]: &quot;rejected&quot;, [[PromiseValue]]: 3} Promise的内部实现是一个状态机。Promise有三种状态：pending，resolved，rejected。当Promise刚创建完成时，处于pending状态；当Promise中的函数参数执行了resolve后，Promise由pending状态变成resolved状态；如果在Promise的函数参数中执行的不是resolve方法，而是reject方法，那么Promise会由pending状态变成rejected状态。 p2、p3刚创建完成时，控制台输出的这两台Promise都处于pending状态，但为什么p1是resolved状态呢？ 这是因为p1的函数参数中执行的是一段同步代码，Promise刚创建完成，resolve方法就已经被调用了，因而紧跟着的输出显示p1是resolved状态。我们通过两个setTimeout函数，延迟1s后再次输出p2、p3的状态，此时p2、p3已经执行完成，状态分别变成resolved和rejected。 Promise 状态的不可逆性var p1 = new Promise(function(resolve, reject){ resolve(&quot;success1&quot;); resolve(&quot;success2&quot;); }); var p2 = new Promise(function(resolve, reject){ resolve(&quot;success&quot;); reject(&quot;reject&quot;); }); p1.then(function(value){ console.log(value); }); p2.then(function(value){ console.log(value); }); 控制台输出： &quot;success1&quot; &quot;success&quot; Promise状态的一旦变成resolved或rejected时，Promise的状态和值就固定下来了，不论你后续再怎么调用resolve或reject方法，都不能改变它的状态和值。因此，p1中resolve(&quot;success2&quot;)并不能将p1的值更改为success2，p2中reject(&quot;reject&quot;)也不能将p2的状态由resolved改变为rejected. 链式调用var p = new Promise(function(resolve, reject){ resolve(1); }); p.then(function(value){ //第一个then console.log(value); return value*2; }).then(function(value){ //第二个then console.log(value); }).then(function(value){ //第三个then console.log(value); return Promise.resolve(&#39;resolve&#39;); }).then(function(value){ //第四个then console.log(value); return Promise.reject(&#39;reject&#39;); }).then(function(value){ //第五个then console.log(&#39;resolve: &#39;+ value); }, function(err){ console.log(&#39;reject: &#39; + err); }) 控制台输出： 1 2 undefined &quot;resolve&quot; &quot;reject: reject&quot; Promise对象的then方法返回一个新的Promise对象，因此可以通过链式调用then方法。then方法接收两个函数作为参数，第一个参数是Promise执行成功时的回调，第二个参数是Promise执行失败时的回调。 两个函数只会有一个被调用，函数的返回值将被用作创建then返回的Promise对象。这两个参数的返回值可以是以下三种情况中的一种： return 一个同步的值 ，或者 undefined（当没有返回一个有效值时，默认返回undefined），then方法将返回一个resolved状态的Promise对象，Promise对象的值就是这个返回值。 return 另一个 Promise，then方法将根据这个Promise的状态和值创建一个新的Promise对象返回。 throw 一个同步异常，then方法将返回一个rejected状态的Promise, 值是该异常。 根据以上分析，代码中第一个then会返回一个值为2（1*2），状态为resolved的Promise对象，于是第二个then输出的值是2。第二个then中没有返回值，因此将返回默认的undefined，于是在第三个then中输出undefined。第三个then和第四个then中分别返回一个状态是resolved的Promise和一个状态是rejected的Promise，依次由第四个then中成功的回调函数和第五个then中失败的回调函数处理。 Promise then() 回调异步性 var p = new Promise(function(resolve, reject){ resolve(&quot;success&quot;); }); p.then(function(value){ console.log(value); }); console.log(&quot;which one is called first ?&quot;); 控制台输出： &quot;which one is called first ?&quot; &quot;success&quot; Promise接收的函数参数是同步执行的，但then方法中的回调函数执行则是异步的，因此，”success”会在后面输出。 Promise 中的异常var p1 = new Promise( function(resolve,reject){ foo.bar(); resolve( 1 ); }); p1.then( function(value){ console.log(&#39;p1 then value: &#39; + value); }, function(err){ console.log(&#39;p1 then err: &#39; + err); } ).then( function(value){ console.log(&#39;p1 then then value: &#39;+value); }, function(err){ console.log(&#39;p1 then then err: &#39; + err); } ); // P2 var p2 = new Promise(function(resolve,reject){ resolve( 2 ); }); p2.then( function(value){ console.log(&#39;p2 then value: &#39; + value); foo.bar(); }, function(err){ console.log(&#39;p2 then err: &#39; + err); } ).then( function(value){ console.log(&#39;p2 then then value: &#39; + value); }, function(err){ console.log(&#39;p2 then then err: &#39; + err); return 1; } ).then( function(value){ console.log(&#39;p2 then then then value: &#39; + value); }, function(err){ console.log(&#39;p2 then then then err: &#39; + err); } ); 控制台输出： p1 then err: ReferenceError: foo is not defined p2 then value: 2 p1 then then value: undefined p2 then then err: ReferenceError: foo is not defined p2 then then then value: 1 Promise中的异常由then参数中第二个回调函数（Promise执行失败的回调）处理，异常信息将作为Promise的值。异常一旦得到处理，then返回的后续Promise对象将恢复正常，并会被Promise执行成功的回调函数处理。另外，需要注意p1、p2 多级then的回调函数是交替执行的 ，这正是由Promise then回调的异步性决定的。 Promise.resolve()var p1 = Promise.resolve( 1 ); var p2 = Promise.resolve( p1 ); var p3 = new Promise(function(resolve, reject){ resolve(1); }); var p4 = new Promise(function(resolve, reject){ resolve(p1); }); console.log(p1 === p2); console.log(p1 === p3); console.log(p1 === p4); console.log(p3 === p4); p4.then(function(value){ console.log(&#39;p4=&#39; + value); }); p2.then(function(value){ console.log(&#39;p2=&#39; + value); }) p1.then(function(value){ console.log(&#39;p1=&#39; + value); }) 控制台输出： true false false false p2=1 p1=1 p4=1 Promise.resolve(...)可以接收一个值或者是一个Promise对象作为参数。当参数是普通值时，它返回一个resolved状态的Promise对象，对象的值就是这个参数；当参数是一个Promise对象时，它直接返回这个Promise参数。因此，p1 === p2。但通过new的方式创建的Promise对象都是一个新的对象，因此后面的三个比较结果都是false。另外，为什么p4的then最先调用，但在控制台上是最后输出结果的呢？因为p4的resolve中接收的参数是一个Promise对象p1，resolve会对p1”拆箱“，获取p1的状态和值，但这个过程是异步的，可参考下一节。 resolve vs rejectvar p1 = new Promise(function(resolve, reject){ resolve(Promise.resolve(&#39;resolve&#39;)); }); var p2 = new Promise(function(resolve, reject){ resolve(Promise.reject(&#39;reject&#39;)); }); var p3 = new Promise(function(resolve, reject){ reject(Promise.resolve(&#39;resolve&#39;)); }); p1.then( function fulfilled(value){ console.log(&#39;fulfilled: &#39; + value); }, function rejected(err){ console.log(&#39;rejected: &#39; + err); } ); p2.then( function fulfilled(value){ console.log(&#39;fulfilled: &#39; + value); }, function rejected(err){ console.log(&#39;rejected: &#39; + err); } ); p3.then( function fulfilled(value){ console.log(&#39;fulfilled: &#39; + value); }, function rejected(err){ console.log(&#39;rejected: &#39; + err); } ); 控制台输出： p3 rejected: [object Promise] p1 fulfilled: resolve p2 rejected: reject Promise回调函数中的第一个参数resolve，会对Promise执行”拆箱”动作。即当resolve的参数是一个Promise对象时，resolve会”拆箱”获取这个Promise对象的状态和值，但这个过程是异步的。p1”拆箱”后，获取到Promise对象的状态是resolved，因此fulfilled回调被执行；p2”拆箱”后，获取到Promise对象的状态是rejected，因此rejected回调被执行。但Promise回调函数中的第二个参数reject不具备”拆箱“的能力，reject的参数会直接传递给then方法中的rejected回调。因此，即使p3 reject接收了一个resolved状态的Promise，then方法中被调用的依然是rejected，并且参数就是reject接收到的Promise对象。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[精读 React 高阶组件]]></title>
    <url>%2F2018%2F05%2F19%2FReact%2F%E7%B2%BE%E8%AF%BB-React-%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[引言高阶组件（ higher-order component ，HOC ）是 React 中复用组件逻辑的一种进阶技巧。它本身并不是 React 的 API，而是一种 React 组件的设计理念，众多的 React 库已经证明了它的价值，例如耳熟能详的 react-redux。 高阶组件的概念其实并不难，我们能通过类比高阶函数迅速掌握。高阶函数是把函数作为参数传入到函数中并返回一个新的函数。这里我们把函数替换为组件，就是高阶组件了。 const EnhancedComponent = higherOrderComponent(WrappedComponent); 当然了解高阶组件的概念只是万里长征第一步，精读文章在阐述其概念与实现外，也强调了其重要性与局限性，以及与其他方案的比较，让我们一起来领略吧。 内容概要高阶组件常见有两种实现方式，一种是 Props Proxy，它能够对 WrappedComponent 的 props 进行操作，提取 WrappedComponent state 以及使用其他元素来包裹 WrappedComponent。Props Proxy 作为一层代理，具有隔离的作用，因此传入 WrappedComponent 的 ref 将无法访问到其本身，需要在 Props Proxy 内完成中转，具体可参考以下代码，react-redux 也是这样实现的。此外各个 Props Proxy 的默认名称是相同的，需要根据 WrappedComponent 来进行不同命名。 function ppHOC(WrappedComponent) { return class PP extends React.Component { // 实现 HOC 不同的命名 static displayName = `HOC(${WrappedComponent.displayName})`; getWrappedInstance() { return this.wrappedInstance; } // 实现 ref 的访问 setWrappedInstance(ref) { this.wrappedInstance = ref; } render() { return &lt;WrappedComponent { ...this.props, ref: this.setWrappedInstance.bind(this), } /&gt; } } } @ppHOC class Example extends React.Component { static displayName = &#39;Example&#39;; handleClick() { ... } ... } class App extends React.Component { handleClick() { this.refs.example.getWrappedInstance().handleClick(); } render() { return ( &lt;div&gt; &lt;button onClick={this.handleClick.bind(this)}&gt;按钮&lt;/button&gt; &lt;Example ref=&quot;example&quot; /&gt; &lt;/div&gt; ); } } 另一种是 Inheritance Inversion，HOC 类继承了 WrappedComponent，意味着可以访问到 WrappedComponent 的 state、props、生命周期和 render 等方法。如果在 HOC 中定义了与 WrappedComponent 同名方法，将会发生覆盖，就必须手动通过 super 进行调用了。通过完全操作 WrappedComponent 的 render 方法返回的元素树，可以真正实现渲染劫持。这种方案依然是继承的思想，对于 WrappedComponent 也有较强的侵入性，因此并不常见。 function ppHOC(WrappedComponent) { return class ExampleEnhance extends WrappedComponent { ... componentDidMount() { super.componentDidMount(); } componentWillUnmount() { super.componentWillUnmount(); } render() { ... return super.render(); } } } 精读HOC 的适用范围对比 HOC 范式 compose(render)(state) 与父组件（Parent Component）的范式 render(render(state))，如果完全利用 HOC 来实现 React 的 implement，将操作与 view 分离，也未尝不可，但却不优雅。HOC 本质上是统一功能抽象，强调逻辑与 UI 分离。但在实际开发中，前端无法逃离 DOM ，而逻辑与 DOM 的相关性主要呈现 3 种关联形式： 与 DOM 相关，建议使用父组件，类似于原生 HTML 编写 与 DOM 不相关，如校验、权限、请求发送、数据转换这类，通过数据变化间接控制 DOM，可以使用 HOC 抽象 交叉的部分，DOM 相关，但可以做到完全内聚，即这些 DOM 不会和外部有关联，均可 DOM 的渲染适合使用父组件，这是 React JSX 原生支持的方式，清晰易懂。最好是能封装成木偶组件（Dumb Component）。HOC 适合做 DOM 不相关又是多个组件共性的操作。如 Form 中，validator 校验操作就是纯数据操作的，放到了 HOC 中。但 validator 信息没有放到 HOC 中。但如果能把 Error 信息展示这些逻辑能够完全隔离，也可以放到 HOC 中（可结合下一小节 Form 具体实践详细了解）。 数据请求是另一类 DOM 不相关的场景，react-refetch 的实现就是使用了 HOC，做到了高效和优雅 connect(props =&gt; ({ usersFetch: `/users?status=${props.status}&amp;page=${props.page}`, userStatsFetch: { url: `/users/stats`, force: true } }))(UsersList) HOC 的具体实践HOC 在真实场景下的运行非常多，之前笔者在 基于Decorator的组件扩展实践 一文中也提过使用高阶组件将更细粒度的组件组合成 Selector 与 Search。结合精读文章，这次让我们通过 Form 组件的抽象来表现 HOC 具有的良好扩展机制。 Form 中会包含各种不同的组件，常见的有 Input、Selector、Checkbox 等等，也会有根据业务需求加入的自定义组件。Form 灵活多变，从功能上看，表单校验可能为单组件值校验，也可能为全表单值校验，可能为常规检验，比如：非空、输入限制，也可能需要与服务端配合，甚至需要根据业务特点进行定制。从 UI 上看，检验结果显示的位置，可能在组件下方，也可能是在组件右侧。 直接裸写 Form，无疑是机械而又重复的。将 Form 中组件的 value 经过 validator，把 value，validator 产生的 error 信息储存到 state 或 redux store 中，然后在 view 层完成显示。这条路大家都是相同的，可以进行复用，只是我们面对的是不同的组件，不同的 validator，不同的 view 而已。对于 Form 而言，既要满足通用，又要满足部分个性化的需求，以往单纯的配置化只会让使用愈加繁琐，我们所需要抽象的是 Form 功能而非 UI，因此通过 HOC 针对 Form 的功能进行提取就成为了必然。 至于 HOC 在 Form 上的具体实现，首先将表单中的组件（Input、Selector…）与相应 validator 与组件值回调函数名（trigger）传入 Decorator，将 validator 与 trigger 相绑定。Decorator 完成了各种不同组件与 Form 内置 Store 间 value 的传递、校验功能的抽象，即精读文章中提到 Props Proxy 方式的其中两种作用：提取state 与 操作props function formFactoryFactory({ validator, trigger = &#39;onChange&#39;, ... }) { return FormFactory(WrappedComponent) { return class Decorator extends React.Component { getBind(trigger, validator) { ... } render() { const newProps = { ...this.props, [trigger]: this.getBind(trigger, validator), ... } return &lt;WrappedComponent {...newProps} /&gt; } } } } // 调用 formFactoryFactory({ validator: (value) =&gt; { return value !== &#39;&#39;; } })(&lt;Input placeholder=&quot;请输入...&quot; /&gt;) 当然为了考虑个性化需求，Form Store 也向外暴露很多 API，可以直接获取和修改 value、error 的值。现在我们需要对一个表单的所有值提交到后端进行校验，根据后端返回，分别列出各项的校验错误信息，就需要借助相应项的 setError 去完成了。 这里主要参考了 rc-form 的实现方式，有兴趣的读者可以阅读其源码。 import { createForm } from &#39;rc-form&#39;; class Form extends React.Component { submit = () =&gt; { this.props.form.validateFields((error, value) =&gt; { console.log(error, value); }); } render() { const { getFieldError, getFieldDecorator } = this.props.form; const errors = getFieldError(&#39;required&#39;); return ( &lt;div&gt; {getFieldDecorator(&#39;required&#39;, { rules: [{ required: true }], })(&lt;Input /&gt;)} {errors ? errors.join(&#39;,&#39;) : null} &lt;button onClick={this.submit}&gt;submit&lt;/button&gt; &lt;/div&gt; ); } } export createForm()(Form); 总结React 始终强调组合优于继承的理念，期望通过复用小组件来构建大组件使得开发变得简单而又高效，与传统面向对象思想是截然不同的。高阶函数（HOC）的出现替代了原有 Mixin 侵入式的方案，对比隐式的 Mixin 或是继承，HOC 能够在 Devtools 中显示出来，满足抽象之余，也方便了开发与测试。当然，不可过度抽象是我们始终要秉持的原则。希望读者通过本次阅读与讨论，能结合自己具体的业务开发场景，获得一些启发。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图说ES Modules]]></title>
    <url>%2F2018%2F05%2F17%2FJs%2F%E5%9B%BE%E8%AF%B4ES-Modules%2F</url>
    <content type="text"><![CDATA[前言原文：ES modules: A cartoon deep-dive, Lin Clark ES modules（ESM） 是 JavaScript 官方的标准化模块系统。然而，它在标准化的道路上已经花费了近 10 年的时间。 可喜的是，标准化之路马上就要完成了。等到 2018 年 5 月 Firefox 60 发布之后，所有的主流浏览器就都支持 ESM 了。同时，Node 模块工作小组也正在为 Node.js 添加 ESM 支持。为 WebAssembly 提供 ESM 集成的工作也正在如火如荼的进行。 许多 JS 开发者都知道，对 ESM 的讨论从开始至今一直都没停过。但是很少有人真正理解 ESM 的工作原理。 今天，让我们来梳理梳理 ESM 到底解决了什么问题，以及它跟其他模块系统之间有什么区别。 为什么要模块化说到 JS 编程，其实说的就是如何管理变量。编程的过程都是关于如何给变量赋值，要么直接赋值给变量，要么是把两个变量结合起来然后再把结果赋值给另一个变量。 因为大部分代码都是关于改变变量的，所以如何组织这些变量就直接影响了编码质量，以及维护它们的成本。 如果代码中仅有少量的变量，那么组织起来其实是很简单的。JS 本身就提供了一种方式帮你组织变量，称为函数作用域。因为函数作用域的缘故，一个函数无法访问另一个函数中定义的变量。 这种方式是很有效的。它使得我们在写一个函数的时候，只需要考虑当前函数，而不必担心其它函数可能会改变当前函数的变量。不过，它也有不好的地方。它会让我们很难在不同函数之间共享变量。 如果我们想跟当前函数以外的函数共享变量要怎么办呢？一种通用的做法是把要共享的变量提升到上一层作用域，比如全局作用域。 在 jQuery 时代这种提升做法相当普遍。在我们加载任何 jQuery 插件之前，我们必须确保 jQuery 已经存在于全局作用域。 这种做法也确实行之有效，但是也带来了令人烦恼的影响。 首先，所有的 script必须以正确的顺序排列，开发者必须非常谨慎地确保没有任何一个脚本排列错误。 如果排列错了，那么在运行过程中，应用将会抛出错误。当函数在全局作用域寻找 jQuery 变量时，如果没有找到，那么它将会抛出异常错误，并且停止继续运行。 这同时也使得代码的后期维护变得困难。它会使得移除旧代码或者脚本标签变得充满不确定性。你根本不知道移除它会带来什么影响。代码之间的依赖是不透明的。任何函数都可能依赖全局作用域中的任何变量，以至于你也不知道哪个函数依赖哪个脚本。 模块化的作用 模块化为你提供了一种更好的方式来组织变量和函数。你可以把相关的变量和函数放在一起组成一个模块。 这种组织方式会把函数和变量放在模块作用域中。模块中的函数可以通过模块作用域来共享变量。 不过，与函数作用域不同的是，模块作用域还提供了一种暴露变量给其他模块使用的方式。模块可以明确地指定哪些变量、类或函数对外暴露。 对外暴露的过程称为导出。一旦导出，其他模块就可以明确地声称它们依赖这些导出的变量、类或者函数。 因为这是一种明确的关系，所以你可以很简单地辨别哪些代码能移除，哪些不能移除。 拥有了在模块之间导出和导入变量的能力之后，你就可以把代码分割成更小的、可以独立运行地代码块了。然后，你就可以像搭乐高积木一样，基于这些代码块，创建所有不同类型的应用。 由于模块化是非常有用的，所以历史上曾经多次尝试为 JS 添加模块化的功能。不过截止到目前，真正得到广泛使用的只有两个模块系统。一个是 Node.js 使用的 CommonJS （CJS）；另一个是 JS 规范的新模块系统 EcmaScript modules（ESM），Node.js 也正在添加对 ESM 的支持。 下面就让我们来深入理解下这个新的模块系统是如何工作的。 ESM 原理当你在使用模块进行开发时，其实是在构建一张依赖关系图。不同模块之间的连线就代表了代码中的导入语句。 正是这些导入语句告诉浏览器或者 Node 该去加载哪些代码。我们要做的是为依赖关系图指定一个入口文件。从这个入口文件开始，浏览器或者 Node 就会顺着导入语句找出所依赖的其他代码文件。 但是呢，浏览器并不能直接使用这些代码文件。它需要解析所有的文件，并把它们变成一种称为模块记录（Module Record）的数据结构。只有这样，它才知道代码文件中到底发生了什么。 解析之后，还需要把模块记录变成一个模块实例。模块实例会把代码和状态结合起来。 所谓代码，基本上是一组指令集合。它就像是制作某样东西的配方，指导你该如何制作。但是它本身并不能让你完成制作。你还需要一些原料，这样才可以按照这些指令完成制作。 所谓状态，它就是原料。具体点，状态是变量在任何时候的真实值。当然，变量实际上就是内存地址的别名，内存才是正在存储值的地方。 所以，可以看出，模块实例中代码和状态的结合，就是指令集和变量值的结合。 对于模块而言，我们真正需要的是模块实例。模块加载会从入口文件开始，最终生成完整的模块实例关系图。 对于 ESM ，这个过程包含三个阶段： 构建：查找，下载，然后把所有文件解析成模块记录。 实例化：为所有模块分配内存空间（此刻还没有填充值），然后依照导出、导入语句把模块指向对应的内存地址。这个过程称为链接（Linking）。 运行：运行代码，从而把内存空间填充为真实值。 大家都说 ESM 是异步的。因为它把整个过程分为了三个不同的阶段：加载、实例化和运行，并且这三个阶段是可以独立进行的。 这意味着，ESM 规范确实引入了一种异步方式，且这种异步方式在 CJS 中是没有的。后面我们会详细说到为什么，然而在 CJS 中，一个模块及其依赖的加载、实例化和运行是一起顺序执行的，中间没有任何间断。 不过，这三个阶段本身是没必要异步化。它们可以同步执行，这取决于它是由谁来加载的。因为 ESM 标准并没有明确规范所有相关内容。实际上，这些工作分为两部分，并且分别是由不同的标准所规范的。 其中，ESM 标准 规范了如何把文件解析为模块记录，如何实例化和如何运行模块。但是它没有规范如何获取文件。 文件是由加载器来提取的，而加载器由另一个不同的标准所规范。对于浏览器来说，这个标准就是HTML。但是你还可以根据所使用的平台使用不同的加载器。 加载器也同时控制着如何加载模块。它会调用 ESM 的方法，包括 ParseModule、Module.Instantiate 和 Module.Evaluate 。它就像是控制着 JS 引擎的木偶。 下面我们将更加详细地说明每一步。 构建 对于每个模块，在构建阶段会做三个处理： 确定要从哪里下载包含该模块的文件，也称为模块定位（Module Resolution） 提取文件，通过从 URL 下载或者从文件系统加载 解析文件为模块记录 下载模块加载器负责定位文件并且提取。首先，它需要找到入口文件。在 HTML 中，你可以通过 &lt;script&gt; 标签来告诉加载器。 但是，加载器要如何定位 main.js 直接依赖的模块呢？这个时候导入语句就派上用场了。导入语句中有一部分称为模块定位符（Module Specifier），它会告诉加载器去哪定位模块。 对于模块定位符，有一点要注意的是：它们在浏览器和 Node 中会有不同的处理。每个平台都有自己的一套方式来解析模块定位符。这些方式称为模块定位算法，不同的平台会使用不同的模块定位算法。当前，一些在 Node 中能工作模块定位符并不能在浏览器中工作，但是已经有一项工作正在解决这个问题。 在这个问题被解决之前，浏览器只接受 URL 作为模块定位符。它们会从 URL 加载模块文件。但是，这并不是在整个关系图上同时发生的。因为在解析完这个模块之前，你根本不知道它依赖哪些模块。而且在它下载完成之前，你也无法解析它。 这就意味着，我们必须一层层遍历依赖树，先解析文件，然后找出依赖，最后又定位并加载这些依赖，如此往复。 如果主线程正在等待这些模块文件下载完成，许多其他任务将会堆积在任务队列中，造成阻塞。这是因为在浏览器中，下载会耗费大量的时间。 而阻塞主线程会使得应用变得卡顿，影响用户体验。这是 ESM 标准把算法分成多个阶段的原因之一。将构建划分为一个独立阶段后，浏览器可以在进入同步的实例化过程之前下载文件然后理解模块关系图。 ESM 和 CJS 之间最主要的区别之一就是，ESM 把算法化为为多个阶段。 CJS 使用不同的算法是因为它从文件系统加载文件，这耗费的时间远远小于从网络上下载。因此 Node 在加载文件的时候可以阻塞主线程，而不造成太大影响。而且既然文件已经加载完成了，那么它就可以直接进行实例化和运行。所以在 CJS 中实例化和运行并不是两个相互独立的阶段。 这也意味着，你可以在返回模块实例之前，顺着整颗依赖树去逐一加载、实例化和运行每一个依赖。 CJS 的方式对 ESM 也有一些启发，这个后面会解释。其中一个就是，在 Node 的 CJS 中，你可以在模块定位符中使用变量。因为已经执行了 require 之前的代码，所以模块定位符中的变量此刻是有值的，这样就可以进行模块定位的处理了。 但是对于 ESM，在运行任何代码之前，你首先需要建立整个模块依赖的关系图。也就是说，建立关系图时变量是还没有值的，因为代码都还没运行。 不过呢，有时候我们确实需要在模块定位符中使用变量。比如，你可能需要根据当前的状况加载不同的依赖。 为了在 ESM 中实现这种方式，人们已经提出了一个动态导入提案。该提案允许你可以使用类似 import(\${path}/foo.js)的导入语句。 这种方式实际上是把使用 import() 加载的文件当成了一个入口文件。动态导入的模块会开启一个全新的独立依赖关系树。 不过有一点要注意的是，这两棵依赖关系树共有的模块会共享同一个模块实例。这是因为加载器会缓存模块实例。在特定的全局作用域中，每个模块只会有一个与之对应的模块实例。 这种方式有助于提高 JS 引擎的性能。例如，一个模块文件只会被下载一次，即使有多个模块依赖它。这也是缓存模块的原因之一，后面说到运行的时候会介绍另一个原因。 加载器使用模块映射（Module Map）来管理缓存。每个全局作用域都在一个单独的模块映射中跟踪其模块。 当加载器要从一个 URL 加载文件时，它会把 URL 记录到模块映射中，并把它标记为正在下载的文件。然后它会发出这个文件请求并继续开始获取下一个文件。 当其他模块也依赖这个文件的时候会发生什么呢？加载器会查找模块映射中的每一个 URL 。如果发现 URL 的状态为正在下载，则会跳过该 URL ，然后开始下一个依赖的处理。 不过，模块映射的作用并不仅仅是记录哪些文件已经下载。下面我们将会看到，模块映射也可以作为模块的缓存。 解析模块至此，我们已经拿到了模块文件，我们需要把它解析为模块记录。这有助于浏览器理解模块的不同部分。 一旦模块记录创建完成，它就会被记录在模块映射中。所以，后续任何时候再次请求这个模块时，加载器就可以直接从模块映射中获取该模块。 解析过程中有一个看似微不足道的细节，但是实际造成的影响却很大。那就是所有的模块都按照严格模式来解析的。也还有其他的小细节，比如，关键字 await 在模块的最顶层是保留字， this 的值为 undefinded。 这种不同的解析方式称为解析目标（Parse Goal）。如果按照不同的解析目标来解析相同的文件，会得到不同的结果。因此，在解析文件之前，必须清楚地知道所解析的文件类型是什么，不管它是不是一个模块文件。 在浏览器中，知道文件类型是很简单的。只需要在 &lt;script&gt; 脚本中添加 type=”module” 属性即可。这告诉浏览器这个文件需要被解析为一个模块。而且，因为只有模块才能被导入，所以浏览器以此推测所有的导入也都是模块文件。 不过在 Node 中，我们并不使用 HTML 标签，所以也没办法通过 type 属性来辨别。社区提出一种解决办法是使用 .mjs 拓展名。使用该拓展名会告诉 Node 说“这是个模块文件”。你会看到大家正在讨论把这个作为解析目标。不过讨论仍在继续，所以目前仍不明确 Node 社区最终会采用哪种方式。 无论最终使用哪种方式，加载器都会决定是否把一个文件作为模块来解析。如果是模块，而且包含导入语句，那它会重新开始处理直至所有的文件都已提取和解析。 到这里，构建阶段差不多就完成了。在加载过程处理完成后，你已经从最开始只有一个入口文件，到现在得到了一堆模块记录。 下一步会实例化这些模块并且把所有的实例链接起来。 实例化正如前文所述，一个模块实例结合了代码和状态。状态存储在内存中，所以实例化的过程就是把所有值写入内存的过程。 首先，JS 引擎会创建一个·模块环境记录（Module Environment Record）·。它管理着模块记录的所有变量。然后，引擎会找出多有导出在内存中的地址。模块环境记录会跟踪每个导出对应于哪个内存地址。 这些内存地址此时还没有值，只有等到运行后它们才会被填充上实际值。有一点要注意，所有导出的函数声明都在这个阶段初始化，这会使得后面的运行阶段变得更加简单。 为了实例化模块关系图，引擎会采用深度优先的后序遍历方式。即，它会顺着关系图到达最底端没有任何依赖的模块，然后设置它们的导出。 最终，引擎会把模块下的所有依赖导出链接到当前模块。然后回到上一层把模块的导入链接起来。 这个过程跟 CJS 是不同的。在 CJS 中，整个导出对象在导出时都是值拷贝。即，所有的导出值都是拷贝值，而不是引用。所以，如果导出模块内导出的值改变了，导入模块中导入的值也不会改变。 相反，ESM 则使用称为实时绑定（Live Binding）的方式。导出和导入的模块都指向相同的内存地址（即值引用）。所以，当导出模块内导出的值改变后，导入模块中的值也实时改变了。 模块导出的值在任何时候都可以能发生改变，但是导入模块却不能改变它所导入的值，因为它是只读的。举例来说，如果一个模块导入了一个对象，那么它只能改变该对象的属性，而不能改变对象本身。 ESM 采用这种实时绑定的原因是，引擎可以在不运行任何模块代码的情况下完成链接。后面会解释到，这对解决运行阶段的循环依赖问题也是有帮助的。 实例化阶段完成后，我们得到了所有模块实例，以及已完成链接的导入、导出值。 现在我们可以开始运行代码并且往内存空间内填充值了。 运行最后一步是往已申请好的内存空间中填入真实值。JS 引擎通过运行顶层代码（函数外的代码）来完成填充。 除了填充值以外，运行代码也会引发一些副作用（Side Effect）。例如，一个模块可能会向服务器发起请求。 因为这些潜在副作用的存在，所以模块代码只能运行一次。前面我们看到，实例化阶段中发生的链接可以多次进行，并且每次的结果都一样。但是，如果运行阶段进行多次的话，则可能会每次都得到不一样的结果。 这正是为什么会使用模块映射的原因之一。模块映射会以 URL 为索引来缓存模块，以确保每个模块只有一个模块记录。这保证了每个模块只会运行一次。跟实例化一样，运行阶段也采用深度优先的后序遍历方式。 那对于前面谈到的循环依赖会怎么处理呢？ 循环依赖会使得依赖关系图中出现一个依赖环，即你依赖我，我也依赖你。通常来说，这个环会非常大。不过，为了解释好这个问题，这里我们举例一个简单的循环依赖。 首先来看下这种情况在 CJS 中会发生什么。最开始时，main 模块会运行 require语句。紧接着，会去加载 counter 模块。 counter 模块会试图去访问导出对象的 message 。不过，由于 main 模块中还没运行到 message 处，所以此时得到的 message 为 undefined。JS 引擎会为本地变量分配空间并把值设为 undefined 。 运行阶段继续往下执行，直到 counter 模块顶层代码的末尾处。我们想知道，当 counter 模块运行结束后，message 是否会得到真实值，所以我们设置了一个超时定时器。之后运行阶段便返回到 main.js 中。 这时，message 将会被初始化并添加到内存中。但是这个 message 与 counter 模块中的 message 之间并没有任何关联关系，所以 counter 模块中的 message 仍然为 undefined。 如果导出值采用的是实时绑定方式，那么 counter 模块最终会得到真实的 message 值。当超时定时器开始计时时，main.js 的运行就已经完成并设置了 message 值。 支持循环依赖是 ESM 设计之初就考虑到的一大原因。也正是这种分段设计使其成为可能。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MVC,MPC,MVVM图示]]></title>
    <url>%2F2018%2F05%2F05%2F%E6%9D%82%E6%96%87%2FMVC-MPC-MVVM%E5%9B%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[MVC,MPC,MVVM区别MVC（Model-View-Controller）是最常见的软件架构之一，业界有着广泛应用。它本身很容易理解，但是要讲清楚，它与衍生的 MVP 和 MVVM 架构的区别就不容易了。 MVCMVC模式的意思是，软件可以分成三个部分 M(Model) 数据保存—将新的数据发送到 View，用户得到反馈 V(View) 用户界面—View 传送指令到 Controller C(Controller) 业务逻辑—完成业务逻辑后，要求 Model 改变状态 所有通信都是单向的。 互动模式 接受用户指令时，MVC 可以分成两种方式。一种是通过 View 接受指令，传递给 Controller。 另一种是直接通过controller接受指令。 实例：Backbone实际项目往往采用更灵活的方式，以 Backbone.js 为例。 用户可以向 View 发送指令（DOM 事件），再由 View 直接要求 Model 改变状态。 用户也可以直接向 Controller 发送指令（改变 URL 触发 hashChange 事件），再由 Controller 发送给 View。 Controller 非常薄，只起到路由的作用，而 View 非常厚，业务逻辑都部署在 View。所以，Backbone 索性取消了 Controller，只保留一个 Router（路由器）。 MVPMVP模式是将controller变为了presenter，同时改变了通信的方向 各部分之间的通信，都是双向的。 View 与 Model 不发生联系，都通过 Presenter 传递。 View 非常薄，不部署任何业务逻辑，称为”被动视图”（Passive View），即没有任何主动性，而 Presenter非常厚，所有逻辑都部署在那里。 MVVMMVVM 模式将 Presenter 改名为 ViewModel，基本上与 MVP 模式完全一致。 唯一的区别是，它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然 原文地址]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax原理与实现]]></title>
    <url>%2F2018%2F05%2F04%2F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2FAjax%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述AJAX全称为“Asynchronous JavaScript and XML”（异步JavaScript和XML），是一种创建交互式网页应用的网页开发技术。 原理与实现 原理：Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。 把服务器端看成一个数据接口(只负责吐数据)，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。 核心Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，XMLHttpRequest是ajax的核心机制，是JavaScript的一个内置对象。它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。 XMLHTTPRequest对象Ajax的一个最大的特点是无需刷新页面便可向服务器传输或读写数据(又称无刷新更新页面),这一特点主要得益于XMLHTTP组件XMLHTTPRequest对象。XMLHttpRequest 对象方法描述Ajax引擎，实际上是一个比较复杂的JavaScript应用程序，用来处理用户请求，读写服务器和更改DOM内容。JavaScript的Ajax引擎读取信息，并且互动地重写DOM，这使网页能无缝化重构，也就是在页面已经下载完毕后改变页面内容，这是我们一直在通过JavaScript和DOM在广泛使用的方法，但要使网页真正动态起来，不仅要内部的互动，还需要从外部获取数据，在以前，我们是让用户来输入数据并通过DOM来改变网页内容的，但现在，XMLHTTPRequest，可以让我们在不重载页面的情况下读写服务器上的数据，使用户的输入达到最少。 Ajax使WEB中的界面与应用分离（也可以说是数据与呈现分离），而在以前两者是没有清晰的界限的，数据与呈现分离的分离，有利于分工合作、减少非技术人员对页面的修改造成的WEB应用程序错误、提高效率、也更加适用于现在的发布系统。也可以把以前的一些服务器负担的工作转嫁到客户端，利于客户端闲置的处理能力来处理。 优点与缺点优点 无需刷新页面更新数据 界面与应用分离（呈现与数据分离） 基于规范广泛使用 异步与服务器通信 前后端负载平衡 缺点 破坏了浏览器的back和history功能 搜索引擎的支持较弱 ajax的安全问题（跨站点脚本攻击，SQL注入攻击等等） Ajax不能很好地支持移动端 破坏程序的异常处理机制 客户端过肥，容易造成客户端的开发成本 AJAX注意点及适用和不适用场景注意点Ajax开发时，网络延迟——即用户发出请求到服务器发出响应之间的间隔——需要慎重考虑。不给予用户明确的回应，没有恰当的预读数据，或者对XMLHttpRequest的不恰当处理，都会使用户感到延迟，这是用户不希望看到的，也是他们无法理解的。通常的解决方案是，使用一个可视化的组件来告诉用户系统正在进行后台操作并且正在读取数据和内容。 Ajax适用场景 表单驱动的交互 深层次的树的导航 快速的用户与用户间的交流响应 类似投票、yes/no等无关痛痒的场景 对数据进行过滤和操纵相关数据的场景 普通的文本输入提示和自动完成的场景 Ajax不适用场景 部分简单的表单 搜索 基本的导航 替换大量的文本 对呈现的操纵 使用ES6去实现一个ajaxfunction Ajax(method,url){ const p = new Promise((resolve,reject) =&gt;{ const xhr = new XMLHttpRequest(); xhr.open(method,url,true) xhr.onReadyStateChange(data){ if(xhr.readyStatus == 4){ if(xhr.status == 200){ resolve(json.parse(xhr.responseText)) }else{ reject(new throw (&#39;not found&#39;)) } } } xhr.send(null) }) }]]></content>
      <categories>
        <category>原理与实现</category>
      </categories>
      <tags>
        <tag>Ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Jsonp的原理与实现]]></title>
    <url>%2F2018%2F05%2F03%2F%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2FJsonp%E7%9A%84%E5%8E%9F%E7%90%86%E4%B8%8E%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[概述Jsonp是一种跨域通信的手段，它的原理实现很简单： 1.首先利用script标签的src属性来实现跨域 2.通过将前端方法作为参数传给服务器端，由服务器端注入参数之后再返回，实现服务器端向客户端通信 3.由于使用script的src属性，所以只支持get方法 实现流程1.设定一个script标签 &lt;script src=&quot;http://jsonp.js?callback=xxx&quot;&gt;&lt;/script&gt; 2.callback定义了一个函数名，而远程服务端通过调用指定的函数并传入参数实现参数传递，将fn(response)传递回客户端 $callback = !empty($_GET[&#39;callback&#39;]) ? $_GET[&#39;callback&#39;]: &#39;callback&#39;; echo $callback.&#39;(.json_encode($data))&#39;; 3.客户端接收到返回的js脚本，开始解析和执行fn(response) jsonp的简单实现一个简单的jsonp实现，其实就是拼接url字符串，动态的添加到script元素的头部 function jsonp(req){ var script = document.createElement(&#39;script&#39;); var url = req.url + &#39;?callback=&#39; + req.callback.name; script.src = url; document.getElementsByTagName(&#39;head&#39;)[0].appendChild(&#39;script&#39;); } 前端js示例 function hello(res){ alert(&#39;hello&#39; + res.data); } jsonp({ url:&#39;&#39;, callback: hello }) 服务器端代码 var http = requrie(&#39;http&#39;); var urllib = require(&#39;url&#39;); var port = 8080; var data = {&#39;data&#39;:&#39;world&#39;}; http.createServer(function(req,res){ var params = urllib.parse(req.url,true); if(params.query.callback){ console.log(params.query.callback); //jsonp var str = params.query.callback + &#39;(&#39; + JSON.stringify(data) + &#39;)&#39;; res.end(str); } else { res.end(); } }).listen(port,function(){ console.log(&#39;jsonp server is on&#39;); }); 然而，这个实现虽然简单，但有一些不足的地方： 1.我们传递的回调必须是一个全局方法，我们都知道要尽量减少全局的方法。2.需要加入一些参数校验，确保接口可以正常执行。 可靠的jsonp实现jsonp部分源码 (function (global) { var id = 0, container = document.getElementsByTagName(&quot;head&quot;)[0]; function jsonp(options) { if(!options || !options.url) return; var scriptNode = document.createElement(&quot;script&quot;), data = options.data || {}, url = options.url, callback = options.callback, fnName = &quot;jsonp&quot; + id++; // 添加回调函数 data[&quot;callback&quot;] = fnName; // 拼接url var params = []; for (var key in data) { params.push(encodeURIComponent(key) + &quot;=&quot; + encodeURIComponent(data[key])); } url = url.indexOf(&quot;?&quot;) &gt; 0 ? (url + &quot;&amp;&quot;) : (url + &quot;?&quot;); url += params.join(&quot;&amp;&quot;); scriptNode.src = url; // 传递的是一个匿名的回调函数，要执行的话，暴露为一个全局方法 global[fnName] = function (ret) { callback &amp;&amp; callback(ret); container.removeChild(scriptNode); delete global[fnName]; } // 出错处理 scriptNode.onerror = function () { callback &amp;&amp; callback({error:&quot;error&quot;}); container.removeChild(scriptNode); global[fnName] &amp;&amp; delete global[fnName]; } scriptNode.type = &quot;text/javascript&quot;; container.appendChild(scriptNode) } global.jsonp = jsonp; })(this); 使用示例 jsonp({ url: &#39;www.example.com&#39;, data: {id :1}, callback: function(ret){ console.log(ret) } }) JSONP的优缺点优点 它不像XMLHttpRequest对象实现的Ajax请求那样受到同源策略的限制，JSONP可以跨越同源策略； 它的兼容性更好，在更加古老的浏览器中都可以运行，不需要XMLHttpRequest或ActiveX的支持 在请求完毕后可以通过调用callback的方式回传结果。将回调方法的权限给了调用方。这个就相当于将controller层和view层终于分 开了。我提供的jsonp服务只提供纯服务的数据，至于提供服务以 后的页面渲染和后续view操作都由调用者来自己定义就好了。如果有两个页面需要渲染同一份数据，你们只需要有不同的渲染逻辑就可以了，逻辑都可以使用同 一个jsonp服务。 缺点 它只支持GET请求而不支持POST等其它类型的HTTP请求 它只支持跨域HTTP请求这种情况，不能解决不同域的两个页面之间如何进行JavaScript调用的问题。 jsonp在调用失败的时候不会返回各种HTTP状态码。 缺点是安全性。万一假如提供jsonp的服务存在页面注入漏洞，即它返回的javascript的内容被人控制的。那么结果是什么？所有调用这个 jsonp的网站都会存在漏洞。于是无法把危险控制在一个域名下…所以在使用jsonp的时候必须要保证使用的jsonp服务必须是安全可信的 安全防范 防止callback参数意外截断js代码,特殊字符单引号双引号,换行符存在风险. 防止callback参数恶意添加script标签,造成xss漏洞 防止跨域请求滥用,阻止非法站点恶意调用]]></content>
      <categories>
        <category>原理与实现</category>
      </categories>
      <tags>
        <tag>jsonp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是函数式编程]]></title>
    <url>%2F2018%2F05%2F02%2Fstudy%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Functional programming你可能听说过函数式编程（Functional programming），甚至已经使用了一段时间。 但是，你能说清楚，它到底是什么吗 网上搜索一下，你会轻松找到好多答案。 与面向对象编程和过程式编程并列的编程范式主要的特征：函数是第一等公民强调将计算过程分解成可复用的函数，典型的例子就是map函数和reduce函数组成的MapReduce函数只有纯函数，没有副作用的函数，才被称为函数 上面这些说法都对，但还不够，都没有回答下面这个更深层的问题。 为什么要这样做？ 范畴论函数式编程的起源，是一门叫做范畴论（Category Theory）的数学分支 理解函数式编程的关键，就是理解范畴论。它是一门很复杂的数学，认为世界上所有的概念体系，都可以抽象成一个个的”范畴”（category）。 范畴的概念什么是范畴呢？ 维基百科的一句话定义如下。 “范畴就是使用箭头连接的物体。”（In mathematics, a category is an algebraic structure that comprises “objects” that are linked by “arrows”. ） 也就是说，彼此之间存在某种关系的概念、事物、对象等等，都构成”范畴”。随便什么东西，只要能找出它们之间的关系，就能定义一个”范畴”。 上图中，各个点与它们之间的箭头，就构成一个范畴。 箭头表示范畴成员之间的关系，正式的名称叫做&quot;态射&quot;（morphism）。范畴论认为，同一个范畴的所有成员，就是不同状态的&quot;变形&quot;（transformation）。通过&quot;态射&quot;，一个成员可以变形成另一个成员。 数学模型既然”范畴”是满足某种变形关系的所有对象，就可以总结出它的数学模型。 所有成员是一个集合 变形关系是函数 也就是说，范畴论是集合论更上层的抽象，简单的理解就是”集合 + 函数”。 理论上通过函数，就可以从范畴的一个成员，算出其他所有成员。 范畴与容器 我们可以把”范畴”想象成是一个容器，里面包含两样东西。 值（value） 值的变形关系，也就是函数。 下面我们使用代码，定义一个简单的范畴。 class Category{ constructor(val){ this.val = val; } addOne(x){ return x +1; } } 上面代码中，Category是一个类，也是一个容器，里面包含一个值（this.val）和一种变形关系（addOne）。你可能已经看出来了，这里的范畴，就是所有彼此之间相差1的数字。 注意，本文后面的部分，凡是提到”容器”的地方，全部都是指”范畴”。 范畴论与函数编程式的关系范畴论使用函数，表达范畴之间的关系本质上，函数式编程只是范畴论的运算方法，跟数理逻辑、微积分、行列式是同一类东西，都是数学方法，只是碰巧它能用来写程序。所以，你明白了吗，为什么函数式编程要求函数必须是纯的，不能有副作用？因为它是一种数学运算，原始目的就是求值，不做其他事情，否则就无法满足函数运算法则了，总之，在函数式编程中，函数就是一个管道（pipe）。这头进去一个值，那头就会出来一个新的值，没有其他作用。 函数的合成与柯里化函数式编程有两个最基本的运算: 合成与柯里化 函数的合成如果一个值要经过多个函数，才能变成另外一个值，就可以把所有中间步骤合并成一个函数，这叫做&quot;函数的合成&quot;（compose）。 上图中，X和Y之间的变形关系是函数f，Y和Z之间的变形关系是函数g，那么X和Z之间的关系，就是g和f的合成函数g·f。 合成两个函数的简单代码如下。 const compose = function(f,g){ return function(x){ return f(g(x)); } } 函数的合成还必须满足结合律。 compose(f, compose(g, h)) // 等同于 compose(compose(f, g), h) // 等同于 compose(f, g, h) 合成也是函数必须是纯的一个原因。因为一个不纯的函数，怎么跟其他函数合成？怎么保证各种合成以后，它会达到预期的行为？ 前面说过，函数就像数据的管道（pipe）。那么，函数合成就是将这些管道连了起来，让数据一口气从多个管道中穿过。 柯里化f(x)和g(x)合成为f(g(x))，有一个隐藏的前提，就是f和g都只能接受一个参数。如果可以接受多个参数，比如f(x, y)和g(a, b, c)，函数合成就非常麻烦。 这时候就需要柯里化，所谓“柯里化”就是把一个多参数的函数，转化为单参数的函数 // 柯里化之前 function(x,y){ return x + y; } add (1,2) // 3 // 柯里化之后 function(y){ return function(x){ return x + y; } } add(2)(1); // 3 有了柯里化以后，我们就能做到，所有函数只接受一个参数。后文的内容除非另有说明，都默认函数只有一个参数，就是所要处理的那个值。 函子（functor）函数不仅可以用于同一个范畴之中值的转换，还可以用于将一个范畴转成另一个范畴。这就涉及到了函子（Functor）。 函子的概念函子是函数式编程里面最重要的数据类型，也是基本的运算单位和功能单位。 它首先是一种范畴，也就是说，是一个容器，包含了值和变形关系。比较特殊的是，它的变形关系可以依次作用于每一个值，将当前容器变形成另一个容器。 上图中，左侧的圆圈就是一个函子，表示人名的范畴。外部传入函数f，会转成右边表示早餐的范畴。 下面是一张更一般的图。 上图中，函数f完成值的转换（a到b），将它传入函子，就可以实现范畴的转换（Fa到Fb）。 函子的代码实现任何具有map方法的数据结构，都可以当作函子的实现。 class Functor{ construcor(val){ this.val = val; } map(f){ return new Functor(f(this.val)); } } 上面代码中，Functor是一个函子，它的map方法接受函数f作为参数，然后返回一个新的函子，里面包含的值是被f处理过的（f(this.val)）。一般约定，函子的标志就是容器具有map方法。该方法将容器里面的每一个值，映射到另一个容器。 下面是一些用法的示例。 (new Functot(2)).map(function(two){ return two + 2; }); //Functor(4) (new Functor(&#39;flamethrowers&#39;)).map(function(s) { return s.toUpperCase(); }); // Functor(&#39;FLAMETHROWERS&#39;) (new Functor(&#39;bombs&#39;)).map(_.concat(&#39; away&#39;)).map(_.prop(&#39;length&#39;)); // Functor(10) 上面的例子说明，函数式编程里面的运算，都是通过函子完成，即运算不直接针对值，而是针对这个值的容器—-函子。函子本身具有对外接口（map方法），各种函数就是运算符，通过接口接入容器，引发容器里面的值的变形。 因此，学习函数式编程，实际上就是学习函子的各种运算。由于可以把运算方法封装在函子里面，所以又衍生出各种不同类型的函子，有多少种运算，就有多少种函子。函数式编程就变成了运用不同的函子，解决实际问题。 of方法你可能注意到了，上面生成新的函子的时候，用了new命令。这实在太不像函数式编程了，因为new命令是面向对象编程的标志。 函数式编程一般约定，函子有一个of方法，用来生成新的容器。 下面就用of方法替换掉new。 Functor.of = function(val) { return new Functor(val); }; 这就更像函数式编程了。 Maybe 函子函子接受各种函数，处理容器内部的值。这里就有一个问题，容器内部的值可能是一个空值（比如null），而外部函数未必有处理空值的机制，如果传入空值，很可能就会出错。 Functor.of(null).map(function (s) { return s.toUpperCase(); }); // TypeError 上面代码中，函子里面的值是null，结果小写变成大写的时候就出错了。 Maybe 函子就是为了解决这一类问题而设计的。简单说，它的map方法里面设置了空值检查。 class Maybe extends Functor { map(f) { return this.val ? Maybe.of(f(this.val)) : Maybe.of(null); } 有了 Maybe 函子，处理空值就不会出错了。 Maybe.of(null).map(function (s) { return s.toUpperCase(); }); // Maybe(null) Either函子条件运算if...else是最常见的运算之一，函数式编程里面，使用Either函子表达。 Either 函子内部有两个值：左值（Left）和右值（Right）。右值是正常情况下使用的值，左值是右值不存在时使用的默认值。 class Either extends Functor{ construcor(left,right){ this.left = left; this.right = right; } map(f){ return this.right ? Either.of(this.left,f(this.right)) : Either.of(f(this.left),this.right); } } Either.of = function(left,right){ return new Either(left,right); } // 下面是用法。 var addOne = function (x) { return x + 1; }; Either.of(5, 6).map(addOne); // Either(5, 7); Either.of(1, null).map(addOne); // Either(2, null); 上面代码中，如果右值有值，就使用右值，否则使用左值。通过这种方式，Either 函子表达了条件运算。 Either 函子的常见用途是提供默认值。下面是一个例子。 Either .of({address: &#39;xxx&#39;}, currentUser.address) .map(updateField); 上面代码中，如果用户没有提供地址，Either 函子就会使用左值的默认地址。 Either 函子的另一个用途是代替try...catch，使用左值表示错误。 function parseJSON(json) { try { return Either.of(null, JSON.parse(json)); } catch (e: Error) { return Either.of(e, null); } } ap函子函子里面包含的值，完全可能是函数。我们可以想象这样一种情况，一个函子的值是数值，另一个函子的值是函数。 function addTwo(x) { return x + 2; } const A = Functor.of(2); const B = Functor.of(addTwo) 上面代码中，函子A内部的值是2，函子B内部的值是函数addTwo。 有时，我们想让函子B内部的函数，可以使用函子A内部的值进行运算。这时就需要用到 ap 函子。 ap 是 applicative（应用）的缩写。凡是部署了ap方法的函子，就是 ap 函子。 class Ap extends Functor{ ap(F){ return Ap.of(this.val(F.val)); } } 注意，ap方法的参数不是函数，而是另一个函子。 因此，前面例子可以写成下面的形式。 Ap.of(addTwo).ap(Functor.of(2))//Ap(4) ap 函子的意义在于，对于那些多参数的函数，就可以从多个容器之中取值，实现函子的链式操作。 function add (y){ return function(y){ return x + y; } } Ap.of(add).ap(Maybe.of(2)).ap(Maybe.of(3)); //Ap(5) 上面代码中，函数add是柯里化以后的形式，一共需要两个参数。通过 ap 函子，我们就可以实现从两个容器之中取值。它还有另外一种写法。 Ap.of(add(2).ap(Maybe.of(3))); Monad 函子函子是一个容器，可以包含任何值。函子之中再包含一个函子，也是完全合法的。但是，这样就会出现多层嵌套的函子。 Maybe.of( Maybe.of( Maybe.of({name: &#39;Mulburry&#39;, number: 8402}) ) ) 上面这个函子，一共有三个Maybe嵌套。如果要取出内部的值，就要连续取三次this.val。这当然很不方便，因此就出现了 Monad 函子。 Monad 函子的作用是，总是返回一个单层的函子。它有一个flatMap方法，与map方法作用相同，唯一的区别是如果生成了一个嵌套函子，它会取出后者内部的值，保证返回的永远是一个单层的容器，不会出现嵌套的情况。 class Monad extends Functor { join() { return this.val; } flatMap(f) { return this.map(f).join(); } } 上面代码中，如果函数f返回的是一个函子，那么this.map(f)就会生成一个嵌套的函子。所以，join方法保证了flatMap方法总是返回一个单层的函子。这意味着嵌套的函子会被铺平（flatten）。 IO 操作Monad 函子的重要应用，就是实现 I/O （输入输出）操作。 var fs = require(&#39;fs&#39;); var readFile = function(filename){ return new IO(function(){ return fs.readFileSync(filename,&#39;utf-8&#39;); }); } var print = function(x) { return new IO(function() { console.log(x); return x; }); } 上面代码中，读取文件和打印本身都是不纯的操作，但是readFile和print却是纯函数，因为它们总是返回 IO 函子。 如果 IO 函子是一个Monad，具有flatMap方法，那么我们就可以像下面这样调用这两个函数。 readFile(&#39;./user.txt&#39;) .flatMap(print) 这就是神奇的地方，上面的代码完成了不纯的操作，但是因为flatMap返回的还是一个 IO 函子，所以这个表达式是纯的。我们通过一个纯的表达式，完成带有副作用的操作，这就是 Monad 的作用。 由于返回还是 IO 函子，所以可以实现链式操作。因此，在大多数库里面，flatMap方法被改名成chain。 var tail = function(x) { return new IO(function() { return x[x.length - 1]; }); } readFile(&#39;./user.txt&#39;) .flatMap(tail) .flatMap(print) // 等同于 readFile(&#39;./user.txt&#39;) .chain(tail) .chain(print) 上面代码读取了文件user.txt，然后选取最后一行输出。 原文地址]]></content>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[封装常用的跨浏览器的事件对象]]></title>
    <url>%2F2018%2F05%2F01%2FJs%2F%E5%B0%81%E8%A3%85%E5%B8%B8%E7%94%A8%E7%9A%84%E8%B7%A8%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1EventUtil%2F</url>
    <content type="text"><![CDATA[前言最近把《javascript高级程序设计》看完了，发现里面有很多跨浏览器的代码，总结一下，方便记录。 跨浏览器的事件对象EventUtil(事件处理程序)var EventUtil = { addHandler: function(element,type,handler) { //事件监听 if(element.addEventListener) { element.addEventListener(type,handler,false); }else if(element.attachEvent) { element.attachEvent(&quot;on&quot;+type,handler); }else { element[&quot;on&quot; +type] = handler; } }, removeHandler: function(element,type,handler){ //移除事件监听 if(element.removeEventListener) { element.removeEventListener(type,handler,false); }else if(element.detachEvent) { element.detachEvent(&quot;on&quot;+type,handler); }else { element[&quot;on&quot; +type] = null; } }, getEvent: function(event) {//获取event对象，返回event对象的引用 return event ? event : window.event; }, getTarget: function(event) {//返回事件目标。 return event.target || event.srcElement; }, preventDefault: function(event){//取消或者阻止事件默认行为 if(event.preventDefault) { event.preventDefault(); }else { event.returnValue = false; } }, stopPropagation: function(event) {//阻止事件流，阻止事件冒泡 if(event.stopPropagation) { event.stopPropagation(); }else { event.cancelBubble = true; } }, getRelatedTarget: function(event){//返回相关元素信息（仅对于mouseover和mouseout事件） if (event.relatedTarget){ return event.relatedTarget; } else if (event.toElement){ return event.toElement; } else if (event.fromElement){ return event.fromElement; } else { return null; } }, getWheelDelta: function(event) {//获取鼠标滚轮增量值，检测是否包含WheelDelta if(event.wheelDelta) { return event.wheelDelta; }else { return -event.detail * 40 } }, getCharCode: function(event) {//获取键盘按键键码。 if(typeof event.charCode == &#39;number&#39;) { return event.charCode; }else { return event.keyCode; } }, getButton:function(event){//在mouseup或者mousedown的时候，event存在一个button属性，用于判断是按了鼠标左键，右键，还是中键，0鼠标主键按钮，1是中间，2是次键（右键） if(document.implementation.hasFeature(&quot;MouseEvents&quot;,&quot;2.0&quot;)){ return event.button; }else{ switch(event.button){ case 0: case 1: case 3: case 5: case 7: return 0; case 2: case 6: return 2; case 4: return 1; } } } }; 使用方法例如click事件 var btn1 = document.getElementById(&quot;myBtn1&quot;); var handler = function(){ alert(&quot;hello haorooms&quot;); } EventUtil.addHandler(btn1, &quot;click&quot;, handler); //EventUtil.removeHandler(btn1, &quot;click&quot;, handler);]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React V16.3 即将更改的生命周期]]></title>
    <url>%2F2018%2F04%2F30%2FReact%2FReact-V16-3-%E5%8D%B3%E5%B0%86%E6%9B%B4%E6%94%B9%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[即将更改的生命周期一年多来，React团队一直致力于实现异步渲染。上个月，他在JSConf冰岛的演讲中，丹揭示了一些令人兴奋的新的异步渲染可能性。现在，我们希望与您分享我们在学习这些功能时学到的一些经验教训，以及一些帮助您准备组件以在启动时进行异步渲染的方法。 我们了解到的最大问题之一是，我们的一些传统组件生命周期会导致一些不安全的编码实践。他们是： componentWillMount componentWillReceiveProps componentWillUpdate 这些生命周期方法经常被误解和滥用;此外，我们预计他们的潜在滥用可能在异步渲染方面有更大的问题。因此，我们将在即将发布的版本中为这些生命周期添加一个“UNSAFE_”前缀。 （这里，“不安全”不是指安全性，而是表示使用这些生命周期的代码将更有可能在未来的React版本中存在缺陷，特别是一旦启用了异步渲染）。 逐步迁移路径React遵循语义版本控制, 所以这种改变将是渐进的。我们目前的计划是： 16.3：为不安全生命周期引入别名UNSAFE_componentWillMount，UNSAFE_componentWillReceiveProps和UNSAFE_componentWillUpdate。 （旧的生命周期名称和新的别名都可以在此版本中使用。） 未来的16.x版本：为componentWillMount，componentWillReceiveProps和componentWillUpdate启用弃用警告。 （旧的生命周期名称和新的别名都可以在此版本中使用，但旧名称会记录DEV模式警告。） 17.0：删除componentWillMount，componentWillReceiveProps和componentWillUpdate。 （从现在开始，只有新的“UNSAFE_”生命周期名称将起作用。） 请注意，如果您是React应用程序开发人员，那么您不必对遗留方法进行任何操作。即将发布的16.3版本的主要目的是让开源项目维护人员在任何弃用警告之前更新其库。这些警告将在未来的16.x版本发布之前不会启用。 从传统生命周期迁移如果您想开始使用React 16.3中引入的新组件API（或者如果您是维护人员提前更新库），以下是一些示例，我们希望这些示例可以帮助您开始考虑组件的变化。随着时间的推移，我们计划在文档中添加额外的“配方”，以展示如何以避免有问题的生命周期的方式执行常见任务。 在开始之前，我们将简要概述为16.3版计划的生命周期更改： 我们正在添加以下生命周期别名： (1) UNSAFE_componentWillMount， (2) UNSAFE_componentWillReceiveProps (3) UNSAFE_componentWillUpdate。 （旧的生命周期名称和新的别名都将受支持。） 我们介绍了两个新的生命周期，分别是getDerivedStateFromProps和getSnapshotBeforeUpdate。 新的生命周期: getDerivedStateFromProps class Example extends React.Component { static getDerivedStateFromProps(nextProps, prevState) { // ... } } 新的静态getDerivedStateFromProps生命周期在组件实例化以及接收新props后调用。它可以返回一个对象来更新state，或者返回null来表示新的props不需要任何state更新。 与componentDidUpdate一起，这个新的生命周期应该覆盖传统componentWillReceiveProps的所有用例。 新的生命周期: getSnapshotBeforeUpdateclass Example extends React.Component { getSnapshotBeforeUpdate(prevProps, prevState) { // ... } } 新的getSnapshotBeforeUpdate生命周期在更新之前被调用（例如，在DOM被更新之前）。此生命周期的返回值将作为第三个参数传递给componentDidUpdate。 （这个生命周期不是经常需要的，但可以用于在恢复期间手动保存滚动位置的情况。） You can find their type signatures in this gist. 我们看看如何在使用这两种生命周期的，例子如下: 例如 Initializing state（初始化状态）Ini Fetching external data（获取外部数据） Adding event listeners（添加事件监听） Updating state based on props（基于props更新state） Invoking external callbacks(调用外部的callbacks) Side effects on props change Fetching external data when props change（props改变时获取外部数据） Reading DOM properties before an update(在更新之前读取DOM属性) 注意为简洁起见，下面的示例是使用实验类属性转换编写的，但如果没有它，则应用相同的迁移策略。 初始化状态：这个例子展示了一个调用componentWillMount中带有setState的组件： // Before class ExampleComponent extends React.Component { state = {}; componentWillMount() { this.setState({ currentColor: this.props.defaultColor, palette: &#39;rgb&#39;, }); } } 这种类型的组件最简单的重构是将状态初始化移动到构造函数或属性初始值设定项，如下所示： // After class ExampleComponent extends React.Component { state = { currentColor: this.props.defaultColor, palette: &#39;rgb&#39;, }; } 获取外部数据以下是使用componentWillMount获取外部数据的组件示例： // Before class ExampleComponent extends React.Component { state = { externalData: null, }; componentWillMount() { this._asyncRequest = asyncLoadData().then( externalData =&gt; { this._asyncRequest = null; this.setState({externalData}); } ); } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } } 对于大多数用例，建议的升级路径是将数据提取移入componentDidMount： // After class ExampleComponent extends React.Component { state = { externalData: null, }; componentDidMount() { this._asyncRequest = asyncLoadData().then( externalData =&gt; { this._asyncRequest = null; this.setState({externalData}); } ); } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } } 有一个常见的错误观念认为，在componentWillMount中提取可以避免第一个空的渲染。在实践中，这从来都不是真的，因为React总是在componentWillMount之后立即执行渲染。如果数据在componentWillMount触发的时间内不可用，则无论你在哪里提取数据，第一个渲染仍将显示加载状态。这就是为什么在绝大多数情况下将提取移到componentDidMount没有明显效果。 注意：一些高级用例（例如，像Relay这样的库）可能想要尝试使用热切的预取异步数据。在这里可以找到一个这样做的例子。 当支持服务器渲染时，目前需要同步提供数据 - componentWillMount通常用于此目的，但构造函数可以用作替换。即将到来的悬念API将使得异步数据在客户端和服务器呈现中都可以清晰地获取。 添加时间监听下面是一个在安装时监听外部事件调度程序的组件示例： // Before class ExampleComponent extends React.Component { componentWillMount() { this.setState({ subscribedValue: this.props.dataSource.value, }); // This is not safe; it can leak! this.props.dataSource.subscribe( this.handleSubscriptionChange ); } componentWillUnmount() { this.props.dataSource.unsubscribe( this.handleSubscriptionChange ); } handleSubscriptionChange = dataSource =&gt; { this.setState({ subscribedValue: dataSource.value, }); }; } 不幸的是，这会导致服务器渲染（componentWillUnmount永远不会被调用）和异步渲染（在渲染完成之前渲染可能被中断，导致componentWillUnmount不被调用）的内存泄漏。 人们经常认为componentWillMount和componentWillUnmount总是配对，但这并不能保证。只有调用componentDidMount后，React才能保证稍后调用componentWillUnmount进行清理。 出于这个原因，添加事件监听的推荐方式是使用componentDidMount生命周期： // After class ExampleComponent extends React.Component { state = { subscribedValue: this.props.dataSource.value, }; componentDidMount() { // Event listeners are only safe to add after mount, // So they won&#39;t leak if mount is interrupted or errors. this.props.dataSource.subscribe( this.handleSubscriptionChange ); // External values could change between render and mount, // In some cases it may be important to handle this case. if ( this.state.subscribedValue !== this.props.dataSource.value ) { this.setState({ subscribedValue: this.props.dataSource.value, }); } } componentWillUnmount() { this.props.dataSource.unsubscribe( this.handleSubscriptionChange ); } handleSubscriptionChange = dataSource =&gt; { this.setState({ subscribedValue: dataSource.value, }); }; } 有时候更新监听以响应属性变化很重要。如果您使用的是像Redux或MobX这样的库，库的容器组件会为您处理。对于应用程序作者，我们创建了一个小型库create-subscription来帮助解决这个问题。我们会将它与React 16.3一起发布。 我们可以使用create-subscription来传递监听的值，而不是像上例那样传递监听 的dataSource prop。 import {createSubscription} from &#39;create-subscription&#39;; const Subscription = createSubscription({ getCurrentValue(sourceProp) { // Return the current value of the subscription (sourceProp). return sourceProp.value; }, subscribe(sourceProp, callback) { function handleSubscriptionChange() { callback(sourceProp.value); } // Subscribe (e.g. add an event listener) to the subscription (sourceProp). // Call callback(newValue) whenever a subscription changes. sourceProp.subscribe(handleSubscriptionChange); // Return an unsubscribe method. return function unsubscribe() { sourceProp.unsubscribe(handleSubscriptionChange); }; }, }); // Rather than passing the subscribable source to our ExampleComponent, // We could just pass the subscribed value directly: `&lt;Subscription source={dataSource}&gt;` {value =&gt; `&lt;ExampleComponent subscribedValue={value} /&gt;`} `&lt;/Subscription&gt;`; 注意像Relay / Apollo这样的库应该使用与创建订阅相同的技术手动管理订阅（如此处所引用的），并采用最适合其库使用的优化方式。 基于props更新state以下是使用旧版componentWillReceiveProps生命周期基于新的道具值更新状态的组件示例： // Before class ExampleComponent extends React.Component { state = { isScrollingDown: false, }; componentWillReceiveProps(nextProps) { if (this.props.currentRow !== nextProps.currentRow) { this.setState({ isScrollingDown: nextProps.currentRow &gt; this.props.currentRow, }); } } } 尽管上面的代码本身并没有问题，但componentWillReceiveProps生命周期通常会被错误地用于解决问题。因此，该方法将被弃用。 从版本16.3开始，更新state以响应props更改的推荐方法是使用新的静态getDerivedStateFromProps生命周期。 （生命周期在组件创建时以及每次收到新道具时调用）： // After class ExampleComponent extends React.Component { // Initialize state in constructor, // Or with a property initializer. state = { isScrollingDown: false, lastRow: null, }; static getDerivedStateFromProps(nextProps, prevState) { if (nextProps.currentRow !== prevState.lastRow) { return { isScrollingDown: nextProps.currentRow &gt; prevState.lastRow, lastRow: nextProps.currentRow, }; } // Return null to indicate no change to state. return null; } } 你可能会注意到在上面的例子中，props.currentRow是一个镜像状态（如state.lastRow）。这使得getDerivedStateFromProps可以像在componentWillReceiveProps中一样访问以前的props值。 您可能想知道为什么我们不只是将先前的props作为参数传递给getDerivedStateFromProps。我们在设计API时考虑了这个选项，但最终决定反对它，原因有两个 在第一次调用getDerivedStateFromProps（实例化后）时，prevProps参数将为null，需要在访问prevProps时添加if-not-null检查。 没有将以前的props传递给这个函数，在未来版本的React中释放内存的一个步骤。 （如果React不需要将先前的道具传递给生命周期，那么它不需要将先前的道具对象保留在内存中。） Note如果您正在编写共享组件，那么react-lifecycles-compat polyfill可以使新的getDerivedStateFromProps生命周期与旧版本的React一起使用。详细了解如何在下面使用它。 调用外部回调函数下面是一个在内部状态发生变化时调用外部函数的组件示例： // Before class ExampleComponent extends React.Component { componentWillUpdate(nextProps, nextState) { if ( this.state.someStatefulValue !== nextState.someStatefulValue ) { nextProps.onChange(nextState.someStatefulValue); } } } 在异步模式下使用componentWillUpdate都是不安全的，因为外部回调可能会多次调用只更新一次。相反，应该使用componentDidUpdate生命周期，因为它保证每次更新只调用一次： // After class ExampleComponent extends React.Component { componentDidUpdate(prevProps, prevState) { if ( this.state.someStatefulValue !== prevState.someStatefulValue ) { this.props.onChange(this.state.someStatefulValue); } } } props改变的副作用与上述 事例类似，有时组件在道具更改时会产生副作用。 // Before class ExampleComponent extends React.Component { componentWillReceiveProps(nextProps) { if (this.props.isVisible !== nextProps.isVisible) { logVisibleChange(nextProps.isVisible); } } } 与componentWillUpdate一样，componentWillReceiveProps可能会多次调用但是只更新一次。出于这个原因，避免在此方法中导致的副作用非常重要。相反，应该使用componentDidUpdate，因为它保证每次更新只调用一次： // After class ExampleComponent extends React.Component { componentDidUpdate(prevProps, prevState) { if (this.props.isVisible !== prevProps.isVisible) { logVisibleChange(this.props.isVisible); } } } props改变时获取外部数据以下是根据propsvalues提取外部数据的组件示例： // Before class ExampleComponent extends React.Component { state = { externalData: null, }; componentDidMount() { this._loadAsyncData(this.props.id); } componentWillReceiveProps(nextProps) { if (nextProps.id !== this.props.id) { this.setState({externalData: null}); this._loadAsyncData(nextProps.id); } } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } _loadAsyncData(id) { this._asyncRequest = asyncLoadData(id).then( externalData =&gt; { this._asyncRequest = null; this.setState({externalData}); } ); } } 此组件的推荐升级路径是将数据更新移动到componentDidUpdate中。在渲染新道具之前，您还可以使用新的getDerivedStateFromProps生命周期清除陈旧的数据： // After class ExampleComponent extends React.Component { state = { externalData: null, }; static getDerivedStateFromProps(nextProps, prevState) { // Store prevId in state so we can compare when props change. // Clear out previously-loaded data (so we don&#39;t render stale stuff). if (nextProps.id !== prevState.prevId) { return { externalData: null, prevId: nextProps.id, }; } // No state update necessary return null; } componentDidMount() { this._loadAsyncData(this.props.id); } componentDidUpdate(prevProps, prevState) { if (this.state.externalData === null) { this._loadAsyncData(this.props.id); } } componentWillUnmount() { if (this._asyncRequest) { this._asyncRequest.cancel(); } } render() { if (this.state.externalData === null) { // Render loading state ... } else { // Render real UI ... } } _loadAsyncData(id) { this._asyncRequest = asyncLoadData(id).then( externalData =&gt; { this._asyncRequest = null; this.setState({externalData}); } ); } } 注意如果您使用支持取消的HTTP库（如axios），那么卸载时取消正在进行的请求很简单。对于原生Promise，您可以使用如下所示的方法。 在更新之前读取DOM属性下面是一个组件的例子，它在更新之前从DOM中读取属性，以便在列表中保持滚动位置： componentWillUpdate(nextProps, nextState) { // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (this.props.list.length &lt; nextProps.list.length) { this.previousScrollOffset = this.listRef.scrollHeight - this.listRef.scrollTop; } } componentDidUpdate(prevProps, prevState) { // If previousScrollOffset is set, we&#39;ve just added new items. // Adjust scroll so these new items don&#39;t push the old ones out of view. if (this.previousScrollOffset !== null) { this.listRef.scrollTop = this.listRef.scrollHeight - this.previousScrollOffset; this.previousScrollOffset = null; } } render() { return ( `&lt;div&gt;` {/* ...contents... */} `&lt;/div&gt;` ); } setListRef = ref =&gt; { this.listRef = ref; }; } 在上面的例子中，componentWillUpdate被用来读取DOM属性。但是，对于异步渲染，“render”阶段生命周期（如componentWillUpdate和render）与“commit”阶段生命周期（如componentDidUpdate）之间可能存在延迟。如果用户在这段时间内做了类似调整窗口大小的操作，则从componentWillUpdate中读取的scrollHeight值将失效。 解决此问题的方法是使用新的“commit”阶段生命周期getSnapshotBeforeUpdate。在数据发生变化之前立即调用该方法（例如，在更新DOM之前）。它可以将React的值作为参数传递给componentDidUpdate，在数据发生变化后立即调用它。 这两个生命周期可以像这样一起使用： class ScrollingList extends React.Component { listRef = null; getSnapshotBeforeUpdate(prevProps, prevState) { // Are we adding new items to the list? // Capture the scroll position so we can adjust scroll later. if (prevProps.list.length &lt; this.props.list.length) { return ( this.listRef.scrollHeight - this.listRef.scrollTop ); } return null; } componentDidUpdate(prevProps, prevState, snapshot) { // If we have a snapshot value, we&#39;ve just added new items. // Adjust scroll so these new items don&#39;t push the old ones out of view. // (snapshot here is the value returned from getSnapshotBeforeUpdate) if (snapshot !== null) { this.listRef.scrollTop = this.listRef.scrollHeight - snapshot; } } render() { return ( `&lt;div&gt;` {/* ...contents... */} `&lt;/div&gt;` ); } setListRef = ref =&gt; { this.listRef = ref; }; } 注意如果您正在编写共享组件，那么react-lifecycles-compat polyfill可以使新的getSnapshotBeforeUpdate生命周期与旧版本的React一起使用。详细了解如何使用它。 其它情况除了以上的一些常见的例子，还可能会有别的情况本篇文章没有涵盖到，如果您以本博文未涉及的方式使用除了以上 componentWillMount，componentWillUpdate或componentWillReceiveProps，并且不确定如何迁移这些传统生命周期，你可以提供您的代码示例和我们的文档，并且一起提交一个新问题。我们将在更新这份文件时提供新的替代模式。 当React 16.3发布时，我们还将发布一个新的npm包， react-lifecycles-compat。该npm包会填充组件，以便新的getDerivedStateFromProps和getSnapshotBeforeUpdate生命周期也可以与旧版本的React（0.14.9+）一起使用。 要使用这个polyfill，首先将它作为依赖项添加到您的库中： # Yarn yarn add react-lifecycles-compat # NPM npm install react-lifecycles-compat --save 接下来，更新您的组件以使用新的生命周期（如上所述）。 最后，使用polyfill将组件向后兼容旧版本的React： import React from &#39;react&#39;; import {polyfill} from &#39;react-lifecycles-compat&#39;; class ExampleComponent extends React.Component { static getDerivedStateFromProps(nextProps, prevState) { // Your state update logic here ... } } // Polyfill your component to work with older versions of React: polyfill(ExampleComponent); export default ExampleComponent; 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript 异步编程]]></title>
    <url>%2F2018%2F04%2F29%2FJs%2FJavascript-%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[为什么JavaScript的异步编程经常被人提起，我想到以下两点原因。首先，JavaScript是单线程的，用事件循环的机制来保证系统的正常运行。如果有同步的ajax请求或者很复杂的运算，JavaScript要等这些操作完成，才能响应其他事件，页面会进入假死状态。然而对于日渐复杂的web应用来说，这个是致命的。这也是为什么Node.js适合高I/O操作的业务，而像PHP，直到现在，I/O操作也没有提供对应的异步版本，对于PHP来说每个请求都在php-fpm的一个新线程里，这个线程阻塞了不影响其他线程，异步也就没有那么迫切。 其次，JavaScript作为动态语言，函数是一等一的公民，可以随意定义函数，将函数作为变量传值传参，极大的方便了JSer灵活的进行异步编程。在C语言里面，也有异步编程，不管是IOCP模型还是epool模型，他们都是创建多个线程来统一的处理回调，在每个线程函数里用一个死循环，在死循环里用一个阻塞的的操作去等待完成的I/O操作。这样的话，I/O操作函数和回调函数不在同一个线程里，这个给流程控制带来很大的不便。Node.js底层肯定也是用的这个来处理I/O的，但这对于JSer来说是透明的，不用操心。 好像有点跑偏了，我们来看一下JavaScript中有哪些灵活的异步编程吧。 编程，就是由coder定好代码的执行顺序，让计算机去跑。那对于同步操作，这个过程很简单。比如执行我们有A和B操作，A操作完成再执行B，如下 A(); B(); 这样就能很好的体现流程，但是当A操作是个异步操作的时候，A操作一开始只执行一个发起的操作（发起请求，发起等待），至于什么时候能完成只有A知道。这时候如果还按如上的方式组织代码，就不能保证“A操作完成再执行B”。 当然，我们可以直接把B直接糅合进A。 function A(){B()} 这样代码之间耦合度太高，增加代码复用的难度 ，于是有了callback形式。 callback 被广泛吐槽的callback，真正该被吐槽的应该是不合格的JSer吧。 setTimeout就是一个典型的异步操作，延迟时间到了时候只有setTimeout自己能得到通知。那么我们就可以以函数的形式先告诉setTimeout延迟时间到了时候我们要执行什么操作。 setTimeout(() =&gt; { console.log(1); console.log(2); }, 1000); 我们都用setTimeout来表示异步操作。 function A(callback){ console.log(&#39;do a start&#39;); setTimeout(() =&gt; { console.log(&#39;do a end&#39;); callback(); }, 1000); } function B() { console.log(&#39;do b&#39;); } A(B); 这样保证了“A操作完成再执行B”，也解决了耦合度高的问题。 但是callback在流程复杂的情况下，难以达到理想编码体验；在流程长的情况下会形成回调地狱，流程难以阅读和维护。 Promise callback的问题是下一步的操作不是靠返回值，而是要靠callback来决定的。这个是跟同步操作最大的区别，也是导致callback烦恼的根本原因。 Promise让异步操作的状态返回出来，而不是在内部处理，是链式调用的基础，也给之后同步方式的写法奠定基础。 function A(){ console.log(&#39;do a start&#39;); return new Promise((resolve,reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;do a end&#39;); resolve(); },1000) }) } function B(){ console.log(&#39;do B&#39;); } A().then(B) 配合defer，Promise.all和Promise.race，使用Promise可以写出很清晰的异步流程。从本质上来讲，Promise连接了异步操作和操作结果，只是将回调延后，再通过链式调用让流程更清晰。 generator 调用generator函数不立即执行，调用一次next执行到下一个yield，拿到yield右边表达式的值，下次调用next传的值赋值给yield左边。 很尴尬啊，写完上面一段话，自己再回头看，也不知道说的啥。还是来看代码吧。 function* generator(){ console.log(&#39;start&#39;); const res = yield 1 + 3; console.log(res); return res; } const gen = generator(); const res1 = gen.next(); console.log(res1); const res2 = gen.next(5); console.log(res2); 可以看到yield的左值不是等于yield右边的结果，而是等于你下一次调用next的时候传入的值。这个特性，使得generator配合Promise，能很好的控制异步。如果yield右边是一个Promise，在Promise的状态变成resolved的时候调用下一次next，传入PromiseValue。 function sleep(msTime = 1000){ return new Promise((resolve,reject) =&gt; { setTimeout(resolve,msTime); }); } function* generator() { const startTime = Date.now(); yield sleep(1000); console.log(Date.now() - startTime); } const gen = generator(); gen.next().value.then((val) =&gt; { gen.next(val); }); 这样所有的流程控制的回调代码都脱离了逻辑函数本身，在generator里，同步和异步的代码混在一起了，但是整个写法看上去是一个同步的，异常的清晰。而后面的控制代码，可以写成一个通用的控制函数，让generator自执行，这个是co模块做的。 import co from &#39;co&#39;; const doSomeThing = co.wrap(function* generator() { const startTime = Date.now(); yield sleep(1000); console.log(Date.now() - startTime); }); doSomeThing(); 使用co模块yield右值可以是promise和trunk函数（为什么是这两个？因为这两个都能从回掉里拿到上一个异步操作的状态），不能是基本类型，确实从异步的角度考虑yield右值放基本类型没有啥意义，但是因为这个报错是有点难以接受的。还值得一提的是co做了一些处理，yield右值也可以是Array和Object，但是里面的值还是必须是promise和trunk。 async/await async/await是es2017出的规范，可以说co和generator的语法糖。不一样的是await的右值兼容了基本类型，但是不再处理Array和Object。 async function doSomeThing() { const startTime = Date.now(); await sleep(1000); console.log(Date.now() - startTime); } doSomeThing(); 从async/await来看JavaScript的异步编程，可以说是很清楚了，同步和异步无缝连接，写起来行云流水，看来清晰明了。想必大家都想用async/await来提高工作效率吧，那么使用async/await要注意什么呢？ 1.async/await离不开Promise，使用Promise.all和Promise.race等优化流程。await写起来太方便了，当两个操作可以并行的时候还请用Promise.all，连续两个await是串行的操作。 2.async函数始终返回的一个Promise，就算简单如下函数。 async function doSomeThing() { return 123; } 3.await右边异步操作变成rejected的时候抛出错误能被try/catch捕捉到，请不要吝啬使用try/catch。 4.还有一点重要的忘记说了，不支持的环境下请转码。 现在的async/await比较完美了，纵观这个变化历程，其实也是蛮辛酸的。在Callback的路上坚持走了很久，期间也出了wind.js等库，或者使用trunk函数，或者使用流式编程的rx.js等。可以看到先辈们的努力，正是他们的努力如今我们可以才可以享受如此硕果。 trunk函数(阮一峰老师的介绍)是个很有意思的想法，通过把callback形式的函数柯里化，很简单的就跟promise一样做到了延迟了回掉。那我们是不是也可以简单的用trunk函数来实现链式调用，答案是no。 不怕大家笑话，因为Promise的then强调的要返回一个Promise，所以，在写本文之前我还一直以为Promise链式调用是依赖回掉的返回值。回想起来，有点好笑，在下一个then调用之前，callback都还没有执行，怎么可能依赖他的返回值来链式调用呢。 这让我们回到一个编程的最基本，就是定义好一系列的操作和操作之前的关系。简单的来将，我们可以把这一系列的操作看成一个数组或者说链表可能更贴切一点，是一环扣一环的，程序开始执行，数组第一个操作完成，然后执行第二个操作，依次类推，直到执行完毕。 在异步编程里面如何应该关心的大概有三个问题： 如何生成这个数组（序列） 写执行器，如何有序的执行完这个数组，在一个操作完成之后通知下一个操作开始执行 看似上面已经完成了所有问题，但还有一个隐藏问题需要解决。在已知的任何事情从宏观的角度来讲，都是一个序列，从前到后的推移，犹如时间的推移。但是从微观的角度，必定会有事件的分支和合流（不知道这样说会不会被打）。如何处理这一部分的逻辑也是重中之重。 对第一个问题，我们直接用数组，可以列为函数的参数，可以像Promise一样链式调用最后组成，奥还有callback。 到第二个问题，我们很容易联想到runSequence这种函数名，于是雏形就有了 `function runSequence(...seqs) { }` 拿到seqs就是干，一个一个执行呗，重要的就是如何一个一个执行。从这一点来看的化，每个异步操作都会有callback，只是callback的时机和写法不一样，或优或劣，从callback里调用下一次操作。我们可以把callback想成next借用koa的思想把序列执行完。这个要求每个操作都会调用并且只调用一次next，以最普通callback函数为例。 function runSequence(...seqs) { let i = 0; const next = (index, ...args) =&gt; { if (i !== index) { console.warn(&#39;next call twice&#39;); return; } let arg, callback; if (typeof args[args.length - 1] === &#39;function&#39;) { arg = args.slice(0, args.length - 1); callback = args[args.length - 1]; } else { arg = args; callback = null; } const seq = seqs[i++]; if (!seq) { callback &amp;&amp; callback(null, ...arg); return; } try { seq.call(null, ...arg, ((i, err, ...res) =&gt; { if (err) { callback &amp;&amp; callback(err); } else { next.call(null, i, ...res, callback); } }).bind(null, i)); } catch (err) { callback &amp;&amp; callback(err); } } return (...args) =&gt; { next.call(null, 0, ...args); } } 大功告成，我们来写一些简单的例子测试一下 const res = { a: &#39;b&#39;, b: &#39;c&#39;, } function fetch(key, next) { console.log(`fetch ${key} start`, Date.now() | 0); if (!key) { next(&#39;err key&#39;); } setTimeout(() =&gt; { console.log(`fetch ${key} end`, Date.now() | 0); if (!res[key]) { next(`${key} not found`); } else { next(null, res[key]); } }, 1000); } function runError(next) { throw new Error(&#39;erred&#39;); next(); } runSequence(fetch, fetch, (data, next) =&gt; { next(null, data + &#39;1&#39;); next(null, data + &#39;2&#39;); }, (data, next) =&gt; { console.log(data); next(null, data + &#39;3&#39;); }, runError)(&#39;a&#39;, (err, ...data) =&gt; { console.log(err, ...data, &#39;finish all&#39;); }); log如下 // fetch a start 5682 // fetch a end 6686 // fetch b start 6687 // fetch b start 6687 // c1 // Error: erred &quot;finish all&quot; // warn: next call twice 看上去没毛病了。我们可以来解决第三个问题，还是拿来主义，借鉴Promise.all和Promise.race。我们也可以给callback写一个对应的all和race。直接贴代码 总的来说，任何方案，只要是有规范，按规范走就能很好的优化这个流程。比如最后一个函数是callback，callback最后，第一个参数是err等等。使用Promise也有一定遵循的，如果Promise.resolve(123, 345);，后面的参数就会被忽略了，如果使用了这一点runSequence也能优化很多。runSequence.all数组里只能用函数bind的形式来写，就很丑，就可以用thunkify来优化。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建你的第一个Express应用]]></title>
    <url>%2F2018%2F04%2F28%2FNode%2F%E6%90%AD%E5%BB%BA%E4%BD%A0%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AAExpress%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Express介绍 Express 是一个简洁而灵活的 node.js Web应用框架, 提供一系列强大特性帮助你创建各种Web应用 丰富的HTTP工具以及来自Connect框架的中间件随取随用，创建强健、友好的API变得快速又简单 Express 不对 node.js 已有的特性进行二次抽象，我们只是在它之上扩展了Web应用所需的功能 使用 Express 可以快速地搭建一个完整功能的网站，它有一套健壮的特性，可用于开发单页、多页和混合Web应用。 开始在确认已经安装了node之后(下载), 在你的机器上创建一个目录，让我们来开始你的第一个应用程序吧 //新建一个目录文件夹,初始化一个packjson.json文件 $mkdir express-demo &amp;&amp; cd express-demo &amp;&amp; npm init //安装Express $ npm install express -g 现在我们来写真正的代码了！创建一个名为app.js 或者 server.js的文件，叫什么看你个人喜好了。 载入express 然后使用代码 express()创建一个新的应用程序: var express = require(&#39;express&#39;); var app = express(); 在这个应用程序实例里，你可以通过 app.VERB()定义路由，下面的例子是”GET /“返回 “Hello World” 字符串。 req 和 res 对象是和node原生提供给你的一致的，你也可以执行 res.pipe(), req.on(‘data’, callback) 等任何事情在没有Express的情况下可以做的事情。 Express 给这些对象加了一个封装好的方法，比如 res.send(), 它会帮你设置Content-Length: app.get(&#39;./&#39;,function(req,res){ console.log(&quot;GET 请求成功&quot;)； req.send(&#39;Hello Express&#39;); }) 现在我们通过执行 app.listen() 来绑定并监听连接。 它接受的参数和nodenet.Server#listen()的方法一致: app.listen(3000,function(){ console.log(&#39;Listening on port %d&#39;, server.address().port); }) 然后在终端执行node app.js 打开3000端口的页面就会看到Hello Express了 使用express-generator 快速生成一个应用程序安装express-generator$ npm install express-generator -g 这个工具提供了一个非常简单的生成一个程序骨架的功能，但是它也有局限，比如它只支持很少的几个模板引擎。 而事实上Express几乎支持所有的为node所建的模板引擎。 使用 –help查看一下帮助: Usage: express [options] Options: -h, --help 输出帮助信息 -V, --version 输出版本号 -e, --ejs 添加 ejs 模板引擎支持 (默认为jade) -H, --hogan 添加 hogan.js模板引擎支持 -c, --css 样式 &lt;引擎&gt; 支持 (less|stylus) (默认为css) -f, --force 强制在非空目录执行 使用 $ express myapp 生成目录的如下: 默认为jade和css的结构 如果你想生成一个支持ejs, Stylus的应用程序，只需要简单的执行下面的命令： 则生成的目录为 app.js：启动文件，或者说入口文件 package.json：存储着工程的信息及模块依赖，当在 dependencies 中添加依赖的模块时，运行npm install，npm 会检查当前目录下的 package.json，并自动安装所有指定的模块 node_modules：存放 package.json 中安装的模块，当你在 package.json 添加依赖的模块并安装后，存放在这个文件夹下 public：存放 image、css、js 等文件 routes：存放路由文件 views：存放视图文件或者说模版文件 bin：存放可执行文件 执行应用 cd myapp npm install DEBUG=myapp:* npm start 打开3000端口就会看到如下页面： 这些就是一个简单的应用程序创建和运行的所有步骤。 记住Express没有限定任何的目录结构，这只是一个方便你工作的基本结构。 如果你想得到更多怎么组织目录结构选择，可以查看github上的示例。 推荐最后给大家推荐一个更详细的例子：使用express搭建一个简单的博客;]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Express</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017 年崛起的 JS 项目]]></title>
    <url>%2F2018%2F04%2F26%2F%E6%9D%82%E6%96%87%2F2017-%E5%B9%B4%E5%B4%9B%E8%B5%B7%E7%9A%84-JS-%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[最受欢迎项目下面是不分类别的 2017 年度最受欢迎 Javascript 项目，如果你时间很紧，看这部分就够了。 Vue.js 蝉联冠军 Vue.js 再次强势登顶年度排行榜冠军，今年在 GitHub 上新增了超过 40K 的 star。相较于 2016 年的（26K star），今年 Vue.js 领先排行榜第 2 名（ React ）的优势更大了。 那么，是什么令 Vue.js 如此出众？ 首先，它学习曲线平缓，使用了与 React 相似语法更让 WEB 开发者熟悉的组件方案； 发展良好的生态圈，社区中涌现出事实上的官方标准库：路由vue-router，状态管理库: Vuex； 把模板、逻辑和样式放入单个 .vue 文件中的单文件组件设计理念在模块化代行其道的今天显得非常亲切； 被流行的 PHP 框架 Laravel 选为默认的视图引擎（View Engine）； 为 Evan You 个人维护，通过众筹方式来获取支持的开源项目，而不是由 Facebook 或 Google 这样的互联网巨头来主导。 也许正因为上述最后一点，Vue.js 在中国拥有大量的拥趸。不仅被中国最大的电商平台阿里巴巴使用，也获得了 GitLab 与 Adobe 这些公司青睐。 React 再次获得亚军React 和 2016 一样稳占第二名，2017 年它在 GitHub 上获得了超过 27K star（再次明确下，此处我们分析的是今年新增的 star 数量而非所有的 star 数量）。 Create React App，是排行榜的季军，已经成为新建 React 项目的首选方式。它的大获成功让不少 React 样板项目（React Boilerplates）慢慢淡出历史舞台。 Dan Abramov（ Redux 作者，现就职于 Facebook）创建 Create React App 的确是做了一件了不起的工作，他在功能性与简洁性之间取得了巧妙的平衡，比如，它没有集成花哨的样式解决方案（只使用了纯粹的 CSS）和服务器端渲染，却具有恰到好处的封装，这些造就了良好的开发体验。 AxiosAxios 库是最广泛使用的 HTTP 客户端。它能同时在用户端（在用户端发起 Ajax 请求）与服务器端（在 Node.js 环境中）使用。 Axios 的成功或许与 Vue.js 有比较大的关系，因为大量的 Vue.js 教程都使用它来发起 API 请求获取数据。 PuppeteerPuppeteer 是17年的大事件之一，是 Google Chrome 团队开发的一个无界面 Chrome 浏览器，即一个在后台运行，且能被代码驱动和控制的浏览器。 它可作如下用途:在真实浏览器中进行自动化界面测试；用生成页面快照的方式来实现服务端渲染；利用 Google Chrome “保存为 PDF” 的功能生成PDF文件； 前端框架前端框架方面向来是兵家必争之地，不过如今已呈三家鼎足分立，大局尘埃落定之势。 Vue、React、Angular 三足鼎立毫无疑问，目前公认的 3 大 UI 框架分别是 Vue.js，React 和 Angular 。 我们习惯称他们为_框架，但准确地讲只有 Angular 是框架，Vue.js 和 React 应归类为库_。 前文中，我们已经分析了 Vue.js 的成功因素和它的集成方案。 与 Vue.js 相对应的，React 方面却依然处于碎片化的状态，开发者需要根据自身项目的情况，进行技术选型：页面间的路由切换问题；如何获取数据；如何把数据绑定到表单；如何存储应用的状态； 相反，Angular 生态圈则更可控也更稳定。有一种叫Angular 准则 的最佳实践用来指导开发。 这可能给人一种 Angular 对于多人协同工作更友好的印象。此外，随着支持静态类型的 TypeScript 加入，Angular 也势必能得到更多熟悉 C# 或 Java 的后端开发人员人观注与青睐。 少即是多在三巨头之后，能非常有趣的发现第四名 Preact。 Preact 是一个 React 的小型替代解决方案：有相同的 API，却只有 3KB 的大小。 类似的还有许多竞争者，为了区别于三巨头，它们在浏览器的性能上下功夫，努力做出自己的特色。 Node.js 框架JavaScript 已不仅仅局限于 Web 前端应用，也被越来越多的人使用开发后端应用。Node.js 社区颇具有影响力的 Mikeal Rogers 做出了 Node.js 会在一年内超越 Java的预测。 和其他语言都有事实上的标准框架不同的是（如 Ruby 有 Ruby on Rails，Python 有 Django，PHP 有 Laravel），目前基于 Node.js 写服务端程序还没有一个大家都认可的标准框架。 Express 并不是 2017 年度的 Node.js 框架分类排行冠军，毕竟这个项目已经成立多年，但它已转变为许多框架和 CMS 的基础组件，包括 Feathers、Keystone 和 Nest。 Express 的极简主义设计似乎完美地符合了当今微服务理念的发展趋势：把一个大型程序解耦成几个小的应用。 与去年相比, 今年有 3 个新面孔进入了 node.js 框架分类排行的 TOP 10： Fastify 是一个受 Hapi 启发而开发的通用 Web 框架，也适合用作 JSON HTTP API 服务器； Server.js 注重于“开箱即用”的开发体验； Nest 是一个用 TypeScript 写的框架，其模块化和控制器组合的架构设计，让 Angular 用户感到十分亲切。 React 生态圈 React 只专注于视图层 (View Layer)，这在为整个生态圈留下更多发展空间的同时，也为自身快速向前发展创造了机会。这个分类下我们会统计基于 React 和 React Native 构建的项目。 Create React App通过集成优秀的预置和包，解决了新建 React 应用时要进行繁琐复杂的配置问题。今年 Facebook 也继续保持了频繁更新的节奏，使他成为目前 React 生态中最活跃的项目。https://stackblitz.com/ 作为 Create React App 的一个成功案例，我们可以看 StackBlitz，这是一个在线 IDE，通过 Create React App，让你在数秒内就可以在浏览器中创建一个应用。 即使 Create React App 已被默认为 React 的新建工具包，开发者们仍然可以有其它选项，例如 React boilerplate，这也是十分受人关注的项目，继承了诸如 GraphQL 的很多有用功能。 Ant Design，Ant Design Pro 和 Material UI 是 React 组件的样式工具集，它们能帮助程序员在新建应用时而不再担心样式问题。 第 10 名 Recompose 的人气值也证明了开发者们喜欢 React 的原因：它的“函数式”特性，一切皆函数。Recompose 提供了一全套的函数来帮助你走的更远。 Vue.js 生态圈 在 2017 年，伴随着 Vue.js 用户的增长，许多 Vue.js 生态圈中的项目也得到了令人惊喜地快速成长。 Element 和 iView 是两个最受欢迎的 UI 组件工具包，专注于桌面端 UI 界面的快速开发。而 Mint UI 与 vux 则相反，是移动端最受欢迎的 UI 工具包。 Vuetify 是一款功能最完备的能同时适用于移动端和桌面端的 Material Design 组件框架内置了包括服务端渲染、PWA、CLI 模板支持等诸多特性。 Nuxt 则是一款基于 Vue.js 的更高级的框架，它能让我们流畅地开发具备服务器端渲染能力的 Vue.js 应用，而它的通用性使我们能用同样的代码库来构建单页引用，甚至生成静态网站。 Weex 是一个可以用 Vue.js 语法和 API 来进行原生渲染的移动桌面应用开发。它由阿里巴巴公司开发，并已运用于世界上一些最高频使用的移动应用中，十分注重性能问题上的优化。 移动开发 无所不能的 JavaScript，自然可已用来编写移动应用，这意为着你可以在 WEB 端与 Native 端复用你的组件。 在本分类中，我们为 3 大前端框架找到了对应的解决方案：React: React NativeVue：Weex 和 QuasarAngular：Ionic 和 NativeScript 与 2016 年一样，React Native 两年蝉联头名，它能让我们使用把 JavaScript 编译成能够运行在 iOS、Android 甚至是 Windows 系统的原生 APP 应用。 正如视频 使用 React Native 来跨平台编译APP中所特别强调的：“Write One, Run Everywhere” 的承诺已经变成现实。 编译工具：Compilers 这里我们将讨论那些编译到标准 JavaScript 代码的语言。 通常情况下，在搭建自己的构建工作流时需要编译器可能有 2 个原因：想立即使用最新的 JavaScript 语言特性，并把它应用到尽可能多的浏览器中，这类需求让 Babel 获得了成功，很多项目都依赖于它；想为语言添加新的特性，比如“类型检查”；对 Javascript 程序员进行分类有个热门的问题是：你是用类型的，还是不用类型的？ JavaScript 本身带有基本的动态类型，但缺乏静态类型。而很多开发者倾向于在代码中使用类型，尤其在大型项目中，因为这样可以让代码变得更为健壮且易于阅读和理解。 如果你需要类型，有两个主流可选项：微软的 TypeScript 和 Facebook 的 Flow（Facebook 在自己的主要项目 React，React Native，Jest 中都有使用) 你可以从 James Kyle 的文章来感受两者的区别: A Comparison Between Adopting Flow or TypeScript 构建工具：Build Tools 构建工具分类中的排行冠军是 Parcel，这或许是今年最大的惊喜，作为一个 8 月份才在 GitHub 上发布的新项目却已达到 14K 个 star 的关注度。 Parcel 不仅提供现代前端开发所需的各种功能，还有个碾压性的优势：零配置！这是它与依靠大量 “loaders” 的 Webpack 最大区别。 请别误解数字，Webpack 依然是最流行的构建应用，它在 GitHub 上 有 35K 的 star 和超 500 人的贡献者。目前有许多项目使用了它，包括今年最流行的两个项目：Create React App 和 Gatsby。 Webpack 不断在迭代更新，2.0 版本可以让开发者通过动态加载的方式轻松实现“代码分割”的功能。 Webpack 与 Parcel 同时定位于构建 WEB 应用，而 Rollup 则定位于库的构建，它专注于 ES6 模块的性能提升上。 Rollup 已被一些主流的库使用，值得一提的是 React 团队也在 2017 年把它们的构建系统从 Browserify 切换到了 Rollup。 在 React 博客中提到 Rollup 可以预编译并且集成到应用中，能与 React 之类相似的库做到完美配合。 Poi 与 Parcel 有同样的目标：一款现代网络应用构建工具，它默认零配置但你可以通过使用 preset 来扩展。 测试框架 Jest 最初是 Facebook 因为 React 组件测试目的而开发的，但最近几个月革命性的版本变更（发布了 22 个大版本）使得它现在能同时用于测试前端、后端代码。 Jest 有几个大的闪光点：无需配置，默认地设定已经满足通常需求；强大的开发者体验 (智能观察模式，直观的错误报告)；语法上与 Mocha 很接近，许多程序员熟悉 describe 和 it 这样的关键词；不需要额外的库来创建 assertions，已全部内置；独特的”快照”模式可以作为重新运行测试时的对比基准； AVA，去年的第一名，仍然有许多吸引人的特点。 这个项目由 Sindre Sorhus 创建并在他所有的项目中使用，熟悉他的同学肯定知道这意味着什么！ 相较于 Jest，AVA 更侧重于并行测试上的速度，更轻量，也更接近测试标准，语法上与测试框架 Tape 接近。 IDE 和编辑器 在这里我们讨论的是利用 WEB 技术来构建的开源的代码编辑器（ Sublime 粉丝们对不住了！）。 2016 年由微软主导的 VS Code 与 GitHub 主导的 Atom 在本类别中齐头并进。今年他们也依然处于领先地位，不过在互相较量中，VS Code 己领先它的对手一大截。 每个月 VS Code 都会发布新版本，带来更多实用 IDE 功能同时性能上却没有太大的损耗。 即使不安装任何插件，你也有一大堆开箱即用的功能：Git 集成功能；自动补全：JavaScript 语法，文件路径进行补全，npm 包名字等等；React 语法集成等； 此外，你可以在编辑器中添加 Prettier 插件，这样每次保存时它都会自动格式化文件，在这样的编程环境下编码真是一种享受。 CSS in JavaScript 目前 React 社区仍然没有就如何有效管理组件样式这个问题达成共识，即没有标准的解决方案。 如果无需太多自定义的标准样式，可以用 Material UI 或 Ant Design 这样现成的组件工具包。如果需要更高度灵活的自定义，你仍然能使用传统方式：用一个像 Bootstrap 或 Bulma 这样的全局 CSS 样式，通过修改组件的 className 属性来达到目的。这样做缺点是组件无法进行自我样式管理，因为样式分布在单独的文件中。 CSS in JavaScript 概念的出现即是为了解决上述问题。 概念本身很简单：既然我们在 React 中己能通过 JavaScript 来同时控制逻辑和模板部分，何不再进一步，连样式也一并管理了呢？ Styled Components 是今年本类别的冠军，它利用 JavasScript 最近新加入的模板字符串特性，让开发者在 React 组件中直接使用标准的 CSS 语法编写样式。 CSS Modules，作为本类别的亚军，则采用了混合的解决方案。它让开发者自己挑选诸如标准 CSS, SASS, NO slug Less, NO slug Stylus等方式编写样式，再以文件的方式导入到组件中。 Mark Dalgleish，CSS Modules 的作者，写了一篇有意思的文章来阐述 CSS-in-JavaScript 解决方案：A Unified Styling Language。如果你对 CSS-in-Javascript 解决方案仍持怀疑态度的话，那此文绝对不容错过。 静态网站生成器 静态网站生成器（SSG，Static Site Generator）是指能够生成一坨 HTML、CSS、JS 文件，方便你快速部署到 WEB 服务器上而不需要安装和配置数据库的工具。 静态网站具有速度快，稳定且易于维护的特点。作为 2016 年的亚军，Gatsby 今年成功拨得头筹。它新增了许多新功能来助你优化静态网站： 快速浏览和导出速度；主动预加载机能；智能代码分解 (模板 + 网页数据)；Gatsby 使用 React 来做视图层(View Layer)，构建时候则用 GraphQL 来查询内容。它有一个强大的社区并且 React 官网也是用 Gatsby 的来搭建的. React Static 是本类别的新面孔。它从 Create React App 项目中获得灵感，定位于做一个轻量的 Gatsby 替代方案，专注于性能和简洁。 此外，值得一提的是 Next.js 也能当静态网站生成器来用。 GraphQL 在未来回顾 GraphQL 的历史时，2017 年很有可能会成为一个转折点。 像 the New York Times 这样的大公司开始使用 GraphQL，Relay 和 Apollo (两个主要的 GraphQL 客户端框架) 也在今年发布了两个重要的版本更新。 在这两大库的身后，像 Graphcool 这样的公司也提供了大量的工具和库，而 Vulcan 这样的全栈框架也开始采用 GraphQL 。 值得注意的是今年最有人气的静态网站生成器 Gatsby 也在数据处理中使用了 GraphQL 。 随着越来越多的人加入到 GraphQL 阵营来, 可以预见其在技术上广泛取代 REST 只是一个时间问题。 总结希望我们今年对 JavaScript 领域做出的回顾能够对你有所启发。 可以看到，Vue.js 两年蝉联冠军并且没有丝毫停下来的征兆。 React 生态圈也最终解决了证书问题，继续繁荣发展的势头。 但是如果让我们评选2017 项目之星的话，那绝对是 Prettier。有了它，我们写代码时的再也不用担心格式问题！ State of JavaScript 2017 survey 收集和分析了 23,000 位开发者的调研问卷，能帮助你从另一个视角来解读社区演化的方向。 原文地址]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>杂文</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux学习之升级水果店面]]></title>
    <url>%2F2018%2F04%2F25%2FReact%2FRedux%2Fredux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%8D%87%E7%BA%A7%E6%B0%B4%E6%9E%9C%E5%BA%97%E9%9D%A2%2F</url>
    <content type="text"><![CDATA[优雅的处理 async action阿大通过请了一个采购员完成了耗时的进口商品的售卖。 但是，阿大同时也发现了一个问题：顾客要买水果生鲜的话需要找销售员，要买进口水果生鲜的话要找采购员，这样的话，顾客需要找不同的人，很麻烦。阿大想了想，能不能让顾客只找销售员，然后销售员如果有需求再找采购员采购呢。 阿大想到了办法，让销售员把所有的需求都告诉采购员，然后采购员再传递给收银员，这样，如果是需要采购的水果生鲜，就可以独自去处理了，这样就需要把采购员改成这样了： const API = store =&gt; { // 和 收银员 对接的方式 const next = store.dispatch; // 接管销售员传来的顾客需求 store.dispatch = action =&gt; { // 处理完了之后再对接 收银员 switch (action.type) { case &#39;BUY_IMPORTED_APPLE&#39;: fetching(2000, () =&gt; next(action)); break; case &#39;BUY_IMPORTED_EGG&#39;: fetching(3000, () =&gt; next(action)); break; default: next(action); } } } API(store); 然后顾客来了之后就都只用找销售员了： store.dispatch(buyApple(3)); store.dispatch(buyImportedApple(10)); store.dispatch(buyEgg(1)); store.dispatch(buyImportedEgg(10)); store.dispatch(buyApple(4)); store.dispatch(buyImportedApple(10)); store.dispatch(buyEgg(8)); store.dispatch(buyImportedEgg(10)); // {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:0,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:1,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:1,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:10},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:20},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:20},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:10}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:20},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:20}} 图解 编写和使用中间件阿大通过改善流程对接完成了水果店的升级。 但是阿大又有一个新的想法，他想详细的看看每一个顾客的购买需求来了之后，账本的前后变化。看来又要加一个新角色记录员了。难道要像加采购员那样手动的一个个的加吗？那可太麻烦了。正好阿大发现 redux 里有一个功能就是中间件。中间件是干嘛的呢？简而言之，就是把顾客的需求从销售员到收银员之间加上各种角色来处理。每一个角色就是一个中间件。接下来阿大就开始来写中间件了。 redux 中间件写起来其实很简单，就是一个函数而已。按照它的要求。这个函数接受一个{ dispatch, getState }对象作为参数，然后返回一个 action 那这样，就可以把原来的采购员也改造成中间件了，其实采购员就是拿到了顾客需求之后让顾客的需求延迟 dispatch，这用延迟用函数就可以做到了: // next 是用中间件增强之后的 dispatch // dispatch 是最原始的 store.dispatch const thunkMiddleware = ({ dispatch }) =&gt; next =&gt; action =&gt; { if (typeof action === &#39;function&#39;) { // 函数形式的 action 就把 dispatch 给这个 action，让 action 决定什么时候 dispatch （控制反转） return action(dispatch); } // 普通的 action 就直接传递给下一个中间件处理 return next(action); } 然后我们就需要把原来的顾客需求改一下了： // 买水果 - 进口苹果 function buyImportedApple(num) { // 返回一个函数类型的 action，这个函数接受 dispatch，可以决定什么时候 dispatch return dispatch =&gt; API.fetchImportedApple(() =&gt; dispatch({ type: &#39;BUY_IMPORTED_APPLE&#39;, payload: num })); } // 买生鲜 - 进口鸡蛋 function buyImportedEgg(num) { return dispatch =&gt; API.fetchImportedEgg(() =&gt; dispatch({ type: &#39;BUY_IMPORTED_EGG&#39;, payload: num })); } 然后采购员就可以只负责采购了，改回去： // 采购商品生成器，不同的商品需要不同的时间采购 function fetching(time, callback) { // 用延时模拟采购时间 const timer = setTimeout(() =&gt; { clearTimeout(timer); // 采购完成，通知销售员 callback(); }, time); } // 采购进口苹果需要 2 天（2s） function fetchImportedApple(callback) { fetching(2000, callback); } // 采购进口苹果需要 3 天（3s） function fetchImportedEgg(callback) { fetching(3000, callback); } // 采购员 const API = { fetchImportedApple, // 采购进口苹果 fetchImportedEgg // 采购进口鸡蛋 } 然后，我们在添加一个记录员的中间件： const loggerMiddleware = ({ getState }) =&gt; next =&gt; action =&gt; { console.log(`state before: ${JSON.stringify(getState())}`); console.log(`action: ${JSON.stringify(action)}`); const result = next(action); console.log(`state after: ${JSON.stringify(getState())}`); console.log(&#39;================================================&#39;); return result; } 删除掉原来的监听： //- store.subscribe(() =&gt; console.log(JSON.stringify(store.getState()))); 好了，接下来就可以通过 redux 的 applyMiddleware 来串联起这些中间件啦。 const { createStore, combineReducers, applyMiddleware } = require(&#39;redux&#39;); // 中间件的调用顺序是从右到左 const store = createStore(reducer, applyMiddleware(thunkMiddleware, loggerMiddleware)); 好了，大功告成，开始服务顾客： store.dispatch(buyApple(3)); store.dispatch(buyImportedApple(10)); // state before: {&quot;fruit&quot;:{&quot;apple&quot;:0,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:0,&quot;importedEgg&quot;:0}} // action: {&quot;type&quot;:&quot;BUY_APPLE&quot;,&quot;payload&quot;:3} // state after: {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:0,&quot;importedEgg&quot;:0}} // ================================================ // state before: {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:0,&quot;importedEgg&quot;:0}} // action: {&quot;type&quot;:&quot;BUY_EGG&quot;,&quot;payload&quot;:1} // state after: {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:1,&quot;importedEgg&quot;:0}} // ================================================ 上面我们写的两个中间件其实就是 redux-thunk 和 redux-logger 的简版。在实际中，推荐使用它们，会更可信。 图解 编写 redux 中间件需要按照要求来，返回这样的函数 // 中间件接受一个对象，里面有原始的 dispatch，和 getState 方法用于获取 state // 中间件函数返回一个函数，这个函数接受一个 next 参数，这个 next 是下一个中间件要做的事情 action =&gt; { ... } function thunkMiddleware({ dispatch, getState }) { return function(next) { return function(action) { // 做你的事情 } } } 原文地址]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redux学习之开店卖水果]]></title>
    <url>%2F2018%2F04%2F25%2FReact%2FRedux%2Fredux%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%BC%80%E5%BA%97%E5%8D%96%E6%B0%B4%E6%9E%9C%2F</url>
    <content type="text"><![CDATA[Redux 是什么每当我们谈及到 redux，大家都会说是 react 的状态管理工具。这么说确实没错，毕竟 redux 项目也是 React Community 组织下的一个子项目。而且 redux 的诞生也是和 react 这个 ui 库急需一个状态管理解决方案有很大的联系。但是 redux 和 react 并没有任何的耦合。虽然它们经常一起用，但是 redux 的用途并不局限于 react，或者说，和 react 的结合只是 redux 的使用方式之一。 那么撇开 react 不谈， redux 到底是什么呢？我们看一下这个例子。 在实际的开发当中，我们可能会碰到这样的需求：监听一个事件，当事件触发的时候，我们可以做一些想做的事情。 redux基础用法—卖水果一天，程序员阿大（化名）想要去买水果吃，发现小区周围居然没有水果店，于是就打算自己开一个水果店赚点小钱。阿大分析了一下水果店的营业模式。其实就是处理每一位顾客的需求，然后记账看看每天的盈亏。那么抽象成程序就是监听顾客的行为，并把每个行为的结果都记在账上，这正好是 redux 所擅长的。阿大胸有成竹，说着就开始写了起来： 首先模拟顾客的购买行为：const action = { type: &#39;BUY_APPLE&#39;, // 买苹果 payload: { count: 2 // 买 2 斤 } } 那不同的顾客要的斤数可能不同，于是他写了下面这个方法： /** * 只要知道斤数就可以快速生成顾客的各种需求 * @param {number} num 顾客要买的斤数 */ function buyApple(num) { return { type: &#39;BUY_APPLE&#39;, payload: { count: num } } } 然后是账本的结构，记录每天卖了多少斤： // 被托管的数据 state // 账本，今天已卖的苹果：0 斤；为了简便，就只举一个例子，事实上还有很多其他水果，大家自行脑补 const state = { apple: 0 }; 好了，现在顾客需求，账本都有了，那谁来记账呢？所以阿大请了一个收银员负责记账，并告诉他这么记账： /** * 监听函数 listener * 收银员只要知道顾客的需求就能正确的操作账本 * @param {object} state 账本 * @param {object} action 顾客的需求 */ function reducer(state, action) { // 注册 ‘买苹果’ 事件 // 如果有人买了苹果，加上顾客买的斤数，更新账本 if (action.type === &#39;BUY_APPLE&#39;) { return Object.assign({}, state, { apple: state.apple + action.payload.count }); } // 没注册的事件不作处理 // 买咱们店里没有的东西，不更新账本，原样返回 return state; } 好，万事俱备，可以正式的监听顾客的购买需求并更新账本了： const {createStore} = require(&#39;redux&#39;); // 创建水果店需要收银员（监听函数 listener）和账本（被托管的数据） const store = createStore(reducer, state); 不仅如此，redux 还提供了一个功能，每服务一个顾客，都可以额外做一些事情，于是阿大就想看看每笔交易之后的账本： // store.getState() 可以获取最新的 state store.subscribe(() =&gt; console.log(JSON.stringify(store.getState()))); 好了，顾客开始来买水果了： // 触发用户购买水果的事件 // 销售员开始销售 store.dispatch(buyApple(3)); // {&quot;apple&quot;:3} store.dispatch(buyApple(4)); // {&quot;apple&quot;:7} 店铺稳定的运营了下去，阿大心里美滋滋~ 讲解不过在此之前要先说 redux 特别讲究也是特别重要的 3 点： 只能有唯一的 store 对象保存整个应用的 state state 是只读的，只能通过 dispatch(action) 的方式来改变 state reducer 必须是纯函数 actionaction 是行为信息的抽象，对象类型，它描述发生了什么。这个对象必须有一个 type 属性，对于对象里面的其他内容，redux 不做限制。但是推荐符合 Flux Standard Action 规范： { type: &#39;ACTION_TYPE&#39;, payload, // action 携带的数据 } action creatoraction creator 顾名思义就是用来创建 action 的，action creator 只简单的返回 action。 function createAction(num) { return { type: &#39;ACTION_TYPE&#39;, payload, } } statestate 是被托管的数据，也就是每次触发监听事件，我们要操作的数据。 reducerreducer 是用来控制 state 改变的函数。action 描述了发生了什么，但是并不会知道相应的 state 该怎么改变。对于不同的 action，相应的 state 变化是用 reducer 来描述的。 reducer 接受两个函数，第一个是 state，第二个是 action，并返回计算之后新的 state。reducer 必须是一个纯函数，对于相同的输入 state 和 action，一定会返回相同的新的 state。 nextState = reducer(prevState, action); 因为 reducer 是纯函数，所以原来的 prevState 并不会改变，新的 nextState 是一个最新的快照。 storestore 是把上面三个元素合起来的一个大对象: { createStore, combineReducers, bindActionCreators, applyMiddleware, compose, __DO_NOT_USE__ActionTypes } 它负责： 托管应用的 state 允许通过 store.getState() 方法访问到托管的 state 允许通过 store.dispatch() 方法来触发 action 更新 state 允许通过 store.subscribe() 注册监听函数监听每一次的 action 触发 允许注销通过 store.subscribe() 方法注册的监听函数 // 注册 const unsubscribe = store.subscribe(() =&gt; { /** do something */}); // 注销 unsubscribe(); reducer拆分谁知道水果店生意越来越好，于是阿大开始拓展业务，不仅卖水果，还卖起了生鲜，于是有了水果部和生鲜部。 于是阿大想了想未来购买生鲜的顾客的行为： // 买生鲜 - 鸡蛋 function buyEgg(num) { return { type: &#39;BUY_EGG&#39;, payload: { count: num } } } 分了不同的部门之后，不同的业务有不同的记账方式，得分账记了，开来要增加一个生鲜的记账本： const freshState = { egg: 0 }; 原来的水果账本也要改个名字： //- const state = { + const fruitsState = { apple: 0 }; 然后增加生鲜部的收银员, 管理生鲜账本 freshState： // 生鲜部收银员 function freshReducer(state = freshState, action) { if (action.type === &#39;BUY_EGG&#39;) { return Object.assign({}, state, { egg: state.egg + action.payload.count }); } return state; } 然后原来水果部的收银员管理水果账本 fruitsState 需要修改下： // 水果部收银员 //- function reducer(state, action) { + function fruitReducer(state = fruitState, action) { if (action.type === &#39;BUY_APPLE&#39;) { return Object.assign({}, state, { apple: state.apple + action.payload.count }); } return state; } 但是阿大并不想看各个部门的分账本，他只想看一个总账本就好了。刚好 redux 提供了 combineReducers 功能，可以把各个收银员管理的账本合起来： //- const { createStore } = require(&#39;redux&#39;); + const { createStore, combineReducers } = require(&#39;redux&#39;); // 总账本 + const state = { + fruits: fruitsReducer, + fresh: freshReducer + }; // 总收银员 + const reducer = combineReducers(state); // 创建新的水果生鲜店 //- const store = createStore(reducer, state); + const store = createStore(reducer); 这样，水果生鲜店就可以营业了，销售员又开始处理顾客的购物需求了： store.dispatch(buyApple(3)); // {&quot;fruit&quot;:{&quot;apple&quot;:3},&quot;fresh&quot;:{&quot;egg&quot;:0}} store.dispatch(buyEgg(1)); // {&quot;fruit&quot;:{&quot;apple&quot;:3},&quot;fresh&quot;:{&quot;egg&quot;:1}} store.dispatch(buyApple(4)); // {&quot;fruit&quot;:{&quot;apple&quot;:7},&quot;fresh&quot;:{&quot;egg&quot;:1}} store.dispatch(buyEgg(8)); // {&quot;fruit&quot;:{&quot;apple&quot;:7},&quot;fresh&quot;:{&quot;egg&quot;:9}} // ... 图解： combineReducers当业务场景越来越复杂的时候，state 的结构也会变得越来越复杂而且庞大。如果只用一个 reducer 来计算 state 的变化势必会特别麻烦。这个时候我们就可以把 state 里独立的数据分离出来，单独用一个 reducer 来计算，然后再通过 combineReducers 方法合入到 state 中。combineReducers 接收一个对象，这个对象就是最终的 state const reducer = combineReducers({ fruits: fruitsReducer, fresh: freshReducer }); 处理 async action阿大通过 redux 的 bindReducers 方法将水果店的业务分治成功，店铺也越做越大。以至于有顾客开始想要买一些进口的水果生鲜。 阿大考虑了一下，决定继续拓展这个店铺，从事进口商品的销售。首先是顾客的需求行为需要购买进口水果生鲜： // 买水果 - 进口苹果 + function buyImportedApple(num) { + return { + type: &#39;BUY_IMPORTED_APPLE&#39;, + payload: { + num + } + } + } // 买生鲜 - 进口鸡蛋 + function buyImportedEgg(num) { + return { + type: &#39;BUY_IMPORTED_EGG&#39;, + payload: { + num + } + } + } 然后水果部和生鲜部的账本也要更新啦： // 水果账本 const fruitState = { orange: 0, apple: 0, banana: 0, + importedApple: 0 }; // 生鲜账本 const freshState = { egg: 0, fish: 0, vegetable: 0, + importedEgg: 0 }; 同样的，相应部门的收银员们也要学会怎么处理进口水果生鲜的记账，他们的记账方式要改成下面这样： // 水果部收银员 function fruitReducer(state = fruitState, action) { // 如果有人买了相应的水果，更新账本 switch (action.type) { case &#39;BUY_APPLE&#39;: return Object.assign({}, state, { apple: state.apple + action.payload.count }); case &#39;BUY_IMPORTED_APPLE&#39;: return Object.assign({}, state, { importedApple: state.importedApple + action.payload.count }); // 买其他的东西，不更新账本，原样返回 default: return state; } ; } // 生鲜部收银员 function freshReducer(state = freshState, action) { switch (action.type) { case &#39;BUY_EGG&#39;: return Object.assign({}, state, { egg: state.egg + action.payload.count }); case &#39;BUY_IMPORTED_EGG&#39;: return Object.assign({}, state, { importedEgg: state.importedEgg + action.payload.count }); default: return state; } ; } 可是这时候阿大发现，进口水果生鲜不能大量存在自己仓库卖，因为它们又贵又容易坏，只有当顾客需要买的时候，才能去采购这些水果生鲜，于是阿大又雇了一个采购员专门负责处理要买进口水果和生鲜的顾客，等到货了再通知销售员取货给顾客： // 采购商品生成器，不同的商品需要不同的时间采购 function fetchGoodsGenerator(time, action) { // 用延时模拟采购时间 const timer = setTimeout(() =&gt; { clearTimeout(timer); // 采购完成，通知销售员 store.dispatch(action); }, time); } // 采购进口苹果需要 2 天（2s） function fetchImportedApple(action) { fetchGoodsGenerator(2000, action); } // 采购进口鸡蛋需要 3 天（3s） function fetchImportedEgg(action) { fetchGoodsGenerator(3000, action); } // 采购员 const API = { fetchImportedApple, // 采购进口苹果 fetchImportedEgg // 采购进口鸡蛋 } 好了，布置完了之后，顾客开始来买水果生鲜了： // 销售员开始销售，采购员开始采购 store.dispatch(buyApple(3)); API.fetchImportedApple(buyImportedApple(10)); store.dispatch(buyEgg(1)); API.fetchImportedEgg(buyImportedEgg(10)); store.dispatch(buyApple(4)); API.fetchImportedApple(buyImportedApple(10)); store.dispatch(buyEgg(8)); API.fetchImportedEgg(buyImportedEgg(10)); // {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:0,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:3,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:1,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:1,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:0},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:10},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:20},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:0}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:20},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:10}} // {&quot;fruit&quot;:{&quot;apple&quot;:7,&quot;importedApple&quot;:20},&quot;fresh&quot;:{&quot;egg&quot;:9,&quot;importedEgg&quot;:20}} 图解 在实际的开发当中我们经常会调用一些 API 接口获取数据更新 state。刚开始使用 redux 的一个误区就是在 reducer 里接收到异步的 action 之后，就在 reducer 里做异步操作，调用 API。但是这样是错误的。reducer 只能是纯函数，不能有任何副作用。这样才能保证对于相同的输入，一定会有相同的输出。 原文地址]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图片懒加载踩坑]]></title>
    <url>%2F2018%2F04%2F24%2F%E6%80%A7%E8%83%BD%2F%E5%9B%BE%E7%89%87%E6%87%92%E5%8A%A0%E8%BD%BD%E8%B8%A9%E5%9D%91%2F</url>
    <content type="text"><![CDATA[原理对网页加载速度影响最大的就是图片，一张普通的图片可能会有好几 M 的大小，当图片很多时，网页的加载速度变得很缓慢。为了优化网页性能以及用户体验，我们对图片进行懒加载。 懒加载是一种对网页性能优化的方式，它的原理是优先加载在可视区域内的图片，而不一次性加载所以图片。当浏览器滚动，图片进入可视区时再去加载图片。通过设置图片的 src 属性来让浏览器发起图片的请求。当这个属性为空或者没有时，就不会发送请求。 实现 懒加载的实现主要是判断当前图片是否到了可视区域这一核心逻辑。我们先来整理一下实现思路：1.拿到所有的图片 img dom 。2.遍历每个图片判断当前图片是否到了可视区范围内。3.如果到了就设置图片的 src 属性。4.绑定 window 的 scroll 事件，对其进行事件监听。 HTML 结构&lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;img-area&quot;&gt; &lt;img id=&quot;first&quot; data-src=&quot;./img/ceng.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt; &lt;img data-src=&quot;./img/data.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt; &lt;img data-src=&quot;./img/huaji.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt; &lt;img data-src=&quot;./img/liqi1.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt; &lt;img data-src=&quot;./img/liqi2.png&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;div class=&quot;img-area&quot;&gt; &lt;img data-src=&quot;./img/steve-jobs.jpg&quot; alt=&quot;&quot;&gt; &lt;/div&gt; &lt;/div&gt; 此时 img 标签是没有 src 属性的，我们把真实的图片地址放在一个属性里，这里我们使用 HTML5 的 data 属性，将真实地址放在自定义的 data-src 中。 判断图片是否进入了可视区域方法一第一种方法我们通过计算该图片距离 document 顶部的高度是否小于当前可视区域相对于 document 顶部高度来判断。 可视区域相对于 document 顶部高度的计算方法： const clientHeight = document.documentElement.clientHeight; // 视口高度，也就是窗口的高度。 const scrollHeight = document.documentElement.scrollTop + clientHeight; // 滚动条偏移文档顶部的高度（也就是文档从顶部开始到可视区域被抹去的高度） + 视口高度 画了一张图方便理解: 然后就是计算该图片距离文档顶部的高度。有两种方法，第一种方法是通过元素的 offsetTop 属性来计算。从上图我们了解到元素的 offsetTop 属性是相对于一个 position 为 非 static 的祖先元素，也就是 child.offsetParent 。同时需要将祖先元素的 border 考虑在内，我们通过child.offsetParent.clientTop可以拿到边框厚度。 由此我们得到元素距离文档顶部的高度的计算方法： function getTop(el, initVal) { let top = el.offsetTop + initVal; if (el.offsetParent !== null) { top += el.offsetParent.clientTop; return getTop(el.offsetParent, top); } else { return top; } } 这里的这个方法使用了 尾递归调用 。可以提高递归性能。当然这里也可以用循环来实现： function getTop(el) { let top = el.offsetTop; var parent = el.offsetParent; while(parent !== null) { top += parent.offsetTop + parent.clientTop; parent = parent.offsetParent; } return top; } 第二种方法是使用 element.getBoundingClientRect() API 直接得到 top 值。 var first = document.getElementById(&#39;first&#39;); getTop(first, 0); // 130 console.log(first.getBoundingClientRect().top); // 130 于是我们得到判断方法： function inSight(el) { const clientHeight = document.documentElement.clientHeight; const scrollHeight = document.documentElement.scrollTop + clientHeight; // 方法一 return getTop(el, 0) &lt; scrollHeight; // 方法二 // return el.getBoundingClientRect().top &lt; clientHeight; } 接下来就是对每个图片进行判断和赋值。 function loadImg(el) { if (!el.src) { el.src = el.dataset.src; } } function checkImgs() { const imgs = document.getElementsByTagName(&#39;img&#39;); Array.from(imgs).forEach(el =&gt; { if (inSight(el)) { loadImg(el); } }) console.log(count++); } 最后给 window 绑定 onscroll 事件以及 onload 事件： window.addEventListener(&#39;scroll&#39;, checkImgs, false); window.onload = checkImgs; 我们知道类似 scroll 或 resize 这样的事件浏览器可能在很短的时间内触发很多次，为了提高网页性能，我们需要一个节流函数来控制函数的多次触发，在一段时间内（如 500ms）只执行一次回调。 /** * 持续触发事件，每隔一段时间，只执行一次事件。 * @param fun 要执行的函数 * @param delay 延迟时间 * @param time 在 time 时间内必须执行一次 */ function throttle(fun, delay, time) { var timeout; var previous = +new Date(); return function () { var now = +new Date(); var context = this; var args = arguments; clearTimeout(timeout); if (now - previous &gt;= time) { fun.apply(context, args); previous = now; } else { timeout = setTimeout(function () { fun.apply(context, args); }, delay); } } } window.addEventListener(&#39;scroll&#39;, throttle(checkImgs, 200, 1000), false); 方法二HTML5 有一个新的 IntersectionObserver API，它可以自动观察元素是否可见。 主要用法： var observer = new IntersectionObserver(callback, option); // 开始观察 observer.observe(document.getElementById(&#39;first&#39;)); // 停止观察 observer.unobserve(document.getElementById(&#39;first&#39;)); // 关闭观察器 observer.disconnect(); 目标的可见性发生变化时就会调用观察器的 callback。 function callback(changes: IntersectionObserverEntry[]) { console.log(changes[0]) } // IntersectionObserverEntry { time: 29.499999713152647, intersectionRatio: 1, boundingClientRect: DOMRectReadOnly { bottom: 144, height: 4, left: 289, right: 293, top: 140, width: 4, x: 289, y: 140 }, intersectionRect: DOMRectReadOnly, isIntersecting: true, rootBounds: DOMRectReadOnly, target: img#first } 详细释义：time： 可见性发生变化的时间，是一个高精度时间戳，单位为毫秒intersectionRatio： 目标元素的可见比例，即 intersectionRect 占 boundingClientRect 的比例，完全可见时为 1 ，完全不可见时小于等于 0boundingClientRect： 目标元素的矩形区域的信息intersectionRect： 目标元素与视口（或根元素）的交叉区域的信息rootBounds： 根元素的矩形区域的信息，getBoundingClientRect() 方法的返回值，如果没有根元素（即直接相对于视口滚动），则返回 nullisIntersecting： 是否进入了视口，boolean 值target： 被观察的目标元素，是一个 DOM 节点对象 使用 IntersectionObserver 实现图片懒加载： function query(tag) { return Array.from(document.getElementsByTagName(tag)); } var observer = new IntersectionObserver( (changes) =&gt; { changes.forEach((change) =&gt; { if (change.intersectionRatio &gt; 0) { var img = change.target; img.src = img.dataset.src; observer.unobserve(img); } }) } ) query(&#39;img&#39;).forEach((item) =&gt; { observer.observe(item); }) 原文地址]]></content>
      <tags>
        <tag>性能</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WEB前端开发人员须知的常见浏览器兼容问题及解决技巧]]></title>
    <url>%2F2018%2F04%2F23%2F%E6%80%A7%E8%83%BD%2FWEB%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E4%BA%BA%E5%91%98%E9%A1%BB%E7%9F%A5%E7%9A%84%E5%B8%B8%E8%A7%81%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%E9%97%AE%E9%A2%98%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[为什么会有兼容问题？由于市场上浏览器种类众多，而不同浏览器其内核亦不尽相同，所以各个浏览器对网页的解析就有一定出入，这也是导致浏览器兼容问题出现的主要原因，我们的网页需要在主流浏览器上正常运行，就需要做好浏览器兼容。 使用Trident内核的浏览器：IE、Maxthon、TT； 使用Gecko内核的浏览器：Netcape6及以上版本、FireFox； 使用Presto内核的浏览器：Opera7及以上版本； 使用Webkit内核的浏览器：Safari、Chrome。 而我现在所说的兼容性问题，主要是说IE与几个主流浏览器如firefox，google等。而对IE浏览器来说，IE7又是个跨度，因为之前的版本更新甚慢，bug甚多。从IE8开始，IE浏览器渐渐遵循标准，到IE9后由于大家都一致认为标准很重要，可以说在兼容性上比较好了，但是在中国来说，由于xp的占有率问题，使用IE7以下的用户仍然很多，所以我们不得不考虑低版本浏览器的兼容。 对浏览器兼容问题，一般分，HTML，Javascript兼容，CSS兼容。 其中html相关问题比较容易处理，无非是高版本浏览器用了低版本浏览器无法识别的元素，导致其不能解析，所以平时注意一点就是。特别是HTML5增加了许多新标签，低版本浏览器有点影响时代进步啊 问题一：不同浏览器的标签默认的外边距和内边距不同问题症状：随便写几个标签，不加样式控制的情况下，各自的margin 和padding差异较大。碰到频率:100%解决方案：css里 {margin:0;padding:0;}备注：这个是最常见的也是最易解决的一个浏览器兼容性问题，几乎所有的css文件开头都会用通配符来设置各个标签的内外补丁是0。 问题二：块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大问题症状:常见症状是ie6中后面的一块被顶到下一行碰到频率：90%（稍微复杂点的页面都会碰到，float布局最常见的浏览器兼容问题）解决方案：在float的标签样式控制中加入 display:inline;将其转化为行内属性备注：我们最常用的就是div+css布局了，而div就是一个典型的块属性标签，横向布局的时候我们通常都是用div float实现的，横向的间距设置如果用margin实现，这就是一个必然会碰到的兼容性问题。 问题三：设置较小高度标签（一般小于10px），在ie6，ie7，遨游中高度超出自己设置高度问题症状：ie6、7和遨游里这个标签的高度不受控制，超出自己设置的高度碰到频率：60%解决方案：给超出高度的标签设置overflow:hidden;或者设置行高line-height 小于你设置的高度。备注：这种情况一般出现在我们设置小圆角背景的标签里。出现这个问题的原因是ie8之前的浏览器都会给标签一个最小默认的行高的高度。即使你的标签是空的，这个标签的高度还是会达到默认的行高。 问题四：行内属性标签，设置display:block后采用float布局，又有横行的margin的情况，ie6间距bug（类似第二种）问题症状：ie6里的间距比超过设置的间距碰到几率：20%解决方案：在display:block;后面加入display:inline;display:table;备注：行内属性标签，为了设置宽高，我们需要设置display:block;(除了input标签比较特殊)。在用float布局并有横向的margin后，在ie6下，他就具有了块属性float后的横向margin的bug。不过因为它本身就是行内属性标签，所以我们再加上display:inline的话，它的高宽就不可设了。这时候我们还需要在display:inline后面加入display:talbe。 图片默认有间距问题症状：几个img标签放在一起的时候，有些浏览器会有默认的间距，加上问题一中提到的通配符也不起作用。碰到几率：20%解决方案：使用float属性为img布局备注：因为img标签是行内属性标签，所以只要不超出容器宽度，img标签都会排在一行里，但是部分浏览器的img标签之间会有个间距。去掉这个间距使用float是正道 标签最低高度设置min-height不兼容问题症状：因为min-height本身就是一个不兼容的css属性，所以设置min-height时不能很好的被各个浏览器兼容碰到几率：5%解决方案：如果我们要设置一个标签的最小高度200px，需要进行的设置为：{min-height:200px; height:auto !important; height:200px; overflow:visible;}备注：在B/S系统前端开时，有很多情况下我们有这种需求。当内容小于一个值（如300px）时。容器的高度为300px；当内容高度大于这个值时，容器高度被撑高，而不是出现滚动条。这时候我们就会面临这个兼容性问题。 问题七：透明度的兼容css设置方法是：每写一小段代码（布局中的一行或者一块）我们都要在不同的浏览器中看是否兼容，当然熟练到一定的程度就没这么麻烦了。建议经常会碰到兼容性问题的新手使用。很多兼容性问题都是因为浏览器对标签的默认属性解析不同造成的，只要我们稍加设置都能轻松地解决这些兼容问题。如果我们熟悉标签的默认属性的话，就能很好的理解为什么会出现兼容问题以及怎么去解决这些兼容问题。 技巧一：css hack使用hacker 我可以把浏览器分为3类：ie6 ；ie7和遨游；其他（ie8 chrome ff safari opera等） ie6认识的hacker 是下划线_ 和星号 ie7 遨游认识的hacker是星号 （包括上面问题6中的 !important也算是hack的一种。不过实用性较小。） 因为优先级相同且相冲突的属性设置后一个会覆盖掉前一个，所以书写的次序是很重要的。 越少的浮动，就会越少的代码，会有更灵活的页面，会有扩展性更强的页面。这不多说，归结为到一定水平了，浮动会用的较少。另外，您也会避免使用浮动+margin的用法。所以，越后来越不易遇到这种bug。 技巧二：padding，marign，height，width注意是技巧，不是方法： 写好标准头 http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd”&gt; http://www.w3.org/1999/xhtml”&gt; 尽量用padding，慎用margin，height尽量补上100%，父级height有定值子级height不用100%，子级全为浮动时底部补个空clear:both的div宽尽量用margin，慎用padding，width算准实际要的减去padding 技巧三：显示类（display:block,inline）display:block,inline两个元素 display:block; //可以为内嵌元素模拟为块元素 display:inline; //实现同一行排列的的效果 display:table; //for FF,模拟table的效果 技巧四：怎样使一个div层居中于浏览器中？&lt;style type=&quot;text/css&quot;&gt; div { position:absolute; top:50%; left:50%; margin:-100px 0 0 -100px; width:200px; height:200px; border:1px solid red; } &lt;/style&gt; 2）div里的内容，IE默认为居中，而FF默认为左对齐，可以尝试增加代码margin: 0 auto; 技巧五：float的div闭合;清除浮动;自适应高度① 例如：＜div id=”floatA”&gt;＜div id=”floatB”&gt;＜div id=”NOTfloatC”&gt; ②作为外部 wrapper 的 div 不要定死高度,为了让高度能自适应，要在wrapper里面加上overflow:hidden; 当包含float的box的时候，高度自适应在IE下无效，这时候应该触发IE的layout私有属性(万恶的IE啊！)用zoom:1;可以做到，这样就达到了兼容。 ③对于排版,我们用得最多的css描述可能就是float:left.有的时候我们需要在n栏的float div后面做一个统一的背景, ④万能float 闭合(非常重要!) 关于 clear float 的原理可参见 [How To ClearFloats Without Structural Markup],将以下代码加入Global CSS 中,给需要闭合的div加上class=”clearfix”即可,屡试不爽。 html5shiv.js解决 ie9 以下浏览器对 html5 新增标签不识别的问题。 &lt;!--[if lt IE 9]&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/html5shiv/3.7.3/html5shiv.min.js&quot;&gt;&lt;/script&gt; &lt;![endif]--&gt; BFC 解决边距重叠问题当相邻元素都设置了 margin 边距时，margin 将取最大值，舍弃小值。为了不让边距重叠，可以给子元素加一个父元素，并设置该父元素为 BFC：overflow: hidden; IE6 双倍边距的问题设置 ie6 中设置浮动，同时又设置 margin，会出现双倍边距的问题display: inline; 解决 IE9 以下浏览器不能使用 opacityopacity: 0.5;filter: alpha(opacity = 50);filter: progid:DXImageTransform.Microsoft.Alpha(style = 0, opacity = 50); 解决 IE6 不支持 fixed 绝对定位以及IE6下被绝对定位的元素在滚动的时候会闪动的问题/* IE6 hack */ *html, *html body { background-image: url(about:blank); background-attachment: fixed; } *html #menu { position: absolute; top: expression(((e=document.documentElement.scrollTop) ? e : document.body.scrollTop) + 100 + &#39;px&#39;); } IE6 背景闪烁的问题问题：链接、按钮用 CSSsprites 作为背景，在 ie6 下会有背景图闪烁的现象。原因是 IE6 没有将背景图缓存，每次触发 hover 的时候都会重新加载 解决：可以用 JavaScript 设置 ie6 缓存这些图片： document.execCommand(&quot;BackgroundImageCache&quot;, false, true); 解决在 IE6 下，列表与日期错位的问题日期span 标签放在标题 a 标签之前即可 解决 IE6 不支持 min-height 属性的问题min-height: 350px;_height: 350px; 让 IE7 IE8 支持 CSS3 background-size属性html { height: 100%; } body { height: 100%; margin: 0; padding: 0; background-image: url(&#39;img/37.png&#39;); background-repeat: no-repeat; background-size: cover; -ms-behavior: url(&#39;css/backgroundsize.min.htc&#39;); behavior: url(&#39;css/backgroundsize.min.htc&#39;); } IE6-7 line-height 失效的问题问题：在ie 中 img 与文字放一起时，line-height 不起作用 解决：都设置成 float td 自动换行的问题问题：table 宽度固定，td 自动换行 解决：设置 Table 为 table-layout: fixed，td 为 word-wrap: break-word 键盘事件 keyCode 兼容性写法var inp = document.getElementById(&#39;inp&#39;) var result = document.getElementById(&#39;result&#39;) function getKeyCode(e) { e = e ? e : (window.event ? window.event : &quot;&quot;) return e.keyCode ? e.keyCode : e.which } inp.onkeypress = function(e) { result.innerHTML = getKeyCode(e) } 求窗口大小的兼容写法// 浏览器窗口可视区域大小（不包括工具栏和滚动条等边线） // 1600 * 525 var client_w = document.documentElement.clientWidth || document.body.clientWidth; var client_h = document.documentElement.clientHeight || document.body.clientHeight; // 网页内容实际宽高（包括工具栏和滚动条等边线） // 1600 * 8 var scroll_w = document.documentElement.scrollWidth || document.body.scrollWidth; var scroll_h = document.documentElement.scrollHeight || document.body.scrollHeight; // 网页内容实际宽高 (不包括工具栏和滚动条等边线） // 1600 * 8 var offset_w = document.documentElement.offsetWidth || document.body.offsetWidth; var offset_h = document.documentElement.offsetHeight || document.body.offsetHeight; // 滚动的高度 var scroll_Top = document.documentElement.scrollTop||document.body.scrollTop;]]></content>
      <categories>
        <category>兼容性</category>
      </categories>
      <tags>
        <tag>浏览器兼容性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每个 JavaScript 工程师都应当知道的 10 个面试题]]></title>
    <url>%2F2018%2F04%2F23%2FInterview%2F%E6%AF%8F%E4%B8%AA-JavaScript-%E5%B7%A5%E7%A8%8B%E5%B8%88%E9%83%BD%E5%BA%94%E5%BD%93%E7%9F%A5%E9%81%93%E7%9A%84-10-%E4%B8%AA%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[能说出来两种对于 JavaScript 工程师很重要的编程范式么？JavaScript 是一门多范式（multi-paradigm）的编程语言，它既支持命令式（imperative）/面向过程（procedural）编程，也支持面向对象编程（OOP，Object-Oriented Programming），还支持函数式编程（functional programming）。JavaScript 所支持的面向对象编程包括原型继承（prototypal inheritance）。 面试加分项 原型继承（即：原型，OLOO——链接到其它对象的对象）； 函数式编程（即：闭包（closure），一类函数（first class functions），lambda 函数：箭头函数）。 面试减分项 连范式都不知道，更别提什么原型 OO（prototypal oo）或者函数式编程了。 深入了解The Two Pillars of JavaScript Part 1：JS 两大支柱之一：原型 OOThe Two Pillars of JavaScript Part 2：JS 两大支柱之二：函数式编程 什么是函数编程函数式编程，是将数学函数组合起来，并且避免了状态共享（shared state）及可变数据（mutable data），由此而产生的编程语言。发明于 1958 年的 Lisp 就是首批支持函数式编程的语言之一，而 λ 演算（lambda calculus）则可以说是孕育了这门语言。即使在今天，Lisp 这个家族的编程语言应用范围依然很广。 函数式编程可是 JavaScript 语言中非常重要的一个概念（它可是 JavaScript 的两大支柱之一）。ES5 规范中就增加了很多常用的函数式工具。 面试加分项 纯函数（pure functions）/函数的纯粹性（function purity） 知道如何避免副作用（side-effects） 简单函数的组合 函数式编程语言：Lisp，ML，Haskell，Erlang，Clojure，Elm，F#，OCaml，等等 提到了 JavaScript 语言中支持函数式编程（FP）的特性：一类函数，高阶函数（higher order functions），作为参数（arguments）/值（values）的函数 面试减分项 没有提到纯函数，以及如何避免副作用 没有提供函数式编程语言的例子 没有说是 JavaScript 中的哪些特性使得函数式编程得以实现 深入了解The Two Pillars of JavaScript Part 2：JS 两大支柱之二：函数式编程 类继承和原型继承有什么区别？类继承（Class Inheritance）：实例（instances）由类继承而来（类和实例的关系，可以类比为建筑图纸和实际建筑 🏠 的关系），同时还会创建父类—子类这样一种关系，也叫做类的分层分类（hierarchical class taxonomies）。通常是用 new 关键字调用类的构造函数（constructor functions）来创建实例的。不过在 ES6 中，要继承一个类，不用 class 关键字也可以。 原型继承（Prototypal Inheritance）：实例/对象直接从其它对象继承而来，创建实例的话，往往用工厂函数（factory functions）或者 Object.create() 方法。实例可以从多个不同的对象组合而来，这样就能选择性地继承了。 在 JavaScript 中，原型继承比类继承更简单，也更灵活。 面试加分项 类：会创建紧密的耦合，或者说层级结构（hierarchies）/分类（taxonomies）。 原型：提到了衔接继承（concatenative inheritance）、原型委托（ prototype delegation）、函数继承（functional inheritance），以及对象组合（object composition）。 面试减分项 原型继承和组合，与类继承相比，不知道哪个更好。 函数式编程和面向对象编程，各有什么优点和不足呢？面向对象编程的优点：关于“对象”的一些基础概念理解起来比较容易，方法调用的含义也好解释。面向对象编程通常使用命令式的编码风格，声明式（declarative style）的用得比较少。这样的代码读起来，像是一组直接的、计算机很容易就能遵循的指令。 面向对象编程的不足：面向对象编程往往需要共享状态。对象及其行为常常会添加到同一个实体上，这样一来，如果一堆函数都要访问这个实体，而且这些函数的执行顺序不确定的话，很可能就会出乱子了，比如竞争条件（race conditions）这种现象（函数 A 依赖于实体的某个属性，但是在 A 访问属性之前，属性已经被函数 B 修改了，那么函数 A 在使用属性的时候，很可能就得不到预期的结果）。 函数式编程的优点：用函数式范式来编程，就不需要担心共享状态或者副作用了。这样就避免了几个函数在调用同一批资源时可能产生的 bug 了。拥有了“无参风格”（point-free style，也叫隐式编程）之类的特性之后，函数式编程就大大简化了，我们也可以用函数式编程的方式来把代码组合成复用性更强的代码了，面向对象编程可做不到这一点。 函数式编程更偏爱声明式、符号式（denotational style）的编码风格，这样的代码，并不是那种为了实现某种目的而需要按部就班地执行的一大堆指令，而是关注宏观上要做什么。至于具体应该怎么做，就都隐藏在函数内部了。这样一来，要是想重构代码、优化性能，那就大有可为了。（译者注：以做一道菜为例，就是由 买菜 -&gt; 洗菜 -&gt; 炒菜 这三步组成，每一步都是函数式编程的一个函数，不管做什么菜，这个流程都是不会变的。而想要优化这个过程，自然就是要深入每一步之中了。这样不管内部如何重构、优化，整体的流程并不会变，这就是函数式编程的好处。）甚至可以把一种算法换成另一种更高效的算法，同时还基本不需要修改代码（比如把及早求值策略（eager evaluation）替换为惰性求值策略（lazy evaluation））。 利用纯函数进行的计算，可以很方便地扩展到多处理器环境下，或者应用到分布式计算集群上，同时还不用担心线程资源冲突、竞争条件之类的问题。 函数式编程的不足：代码如果过度利用了函数式的编程特性（如无参风格、大量方法的组合），就会影响其可读性，从而简洁度有余、易读性不足。 大部分工程师还是更熟悉面向对象编程、命令式编程，对于刚接触函数式编程的人来说，即使只是这个领域的一些的简单术语，都可能让他怀疑人生。 函数式编程的学习曲线更陡峭，因为面向对象编程太普及了，学习资料太多了。相比而言，函数式编程在学术领域的应用更广泛一些，在工业界的应用稍逊一筹，自然也就不那么“平易近人”了。在探讨函数式编程时，人们往往用 λ 演算、代数、范畴学等学科的专业术语和专业符号来描述相关的概念，那么其他人想要入门函数式编程的话，就得先把这些领域的基础知识搞明白，能不让人头大么。 面试加分项 共享状态的缺点、资源竞争、等等（面向对象编程） 函数式编程能够极大地简化应用开发 面向对象编程和函数式编程学习曲线的不同 两种编程方式各自的不足之处，以及对代码后期维护带来的影响 函数式风格的代码库，学习曲线会很陡峭 面向对象编程风格的代码库，修改起来很难，很容易出问题（和水平相当的函数式风格的代码相比） 不可变性（immutability），能够极大地提升程序历史状态（program state history）的可见性（accessible）和扩展性（malleable），这样一来，想要添加诸如无限撤销/重做、倒带/回放、可后退的调试之类的功能的话，就简单多了。不管是面向对象编程还是函数式编程，这两种范式都能实现不可变性，但是要用面向对象来实现的话，共享状态对象的数量就会剧增，代码也会变得复杂很多。 面试减分项没有讲这两种编程范式的缺点——如果熟悉至少其中一种范式的话，应该能够说出很多这种范式的缺点吧。 什么时候该用类继承？千万别用类继承！或者说尽量别用。如果非要用，就只用它继承一级（one level）就好了，多级的类继承简直就是反模式的。这个话题（不太明白是关于什么的……）我也参与讨论过好些年了，仅有的一些回答最终也沦为 常见的误解 之一。更多的时候，这个话题讨论着讨论着就没动静了。 如果一个特性有时候很有用但有时候又很危险并且还有另一种更好的特性可以用那务必要用另一种更好的特性~ Douglas Crockford 面试加分项 尽量别用，甚至是彻底不用类继承。 有时候只继承一级的话也还是 OK 的，比如从框架的基类继承，例如 React.Component。 相比类继承，对象组合（object composition）更好一些。 什么时候该用原型继承？原型继承可以分为下面几类： 委托（delegation，也就是原型链） 组合（concatenative，比如混用（mixins）、Object.assign()） 函数式（functional，这个函数式原型继承不是函数式编程。这里的函数是用来创建一个闭包，以实现私有状态（private state）或者封装（encapsulation）） 上面这三种原型继承都有各自的适用场景，不过它们都很有用，因为都能实现组合继承（composition），也就是建立了 A 拥有特性 B（has-a）、A 用到了特性 B（uses-a） 或者 A 可以实现特性 B（can-do） 的这样一种关系。相比而言，类继承建立的是 A 就是 B 这样一种关系。 面试加分项 知道在什么情况下不适合用模块化（modules）或者函数式编程。 知道需要组合多个不同来源的对象时，应该怎么做。 知道什么时候该用继承。 面试减分项 不知道什么时候应该用原型。 不知道混用和 Object.assign()。 为什么说“对象组合比类继承更好”？这句话引用的是《设计花纹》（Design Patterns，设计模式）这本书的内容。意思是要想实现代码重用，就应该把一堆小的功能单元组合成满足需求的各种对象，而不是通过类继承弄出来一层一层的对象。 换句话说，就是尽量编程实现 can-do、has-a 或者 uses-a 这种关系，而不是 is-a 这种关系。 面试加分项 避免使用类继承。 避免使用问题多多的基类。 避免紧耦合。 避免极其不灵活的层次分类（taxonomy）（类继承所产生的 is-a 关系可能会导致很多误用的情况） 避免大猩猩香蕉问题（“你只是想要一根香蕉，结果最后却整出来一只拿着香蕉的大猩猩，还有整个丛林”）。 要让代码更具扩展性。 面试减分项 没有提到上面任何一种问题。 没有表达清楚对象组合与类继承有什么区别，也没有提到对象组合的优点。 双向数据绑定/单向数据流的含义和区别双向数据绑定（two-way data binding），意味着 UI 层所呈现的内容和 Model 层的数据动态地绑定在一起了，其中一个发生了变化，就会立刻反映在另一个上。比如用户在前端页面的表单控件中输入了一个值，Model 层对应该控件的变量就会立刻更新为用户所输入的值；反之亦然，如果 Modal 层的数据有变化，变化后的数据也会立刻反映至 UI 层。 单向数据流（one-way data flow）， 意味着只有 Model 层才是单一数据源（single source of truth）。UI 层的变化会触发对应的消息机制，告知 Model 层用户的目的（对应 React 的 store）。只有 Model 层才有更改应用状态的权限，这样一来，数据永远都是单向流动的，也就更容易了解应用的状态是如何变化的。 采用单向数据流的应用，其状态的变化是很容易跟踪的，采用双向数据绑定的应用，就很难跟踪并理解状态的变化了。 面试加分项 React 是单向数据流的典型，面试时提到这个框架的话会加分。Cycle.js 则是另一个很流行的单向数据流的库。 Angular 则是双向数据绑定的典型。 单体架构和微服务架构各有何优劣？采用单体架构（monolithic architecture）的应用，各组件的代码是作为一个整体存在的，组件之间互相合作，共享内存和资源。 而微服务架构（microservice architecture）则是由许许多多个互相独立的小应用组成，每个应用都有自己的内存空间，应用在扩容时也是独立于其它应用进行的。 单体架构的优势：大部分应用都有相当数量的横切关注点（cross-cutting concerns），比如日志记录，流量限制，还有审计跟踪和 DOS 防护等安全方面的需求，单体架构在这方面就很有优势。 当所有功能都运行在一个应用里的时候，就可以很方便地将组件与横切关注点相关联。 单体架构也有性能上的优势，毕竟访问共享内存还是比进程间通信（inter-process communication，IPC）要快的。 单体架构的劣势：随着单体架构应用功能的不断开发，各项服务之间的耦合程度也会不断增加，这样一来就很难把各项服务分离开来了，要做独立扩容或者代码维护也就更不方便了。 微服务的优势：微服务架构一般都有更好的组织结构，因为每项服务都有自己特定的分工，而且也不会干涉其它组件所负责的部分。服务解耦之后，想要重新组合、配置来为各个不同的应用提供服务的话，也更方便了（比如同时为 Web 客户端和公共 API 提供服务）。 如果用合理的架构来部署微服务的话，它在性能上也是很有优势的，因为这样一来，就可以很轻松地分离热门服务，对其进行扩容，同时还不会影响到应用中的其它部分。 微服务的劣势：在实际构建一个新的微服务架构的时候，会遇到很多在设计阶段没有预料到的横切关注点。如果是单体架构应用的话就很简单，新建一个中间件（shared magic helpers 不知道怎么翻译……）来解决这样的问题就行了，没什么麻烦的。 但是在微服务架构中就不一样了，要解决这个问题，要么为每个横切关注点都引入一个独立的模块，要么就把所有横切关注点的解决方案封装到一个服务层中，让所有流量都从这里走一遍就行了。 为了解决横切关注点的问题，虽然单体架构也趋向于把所有的路由流量都从一个外部服务层走一遍，但是在这种架构中，可以等到项目非常成熟之后再进行这种改造，这样就可以把还这笔技术债的时间尽量往后拖一拖。 微服务一般都是部署在虚拟机或容器上的，随着应用规模的不断增加，虚拟机抢工作（VM wrangling work）的情况也会迅速增加。任务的分配一般都是通过容器群（container fleet）管理工具来自动实现的。 面试加分项 对于微服务的积极态度，虽然初始成本会比单体架构要高一些。知道微服务的性能和扩容在长期看来表现更佳。 在微服务架构和单体架构应用上都有实战经验。能够使应用中的各项服务在代码层面互相独立，但是又可以在开发初期迅速地将各项服务打包成一整个的单体架构应用。微服务化的改造可以在应用相当成熟之后，改造成本在可承受范围内的时候再进行。 面试减分项 不知道单体架构和微服务架构的区别。 不知道微服务架构额外的开销，或者没有实际经验。 不知道微服务架构中，IPC 和网络通信所导致的额外的性能开销。 过分贬低微服务。说不清楚什么时候应该把单体架构应用解耦成微服务。 低估了可独立扩容的微服务的优势。 异步编程是什么？又为什么在 JavaScript 中这么重要？在同步编程中，代码会按顺序自顶向下依次执行（条件语句和函数调用除外），如果遇到网络请求或者磁盘读/写（I/O）这类耗时的任务，就会堵塞在这样的地方。 在异步编程中，JS 运行在事件循环（event loop）中。当需要执行一个阻塞操作（blocking operation）时，主线程发起一个（异步）请求，（工作线程就会去执行这个异步操作，）同时主线程继续执行后面的代码。（工作线程执行完毕之后，）就会发起响应，触发中断（interrupt），执行事件处理程序（event handler），执行完后主线程继续往后走。这样一来，一个程序线程就可以处理大量的并发操作了。 用户界面（user interface，UI）天然就是异步的，大部分时间它都在等待用户输入，从而中断事件循环，触发事件处理程序。 Node.js 默认是异步的，采用它构建的服务端和用户界面的执行机制差不多，在事件循环中等待网络请求，然后一个接一个地处理这些请求。 异步在 JavaScript 中非常重要，因为它既适合编写 UI，在服务端也有上佳的性能表现。 面试加分项 理解阻塞的含义，以及对性能带来的影响。 理解事件处理程序，以及它为什么对 UI 部分的代码很重要。 面试减分项不熟悉同步、异步的概念。讲不清楚异步代码和 UI 代码的性能影响，也说不明白它俩之间的关系。 原文地址]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端工程精粹（一）：静态资源版本更新与缓存]]></title>
    <url>%2F2018%2F04%2F22%2F%E6%80%A7%E8%83%BD%2F%E5%89%8D%E7%AB%AF%E5%B7%A5%E7%A8%8B%E7%B2%BE%E7%B2%B9%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9A%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E7%89%88%E6%9C%AC%E6%9B%B4%E6%96%B0%E4%B8%8E%E7%BC%93%E5%AD%98%2F</url>
    <content type="text"><![CDATA[每个参与过开发企业级web应用的前端工程师或许都曾思考过前端性能优化方面的问题。我们有雅虎14条性能优化原则，还有两本很经典的性能优化指导书：《高性能网站建设指南》、《高性能网站建设进阶指南》。经验丰富的工程师对于前端性能优化方法耳濡目染，基本都能一一列举出来。这些性能优化原则大概是在7年前提出的，对于web性能优化至今都有非常重要的指导意义。 然而，对于构建大型web应用的团队来说，要坚持贯彻这些优化原则并不是一件十分容易的事。因为优化原则中很多要求是与工程管理相违背的，比如“把css放在头部”和“把js放在尾部”这两条原则，我们不能让团队的工程师在写样式和脚本引用的时候都去修改一个相同的页面文件。这样做会严重影响团队成员间并行开发的效率，尤其是在团队有版本管理的情况下，每天要花大量的时间进行代码修改合并，这项成本是难以接受的。因此在前端工程界，总会看到周期性的性能优化工作，辛勤的前端工程师们每到月圆之夜就会倾巢出动根据优化原则做一次性能优化。 本文从一个全新的视角来思考web性能优化与前端工程之间的关系，通过解读百度前端集成解决方案小组（F.I.S）在打造高性能前端架构并统一百度40多条前端产品线的过程中所经历的技术尝试，揭示前端性能优化在前端架构及开发工具设计层面的实现思路。 性能优化原则及分类笔者先假设本文的读者是有前端开发经验的工程师，并对企业级web应用开发及性能优化有一定的思考，因此我不会重复介绍雅虎14条性能优化原则。如果您没有这些前续知识，请移步这里来学习。 首先，我们把雅虎14条优化原则，《高性能网站建设指南》以及《高性能网站建设进阶指南》中提到的优化点做一次梳理，按照优化方向分类，可以得到这样一张表格： 优化方向 优化手段 请求数量 合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域 请求带宽 启GZip，精简JavaScript，移除重复脚本，图像优化 缓存利用 使用CDN，使用外部JavaScript和CSS，添加Expires头，减少DNS查找，配置ETag，使AjaX可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 代码校验 避免CSS表达式，避免重定向 表格1 性能优化原则分类 目前大多数前端团队可以利用yui compressor或者google closure compiler等压缩工具很容易做到“精简Javascript”这条原则； 同样的，也可以使用图片压缩工具对图像进行压缩，实现“图像优化”原则。这两条原则是对单个资源的处理，因此不会引起任何工程方面的问题。 很多团队也通过引入代码校验流程来确保实现“避免css表达式”和“避免重定向”原则。 目前绝大多数互联网公司也已经开启了服务端的Gzip压缩，并使用CDN实现静态资源的缓存和快速访问； 一些技术实力雄厚的前端团队甚至研发出了自动CSS Sprites工具，解决了CSS Sprites在工程维护方面的难题。 使用“查找-替换”思路，我们似乎也可以很好的实现“划分主域”原则。 我们把以上这些已经成熟应用到实际生产中的优化手段去除掉，留下那些还没有很好实现的优化原则。再来回顾一下之前的性能优化分类： 优化方向 优化手段 请求数量 合并脚本和样式表，拆分初始化负载 请求带宽 移除重复脚本 缓存利用 添加Expires头，配置ETag，使Ajax可缓存 页面结构 将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出 表格2 较难实现的优化原则 现在有很多顶尖的前端团队可以将上述还剩下的优化原则也都一一解决，但业界大多数团队都还没能很好的解决这些问题。因此，本文将就这些原则的解决方案做进一步的分析与讲解，从而为那些还没有进入前端工业化开发的团队提供一些基础技术建设意见，也借此机会与业界顶尖的前端团队在工业化工程化方向上交流一下彼此的心得。 静态资源版本更新与缓存如表格2所示，“缓存利用”分类中保留了“添加Expires头”和“配置ETag”两项。或许有些人会质疑，明明这两项只要配置了服务器的相关选项就可以实现，为什么说它们难以解决呢？确实，开启这两项很容易，但开启了缓存后，我们的项目就开始面临另一个挑战：如何更新这些缓存。 相信大多数团队也找到了类似的答案，它和《高性能网站建设指南》关于“添加Expires头”所说的原则一样——修订文件名。即： 最有效的解决方案是修改其所有链接，这样，全新的请求将从原始服务器下载最新的内容。 思路没错，但要怎么改变链接呢？变成什么样的链接才能有效更新缓存，又能最大限度避免那些没有修改过的文件缓存不失效呢？ 先来看看现在一般前端团队的做法： &lt;script scr = &quot;a.js?t=202131&quot;&gt;&lt;/script&gt; 或者 &lt;script src = &quot;a.js?v=1.0.0&quot;&gt;&lt;/script&gt; 大家会采用添加query的形式修改链接。这样做是比较直观的解决方案，但在访问量较大的网站，这么做可能将面临一些新的问题。 通常一个大型的web应用几乎每天都会有迭代和更新，发布新版本也就是发布新的静态资源和页面的过程。以上述代码为例，假设现在线上运行着index.html文件，并且使用了线上的a.js资源。index.html的内容为： &lt;script src = &quot;a.js?v=1.0.0&quot;&gt;&lt;/script&gt; 这次我们更新了页面中的一些内容，得到一个index.html文件，并开发了新的与之匹配的a.js资源来完成页面交互，新的index.html文件的内容因此而变成了 &lt;script src = &quot;a.js?v=1.0.1&quot;&gt;&lt;/script&gt; 好了，现在要开始将两份新的文件发布到线上去。可以看到，index.html和a.js的资源实际上是要覆盖线上的同名文件的。不管怎样，在发布的过程中，index.html和a.js总有一个先后的顺序，从而中间出现一段或大或小的时间间隔。对于一个大型互联网应用来说即使在一个很小的时间间隔内，都有可能出现新用户访问。在这个时间间隔中，访问了网站的用户会发生什么情况呢？ 1.如果先覆盖index.html，后覆盖a.js，用户在这个时间间隙访问，会得到新的index.html配合旧的a.js的情况，从而出现错误的页面。2.如果先覆盖a.js，后覆盖index.html，用户在这个间隙访问，会得到旧的index.html配合新的a.js的情况，从而也出现了错误的页面。 这就是为什么大型web应用在版本上线的过程中经常会较集中的出现前端报错日志的原因，也是一些互联网公司选择加班到半夜等待访问低峰期再上线的原因之一。此外，由于静态资源文件版本更新是“覆盖式”的，而页面需要通过修改query来更新，对于使用CDN缓存的web产品来说，还可能面临CDN缓存攻击的问题。我们再来观察一下前面说的版本更新手段： &lt;script src = &quot;a.js?v=1.0.0&quot;&gt;&lt;/script&gt; 我们不难预测，a.js的下一个版本是“1.0.1”，那么就可以刻意构造一串这样的请求“a.js?v=1.0.1”、“a.js?v=1.0.2”、……让CDN将当前的资源缓存为“未来的版本”。这样当这个页面所用的资源有更新时，即使更改了链接地址，也会因为CDN的原因返回给用户旧版本的静态资源，从而造成页面错误。即便不是刻意制造的攻击，在上线间隙出现访问也可能导致区域性的CDN缓存错误。 此外，当版本有更新时，修改所有引用链接也是一件与工程管理相悖的事，至少我们需要一个可以“查找-替换”的工具来自动化的解决版本号修改的问题。 对付这个问题，目前来说最优方案就是基于文件内容的hash版本冗余机制了。也就是说，我们希望工程师源码是这么写的： &lt;script src = &quot;a.js?v=1.0.0&quot;&gt;&lt;/script&gt; 但是线上代码是这样的 &lt;script src = &quot;a_2131e3.js&quot;&gt;&lt;/script&gt; 其中”_82244e91”这串字符是根据a.js的文件内容进行hash运算得到的，只有文件内容发生变化了才会有更改。由于版本序列是与文件名写在一起的，而不是同名文件覆盖，因此不会出现上述说的那些问题。同时，这么做还有其他的好处： 1.线上的a.js不是同名文件覆盖，而是文件名+hash的冗余，所以可以先上线静态资源，再上线html页面，不存在间隙问题；2.遇到问题回滚版本的时候，无需回滚a.js，只须回滚页面即可；3.由于静态资源版本号是文件内容的hash，因此所有静态资源可以开启永久强缓存，只有更新了内容的文件才会缓存失效，缓存利用率大增；4.修改静态资源后会在线上产生新的文件，一个文件对应一个版本，因此不会受到构造CDN缓存形式的攻击 虽然这种方案是相比之下最完美的解决方案，但它无法通过手工的形式来维护，因为要依靠手工的形式来计算和替换hash值，并生成相应的文件。这将是一项非常繁琐且容易出错的工作，因此我们需要借助工具。(webpack,gulp等) 原文地址]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你不知道的JSON.parse()和JSON.stringify()高级技巧]]></title>
    <url>%2F2018%2F04%2F20%2FJs%2F%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84JSON-parse-%E5%92%8CJSON-stringify-%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[前言JSON对象的两个方法：JSON.parse() 和 JSON.stringify() 通常用做JSON对象和字符串之间的相互转换; JSON.parse()JSON.parse() 可以接受第二个参数，它可以在返回之前转换对象值。比如这例子中，将返回对象的属性值大写： const user = { name: &#39;John&#39;, email: &#39;john@awesome.com&#39;, plan: &#39;Pro&#39; }; const userStr = JSON.stringify(user); const newUserStr = JSON.parse(userStr, (key, value) =&gt; { if (typeof value === &#39;string&#39;) { return value.toUpperCase(); } return value; }); console.log(newUserStr); //{name: &quot;JOHN&quot;, email: &quot;JOHN@AWESOME.COM&quot;, plan: &quot;PRO&quot;} 注：尾随逗号在JSON 中无效，所以如果传递给它的字符串有尾随逗号，JSON.parse()将会抛出错误。 JSON.stringify()JSON.stringify() 可以带两个额外的参数，第一个是替换函数，第二个间隔字符串，用作隔开返回字符串。 参数： value ： 将要转为JSON字符串的javascript对象。 replacer ：该参数可以是多种类型,如果是一个函数,则它可以改变一个javascript对象在字符串化过程中的行为, 如果是一个包含 String 和 Number 对象的数组,则它将作为一个白名单.只有那些键存在域该白名单中的键值对才会被包含进最终生成的JSON字符串中.如果该参数值为null或者被省略,则所有的键值对都会被包含进最终生成的JSON字符串中。 space ：该参数可以是一个 String 或 Number 对象,作用是为了在输出的JSON字符串中插入空白符来增强可读性. 如果是Number对象, 则表示用多少个空格来作为空白符; 最大可为10,大于10的数值也取10.最小可为1,小于1的数值无效,则不会显示空白符. 如果是个 String对象, 则该字符串本身会作为空白符,字符串最长可为10个字符.超过的话会截取前十个字符. 如果该参数被省略 (或者为null), 则不会显示空白符 替换函数可以用来过滤值，因为任何返回 undefined 的值将不在返回的字符串中： const user = { id: 229, name: &#39;John&#39;, email: &#39;john@awesome.com&#39; }; function replacer(key, value) { console.log(typeof value); if (key === &#39;email&#39;) { return undefined; } return value; } const userStr = JSON.stringify(user, replacer); // &quot;{&quot;id&quot;:229,&quot;name&quot;:&quot;John&quot;}&quot; 传入一个间隔参数的示例： const user = { name: &#39;John&#39;, email: &#39;john@awesome.com&#39;, plan: &#39;Pro&#39; }; const userStr = JSON.stringify(user, null, &#39;...&#39;); // &quot;{ // ...&quot;name&quot;: &quot;John&quot;, // ...&quot;email&quot;: &quot;john@awesome.com&quot;, // ...&quot;plan&quot;: &quot;Pro&quot; // }&quot; toJSON方法如果一个被序列化的对象拥有 toJSON 方法，那么该 toJSON 方法就会覆盖该对象默认的序列化行为：不是那个对象被序列化，而是调用 toJSON 方法后的返回值会被序列化 var obj = { foo: &#39;foo&#39;, toJSON:function(){ return &#39;bar&#39;; } } JSON.stringify(obj);//&#39;&quot;bar&quot;&#39; JSON.stringify({x:obj});//&#39;{&quot;x&quot;:&quot;bar&quot;}&#39; 利用toJSON方法,我们可以修改对象转换成JSON的默认行为。 用 JSON.stringify 来格式化对象在实际使用中,我们可能会格式化一些复杂的对象，这些对象往往对象内嵌套对象。直接看起来并不那么直观,结合上面的的 replacer 和 space 参数,我们可以这样格式化复杂对象： var censor = function(key,value){ if(typeof(value) == &#39;function&#39;){ return Function.prototype.toString.call(value) } return value; } var foo = {bar:&quot;1&quot;,baz:3,o:{name:&#39;xiaoli&#39;,age:21,info:{sex:&#39;男&#39;,getSex:function(){return &#39;sex&#39;;}}}}; console.log(JSON.stringify(foo,censor,4)) 实际返回的字符串，记住是字符串，如下: { &quot;bar&quot;: &quot;1&quot;, &quot;baz&quot;: 3, &quot;o&quot;: { &quot;name&quot;: &quot;xiaoli&quot;, &quot;age&quot;: 21, &quot;info&quot;: { &quot;sex&quot;: &quot;男&quot;, &quot;getSex&quot;: &quot;function (){return &#39;sex&#39;;}&quot; } } }]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端代码规范-JS篇]]></title>
    <url>%2F2018%2F04%2F19%2FRecord%2F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-JS%E7%AF%87%2F</url>
    <content type="text"><![CDATA[更多前端代码规范请移步 如果是个人或者小作坊开发，其实这些所谓的编码规范也没啥意思，因为大家写好的代码直接就给扔到网上去了，很少有打包、压缩、校检等过程，别人来修改你代码的情况也比较少。但是，对于一定规模的团队来说，这些东西还是挺有必要的！一个是保持代码的整洁美观，同时良好的代码编写格式和注释方式可以让后来者很快地了解你代码的大概思路，提高开发效率。 不规范写法举例 句尾没有分号var isHotel = json.type == &quot;hotel&quot; ? true : false 变量命名各种各样var is_hotel; var isHotel; var ishotel; if 缩写if (isHotel) console.log(true) else console.log(false) 使用 evalvar json = eval(jsonText); 变量未定义到处都是 function() { var isHotel = &#39;true&#39;; ....... var html = isHotel ? &#39;&lt;p&gt;hotel&lt;/p&gt;&#39; : &quot;&quot;; } 超长函数function() { var isHotel = &#39;true&#39;; //....... 此处省略500行 return false; } 前端规范之JavaScript变量、常量、类的命名按（必须）以下规则执行： 1） 变量：必须采用骆驼峰的命名且首字母小写 // 正确的命名 var isHotel, isHotelBeijing, isHotelBeijingHandian; // 不推荐的命名 var is_Hotel, ishotelbeijing, IsHotelBeiJing; 2） 常量：必须采用全大写的命名，且单词以_分割，常量通常用于ajax请求url，和一些不会改变的数据 // 正确的命名 var HOTEL_GET_URL = &#39;http://map.baidu.com/detail&#39;, PLACE_TYPE = &#39;hotel&#39;; 3） 类：必须采用骆驼峰的命名且首字母大写，如： // 正确的写法 var FooAndToo = function(name) { this.name = name; } if中的空格，先上例子 //正确的写法 if (isOk) { console.log(&quot;ok&quot;); } //不推荐的写法 if(isOk){ console.log(&quot;ok&quot;); } ()中的判断条件前后都(必须)加空格 ()里的判断前后(禁止)加空格，如：正确的写法: if (isOk)；不推荐的写法: if ( isOk ) 2）switch中的空格, 先上例子 //正确的写法 switch(name) { case &quot;hotel&quot;: console.log(name); break; case &quot;moive&quot;: console.log(name); break; default: // code } for中的空格，先上例子 // 正确的写法 var names = [&quot;hotel&quot;, &quot;movie&quot;], i, len; for (i=0, len=names.length; i &lt; len; i++) { // code } for后（必须）加空格 每个;后（必须）加空格 ()中禁止用var声明变量; 且变量的赋值 = 前后（禁止）加空格 function 中的空格, 先上例子 // 正确的写法 function call(name) { } var cell = function () { }; 参数的反括号后（必须）加空格 function 后（必须）加空格 var 中空格及定义，先上例子// 一个推荐的var写法组 function(res) { var code = 1 + 1, json = JSON.parse(res), type, html; // code } 声明变量 = 前后（必须）添加空格 每个变量的赋值声明以,结束后（必须）换行进行下一个变量赋值声明（推荐）将所有不需要进行赋值的变量声明放置最后一行，且变量之间不需要换行 （推荐）当一组变量声明完成后，空一行后编写其余代码 在同一个函数内部，局部变量的声明必须置于顶端因为即使放到中间，js解析器也会提升至顶部（hosting） // 正确的书写 var clear = function(el) { var id = el.id, name = el.getAttribute(&quot;data-name&quot;); ......... return true; } // 不推荐的书写 var clear = function(el) { var id = el.id; ...... var name = el.getAttribute(&quot;data-name&quot;); ......... return true; } 块内函数必须用局部变量声明// 错误的写法 var call = function(name) { if (name == &quot;hotel&quot;) { function foo() { console.log(&quot;hotel foo&quot;); } } foo &amp;&amp; foo(); } // 推荐的写法 var call = function(name) { var foo; if (name == &quot;hotel&quot;) { foo = function() { console.log(&quot;hotel foo&quot;); } } foo &amp;&amp; foo(); } 引起的bug：第一种写法foo的声明被提前了; 调用call时：第一种写法会调用foo函数，第二种写法不会调用foo函数 注：不同浏览器解析不同，具体请移步汤姆大叔深入解析Javascript函数篇 禁止）使用eval，采取$.parseJSON 三个原因：有注入风险，尤其是ajax返回数据不方便debug效率低，eval是一个执行效率很低的函数 建议：使用new Function来代替eval的使用，最好就别用。 除了三目运算，if,else等（禁止）简写 // 正确的书写 if (true) { alert(name); } console.log(name); // 不推荐的书写 if (true) alert(name); console.log(name); // 不推荐的书写 if (true) alert(name); console.log(name) （推荐）在需要以{}闭合的代码段前增加换行，如：for if // 没有换行，小的代码段无法区分 if (wl &amp;&amp; wl.length) { for (i = 0, l = wl.length; i &lt; l; ++i) { p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) { if (merge &amp;&amp; type == &#39;object&#39;) { Y.mix(r[p], s[p]); } else if (ov || !(p in r)) { r[p] = s[p]; } } } } // 有了换行，逻辑清楚多了 if (wl &amp;&amp; wl.length) { for (i = 0, l = wl.length; i &lt; l; ++i) { p = wl[i]; type = Y.Lang.type(r[p]); if (s.hasOwnProperty(p)) { // 处理merge逻辑 if (merge &amp;&amp; type == &#39;object&#39;) { Y.mix(r[p], s[p]); } else if (ov || !(p in r)) { r[p] = s[p]; } } } } 换行可以是空行，也可以是注释 (推荐）使用Function进行类的定义，(不推荐)继承，如需继承采用成熟的类库实现继承// 类的实现 function Person(name) { this.name = name; } Person.prototype.sayName = function() { alert(this.name); }; var me = new Person(&quot;Nicholas&quot;); // 将this放到局部变量self function Persion(name, sex) { var self = this; self.name = name; self.sex = sex; } 平时咱们写代码，基本都是小程序，真心用不上什么继承，而且继承并不是JS的擅长的语言特性，尽量少用。如果非要使用的话，注意一点： function A(){ //... } function B(){ //... } B.prototype = new A(); B.prototype.constructor = B; //原则上，记得把这句话加上 继承从原则上来讲，别改变他的构造函数，否则这个继承就显得很别扭了~ (推荐)使用局部变量缓存反复查找的对象(包括但不限于全局变量、dom查询结果、作用域链较深的对象) // 缓存对象 var getComment = function() { var dom = $(&quot;#common-container&quot;), // 缓存dom appendTo = $.appendTo, // 缓存全局变量 data = this.json.data; // 缓存作用域链较深的对象 } 当需要缓存this时必须使用self变量进行缓存// 缓存this function Row(name) { var self = this; self.name = name; $(&quot;.row&quot;).click(function() { self.getName(); }); } self是一个保留字，不过用它也没关系。在这里，看个人爱好吧，可以用_this, that, me等这些词，都行，但是团队开发的时候统一下比较好。 ##（不推荐）超长函数, 当函数超过100行，就要想想是否能将函数拆为两个或多个函数 原文地址]]></content>
      <categories>
        <category>Standard</category>
      </categories>
      <tags>
        <tag>Record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端代码规范-CSS篇]]></title>
    <url>%2F2018%2F04%2F18%2FRecord%2F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83-CSS%E7%AF%87%2F</url>
    <content type="text"><![CDATA[tab键用（必须）四个空格代替 因为在不同系统的编辑工具对tab解析不一样，windows下的tab键是占四个空格的位置，而在linux下会变成占八个空格的位置（除非你自己设定了tab键所占的位置长度）。 每个样式属性后（必须）加 “;”方便压缩工具&quot;断句&quot;。 Class命名中（禁止）出现大写字母，（必须）采用” - “对class中的字母分隔，如： /* 正确的写法 */ .hotel-title { font-weight: bold; } /* 不推荐的写法 */ .hotelTitle { font-weight: bold; } 用”-“隔开比使用驼峰是更加清晰。 产品线-产品-模块-子模块，命名的时候也可以使用这种方式（@Artwl） 空格的使用，以下规则（必须）执行：.hotel-content { font-weight: bold; } 选择器与 { 之前（必须）要有空格 属性名的 : 后（必须）要有空格 属性名的 : 前（禁止）加空格 多选择器规则之间（必须）换行当样式针对多个选择器时每个选择器占一行 /* 推荐的写法 */ a.btn, input.btn, input[type=&quot;button&quot;] { ...... } （禁止）将样式写为单行, 如.hotel-content {margin: 10px; background-color: #efefef;} 单行显示不好注释，不好备注，这应该是压缩工具的活儿~ （禁止）向 0 后添加单位, 如：.obj { left: 0px; } （禁止）使用css原生import使用css原生import有很多弊端，比如会增加请求数等…. （推荐）属性的书写顺序, 举个例子:.hotel-content { /* 定位 */ display: block; position: absolute; left: 0; top: 0; /* 盒模型 */ width: 50px; height: 50px; margin: 10px; border: 1px solid black; / *其他* / color: #efefef; } 定位相关, 常见的有：display position left top float 等 盒模型相关, 常见的有：width height margin padding border 等 其他属性 按照这样的顺序书写可见提升浏览器渲染dom的性能 简单举个例子，网页中的图片，如果没有设置width和height，在图片载入之前，他所占的空间为0，但是当他加载完毕之后，那块为0的空间突然被撑开了，这样会导致，他下面的元素重新排列和渲染，造成重绘（repaint）和回流（reflow）。我们在写css的时候，把元素的定位放在前头，首先让浏览器知道该元素是在文本流内还是外，具体在页面的哪个部位，接着让浏览器知道他们的宽度和高度，border等这些占用空间的属性，其他的属性都是在这个固定的区域内渲染的，差不多就是这个意思吧~(@frec) 推荐文章： https://css-tricks.com/poll-results-how-do-you-order-your-css-properties/ http://www.mozilla.org/css/base/content.css 小图片（必须）sprite 合并推荐文章：NodeJs智能合并CSS精灵图工具iSpriter (推荐）当编写针对特定html结构的样式时，使用元素名 + 类名/ 所有的nav都是针对ul编写的 / ul.nav { ...... } “.a div”和”.a div.b”，为什么后者好？如果需求有所变化，在”.a”下有多加了一个div，试问，开始的样式是不是会影响后来的div啊~ (推荐）IE Hack List /* 针对ie的hack */ selector { property: value; /* 所有浏览器 */ property: value\9; /* 所有IE浏览器 */ property: value\0; /* IE8 */ +property: value; /* IE7 */ _property: value; /* IE6 */ *property: value; /* IE6-7 */ } 当使用hack的时候想想能不能用更好的样式代替 （不推荐）ie使用filter,（ 禁止）使用expression这里主要是效率问题，应该当格外注意，咱们要少用烧CPU的东西~ (禁止）使用行内（inline）样式&lt;p style=&quot;font-size: 12px; color: #FFFFFF&quot;&gt;靖鸣君&lt;/p&gt; 像这样的行内样式，最好用一个class代替。又如要隐藏某个元素，可以给他加一个class .hide { display: none;}尽量做到样式和结构分离~ （推荐）reset.css样式推荐网站：http://www.cssreset.com/ （禁止）使用”*”来选择元素/*别这样写*/ * { margin: 0; padding: 0; } 这样写是没有必要的，一些元素在浏览器中默认有margin或padding值，但是只是部分元素，没有必要将所有元素的margin、padding值都置为0。 链接的样式，（务必）按照这个顺序来书写 a:link -&gt; a:visited -&gt; a:hover -&gt; a:active 原文地址]]></content>
      <categories>
        <category>Standard</category>
      </categories>
      <tags>
        <tag>Record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack3,从入门到放弃]]></title>
    <url>%2F2018%2F04%2F17%2FTools%2Fwebpack3-%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%83%2F</url>
    <content type="text"><![CDATA[前言 首先，这篇文章是根据 webpack 版本 (即 v3.4.1) 撰写，较长一段时间内无需担心过时的问题。其次，这应该会是一篇极长的文章，涵盖了基本的使用方法，有更高级功能的需求可以参考官方文档继续学习。再次，即使是基本的功能，也内容繁多，我尽可能地解释通俗易懂，将我学习过程中的疑惑和坑一一解释，如有纰漏，敬请雅正。再次，为了清晰有效地讲解，我会演示从零编写 demo，只要一步步跟着做，就会清晰许多。 本文demo地址 Webpack，何许人也？借用官方的说法: webpack is a module bundler. Its main purpose is to bundle JavaScript files for usage in a browser, yet it is also capable of transforming, bundling, or packaging just about any resource or asset. 简言之，webpack 是一个模块打包器 (module bundler)，能够将任何资源如 JavaScript 文件、CSS 文件、图片等打包成一个或少数文件。 为什么要用介个 Webpack?首先，定义已经说明了 webpack 能将多个资源模块打包成一个或少数文件，这意味着与以往的发起多个 HTTP 请求来获得资源相比，现在只需要发起少量的 HTTP 请求。 其次，webpack 能将你的资源转换为最适合浏览器的“格式”，提升应用性能。比如只引用被应用使用的资源 (剔除未被使用的代码)，懒加载资源 (只在需要的时候才加载相应的资源)。 再次，对于开发阶段，webpack 也提供了实时加载和热加载的功能，大大地节省了开发时间。除此之外，还有许多优秀之处之处值得去挖掘。不过，webpack 最核心的还是打包的功能。 webpack，gulp/grunt，npm，它们有什么区别?webpack 是模块打包器（module bundler），把所有的模块打包成一个或少量文件，使你只需加载少量文件即可运行整个应用，而无需像之前那样加载大量的图片，css文件，js文件，字体文件等等。 而gulp／grunt 是自动化构建工具，或者叫任务运行器（task runner），是把你所有重复的手动操作让代码来做，例如压缩JS代码、CSS代码，代码检查、代码编译等等，自动化构建工具并不能把所有模块打包到一起，也不能构建不同模块之间的依赖图。 两者来比较的话，gulp/grunt 无法做模块打包的事，webpack 虽然有 loader 和 plugin可以做一部分 gulp／grunt 能做的事，但是终究 webpack 的插件还是不如 gulp／grunt 的插件丰富，能做的事比较有限。 于是有人两者结合着用，将 webpack 放到 gulp／grunt 中用。然而，更好的方法是用 npm scripts 取代 gulp／grunt，npm 是 node 的包管理器 (node package manager)，用于管理 node 的第三方软件包，npm 对于任务命令的良好支持让你最终省却了编写任务代码的必要，取而代之的，是老祖宗的几个命令行，仅靠几句命令行就足以完成你的模块打包和自动化构建的所有需求。 准备开始先来看看一个 webpack 的一个完备的配置文件，是 介样 的，当然啦，这里面有很多配置项是即使到这个软件被废弃你也用不上的：），所以无需担心。 基本配置开始之前，请确定你已经安装了当前 Node 的较新版本。 然后执行以下命令以新建我们的 demo 目录： $ mkdir webpack-demo &amp;&amp; cd webpack-demo &amp;&amp; npm init -y $ npm i --save-dev webpack $ mkdir src &amp;&amp; cd src &amp;&amp; touch index.js 我们使用工具函数库 lodash 来演示我们的 demo。先安装之： $ npm i --save lodash src/index.js import _ from &#39;lodash&#39;; function component() { const element = document.createElement(&#39;div&#39;); element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); return element; } document.body.appendChild(component()); Tipsimport 和 export 已经是 ES6 的标准，但是仍未得到大多数浏览器的支持 (可喜的是， Chrome 61 已经开始默认支持了，见 ES6 modules)，不过 webpack 提供了对这个特性的支持，但是除了这个特性，其他的 ES6 特性并不会得到 webpack 的特别支持，如有需要，须借助 Babel 进行转译 (transpile)。 然后新建发布版本目录： $ cd .. &amp;&amp; mkdir dist &amp;&amp; cd dist &amp;&amp; touch index.html dist/index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;webpack demo&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 现在，我们运行 webpack 来打包 index.js 为 bundle.js，本地安装了 webpack 后可以通过 node_modules/.bin/webpack 来访问 webpack 的二进制版本。 $ cd .. $ ./node_modules/.bin/webpack src/index.js dist/bundle.js //第一个参数是打包的入口文件，第二个参数是打包的出口文件 咻咻咻，大致如下输出一波： Hash: de8ed072e2c7b3892179 Version: webpack 3.4.1 Time: 390ms Asset Size Chunks Chunk Names bundle.js 544 kB 0 [emitted] [big] main [0] ./src/index.js 225 bytes {0} [built] [2] (webpack)/buildin/global.js 509 bytes {0} [built] [3] (webpack)/buildin/module.js 517 bytes {0} [built] + 1 hidden module 现在，你已经得到了你的第一个打包文件 (bundle.js) 了。 使用配置文件像上面这样使用 webpack 应该是最挫的姿势了，所以我们要使用 webpack 的配置文件来提高我们的姿势水平。 $ touch webpack.config.js webpack.config.js const path = require(&#39;path&#39;); module.exports = { entry: &#39;./src/index.js&#39;, // 入口起点，可以指定多个入口起点 output: { // 输出，只可指定一个输出配置 filename: &#39;bundle.js&#39;, // 输出文件名 path: path.resolve(__dirname, &#39;dist&#39;) // 输出文件所在的目录 } }; 执行： $ ./node_modules/.bin/webpack --config webpack.config.js //`--config` 制定 webpack 的配置文件，默认是 `webpack.config.js` 所以这里可以省却 --config webpack.config.js。但是每次都要写 ./node_modules/.bin/webpack 实在让人不爽，所以我们要动用 NPM Scripts。 package.json { ... &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot; }, ... } 执行： $ npm run build 一波输出后便得到了打包文件。 打包其他类型的文件因为其他文件和 JS 文件类型不同，要把他们加载到 JS 文件中就需要经过加载器 (loader) 的处理 加载 CSS我们需要安装两个 loader 来处理 CSS 文件： $ npm i --save-dev style-loader css-loader style-loader 通过插入 style 标签将 CSS 加入到 DOM 中，css-loader 会像解释 import/require() 一样解释 @import 和 url()。 const path = require(&#39;path&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, module: { // 如何处理项目中不同类型的模块 rules: [ // 用于规定在不同模块被创建时如何处理模块的规则数组 { test: /\.css$/, // 匹配特定文件的正则表达式或正则表达式数组 use: [ // 应用于模块的 loader 使用列表 &#39;style-loader&#39;, &#39;css-loader&#39; ] } ] } }; 我们来创建一个 CSS 文件： $ cd src &amp;&amp; touch style.css src/style.css .hello { color: red; } src/index.js import _ from &#39;lodash&#39;; import &#39;./style.css&#39;; // 通过`import`引入 CSS 文件 function component() { const element = document.createElement(&#39;div&#39;); element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); element.classList.add(&#39;hello&#39;); // 在相应元素上添加类名 return element; } document.body.appendChild(component()); 执行npm run build，然后打开index.html，就可以看到红色的字体了。CSS 文件此时已经被打包到 bundle.js 中。再打开浏览器控制台，就可以看到 webpack 做了些什么。 加载图片$ npm install --save-dev file-loader file-loader 指示 webpack 以文件格式发出所需对象并返回文件的公共URL，可用于任何文件的加载。 webpack.config.js const path = require(&#39;path&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, module: { rules: [ { test: /\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] }, { // 增加加载图片的规则 test: /\.(png|svg|jpg|gif)$/, use: [ &#39;file-loader&#39; ] } ] } }; 我们在当前项目的Src目录中如下增加图片 src/index.js import _ from &#39;lodash&#39;; import &#39;./style.css&#39;; import Icon from &#39;./icon.jpg&#39;; // Icon 是图片的 URL function component() { const element = document.createElement(&#39;div&#39;); element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); element.classList.add(&#39;hello&#39;); const myIcon = new Image(); myIcon.src = Icon; element.appendChild(myIcon); return element; } document.body.appendChild(component()); src/style.css .hello { color: red; background: url(./icon.jpg); } 再npm run build之。现在你可以看到单独的图片和以图片为基础的背景图了。 加载字体加载字体用的也是 file-loader。 webpack.config.js const path = require(&#39;path&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, module: { rules: [ { test: /\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] }, { test: /\.(png|svg|jpg|gif)$/, use: [ &#39;file-loader&#39; ] }, { // 增加加载字体的规则 test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &#39;file-loader&#39; ] } ] } }; 在当前项目的Src目录中如下增加字体： src/style.css @font-face { font-family: MyFont; src: url(./my-font.ttf); } .hello { color: red; background: url(./icon.jpg); font-family: MyFont; } 运行打包命令之后便可以看到打包好的文件和发生改变的页面。 加载 JSON 文件因为 webpack 对 JSON 文件的支持是内置的，所以可以直接添加。 src/data.json { &quot;name&quot;: &quot;webpack-demo&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;author&quot;: &quot;Sam Yang&quot; } src/index.js import _ from &#39;lodash&#39;; import &#39;./style.css&#39;; import Icon from &#39;./icon.jpg&#39;; import Data from &#39;./data.json&#39;; // Data 变量包含可直接使用的 JSON 解析得到的对象 function component() { const element = document.createElement(&#39;div&#39;); element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); element.classList.add(&#39;hello&#39;); const myIcon = new Image(); myIcon.src = Icon; element.appendChild(myIcon); console.log(Data); return element; } document.body.appendChild(component()); 关于其他文件的加载，可以寻求相应的 loader。 输出管理前面我们只有一个输入文件，但现实是我们往往有不止一个输入文件，这时我们就需要输入多个入口文件并管理输出文件。我们在 src 目录下增加一个 print.js 文件。 src/print.js export default function printMe() { console.log(&#39;I get called from print.js!&#39;); } src/index.js import _ from &#39;lodash&#39;; import printMe from &#39;./print.js&#39;; // import &#39;./style.css&#39;; // import Icon from &#39;./icon.jpg&#39;; // import Data from &#39;./data.json&#39;; function component() { const element = document.createElement(&#39;div&#39;); const btn = document.createElement(&#39;button&#39;); element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); // element.classList.add(&#39;hello&#39;); // const myIcon = new Image(); // myIcon.src = Icon; // element.appendChild(myIcon); // console.log(Data); btn.innerHTML = &#39;Click me and check the console!&#39;; btn.onclick = printMe; element.appendChild(btn); return element; } document.body.appendChild(component()); dist/index.html &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;webpack demo&lt;/title&gt; &lt;script src=&quot;./print.bundle.js&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- &lt;script src=&quot;bundle.js&quot;&gt;&lt;/script&gt; --&gt; &lt;script src=&quot;./app.bundle.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; webpack.config.js const path = require(&#39;path&#39;); module.exports = { // entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/index.js&#39;, print: &#39;./src/print.js&#39; }, output: { // filename: &#39;bundle.js&#39;, filename: &#39;[name].bundle.js&#39;, // 根据入口起点名动态生成 bundle 名，可以使用像 &quot;js/[name]/bundle.js&quot; 这样的文件夹结构 path: path.resolve(__dirname, &#39;dist&#39;) }, // ... }; Tipsfilename: ‘[name].bundle.js’中的[name]会替换为对应的入口起点名，其他可用的替换请参见 output.filename。 现在可以打包文件了。但是如果我们修改了入口文件名或增加了入口文件，index.html是不会自动引用新文件的，而手动修改实在太挫。是时候使用插件 (plugin) 来完成这一任务了。我们使用 HtmlWebpackPlugin 自动生成 html 文件。 loader 和 plugin，有什么区别？loader (加载器)，重在“加载”二字，是用于预处理文件的，只用于在加载不同类型的文件时对不同类型的文件做相应的处理。而 plugin (插件)，顾名思义，是用来增加 webpack 的功能的，作用于整个 webpack 的构建过程。在 webpack 这个大公司中，loader 是保安大叔，负责对进入公司的不同人员的处理，而 plugin 则是公司里不同职位的职员，负责公司里的各种不同业务，每增加一种新型的业务需求，我们就需要增加一种 plugin。 安装插件： $ npm i --save-dev html-webpack-plugin webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); module.exports = { // entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/index.js&#39;, print: &#39;./src/print.js&#39; }, output: { // filename: &#39;bundle.js&#39;, filename: &#39;[name].bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, plugins: [ // 插件属性，是插件的实例数组 new HtmlWebpackPlugin({ title: &#39;webpack demo&#39;, // 生成 HTML 文档的标题 filename: &#39;index.html&#39; // 写入 HTML 文件的文件名，默认 `index.html` }) ], // ... }; 你可以先把 dist 文件夹的index.html文件删除，然后执行打包命令。咻咻咻，我们看到 dist 目录下已经自动生成了一个index.html文件，但即使不删除原先的index.html，该插件默认生成的index.html也会替换原本的index.html。 此刻，当你细细观察 dist 目录时，虽然现在生成了新的打包文件，但原本的打包文件bundle.js及其他不用的文件仍然存在在 dist 目录中，所以在每次构建前我们需要晴空 dist 目录，我们使用 CleanWebpackPlugin 插件。 $ npm i clean-webpack-plugin --save-dev webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); module.exports = { // entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/index.js&#39;, print: &#39;./src/print.js&#39; }, output: { // filename: &#39;bundle.js&#39;, filename: &#39;[name].bundle.js&#39;, path: path.resolve(__dirname, &#39;dist&#39;) }, plugins: [ new HtmlWebpackPlugin({ title: &#39;webpack demo&#39;, filename: &#39;index.html&#39; }), new CleanWebpackPlugin([&#39;dist&#39;]) // 第一个参数是要清理的目录的字符串数组 ], // ... }; 打包之，现在，dist 中只存在打包生成的文件。 webpack 提供了很多便于开发时使用的功能，来一一看看吧。使用代码映射 (source map)当你的代码被打包后，如果打包后的代码发生了错误，你很难追踪到错误发生的原始位置，这个时候，我们就需要代码映射 (source map) 这种工具，它能将编译后的代码映射回原始的源码，你的错误是起源于打包前的b.js的某个位置，代码映射就能告诉你错误是那个模块的那个位置。webpack 默认提供了 10 种风格的代码映射，使用它们会明显影响到构建 (build) 和重构建 (rebuild，每次修改后需要重新构建) 的速度，十种风格的差异可以参看 devtool。关于如何选择映射风格可以参看 Webpack devtool source map。这里，我们为了准确显示错误位置，选择速度较慢的inline-source-map。 webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); module.exports = { devtool: &#39;inline-source-map&#39;, // 控制是否生成以及如何生成 source map // entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/index.js&#39;, print: &#39;./src/print.js&#39; }, // ... }; 现在来手动制造一些错误： src/print.js export default function printMe() { - console.log(&#39;I get called from print.js!&#39;); + cosnole.log(&#39;I get called from print.js!&#39;); } 打包之后打开index.html再点击按钮，你就会看到控制台显示如下报错： Uncaught ReferenceError: cosnole is not defined at HTMLButtonElement.printMe (print.js:2) 现在，我们很清楚哪里发生了错误，然后轻松地改正之。 webpack-dev-server你一定有这样的体验，开发时每次修改代码保存后都需要重新手动构建代码并手动刷新浏览器以观察修改效果，这是很麻烦的，所以，我们要实时加载代码。可喜的是，webpack 提供了对实时加载代码的支持。我们需要安装 webpack-dev-server 以获得支持。 $ npm i --save-dev webpack-dev-server webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); module.exports = { devtool: &#39;inline-source-map&#39;, devServer: { // 检测代码变化并自动重新编译并自动刷新浏览器 contentBase: path.resolve(__dirname, &#39;dist&#39;) // 设置静态资源的根目录 }, // entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/index.js&#39;, print: &#39;./src/print.js&#39; }, // ... }; package.json { ... &quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot; }, ... } Tips使用 webpack-dev-server 时，webpack 并没有将所有生成的文件写入磁盘，而是放在内存中，提供更快的内存内访问，便于实时更新。 现在，可以直接运行npm start (start是 npm scripts 的内置属性，可直接运行)，然后浏览器自动加载应用的页面，默认在localhost:8080显示。 模块热替换 (HMR, Hot Module Replacement)webpack 提供了对模块热替换 (或者叫热加载) 的支持。这一特性能够让应用运行的时候替换、增加或删除模块，而无需进行完全的重载。想进一步地了解其工作机理，可以参见 Hot Module Replacement，但这并不是必需的，你可以选择跳过机理部分继续往下阅读。 Tips模块热替换（HMR）只更新发生变更（替换、添加、删除）的模块，而无需重新加载整个页面（实时加载，LiveReload），这样可以显著加快开发速度，一旦打开了 webpack-dev-server 的 hot 模式，在试图重新加载整个页面之前，热模式会尝试使用 HMR 来更新。 webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); const webpack = require(&#39;webpack&#39;); // 引入 webpack 便于调用其内置插件 module.exports = { devtool: &#39;inline-source-map&#39;, devServer: { contentBase: path.resolve(__dirname, &#39;dist&#39;), hot: true, // 告诉 dev-server 我们在用 HMR hotOnly: true // 指定如果热加载失败了禁止刷新页面 (这是 webpack 的默认行为)，这样便于我们知道失败是因为何种错误 }, // entry: &#39;./src/index.js&#39;, entry: { app: &#39;./src/index.js&#39;, // print: &#39;./src/print.js&#39; }, // ... plugins: [ new HtmlWebpackPlugin({ title: &#39;webpack demo&#39;, filename: &#39;index.html&#39; }), new CleanWebpackPlugin([&#39;dist&#39;]), new webpack.HotModuleReplacementPlugin(), // 启用 HMR new webpack.NamedModulesPlugin() // 打印日志信息时 webpack 默认使用模块的数字 ID 指代模块，不便于 debug，这个插件可以将其替换为模块的真实路径 ], // ... }; Tipswebpack-dev-server 会为每个入口文件创建一个客户端脚本，这个脚本会监控该入口文件的依赖模块的更新，如果该入口文件编写了 HMR 处理函数，它就能接收依赖模块的更新，反之，更新会向上冒泡，直到客户端脚本仍没有处理函数的话，webpack-dev-server 会重新加载整个页面。如果入口文件本身发生了更新，因为向上会冒泡到客户端脚本，并且不存在 HMR 处理函数，所以会导致页面重载。 我们已经开启了 HMR 的功能，HMR 的接口已经暴露在module.hot属性之下，我们只需要调用 HMR API 即可实现热加载。当“被加载模块”发生改变时，依赖该模块的模块便能检测到改变并接收改变之后的模块。 src/index.js import _ from &#39;lodash&#39;; import printMe from &#39;./print.js&#39;; // import &#39;./style.css&#39;; // import Icon from &#39;./icon.jpg&#39;; // import Data from &#39;./data.json&#39;; function component() { const element = document.createElement(&#39;div&#39;); const btn = document.createElement(&#39;button&#39;); element.innerHTML = _.join([&#39;Hello&#39;, &#39;webpack&#39;], &#39; &#39;); // element.classList.add(&#39;hello&#39;); // const myIcon = new Image(); // myIcon.src = Icon; // element.appendChild(myIcon); // console.log(Data); btn.innerHTML = &#39;Click me and check the console!&#39;; btn.onclick = printMe; element.appendChild(btn); return element; } document.body.appendChild(component()); if(module.hot) { // 习惯上我们会检查是否可以访问 `module.hot` 属性 module.hot.accept(&#39;./print.js&#39;, function() { // 接受给定依赖模块的更新，并触发一个回调函数来对这些更新做出响应 console.log(&#39;Accepting the updated printMe module!&#39;); printMe(); }); } npm start之。为了演示效果，我们做如下修改： src/print.js export default function printMe() { - console.log(&#39;I get called from print.js!&#39;); + console.log(&#39;Updating print.js...&#39;); } 我们会看到控制台打印出的信息中含有以下几行： index.js:33 Accepting the updated printMe module! print.js:2 Updating print.js... log.js:23 [HMR] Updated modules: log.js:23 [HMR] - ./src/print.js log.js:23 [HMR] App is up to date. Tipswebpack-dev-server 在 inline mode (此为默认模式) 时，会为每个入口起点 (entry) 创建一个客户端脚本，所以你会在上面的输出中看到有些信息重复输出两次。 但是当你点击页面的按钮时，你会发现控制台输出的是旧的printMe函数输出的信息，因为onclick事件绑定的仍是原始的printMe函数。我们需要在module.hot.accept里更新绑定。 src/index.js import _ from &#39;lodash&#39;; import printMe from &#39;./print.js&#39;; // import &#39;./style.css&#39;; // import Icon from &#39;./icon.jpg&#39;; // import Data from &#39;./data.json&#39;; // ... // document.body.appendChild(component()); var element = component(); document.body.appendChild(element); if(module.hot) { module.hot.accept(&#39;./print.js&#39;, function() { console.log(&#39;Accepting the updated printMe module!&#39;); // printMe(); document.body.removeChild(element); element = component(); document.body.appendChild(element); }); } 模块热替换也可以用于样式的修改，效果跟控制台修改一样一样的。 src/index.js import _ from &#39;lodash&#39;; import printMe from &#39;./print.js&#39;; import &#39;./style.css&#39;; // import Icon from &#39;./icon.jpg&#39;; // import Data from &#39;./data.json&#39;; // ... npm start之，做如下修改： /* ... */ body { background-color: yellow; } 可以发现在不重载页面的前提下我们对样式的修改进行了热加载，棒！ 生产环境自动方式我们只需要运行webpack -p (相当于 webpack –optimize-minimize –define process.env.NODE_ENV=”‘production’”)这个命令，便可以自动构建生产版本的应用，这个命令会完成以下步骤： 使用 UglifyJsPlugin (webpack.optimize.UglifyJsPlugin) 压缩 JS 文件 (此插件和 uglifyjs-webpack-plugin 相同) 运行 LoaderOptionsPlugin 插件，这个插件是用来迁移的，见 document 设置 NodeJS 的环境变量，触发某些 package 包以不同方式编译 值得一提的是，webpack -p设置的process.env.NODE_ENV环境变量，是用于编译后的代码的，只有在打包后的代码中，这一环境变量才是有效的。如果在 webpack 配置文件中引用此环境变量，得到的是 undefined，可以参见 #2537。但是，有时我们确实需要在 webpack 配置文件中使用 process.env.NODE_ENV，怎么办呢？一个方法是运行NODE_ENV=’production’ webpack -p命令，不过这个命令在Windows中是会出问题的。为了解决兼容问题，我们采用 cross-env 解决跨平台的问题。 $ npm i --save-dev cross-env package.json { ... &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack -p&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot; }, ... } 现在可以在配置文件中使用process.env.NODE_ENV了。 webpack.config.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); const webpack = require(&#39;webpack&#39;); module.exports = { // ... output: { // filename: &#39;bundle.js&#39;, // filename: &#39;[name].bundle.js&#39;, filename: process.env.NODE_ENV === &#39;production&#39; ? &#39;[name].[chunkhash].js&#39; : &#39;[name].bundle.js&#39;, // 在配置文件中使用`process.env.NODE_ENV` path: path.resolve(__dirname, &#39;dist&#39;) }, plugins: [ new HtmlWebpackPlugin({ title: &#39;webpack demo&#39;, filename: &#39;index.html&#39; }), new CleanWebpackPlugin([&#39;dist&#39;]), // new webpack.HotModuleReplacementPlugin(), // 关闭 HMR 功能 new webpack.NamedModulesPlugin() ], // ... }; Tips[chunkhash]不能和 HMR 一起使用，换句话说，不应该在开发环境中使用 [chunkhash] (或者 [hash])，这会导致许多问题。 build 之，我们得到了生产版本的压缩好的打包文件。 多配置文件配置有时我们会需要为不同的环境配置不同的配置文件，可以选择 简易方法，这里我们采用较为先进的方法。先准备一个基本的配置文件，包含了所有环境都包含的配置，然后用 webpack-merge 将它和特定环境的配置文件合并并导出，这样就减少了基本配置的重复。 $ npm i --save-dev webpack-merge webpack.common.js const path = require(&#39;path&#39;); const HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;); const CleanWebpackPlugin = require(&#39;clean-webpack-plugin&#39;); module.exports = { entry: { app: &#39;./src/index.js&#39;, print: &#39;./src/print.js&#39; }, output: { path: path.resolve(__dirname, &#39;dist&#39;) }, plugins: [ new HtmlWebpackPlugin({ title: &#39;webpack demo&#39;, filename: &#39;index.html&#39; }), new CleanWebpackPlugin([&#39;dist&#39;]) ], module: { rules: [ { test: /\.css$/, use: [ &#39;style-loader&#39;, &#39;css-loader&#39; ] }, { test: /\.(png|svg|jpg|gif)$/, use: [ &#39;file-loader&#39; ] }, { test: /\.(woff|woff2|eot|ttf|otf)$/, use: [ &#39;file-loader&#39; ] } ] } }; webpack.dev.js const path = require(&#39;path&#39;); const webpack = require(&#39;webpack&#39;); const Merge = require(&#39;webpack-merge&#39;); const CommonConfig = require(&#39;./webpack.common.js&#39;); module.exports = Merge(CommonConfig, { devtool: &#39;cheap-module-eval-source-map&#39;, devServer: { contentBase: path.resolve(__dirname, &#39;dist&#39;), hot: true, hotOnly: true }, output: { filename: &#39;[name].bundle.js&#39; }, plugins: [ new webpack.DefinePlugin({ &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;development&#39;) // 在编译的代码里设置了`process.env.NODE_ENV`变量 }), new webpack.HotModuleReplacementPlugin(), new webpack.NamedModulesPlugin() ] }); webpack.prod.js const path = require(&#39;path&#39;); const webpack = require(&#39;webpack&#39;); const Merge = require(&#39;webpack-merge&#39;); const CommonConfig = require(&#39;./webpack.common.js&#39;); module.exports = Merge(CommonConfig, { devtool: &#39;cheap-module-source-map&#39;, output: { filename: &#39;[name].[chunkhash].js&#39; }, plugins: [ new webpack.DefinePlugin({ &#39;process.env.NODE_ENV&#39;: JSON.stringify(&#39;production&#39;) }), new webpack.optimize.UglifyJsPlugin() ] }); package.json { ... &quot;scripts&quot;: { &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack -p&quot;, &quot;start&quot;: &quot;webpack-dev-server --open&quot;, &quot;build:dev&quot;: &quot;webpack-dev-server --open --config webpack.dev.js&quot;, &quot;build:prod&quot;: &quot;webpack --progress --config webpack.prod.js&quot; }, ... } 现在只需执行npm run build:dev或npm run build:prod便可以得到开发版或者生产版了！ 原文地址]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Webpack</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS高级之面试必须知道的几个点]]></title>
    <url>%2F2018%2F04%2F16%2FInterview%2FJS%E9%AB%98%E7%BA%A7%E4%B9%8B%E9%9D%A2%E8%AF%95%E5%BF%85%E9%A1%BB%E7%9F%A5%E9%81%93%E7%9A%84%E5%87%A0%E4%B8%AA%E7%82%B9%2F</url>
    <content type="text"><![CDATA[函数的3种定义函数声明//ES5 function getSum(){} function (){}//匿名函数 //ES6 ()=&gt;{}//如果{}内容只有一行{}和return关键字可省, 函数表达式（字面量形式）//ES5 var sum=function getSum(){} //ES6 let sum=()=&gt;{}//如果{}内容只有一行{}和return关键字可省, 构造函数var sum=new GetSum(num1,num2) 三种方法的对比1.函数声明有预解析,而且函数声明的优先级高于变量;2.使用Function构造函数定义函数的方式是一个函数表达式,这种方式会导致解析两次代码，影响性能。第一次解析常规的JavaScript代码，第二次解析传入构造函数的字符串 Es5函数中的4种调用在ES5中函数内容的this指向和调用方法有关 函数调用模式包括函数名()和匿名函数调用,this指向window function getSum() { console.log(this) //window } getSum() (function() { console.log(this) //window })() var getSum=function() { console.log(this) //window } 方法调用对象.方法名(),this指向对象 var objList = { name: &#39;methods&#39;, getSum: function() { console.log(this) //objList对象 } } objList.getSum() 构造器调用new 构造函数名(),this指向构造函数 function Person() { console.log(this); //指向构造函数Person } var personOne = new Person(); 间接调用利用call和apply来实现,this就是call和apply对应的第一个参数,如果不传值或者第一个值为null,undefined时this指向window function foo() { console.log(this); } foo.apply(&#39;我是apply改变的this值&#39;);//我是apply改变的this值 foo.call(&#39;我是call改变的this值&#39;);//我是call改变的this值 Es6函数的调用箭头函数不可以当作构造函数使用，也就是不能用new命令实例化一个对象，否则会抛出一个错误箭头函数的this是和定义时有关和调用无关调用就是函数调用模式 (() =&gt; { console.log(this)//window })() let arrowFun = () =&gt; { console.log(this)//window } arrowFun() let arrowObj = { arrFun: function() { (() =&gt; { console.log(this)//arrowObj })() } } arrowObj.arrFun(); call,apply和bind1.IE5之前不支持call和apply,bind是ES5出来的;2.call和apply可以调用函数,改变this,实现继承和借用别的对象的方法; call和apply定义调用方法,用一个对象替换掉另一个对象(this)对象.call(新this对象,实参1,实参2,实参3…..) 参数列表对象.apply(新this对象,[实参1,实参2,实参3…..]) 参数数组 call和apply用法1.间接调用函数,改变作用域的this值2.劫持其他对象的方法 var foo = { name:&quot;张三&quot;, logName:function(){ console.log(this.name); } } var bar={ name:&quot;李四&quot; }; foo.logName.call(bar);//李四 实质是call改变了foo的this指向为bar,并调用该函数 3.两个函数实现继承 function Animal(name){ this.name = name; this.showName = function(){ console.log(this.name); } } function Cat(name){ Animal.call(this, name); } var cat = new Cat(&quot;Black Cat&quot;); cat.showName(); //Black Cat 4.为类数组(arguments和nodeList)添加数组方法push,pop (function(){ Array.prototype.push.call(arguments,&#39;王五&#39;); console.log(arguments);//[&#39;张三&#39;,&#39;李四&#39;,&#39;王五&#39;] })(&#39;张三&#39;,&#39;李四&#39;) 5.合并数组 let arr1=[1,2,3]; let arr2=[4,5,6]; Array.prototype.push.apply(arr1,arr2); //将arr2合并到了arr1中 6.求数组最大值 Math.max.apply(null,arr) 7.判断字符类型 Object.prototype.toString.call({}) bindbind是function的一个函数扩展方法，bind以后代码重新绑定了func内部的this指向,不会调用方法,不兼容IE8 var name = &#39;李四&#39; var foo = { name: &quot;张三&quot;, logName: function(age) { console.log(this.name, age); } } var fooNew = foo.logName; var fooNewBind = foo.logName.bind(foo); fooNew(10)//李四,10 fooNewBind(11)//张三,11 因为bind改变了fooNewBind里面的this指向 常见的四种设计模式工厂模式简单的工厂模式可以理解为解决多个相似的问题; function CreatePerson(name,age,sex) { var obj = new Object(); obj.name = name; obj.age = age; obj.sex = sex; obj.sayName = function(){ return this.name; } return obj; } var p1 = new CreatePerson(&quot;longen&quot;,&#39;28&#39;,&#39;男&#39;); var p2 = new CreatePerson(&quot;tugenhua&quot;,&#39;27&#39;,&#39;女&#39;); console.log(p1.name); // longen console.log(p1.age); // 28 console.log(p1.sex); // 男 console.log(p1.sayName()); // longen console.log(p2.name); // tugenhua console.log(p2.age); // 27 console.log(p2.sex); // 女 console.log(p2.sayName()); // tugenhua 单例模式只能被实例化(构造函数给实例添加属性与方法)一次 // 单体模式 var Singleton = function(name){ this.name = name; }; Singleton.prototype.getName = function(){ return this.name; } // 获取实例对象 var getInstance = (function() { var instance = null; return function(name) { if(!instance) {//相当于一个一次性阀门,只能实例化一次 instance = new Singleton(name); } return instance; } })(); // 测试单体模式的实例,所以a===b var a = getInstance(&quot;aa&quot;); var b = getInstance(&quot;bb&quot;); 沙箱模式将一些函数放到自执行函数里面,但要用闭包暴露接口,用变量接收暴露的接口,再调用里面的值,否则无法使用里面的值 let sandboxModel=(function(){ function sayName(){}; function sayAge(){}; return{ sayName:sayName, sayAge:sayAge } })() 发布者订阅模式就例如如我们关注了某一个公众号,然后他对应的有新的消息就会给你推送, //发布者与订阅模式 var shoeObj = {}; // 定义发布者 shoeObj.list = []; // 缓存列表 存放订阅者回调函数 // 增加订阅者 shoeObj.listen = function(fn) { shoeObj.list.push(fn); // 订阅消息添加到缓存列表 } // 发布消息 shoeObj.trigger = function() { for (var i = 0, fn; fn = this.list[i++];) { fn.apply(this, arguments);//第一个参数只是改变fn的this, } } // 小红订阅如下消息 shoeObj.listen(function(color, size) { console.log(&quot;颜色是：&quot; + color); console.log(&quot;尺码是：&quot; + size); }); // 小花订阅如下消息 shoeObj.listen(function(color, size) { console.log(&quot;再次打印颜色是：&quot; + color); console.log(&quot;再次打印尺码是：&quot; + size); }); shoeObj.trigger(&quot;红色&quot;, 40); shoeObj.trigger(&quot;黑色&quot;, 42); 代码实现逻辑是用数组存贮订阅者, 发布者回调函数里面通知的方式是遍历订阅者数组,并将发布者内容传入订阅者数组 更多设计模式请戳:Javascript常用的设计模式详解 原型链定义对象继承属性的一个链条 构造函数,实例与原型对象的关系构造函数,实例与原型对象的关系 var Person = function (name) { this.name = name; }//person是构造函数 var o3personTwo = new Person(&#39;personTwo&#39;)//personTwo是实例 构造函数,实例与原型对象的关系例子 原型对象都有一个默认的constructor属性指向构造函数 创建实例的方法1.字面量 let obj={&#39;name&#39;:&#39;张三&#39;} 2.Object构造函数创建 let Obj=new Object() Obj.name=&#39;张三&#39; 3.使用工厂模式创建对象 function createPerson(name){ var o = new Object(); o.name = name; }; return o; } var person1 = createPerson(&#39;张三&#39;); 4.使用构造函数创建对象 function Person(name){ this.name = name; } var person1 = new Person(&#39;张三&#39;); new运算符1.创了一个新对象;2.this指向构造函数;3.构造函数有返回,会替换new出来的对象,如果没有就是new出来的对象4.手动封装一个new运算符 var new2 = function (func) { var o = Object.create(func.prototype); //创建对象 var k = func.call(o); //改变this指向，把结果付给k if (typeof k === &#39;object&#39;) { //判断k的类型是不是对象 return k; //是，返回k } else { return o; //不是返回返回构造函数的执行结果 } } 更多详情:详谈JavaScript原型链 对象的原型链对象的原型链 继承的方式JS是一门弱类型动态语言,封装和继承是他的两大特性 原型链继承将父类的实例作为子类的原型代码实现 定义父类: // 定义一个动物类 function Animal (name) { // 属性 this.name = name || &#39;Animal&#39;; // 实例方法 this.sleep = function(){ console.log(this.name + &#39;正在睡觉！&#39;); } } // 原型方法 Animal.prototype.eat = function(food) { console.log(this.name + &#39;正在吃：&#39; + food); }; 子类: function Cat(){ } Cat.prototype = new Animal(); Cat.prototype.name = &#39;cat&#39;; // Test Code var cat = new Cat(); console.log(cat.name);//cat console.log(cat.eat(&#39;fish&#39;));//cat正在吃：fish undefined console.log(cat.sleep());//cat正在睡觉！ undefined console.log(cat instanceof Animal); //true console.log(cat instanceof Cat); //true 优缺点简单易于实现,但是要想为子类新增属性和方法，必须要在new Animal()这样的语句之后执行,无法实现多继承 构造继承实质是利用call来改变Cat中的this指向代码实现子类: function Cat(name){ Animal.call(this); this.name = name || &#39;Tom&#39;; } 优缺点可以实现多继承,不能继承原型属性/方法 实例继承为父类实例添加新特性，作为子类实例返回代码实现子类 function Cat(name){ var instance = new Animal(); instance.name = name || &#39;Tom&#39;; return instance; } 优缺点不限制调用方式,但不能实现多继承 拷贝继承将父类的属性和方法拷贝一份到子类中子类: function Cat(name){ var animal = new Animal(); for(var p in animal){ Cat.prototype[p] = animal[p]; } Cat.prototype.name = name || &#39;Tom&#39;; } 优缺点支持多继承,但是效率低占用内存 组合继承通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用子类: function Cat(name){ Animal.call(this); this.name = name || &#39;Tom&#39;; } Cat.prototype = new Animal(); Cat.prototype.constructor = Cat; 寄生组合继承function Cat(name){ Animal.call(this); this.name = name || &#39;Tom&#39;; } (function(){ // 创建一个没有实例方法的类 var Super = function(){}; Super.prototype = Animal.prototype; //将实例作为子类的原型 Cat.prototype = new Super(); })(); ES6的extends继承ES6 的继承机制是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this,链接描述 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + &#39; &#39; + super.toString(); // 调用父类的toString() } } 更多详情请戳:JS继承的实现方式 原文地址]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React,Redux,React-redux]]></title>
    <url>%2F2018%2F04%2F15%2FReact%2FReact-Redux-React-redux%2F</url>
    <content type="text"><![CDATA[Reactreact一些小型项目，只使用 React 完全够用了，数据管理使用props、state即可，那什么时候需要引入Redux呢？ 当渲染一个组件的数据是通过props从父组件中获取时，通常情况下是A –&gt; B，但随着业务复杂度的增加，有可能是这样的：A –&gt; B –&gt; C –&gt; D –&gt; E，E需要的数据需要从A那里通过props传递过来，以及对应的E –&gt; A逆向传递callback。组件BCD是不需要这些数据的，但是又必须经由它们来传递，这确实有点不爽，而且传递的props以及callback对BCD组件的复用也会造成影响。或者兄弟组件之间想要共享某些数据，也不是很方便传递、获取等。诸如此类的情况，就有必要引入Redux`了。 其实 A --&gt; B --&gt; C --&gt; D --&gt; E 这种情况，React不使用props层层传递也是能拿到数据的，使用Context即可。后面要讲到的react-redux就是通过Context让各个子组件拿到store中的数据的。 ReduxRedux其实我们只是想找个地方存放一些共享数据而已，大家都可以获取到，也都可以进行修改，仅此而已。那放在一个全部变量里面行不行？行，当然行，但是太不优雅，也不安全，因为是全局变量嘛，谁都能访问、谁都能修改，有可能一不小心被哪个小伙伴覆盖了也说不定。那全局变量不行就用私有变量呗，私有变量、不能轻易被修改，是不是立马就想到闭包`了… 现在要写这样一个函数，其满足： 存放一个数据对象 外界能访问到这个数据 外界也能修改这个数据 当数据有变化的时候，通知订阅者 function createStore(reducer, initialState) { // currentState就是那个数据 let currentState = initialState; let listener = () =&gt; {}; function getState() { return currentState; } function dispatch(action) { currentState = reducer(currentState, action); // 更新数据 listener(); // 执行订阅函数 return action; } function subscribe(newListener) { listener = newListener; // 取消订阅函数 return function unsubscribe() { listener = () =&gt; {}; }; } return { getState, dispatch, subscribe }; } const store = createStore(reducer); store.getState(); // 获取数据 store.dispatch({type: &#39;ADD_TODO&#39;}); // 更新数据 store.subscribe(() =&gt; {/* update UI */}); // 注册订阅函数 更新数据执行的步骤： What：想干什么 — dispatch(action) How：怎么干，干的结果 — reducer(oldState, action) =&gt; newState Then?：重新执行订阅函数（比如重新渲染UI等） 这样就实现了一个store，提供一个数据存储中心，可以供外部访问、修改等，这就是Redux的主要思想。所以，Redux确实和React没有什么本质关系，Redux可以结合其他库正常使用。只不过Redux这种数据管理方式，跟React的数据驱动视图理念很合拍，它俩结合在一起，开发非常便利。 现在既然有了一个安全的地方存取数据，怎么结合到React里面呢？我们可以在应用初始化的时候，创建一个window.store = createStore(reducer)，然后在需要的地方通过store.getState()去获取数据，通过store.dispatch去更新数据，通过store.subscribe去订阅数据变化然后进行setState...如果很多地方都这样做一遍，实在是不堪其重，而且，还是没有避免掉全局变量的不优雅。 React-ReduxReact-Redux 由于全局变量有诸多的缺点，那就换个思路，把store直接集成到React应用的顶层props里面，只要各个子组件能访问到顶层props就行了，比如这样： &lt;TopWrapComponent store={store}&gt; &lt;App /&gt; &lt;/TopWrapComponent&gt;, React恰好提供了这么一个钩子，Context，用法很简单，看一下官方demo就明了。现在各个子组件已经能够轻易地访问到store了，接下来就是子组件把store中用到的数据取出来、修改、以及订阅更新UI等。每个子组件都需要这样做一遍，显然，肯定有更便利的方法：高阶组件。通过高阶组件把store.getState()、store.dispatch、store.subscribe封装起来，子组件对store就无感知了，子组件正常使用props获取数据以及正常使用callback触发回调，相当于没有store存在一样。 function connect(mapStateToProps, mapDispatchToProps) { return function(WrappedComponent) { class Connect extends React.Component { componentDidMount() { // 组件加载完成后订阅store变化，如果store有变化则更新UI this.unsubscribe = this.context.store.subscribe(this.handleStoreChange.bind(this)); } componentWillUnmount() { // 组件销毁后，取消订阅事件 this.unsubscribe(); } handleStoreChange() { // 更新UI this.forceUpdate(); } render() { return ( &lt;WrappedComponent {...this.props} {...mapStateToProps(this.context.store.getState())} // 参数是store里面的数据 {...mapDispatchToProps(this.context.store.dispatch)} // 参数是store.dispatch /&gt; ); } } Connect.contextTypes = { store: PropTypes.object }; return Connect; }; } 使用connect的时候，我们知道要写一些样板化的代码，比如mapStateToProps、mapDispatchToProps这两个函数： const mapStateToProps = state =&gt; { return { count: state.count }; }; const mapDispatchToProps = dispatch =&gt; { return { dispatch }; }; export default connect(mapStateToProps, mapDispatchToProps)(Child); // 上述代码执行之后，可以看到connect函数里面的 &lt;WrappedComponent {...this.props} {...mapStateToProps(this.context.store.getState())} {...mapDispatchToProps(this.context.store.dispatch)} /&gt; // 就变成了 &lt;WrappedComponent {...this.props} {count: store.getState().count} {dispatch: store.dispatch} /&gt; // 这样，子组件Child的props里面就多了count和dispatch两个属性 // count可以用来渲染UI，dispatch可以用来触发回调 So，这样就OK了？OK了。通过一个闭包生成一个数据中心store，然后把这个store绑定到React的顶层props里面，子组件通过HOC建立与顶层props.store的联系，进而获取数据、修改数据、更新UI。这里主要讲了一下三者怎么窜在一起的，如果想了解更高级的功能，比如redux中间件、reducer拆分、connect的其他参数等，可以去看一下对应的源码。 原文链接：]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最强日期正则表达式]]></title>
    <url>%2F2018%2F04%2F14%2FJs%2F%E6%9C%80%E5%BC%BA%E6%97%A5%E6%9C%9F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[简单的日期判断（YYYY/MM/DD）：^\d{4}(\-|\/|\.)\d{1,2}\1\d{1,2}$ 演化的日期判断（YYYY/MM/DD| YY/MM/DD） ^(^(\d{4}|\d{2})(\-|\/|\.)\d{1,2}\3\d{1,2}$)|(^\d{4}年\d{1,2}月\d{1,2}日$)$ 加入闰年的判断的：实例： ^((((1[6-9]|[2-9]\d)\d{2})-(0?[13578]|1[02])-(0?[1-9]|[12]\d|3[01]))|(((1[6-9]|[2-9]\d)\d{2})-(0?[13456789]|1[012])-(0?[1-9]|[12]\d|30))|(((1[6-9]|[2-9]\d)\d{2})-0?2-(0?[1-9]|1\d|2[0-8]))|(((1[6-9]|[2-9]\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))-0?2-29-))$ 分析：1、什么是合法的日期范围？对于不同的应用场景，这个问题有不同的解释。这里采纳MSDN中的约定：DateTime值类型表示值范围在公元（基督纪元）0001 年 1 月 1 日午夜 12:00:00 到公元 (C.E.) 9999 年 12 月 31 日晚上 11:59:59 之间的日期和时间。 2、关于闰年的阐释。关于公历闰年是这样规定的：地球绕太阳公转一周叫做一回归年，一回归年长365日5时48分 46秒。因此，公历规定有平年和闰年，平年一年有365日，比回归年短0.2422日，四年共短0.9688日，故每四年增加一日，这一年有366日，就是闰年。但四年增加一日比四个回归年又多0.0312日,400年后将多3.12日,故在400年中少设3个闰年,也就是在400年中只设97个闰年，这样公历年的平均长度与回归年就相近似了。由此规定：年份是整百数的必须是400的倍数才是闰年，例如1900年、2100年就不是闰年。 首先需要验证年份，显然，年份范围为 0001 - 9999，匹配YYYY的正则表达式为： [0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3} 其中 [0-9] 也可以表示为 \d，但 \d 不如 [0-9] 直观，因此下面我将一直采用 [0-9] 用正则表达式验证日期的难点有二：一是大小月份的天数不同，二是闰年的考虑。 对于第一个难点，我们首先不考虑闰年，假设2月份都是28天，这样，月份和日期可以分成三种情况：1、月份为 1, 3, 5, 7, 8, 10, 12，天数范围为 01 - 31，匹配MM-DD的正则表达式为： (0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]) 2、月份为 4, 6, 9, 11，天数范围为 01-30，匹配MM-DD的正则表达式为： (0[469]|11)-(0[1-9]|[12][0-9]|30) 3、月份为 2，考虑平年情况，匹配MM-DD的正则表达式为： 02-(0[1-9]|[1][0-9]|2[0-8]) 根据上面的成果，我们可以得到匹配平年日期格式为YYYY-MM-DD的正则表达式： ([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))) 接着我们来解决第二个难点：闰年的考虑。根据闰年的定义，我们可以将闰年分为两类： 1、能被4整除但不能被100整除的年份。寻找后两位的变化规律，可以很快得到下面的正则匹配： ([0-9]{2})(0[48]|[2468][048]|[13579][26]) 2、能被400整除的年份。能被400整除的数肯定能被100整除，因此后两位肯定是00，我们只要保证前两位能被4整除即可，相应的正则表达式为： (0[48]|[2468][048]|[3579][26])00 2.最强验证日期的正则表达式,添加了闰年的验证 这个日期正则表达式支持YYYY-MM-DDYYYY/MM/DDYYYY_MM_DDYYYY.MM.DD的形式 match : 2008-2-29 2008/02/29 not match : 2008-2-30 2007-2-29 完整的正则表达式如下((^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(10|12|0?[13578])([-\/\._])(3[01]|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(11|0?[469])([-\/\._])(30|[12][0-9]|0?[1-9])$)|(^((1[8-9]\d{2})|([2-9]\d{3}))([-\/\._])(0?2)([-\/\._])(2[0-8]|1[0-9]|0?[1-9])$)|(^([2468][048]00)([-\/\._])(0?2)([-\/\._])(29)$)|(^([3579][26]00)([-\/\._])(0?2)([-\/\._])(29)$)|(^([1][89][0][48])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][0][48])([-\/\._])(0?2)([-\/\._])(29)$)|(^([1][89][2468][048])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][2468][048])([-\/\._])(0?2)([-\/\._])(29)$)|(^([1][89][13579][26])([-\/\._])(0?2)([-\/\._])(29)$)|(^([2-9][0-9][13579][26])([-\/\._])(0?2)([-\/\._])(29)$)) 闰年的2月份有29天，因此匹配闰年日期格式为YYYY-MM-DD的正则表达式为： (([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29 最后，将平年和闰年的日期验证表达式合并，我们得到最终的验证日期格式为YYYY-MM-DD的正则表达式为： ([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3})-(((0[13578]|1[02])-(0[1-9]|[12][0-9]|3[01]))|((0[469]|11)-(0[1-9]|[12][0-9]|30))|(02-(0[1-9]|[1][0-9]|2[0-8]))))|((([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00))-02-29) DD/MM/YYYY格式的正则验证表达式为： (((0[1-9]|[12][0-9]|3[01])/((0[13578]|1[02]))|((0[1-9]|[12][0-9]|30)/(0[469]|11))|(0[1-9]|[1][0-9]|2[0-8])/(02))/([0-9]{3}[1-9]|[0-9]{2}[1-9][0-9]{1}|[0-9]{1}[1-9][0-9]{2}|[1-9][0-9]{3}))|(29/02/(([0-9]{2})(0[48]|[2468][048]|[13579][26])|((0[48]|[2468][048]|[3579][26])00)))]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery 与 Zepto的区别]]></title>
    <url>%2F2018%2F04%2F13%2FJs%2FjQuery-%E4%B8%8E-Zepto%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[jQuery 的意义是在于抹平 DOM、BOM、CSSOM 的多浏览器差异，并统一提供接口。它不能当作 Framework（框架）被使用，而是扮演 Utility（工具）的角色。 虽然 Zepto 和 jQuery 的中的很多 API 的用法是相似的，但仍有一些 API 在用法上差异很大。下面就实际使用中遇到的场景做一下列举。 创建DOM节点并赋与属性使用 $ 操作符可以轻松创建节点并赋予属性，具体代码是 $(htmlString, attributes) ，支持链式写法。喜欢刨根问底的同学可以看看下面的文档。 jquert文档zepto文档 DOM操作的区别jquery操作ul元素时候，添加id不会生效 (function($){ $(function){ var $list = $(&#39;&lt;ul&gt;&lt;li&gt;jQuery 插入&lt;/li&gt;&lt;/ul&gt;&#39;, { id: &#39;insert-by-jquery&#39; }); $list.appendTo($(&#39;body&#39;)); } })(window.jQuery) // Result // &lt;ul&gt;&lt;li&gt;jQuery 插入&lt;/li&gt;&lt;/ul&gt; zepto操作ul元素时候，添加id会生效 zepto(function($){ var $list = $(&#39;&lt;ul&gt;&lt;li&gt;jQuery 插入&lt;/li&gt;&lt;/ul&gt;&#39;, { id: &#39;insert-by-jquery&#39; }); $list.appendTo($(&#39;body&#39;)); }) // Result // &lt;ul id=&quot;insert-by-zepto&quot;&gt;&lt;li&gt;Zepto 插入&lt;/li&gt;&lt;/ul&gt; 事件触发的区别jquery时load事件的处理函数不会执行 (function($) { $(function() { $script = $(&#39;&lt;script /&gt;&#39;, { src: &#39;http://cdn.amazeui.org/amazeui/1.0.1/js/amazeui.js&#39;, id: &#39;ui-jquery&#39; }); $script.appendTo($(&#39;body&#39;)); $script.on(&#39;load&#39;, function() { console.log(&#39;jQ script loaded&#39;);//没有打印出 }); }); })(window.jQuery); 使用 Zepto 时 load 事件的处理函数会执行 Zepto(function($) { $script = $(&#39;&lt;script /&gt;&#39;, { src: &#39;http://cdn.amazeui.org/amazeui/1.0.1/js/amazeui.js&#39;, id: &#39;ui-zepto&#39; }); $script.appendTo($(&#39;body&#39;)); $script.on(&#39;load&#39;, function() { console.log(&#39;zepto script loaded&#39;); //zepto script loaded }); }); 事件委托的区别在 Zepto 中，当 a 被点击后，依次弹出了内容为”a事件“和”b事件“的弹出框。说明虽然事件委托在.a上可是却也触发了.b上的委托。 但是在 jQuery 中只会触发 .a 上面的委托。 var $doc = $(document); // Class &#39;a&#39; bind event &#39;a&#39; $doc.on(&#39;click&#39;, &#39;.a&#39;, function () { alert(&#39;a事件&#39;); // Class &#39;a&#39; change to class &#39;b&#39; $(this).removeClass(&#39;a&#39;).addClass(&#39;b&#39;); }); // Class &#39;b&#39; bind event &#39;b&#39; $doc.on(&#39;click&#39;, &#39;.b&#39;, function () { alert(&#39;b事件&#39;); }); 原理分析 // Zepto source code $.fn.on = function(event, selector, data, callback, one) { var autoRemove, delegator, $this = this if (event &amp;&amp; !isString(event)) { // Core code $.each(event, function (type, fn) { $this.on(type, selector, data, fn, one) }) return $this } //... } 在 Zepto 中代码解析的时候，document上所有的click委托事件都依次放入到一个队列中，点击的时候先看当前元素是不是.a，符合则执行，然后查看是不是.b，符合则执行。 这样的话，就导致如果.a的事件在前面，会先执行.a事件，然后class更改成b，Zepto再查看当前元素是不是.b，以此类推。 在 jQuery 中代码解析的时候，document上委托了2个click事件，点击后通过选择符进行匹配，执行相应元素的委托事件。 这样就很好的避免了在 Zepto 中的发生的情况。 API方面的区别winth() 和 height的区别 Zepto 由盒模型(box-sizing)决定； jQuery 会忽略盒模型，始终返回内容区域的宽/高(不包含padding、border)。 解决方式就是使用 .css(&#39;width&#39;) 而不是.width() 。下面我们举个叫做《边框三角形宽高的获取》的栗子来说明这个问题。 首先用下面的 HTML 和 CSS 画了一个小三角形吧。 // html &lt;div class=&quot;caret&quot;&gt;&lt;/div&gt; // css .caret{ width:0; height:0; border-width: 0 20px 20px; border-color: transparent transparent blue; border-style: none dotted solid; } jQuery 使用 .width() 和 .css(‘width’) 都返回 ，高度也一样； Zepto 使用 .width() 返回 ，使用 .css(‘width’) 返回 0px 。所以，这种场景，jQuery 使用 .outerWidth() / .outerHeight() ；Zepto 使用 .width() / .height() 。 offSet()的区别// offset() {function} // @desc Zepto // @return top|left|width|height // @desc jQuery // @return width|height 获取隐藏元素width和height的区别Zepto 无法获取隐藏元素宽高，jQuery 可以。 extend() 的区别jQuery 在原型上拓展方法使用的方式是： // For example // Extend a function named &#39;sayHello&#39; to the protorype of jQuery (function($) { $.fn.extend({ sayHello: function() { $(this).html(&#39;Hello !&#39;); } }); })(window.jQuery); Zepto 中并没有为原型定义extend方法，所以如果要是要在 Zepto 的原型上拓展方法可以使用的方式是： // For example // Extend a function named &#39;sayHello&#39; to the protorype of Zepto Zepto(function($) { sayHello: function() { $(this).html(&#39;Hello !&#39;); } }); 随着 jQuery 2.x 的发布以及未来 3.0 对浏览器支持的划分，似乎找不到再使用 Zepto 的理由了。如果你真在乎文件大小，那你可以自行打包 jQuery 中需要的模块。这和 Zepto 是一样的，Zepto 官方提供的版本只打包了很基础的模块。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6你可能不知道的事---进阶篇]]></title>
    <url>%2F2018%2F04%2F12%2FJs%2FEs6%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B-%E8%BF%9B%E9%98%B6%E7%AF%87%2F</url>
    <content type="text"><![CDATA[正文Module模块化是一个进行很久的话题，发展历程中出现过很多模式，例如AMD,CommonJS等等。 Module是ES6的一个新特性，是语言层面对模块化的支持。 与之前模块加载机制不同，Module是动态加载，导入的变量的只读引用，而不是拷贝。 // 1. export default 可以做默认导出 // a.js export default 5; // 默认导出 // b.js import b, {a} from &#39;./a.js&#39;; // 默认导入，不需要加花括号 // 2. 动态的加载机制 // a.js export let a = 10; export let b = 10; export function add() { a = 15; b = 20; return a+b; }; // b.js import {a, b, add} from &#39;./a.js&#39;; a+b; // 20 add(); // 35 a+b; // 35 Symbolsymbol是es6的一个新特性，他有如下特点： 1.symbol是“新”的基本数据类型，从es6开始基本数据类型变成了6个，undefind,null,number,boolean,string,symbol2.symbol可以用作object的key3.symbol存在全局作用域，利用Symbol.for(key)方法，可以创建(全局作用域无指定键)或获取全局作用域的symbol；利用symbol.keyFor(sym)可以获取指定的symbol的值4.Javascript内部使用了很多内置symbol值，作为特殊的键，来实现一些内部功能；例如：symbol.iterator用于标示对象的迭代器 “新” 仅仅是针对前端开发人员来说的，其实 Symbol 概念本身已经在 JavaScript 语言内部长时间使用了`javascript// 1. “Symbol(desc)” 方法用于创建一个新的 symbol，参数 “desc” 仅用做 symbol 的描述，并不用于唯一标示 symbolSymbol(‘abc’) === Symbol(‘abc’); // false，’abc’仅作为两个 symbol 的描述信息 // 2. “Symbol.for(key)” 方法，参数 “key” 是用于在全局作用域中标示 symbol 的唯一键，同时也作为该 symbol 的描述信息Symbol.for(‘abc’) === Symbol(‘abc’); //true 左侧为创建，右侧为获取Symbol.for(‘abc’) === Symbol(‘abc’); //false // 3. symbol 无法被 for…in 遍历到 (不可枚举)，可以利用 Object.getOwnPropertySymbols 获取const obj = { [Symbol(‘abc’)]:’abc’, ‘abc’:’abc’};for(let i in obj){ console.log(i);//abc}Object.getOwnPropertySymbols(obj);//[Symbol(abc)] ## Iterator + for ...of ES6 中除了新特性外，还有一个新的规范，那就是关于迭代的规范，他包括两部分分别是 “可迭代规范（iterable protocol）” 和 “迭代器规范（iterator protocol）”。任何实现了前者的对象，都可以进行 for…of 循环。 **String,Map,Set,Array**等是原生可迭代对象，因为他们都是在原型(prototype)对象中实现了`Symbol.iterator`键对应的方法。 &gt; for...of是对对象迭代器的遍历（键和值都可以遍历），而for...in是对象可枚举值的遍历 下面用代码来解释一下两个规范： ```javascript //1.迭代器规范 const iter = { conter:0, next(){ // 迭代器是实现了 &quot;next()&quot; 函数的对象 if(++this.conter &lt; 10){ return{ // 返回一个含有两个键值对的对象，Object {done =&gt; boolean, value =&gt; any} done:false, value:this.conter } }else{ this.conter = 0; return { // done = true 时，value非必须 done : true; } } } } // 2. 可迭代规范，实现 &quot;Symbol.iterator =&gt; func()&quot; 键值对；而 &quot;func()&quot; 返回一个 迭代器对象 const iterObj = {}; for(let i of iterObj){}; iterObj[Symbol.iterator] = function(){ return iter; } for(let i of iterObj){ console.log(i);//1,2,3,4,5,6,7,8,9 } 关于集合原来我们使用集合，多数情况下会直接用 Object 代替，ES6新增了两个特性，Map 和 Set，他们是对 JavaScript 关于集合概念的补充。 Map为什么要有Map这种数据结构？直接使用Object不好吗？是不是完全可以使用Map取代object用于数据存取？ Map和Object的区别？1.Map和Object都可以用作数据存取，Map适用于存取需要常需要变化(增减键值对)或遍历的数剧集，而Object适用于存取静态（例如配置信息）的数据集2.Object的key必须是String或者symbol类型，而Map却无此限制，可以是任何值3.Map可以很方便的取到键对值的数量，而Object则需要用额外途径 SetSet作为最简单的集合，有如下特点： 1.Set可以存储任何类型的值，遍历顺序与插入顺序相同 2.Set内无重复值 // 1. Set 的构造函数可以传入一个 “可迭代的对象（例如数组）”，其中包含任意值 const first = new Set([&#39;a&#39;, 1, {&#39;b&#39;: 1}, null]); // Set {&quot;a&quot;, 1, Object {b: 1}, null} // 2. Set 无法插入重复的值 first.add(1); // Set {&quot;a&quot;, 1, Object {b: 1}, null} WeakMap + WeakSetWeakMap 与 WeakSet 作为一个比较新颖的概念，其主要特点在于弱引用。 相比于 Map 与 Set 的强引用，弱引用可以令对象在 “适当” 情况下正确被 GC 回收，减少内存资源浪费。 但由于不是强引用，所以无法进行遍历或取得值数量，只能用于值的存取（WeakMap）或是否存在值得判断（WeakSet） 在弱引用的情况下，GC 回收时，不会把其视作一个引用；如果没有其他强引用存在，那这个对象将被回收 // 1. WeakMap 键必须是对象 const err = new WeakMap([[&#39;a&#39;,1]]); // TypeError: Invalid value used as weak map key // 2. WeakMap/WeakSet 的弱引用 const wm = new WeakMap([[{&#39;a&#39;:1},1]]); // Object {&#39;a&#39;: 1} 会正常被 GC 回收 const ws = new WeakSet(); ws.add({&#39;a&#39;:1}); // Object {&#39;a&#39;: 1} 会正常被 GC 回收 const obj = {&#39;b&#39;: 1}; ws.add(obj); // Object {&#39;b&#39;: 1} 不会被正常 GC 回收，因为存在一个强引用 obj = undefined; // Object {&#39;b&#39;: 1} 会正常被 GC 回收 异步编程在 ES6 之前，JavaScript 的异步编程都跳不出回调函数这个方式。回调函数方式使用非常简单，在简单异步任务调用时候没有任何问题，但如果出现复杂的异步任务场景时，就显得力不从心了，最主要的问题就是多层回调函数的嵌套会导致代码的横向发展，难以维护；ES6 带来了两个新特性来解决异步编程的难题。 // 一个简单的多层嵌套回调函数的例子 (Node.js) const git = require(&#39;shell&#39;).git; const commitMsg = &#39;...&#39;; git.add(&#39;pattern/for/some/files/*&#39;, (err) =&gt; { if(!err){ git.commit(commitMsg, (err) =&gt; { if(!err){ git.push(pushOption); }else{ console.log(err); } }); }else{ console.log(err); } }); PromisePromise是ES6的一个新特性，ta他有如下特点： 1.本质还是回调函数2.区分成功和失败的回调，省去嵌套在内层的判断逻辑3.可以很轻松的完成回调函数模式到promise模式的转化4.代码由回调函数嵌套的横向扩展，变为链式调用的纵向扩展，便于编程和维护 promise 虽然优势颇多，但是代码结构仍与同步代码区别较大 // 上例用 Promise 实现 // 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象 const git = require(&#39;shell&#39;).git; const commitMsg = &#39;...&#39;; git.add(&#39;pattern/for/some/files/*&#39;) .then(() =&gt; git.commit(commitMsg)) .then(git.push) .catch((err) =&gt; { console.log(err); }); generatorGenerator 作为 ES6 的新特性，是一个语言层面的升级。它有以下几个特点：1.可以使用yield关键字，终止执行返回（内到外）2.可以通过next(val)方法调用重新唤醒，继续执行（外回内）3.运行时（包括挂起态），共享局部变量4.Generator 执行会返回一个结果对象，结果对象本身既是迭代器，同时也是可迭代对象（同时满足两个迭代规范），所以 Generator 可以直接用于 自定义对象迭代器 由于具备以上特点（第四点除外），Generator 也是 JavaScript 对 协程（coroutine）的实现，协程可以理解为 “可由开发人员控制调度的多线程” 协程按照调度机制来区分，可以分为对称式和非对称式 非对称式：被调用者（协程）挂起时，必须将控制权返还调用者（协程） 对称式：被调用者（协程）挂起时，可将控制权转给 “任意” 其他协程 JavaScript 实现的是 非对称式协程（semi-coroutine）；非对称式协程相比于对称式协程，代码逻辑更清晰，易于理解和维护 协程给 JavaScript 提供了一个新的方式去完成异步编程；由于 Generator 的执行会返回一个迭代器，需要手动去遍历，所以如果要达到自动执行的目的，除了本身语法外，还需要实现一个执行器，例如 TJ 大神的 co 框架。 // 上例用 Generator 实现 // 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象 const co = require(&#39;co&#39;); const git = require(&#39;shell&#39;).git; co(function* (){ const commitMsg = &#39;...&#39;; // 共享的局部变量 yield git.add(&#39;pattern/for/some/files/*&#39;); yield git.commit(commitMsg); yield git.push(); }).catch((err) =&gt; { console.log(err); }); Generator 是一个 ES6 最佳的异步编程选择么？显然不是，因为除了基本语法外，我们还要额外去实现执行器来达到执行的目的，但是它整体的代码结构是优于回调函数嵌套和 Promise 模式的。 Async-Await这并不是一个 ES6 新特性，而是 ES7 的语法，放在这里是因为它将是 JavaScript 目前支持异步编程最好的方式 // 上例用 async-await 实现 // 假定 git.add, git.commit, git.push 均做了 Promise 封装，返回一个 Promise 对象 const git = require(&#39;shell&#39;).git; (async function(){ const commitMsg = &#39;&#39;; //共享局部变量 try(){ await git.add(&#39;pattern/for/some/files/*&#39;); await git.commit(commitMsg); await git.push(); }catch(err){ console.log(err); } })() 元编程元编程是指的是开发人员对 “语言本身进行编程”。一般是编程语言暴露了一些 API，供开发人员来操作语言本身的某些特性。ES6 两个新特性 Proxy 和 Reflect 是 JavaScript 关于对象元编程能力的扩展。 proxyProxy 是 ES6 加入的一个新特性，它可以 “代理” 对象的原生行为，替换为执行自定义行为。 这样的元编程能力使得我们可以更轻松的扩展出一些特殊对象。 任何对象都可以被“代理” 利用 Proxy.revocable(target, handler) 可以创建出一个可逆的 “被代理” 对象 // 简单 element 选择控制工具的实现 const cacheElement = function(target, prop) { if(target.hasOwnProperty(prop)){ return target[prop]; }else{ return target[prop] = document.getElementById(prop); } } const elControl = new Proxy(cacheElement, { get: (target, prop) =&gt; { return cacheElement(target, prop); }, set: (target, prop, val) =&gt; { cacheElement(target, prop).textContent = val; }, apply: (target, thisArg, args) =&gt; { return Reflect.ownKeys(target); } }); elControl.first; // div#first elControl.second; // div#second elControl.first = 5; // div#first =&gt; 5 elControl.second = 10; // div#second =&gt; 10 elControl(); // [&#39;first&#39;, &#39;second&#39;] ReflectES6 中引入的 Reflect 是另一个元编程的特性，它使得我们可以直接操纵对象的原生行为。Reflect 可操纵的行为与 Proxy 可代理的行为是一一对应的，这使得可以在 Proxy 的自定义方法中方便的使用 Reflect 调起原生行为 // 1. Proxy 的自定义方法中，通过 Reflect 调用原生行为 const customProxy = new Proxy({ &#39;custom&#39;: 1 }, { get: (target, prop) =&gt; { console.log(`get ${prop} !`); return Reflect.get(target, undefined, prop); } }); customProxy.custom; // get custom, 1 // 2. 与 Object 对象上已经开放的操作原生行为方法相比，语法更加清晰易用（例如：Object.hasOwnProperty 与 Reflect.has） const symb = Symbol(&#39;b&#39;); const a = { [symb]: 1, &#39;b&#39;: 2 }; if(Reflect.has(a, symb) &amp;&amp; Reflect.has(a, &#39;b&#39;)){ // good console.log(&#39;good&#39;); } Reflect.ownKeys(a); // [&quot;b&quot;, Symbol(b)] 进阶阅读如果你关注兼容性，推荐看：https://kangax.github.io/compat-table/es6/，这里介绍了从 ES5 到 ES2016+ 的所有特性（包括仍未定稿的特性）及其在各环境的兼容性 如果你关注性能，推荐看：http://kpdecker.github.io/six-speed/，这里通过性能测试，将 ES6 特性的原生实现与 ES5 polyfill 版本进行对比，覆盖了各主流环境；同时也可以侧面对比出各环境在原生实现上的性能优劣 如果你想全面了解特性，推荐看：https://developer.mozilla.org/en-US/docs/Web/JavaScript，覆盖特性的各方面，包括全面的 API（包括不推荐和废弃的）和基础用法 如果你想看特性更多的使用示例和对应的 polyfill 实现，推荐看：http://es6-features.org/#Constants，这里对各个特性都给出了使用丰富的例子和一个 polyfill 实现，简单明了 如果想了解 ECMA Script 最多最全面的细节，英语又比较过硬，推荐在需要时看：http://www.ecma-international.org/publications/files/ECMA-ST/Ecma-262.pdf，（或者直接看最新的：https://tc39.github.io/ecma262/） 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6你可能不知道的事---基础篇]]></title>
    <url>%2F2018%2F04%2F11%2FJs%2FEs6%E4%BD%A0%E5%8F%AF%E8%83%BD%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%8B-%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[ES6，或许应该叫 ES2015（2015 年 6 月正式发布），对于大多数前端同学都不陌生。 正文let + const这个大概是开始了解 ES6 后，我们第一个感觉自己完全明白并兴致勃勃的开始使用的特性。 // 定义常量 const REG_GET_INPUT = /^\d{1,3}$/; // 定义配置项 let config = { isDev : false, pubDir: &#39;./admin/&#39; } // 引入 gulp let gulp = require(&#39;gulp&#39;); // 引入gulp相关插件 let concat = require(&#39;gulp-concat&#39;); let uglify = require(&#39;gulp-uglify&#39;); let cssnano = require(&#39;gulp-cssnano&#39;); 很多人看完概念之后，第一印象都是：“const 是表示不可变的值，而 let 则是用来替换原来的 var 的。” 所以就会出现上面代码中的样子；一段代码中出现大量的 let，只有部分常量用 const 去做定义，这样的使用方式是错误的。 你可能不知道的事const 的定义是不可重新赋值的值，与不可变的值(immutable value)不同；const 定义的 Object，在定义之后仍可以修改其属性。 所以其实他的使用场景很广，包括常量、配置项以及引用的组件、定义的 “大部分” 中间变量等，都应该以const做定义。反之就 let 而言，他的使用场景应该是相对较少的，我们只会在 loop(for，while 循环)及少量必须重定义的变量上用到他。 猜想：就执行效率而言，Const由于不可重新赋值，所以可以做更多语法静态分析方面的优化，从而有更高的执行效率 所以上面代码中，所有使用 let 的部分，其实都应该是用 const 的。 Template Strings（字符串模板）字符串模板是我刚接触ES6时最喜欢的特性之一，他语法简洁，语义明确，而且很好的解决了之前字符串拼接麻烦的问题我们先来看看他的一般使用场景： const start = &#39;hi all&#39;; const getName = () =&gt; { return &#39;jelly&#39;; }; const conf = { fav: &#39;Coding&#39; }; // 模板 const msg = `${start}, my name is ${getName()}, ${conf.fav} is my favourite`; 你可能不知道的事// 1. 与引号混用 const wantToSay = `I&#39;m a &quot;tbfed&quot;`; // 2. 支持多行文本 const slogan = ` I have a dream today! `; // 比较适合写HTML const resultTpl = ` &lt;section&gt; &lt;div&gt;...&lt;/div&gt; &lt;/section&gt; `; Enhanced Object Literals（增强的对象字面量）增强的对象字面量是 ES6 中的升华功能，他设计了很多简写，这些简写不但保留了明确的语义，还减少了我们多余的代码量。 当他的使用成为一个习惯时，我们会看到自己代码变得更为优雅。 你可能不知道的事const _bookNum = 4; const basicConfig = { level: 5 } const config = { // 直接指定原型对象 __proto__: basicConfig, // 属性简写 相当于_bookNum:_bookNum _bookNum, // 方法简写 //相当于 getBookNum:function(){..} getBookNum() { return this.bookNum; } } Arrows and Lexical This（箭头函数）箭头函数是ES6中的一个新的语法特性，他的用法简单，形态优雅，备受人们青睐。大多数同学初识这个特性时，更多的仅仅用它作为函数定义的简写，这其实就有些屈才了。 // 未使用箭头函数的写法 { ... addOptions: function (options) { var self = this; options.forEach(function(name, opts){ self[name] = self.addChild(name, opts); }); } } // 使用箭头函数后的写法 { ... addOptions: function (options) { options.forEach((name, opts) =&gt; { this[name] = this.addChild(name, opts); }); } } 可以注意到上下两段代码的区别。 在未使用箭头函数前，我们在过程函数中使用父级 this，需要将其显式缓存到另一个中间变量中，因为过程函数有独立的 this 变量，会覆盖父级；使用箭头函数后，不但简写了一个过程函数（ forEach 的参数），还省略掉了 this 的中间变量的定义。 原因：箭头函数没有独立执行上下文（ this ），所以其内部引用 this 对象会直接访问父级。 当然，从这块我们也可以看出，箭头函数是无法替代全部 function 的使用场景的，例如我们需要有独立 this 的函数。 你可能不知道的事 箭头函数不但没有独立的this，他也没有独立的arguments，所以如果需要取不定参的时候，要么使用 function，要么用 ES6 的另一个新特性 rest（具体在 rest 中会有详解）。 箭头函数语法很灵活，在只有一个参数或者只有一句表达式做方法体时，可以省略相应括号。 // 完整写法 const getOptions = (name, key) =&gt; { ... } // 省略参数括号 const getOptions = key =&gt; { ... } // 省略参数和方法体括号 const getOptions = key =&gt; console.log(key); // 无参数或方法体，括号不能省略 const noop = () =&gt; {}; 有个简单小栗子，这一灵活的语法在写连续的Promise链式调用时，可以使代码更加优雅 gitPromise .then(() =&gt; git.add()) .then(() =&gt; git.commit()) .then(() =&gt; git.log()) .then((msg) =&gt; { ... }) .then(() =&gt; git.push()) .catch((err) =&gt; { utils.error(err); }); Destructuring（解构）解构这个特性可以简单解读为分别定义，用于一次定义多个变量，常常用于分解方法返回对象为多个变量，分别使用。使用过ES6的同学应该或多或少接触过这个特性，但是你可能不知道它如下几个用法： 你可能不知道的事const bookSet = [&#39;UED&#39;, &#39;TB fed&#39;, &#39;Not find&#39;]; const bookCollection = () =&gt; { return {book1: &#39;UED&#39;, book2: &#39;TB fed&#39;}; }; // 1. 解构也可以设置默认值 const {book1, book3 = &#39;Not find&#39;} = bookCollection(); // 2. 解构数组时候是可以跳过其中某几项的 const [book1,,book3] = bookSet; // book1 = &#39;UED&#39;, book3 = &#39;Not find&#39; // 3. 解构可以取到指定对象的任何属性，包括它包含的方法 const {length: setLength} = bookSet; // setLength = 3 Rest + SpreadRest 和 Spread 主要是应用 ... 运算符，完成值的聚合和分解。 你可能不知道的事 // 1. rest 得到的是一个真正的数组而不是一个伪数组 const getOptions = function(...args){ console.log(args.join); // function }; // 2. rest 可以配合箭头函数使用，达到取得所有参数的目的 const getOptions = (...args) =&gt; { console.log(args); // array }; // 3. spread 可以用于解构时，聚合所得的值 const [opt1, ...opts] = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]; // 4. spread 可以用于数组定义 const opts = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;, &#39;four&#39;]; const config = [&#39;other&#39;, ...opts]; ClassesES6 中实现的一个语法糖，用于简化基于原型集成实现类定义的场景。虽然有很多人不太喜欢这个特性，认为它作为一个简单增强扩展，并没有其他语言 class 应有的特点。但是就我自己观点来看，还是感觉这样一种写法确实比原有的原型继承的写法语义更清晰、明确，而且语法更简单。 同样，可能有些用法是你之前容易忽略掉的，在此做个补充。 你可能不知道的事// 1. 静态变量 // ES6 的类定义实现了静态方法的定义，但静态变量呢？ // 可以用如下方式实现: class TbFedMembers{ static get HuaChen(){ return &#39;jelly&#39;; } } TbFedMembers.HuaChen; // &quot;化辰&quot; // 2. 私有属性（私有属性有多种实现方式，只谈及其中一种） // 闭包 const TbFedMembers = (() =&gt; { const HuaChen = &#39;jelly&#39;; return class{ getOneMemberName(){ return HuaChen; } }; })(); PromisesPromise 不只是一个对象、一个语法，他更是一种异步编程方式的变化相信使用过 ES6 的同学都已经开始尝试了 Promise，甚至在不支持ES6的时候，已经开始使用一些基于 Promise 思想的开源框架。 那么我们之前用 Promise 究竟用的对么？有什么需要注意的点呢？ 你可能不知道的事 // 1. 多个异步任务同时执行用 Promise.all，顺序执行使用链式调用 // Promise.all Promise .all([jsBuildPromise, cssBuildPromise]) .then(() =&gt; { ... }); // chain jsBuildPromise .then(() =&gt; cssBuildPromise) .then(() =&gt; { ... }); // 2. Promise 的链式调用需要每一个过程返回一个 Promise 对象才能保证顺序执行 gitPromise .then(() =&gt; git.add()) // 正确，箭头函数简写 .then(() =&gt; { git.commit(); // 错误，函数返回 undefined，会立即执行下一过程 }) .then(() =&gt; { return git.log(); // 正确 }); // 3. Promise 需要调用 catch 方法来捕获错误，而且过程内的错误不会阻塞后续代码执行 new Promise(() =&gt; { f; // not define error ! }) .catch((err) =&gt; { console.log(err) // show &#39;f is not define&#39; }); console.log(&#39;error test&#39;); // 此行可以被正常执行 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是作用域和执行上下文]]></title>
    <url>%2F2018%2F04%2F09%2FJs%2F%E4%BB%80%E4%B9%88%E6%98%AF%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87%2F</url>
    <content type="text"><![CDATA[作用域首先我们说下作用域，简单地来说作用域指的是一个区域，里面包括变量，函数，常量等等定义信息和赋值信息，以及这个区域内代码书写的结构信息。作用域可以嵌套，我们通常知道js函数内是可以产生作用域的。下面我们用具体代码来示例下： 全局作用域（global scope）里面定义了两个变量，一个函数。walk 函数生成的作用域里面定义了一个变量，两个函数。innerFunc 和 anotherInnerFunc 这两个函数生成的作用域里面分别定义了一个变量。在规范中作用域更官方的叫法是词法环境（Lexical Environments）。什么意思？就是作用域包含哪些内容取决于你代码怎么写，你把定义 go 变量写在了 walk 函数里面，那么 go 变量就属于walk 函数作用域。 作用域其实由两部分组成(全局作用域，局部作用域)1.记录作用域内变量信息（我们假设变量，常量，函数等统称为变量）和代码结构信息的东西，称之为 Environment Record。2.一个引用 __outer__，这个引用指向当前作用域的父作用域。拿上面代码为例。innerFunc 的函数作用域有一个引用指向 walk 函数作用域，walk 函数作用域有一个引用指向全局作用域。全局作用域的 __outer__为 null。 生成作用域的语法 1.函数声明 function f(){ var inner = &#39;inner&#39;; console.log(inner); } f();//inner console.log( inner );//Uncaught ReferenceError: inner is not defined 2.catch语句 try { throw new Error( &#39;customized error&#39; ); } catch( err ) { var iamnoterror = &#39;not error&#39;; console.log( iamnoterror ); // not error console.log( err ); // Error: customized error } console.log( iamnoterror ); // not error console.log( err ); // Uncaught ReferenceError: e is not defined catch语句生成的作用域只会框住参数部分的变量，使其不能在外部访问。对于 catch 语句体里面声明的变量并不起作用 3.语句块 if ( true ) { let bv = &#39;bv&#39;; const B_C = &#39;BC&#39;; let blockFunc = function() {} function notBlockFunc() {} console.log( bv ); // bv console.log( B_C ); // BC console.log( notBlockFunc ); // function notBlockFunc() {} console.log( blockFunc ); // function () {} } console.log( bv ); // Uncaught ReferenceError: bv is not defined console.log( B_C ); // Uncaught ReferenceError: B_C is not defined console.log( notBlockFunc ); // function notBlockFunc() {} console.log( blockFunc ); // ReferenceError: blockFunc is not defined 语句块 {} 会生成一个新的作用域，但是这个作用域只绑定块级变量，常量等，即 let，const 声明的属于块级作用域，而 var 声明的还是属于块级作用域的父作用域。 执行上下文（execution context）执行上下文是用于跟踪代码的运行情况，其特征如下: 一段代码块对应一个执行上下文，被封装成函数的代码被视作一段代码块，或者全局作用域也被视作一个代码块。 当程序运行，进入到某段代码块时，一个新的执行上下文被创建，并被放入一个 stack 中。当程序运行到这段代码块结尾后，对应的执行上下文被弹出 stack 当程序在某段代码块中运行到某个点需要转到了另一个代码块时（调用了另一个函数），那么当前的可执行上下文的状态会被置为挂起，然后生成一个新的可执行上下文放入 stack 的顶部。 stack 最顶部的可执行上下文被称为 running execution context。当顶部的可执行上下文被弹出后，上一个挂起的可执行上下文继续执行。 我们用代码来示例下（从 outer 调用到 level1 调用，再逐层返回）： 执行上下文对象的内部属性： [[code evaluation]]：当前代码块执行的状态：prerform，suspend，resume。 [[Function]]：如果当前执行上下文对应的是一个函数，那么这个属性就保存的这个函数对象。如果对应的是全局环境（可以是一个 script 或者 module），属性值是 null。 [[Real]]：类似与沙箱的概念？（我还没有看懂，不过不太影响此篇的内容） 如果程序执行到某个点抛出异常了，那么我们可以用这个记录执行上下文的 stack 来追踪到底哪里出错了，可以看到整个调用栈，此时内部属性 [[Function]] 就起到作用了： 如果程序执行到某个点抛出异常了，那么我们可以用这个记录执行上下文的 stack 来追踪到底哪里出错了，可以看到整个调用栈，此时内部属性 [[Function]] 就起到作用了： 作用域与执行上下文的关系因为在一个函数被执行时，创建的执行上下文对象除了保存了些代码执行的信息，还会把当前的作用域保存在执行上下文中，所以他们的关系只是存储关系。 变量查找结合作用域和执行上下文，我们再来看下变量查找的过程。其实第一步不是到作用域里面找 Environment Record，而是先从当前的执行上下文中找保存的作用域（对象），然后再是通过作用域链向上查找变量。而且同一个执行上下文保存的作用域（对象）是可变的，当代码在同一个执行上下文中执行的时候，如果碰到有必要生成一个新作用域的时候，这个新的作用域会被添加到作用域链的头部，然后执行上下文就保存的作用域对象就更新成这个新的作用域。等这个新的作用域生命周期完成后，作用域链又会恢复到之前的状况，然后执行上下文保存的作用域也会恢复成之前的 this网上有把执行上下文等同于 this 的文章，其实 this 的值是通过当前执行上下文中保存的作用域（对象）来获取到的，规范如下。 ResolveThisBinding ( )The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context. ResolveThisBinding performs the following steps: 1.Let envRec be GetThisEnvironment( ). 2.Return envRec.GetThisBinding(). 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[props 和 state 的区别]]></title>
    <url>%2F2018%2F04%2F08%2FReact%2Fprops-%E5%92%8C-state-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[react是基于状态实现对DOM控制和渲染。组件状态可分为两种：一种是组件间的状态传递，另一种是组件的内部状态。这两种状态使用props和state表示。props用于父组件向子组件的数据传递，组件内部也有自己的状态：state，这些状态只能在组件内部修改。 数据流与propsreact的数据流是单向的，只会从父组件传递到子组件。属性props（properties）是父子组件进行传递状态的接口。React会向下遍历整个组件树，并重新渲染使用这个属性的组件。 设置props可以在组件挂载时设置props var sites = [{title:&#39;baidu.com&#39;}]; &lt;ListSites sites = {sites}/&gt; 也可以通过调用组件实例的SetProps()方法设置props var sites = [{title:&#39;baidu.com&#39;}]; ReactDOM.render( &lt;ListSites/&gt;, document.getElementById(&#39;example&#39;) ) SetProps()方法只能用于组件外部调用，不能在组件内使用this.SetProps()修改组件属性。组件内部的this.props是只读的，只能用于访问props属性，不能修改组件自身的属性。 JSX语法中的属性设置JSX语法中，props可以设置为字符串： &lt;a href=&quot;http://itbilu.com&quot;&gt;IT笔录&lt;/a&gt; 或是通过{}语法设置： var obj = {url:&#39;itbilu.com&#39;, name:&#39;IT笔录&#39;}; &lt;a href=&quot;http://{obj.url}&quot;&gt;{obj.name}&lt;/a&gt; JSX还支持将props直接设置为一个对象： class Site extends React.Component{ render(){ var obj = ({url:&#39;baidu.com&#39;,name:&#39;IT笔录&#39;}) return( &lt;Site {...obj}/&gt; ) } } props还可以用来添加事件处理： var saveBtn = React.createClass({ render:function(){ &lt;a onClick={this.handleClick}&gt;保存&lt;/a&gt; } handleClick:function(){ //... } }) props的传递组件接收上级组件的props，并传递到下级组件，如： var myCheackBox = React.createClass ({ render:myCheackBox(){ var myClass = this.props.cheacked ? &#39;MyCheacked&#39;:&#39;MyCheackBox&#39;; return( &lt;div className = {myClass} onClick = {this.props.onClick}&gt; {this.props.children} &lt;/div&gt; ) } }) React.render( &lt;MyCheackBox cheacked = {true} onClick = {console.log.bind(console)}&gt; hello world &lt;MyCheackBox/&gt;, document.getElementById(&#39;example&#39;) ) 组件内部状态与Stateprops可以理解为父子组件的状态传递，而React有自己内部的状态，这个内部状态则用State表示。 如，用state定义一个组件的状态： var SiteDropdown = React.createClass({ getInitalState: function() { return: { showOptions: false } } render:function(){ var opts; if(this.state.showOptions){ &lt;ul&gt; &lt;li&gt;itbilu.com&lt;/li&gt; &lt;li&gt;yijiebuyi.com&lt;/li&gt; &lt;li&gt;niefengjun.cn&lt;/li&gt; &lt;/ul&gt; }; return( &lt;div onClick={this.handleClick} &gt; &lt;/div&gt; ) }, handleClick:function(){ this.SetState ({ showOptions: true }) } } }) 随着state的变化，render也会调用，react会对比render返回的值，如果有变化就会DOM；state与props类似，只能通过setState()方法修改。不同的是，state只能在组件内部使用，其实是对组件本身状态的一个引用 props与state的比较React会根据props和state更新视图状态，虽然二者有相似之处，但是两者的应用范围不同。具体表现如下： props会在整个组件数中传递数据和配置，props可以设置任命类型的数据，应该把当作组件的数据源。其不但可以用于上级组件与下级组件的通信，也可以用作事件处理器 state只能组件内部使用，state只应该用于存储简单的视图状（如：上面示例用于控制下拉框的可见状态） props与state都不能直接修改，而应该分别使用SetProps()和SetProps()修改 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React：组件生命周期]]></title>
    <url>%2F2018%2F04%2F04%2FReact%2FReact%EF%BC%9A%E7%BB%84%E4%BB%B6%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[在组件的整个生命周期中，随着该组件的props或者state发生改变，其DOM表现也会有相应的变化。一个组件就是一个状态机，对于特定地输入，它总返回一致的输出。 一个React组件的生命周期分为三个部分：实例化、存在期和销毁时。 实例化当组件在客户端被实例化，第一次被创建时，以下方法依次被调用： 1、getDefaultProps2、getInitialState 1、2步骤使用Es6语法则为 constructor(props){ super(props); this.state = {} } 3、componentWillMount4、render5、componentDidMount 当组件在服务端被实例化，首次被创建时，以下方法依次被调用：1、getDefaultProps2、getInitialState3、componentWillMount4、render componentDidMount 不会在服务端被渲染的过程中调用。 getDefaultProps对于每个组件实例来讲，这个方法只会调用一次，该组件类的所有后续应用，getDefaultPops 将不会再被调用，其返回的对象可以用于设置默认的 props(properties的缩写) 值。 var Hello = React.createClass({ getDefaultProps:function(){ return{ name : &quot;tom&quot;, git : &quot;dwqs&quot; } }, render : function(){ return{ &lt;div&gt;Hello,{this.props.name},git username is {this.props.git}&lt;/div&gt; } } }) ReactDOM.render(&lt;Hello/&gt;,document.body) 也可以在挂载组件的时候设置 props： var data = [{title:&#39;Hello&#39;}]; &lt;Hello data={data}/&gt;&gt; 或者调用 setProps （一般不需要调用）来设置其 props var data = [{title:&#39;data&#39;}]; var Hello = ReactDOM.render(&lt;/Demo&gt;,document.body); Hello.setProps({data:data}) 但只能在子组件或组件树上调用 setProps。别调用 this.setProps 或者 直接修改 this.props。将其当做只读数据。 React通过 propTypes 提供了一种验证 props 的方式，propTypes 是一个配置对象，用于定义属性类型： var survey = React.createClass({ propTypes:{ survey:React.propTypes.shape({ id: React.propType.number.isRequered; }).isRequiered, onClick:React.propTypes.func, name: React.propTypes.string, score: React.propTypes.array //... }, // ... }) 组件初始化时，如果传递的属性和 propTypes 不匹配，则会打印一个 console.warn 日志。如果是可选配置，可以去掉.isRequired。propTypes 的详解可戳此 getInitalState对于组件的每个实例来说，这个方法的调用getInitalState有且只有一次，getInitalState用来初始化每个实例的 state，在这个方法里，可以访问组件的 props。每一个React组件都有自己的 state，其与 props 的区别在于 state只存在组件的内部，props 在所有实例中共享。 getInitialState 和 getDefaultPops 的调用是有区别的，getDefaultPops 是对于组件类来说只调用一次，后续该类的应用都不会被调用，而 getInitialState 是对于每个组件实例来讲都会调用，并且只调一次 var LikeButton = React.createClass({ getInitalState:function(){ return {liked :false} } handleClick:function(event){ this.setState({liked : !this.state.liked}) } render:function(){ var text = this.state.liked ? &#39;liked&#39; : &#39;dont like&#39; return( &lt;p onClick = {this.handleClick}&gt; you {text} this book; &lt;/p&gt; ) } }) ReactDOM.render( &lt;LikeButton /&gt;, document.getElementById(&#39;example&#39;) ); 每次修改 state，都会重新渲染组件，实例化后通过 state 更新组件，会依次调用下列方法 1、shouldComponentUpdate2、conponentWillUpdate3、render4、conponentDidUpdate 但是不要直接修改 this.state，要通过 this.setState 方法来修改。 componentWillMount在首次渲染执行前立即调用且仅调用一次。如果在这个方法内部调用 setState 并不会触发重新渲染，这也是在 render 方法调用之前修改 state 的最后一次机会。 render该方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法需要满足下面几点： 1.只能通过this.state和this.props访问数据（不能修改）2.可以返回null和false 或者任何React组件3.只能出现一个顶级组件，不能返回一组元素4.不能改变组件的状态5.不能修改Dom的输出 render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。react之所以效率高，就是这个原因。 componentDidMount该方法不会在服务端被渲染的过程中调用。该方法被调用时，已经渲染出真实的 DOM，可以再该方法中通过 this.getDOMNode() 访问到真实的 DOM(推荐使用 ReactDOM.findDOMNode())。 var data = [..]; var comp = React.createClass({ render: function(){ return &lt;imput .. /&gt; }, conponentDidMount: function(){ $(this.getDOMNode()).autoComplete({ src: data }) } }) 由于组件并不是真实的 DOM 节点，而是存在于内存之中的一种数据结构，叫做虚拟 DOM （virtual DOM）。只有当它插入文档以后，才会变成真实的 DOM 。有时需要从组件获取真实 DOM 的节点，这时就要用到 ref 属性 var Aera = React.createClass ({ render:function(){ this.getDOMNode();//render调用时，这里未挂载，会报错 return( return &lt;canvas ref=&#39;mainCanvas&#39;&gt; ) }， componentDidMount: function(){ var canvas = this.refs.mainCanvas.getDOMNode(); //这是有效的，可以访问到 Canvas 节点 } }) 需要注意的是，由于 this.refs.[refName] 属性获取的是真实 DOM ，所以必须等到虚拟 DOM 插入文档以后，才能使用这个属性，否则会报错 存在期此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用1、componentWillReceiveProps2、shouldComponentUpdate3、componentWillUpdate4、render5、componentDidUpdate componentWillReceiveProps组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。 componentWillReceliveProps:function(nextProps){ if(nextProps.click !== undefined){ this.setState({ checked: nextProps.checked }) } } shouldComponentUpdate如果你确定组件的 props 或者 state 的改变不需要重新渲染，可以通过在这个方法里通过返回 false 来阻止组件的重新渲染，返回 false则不会执行 render 以及后面的 componentWillUpdate，componentDidUpdate方法。 该方法是非必须的，并且大多数情况下没有在开发中使用。 shouldComponentUpdate: function(nextProps, nextState){ return this.state.checked === nextState.checked; //return false 则不更新组件 } componentWillUpdate这个方法和 componentWillMount 类似，在组件接收到了新的 props 或者 state 即将进行重新渲染前，componentWillUpdate(object nextProps, object nextState) 会被调用，注意不要在此方面里再去更新 props 或者 state。 componentDidUpdate这个方法和 componentDidMount 类似，在组件重新被渲染之后，componentDidUpdate(object prevProps, object prevState) 会被调用。可以在这里访问并修改 DOM。 销毁期componentWillUnmount每当React使用完一个组件，这个组件必须从 DOM 中卸载后被销毁，此时 componentWillUnmout 会被执行，完成所有的清理和销毁工作，在 conponentDidMount 中添加的任务都需要再该方法中撤销，如创建的定时器或事件监听器。 当再次装载组件时，以下方法会被依次调用：1、getInitialState2、componentWillMount3、render4、componentDidMount 反模式在 getInitialState 方法中，尝试通过 this.props 来创建 state 的做法是一种反模式。 //反模式 getDefaultProps: function(){ return { data: new Date() } }, getInitialState: function(){ return { day: this.props.date - new Date() } }, render: function(){ return &lt;div&gt;Day:{this.state.day}&lt;/div&gt; } 经过计算后的值不应该赋给 state，正确的模式应该是在渲染时计算这些值。这样保证了计算后的值永远不会与派生出它的 props 值不同步。 getDefaultProps: function(){ return { data: new Date() } }, render: function(){ var day = this.props.date - new Date(); return &lt;div&gt;Day:{day}&lt;/div&gt; } 如果只是简单的初始化 state，那么应用反模式是没有问题的。 总结下面的一张图总结组件的生命周期： 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Context API详解]]></title>
    <url>%2F2018%2F04%2F03%2FReact%2FContext-API%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[React在版本16.3-alpha里引入了新的Context API，社区一片期待之声。我们先通过简单的例子，看下新的Context API长啥样，然后再简单探讨下新的API的意义。 Demo地址 看下新的Context API需要安装16.3-alpha版本的react。下面，直接来看代码，如果用过react-redux应该会觉得很眼熟。首先，创建context实例： import React from &#39;react&#39;; import ReactDOM from &#39;react-dom&#39;; // 创建context实例 const ThemeContext = React.createContext({ background: &#39;red&#39;, color: &#39;white&#39; }); 然后，定义App组件，注意这里用到了Provider组件，类似react-redux的Provider组件 class App extends React.Component { render () { return ( &lt;ThemeContext.Provider value={{background: 'green', color: 'white'}}&gt; &lt;Header /&gt; &lt;/ThemeContext.Provider&gt; ); } } 接下来，定义Header、Title组件。注意： Title组件用到了Consumer组件，表示要消费Provider传递的数据。Title组件是App的孙组件，但跳过了Header消费数据。 class Header extends React.Component { render () { return ( &lt;Title&gt;Hello React Context API&lt;/Title&gt; ); } } class Title extends React.Component { render () { return ( &lt;ThemeContext.Consumer&gt; {context =&gt; ( &lt;h1 style={{background: context.background, color: context.color}}&gt; {this.props.children} &lt;/h1&gt; )} &lt;/ThemeContext.Consumer&gt; ); } } 最后常规操作 ReactDOM.render( &lt;App /&gt;, document.getElementById(&#39;container&#39;) ); 为什么有新的Context API过redux + react-redux的同学，应该会觉得新的Context API很眼熟。而有看过react-redux源码的同学就知道，react-redux本身就是基于旧版本的Context API实现的。 既然已经有了现成的解决方案，为什么还会有新的Context API呢？ 现有Context API的实现存在一定问题：比如当父组件的shouldComponentUpdate性能优化，可能会导致消费了context数据的子组件不更新。1.降低复杂度：类似redux全家桶这样的解决方案，给项目引入了一定的复杂度，尤其是对方案了解不足的同学，遇到问题可能一筹莫展。2.新Context API的引入，一定程度上可以不少项目对redux全家桶的依赖。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react 16.3新特性]]></title>
    <url>%2F2018%2F04%2F02%2FReact%2Freact-16-3%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Context APIContext API总是很让人迷惑。这个API是官方的，但是官方又不希望开发者们使用这个API，说是这个API会在以后发生改变。现在就是那个改变的时刻。新的API已经被merge了。而且它看起来更加的“用户友好”了。尤其是你不得不使用redux、mobx的时候，可以选择新的Context API实现更加简单的状态管理。 新的API用起来非常的简单：React.createContext()，这样就创建了两个组件： import {context} from &#39;react&#39;; const ThemeContext = createContext({ background: &#39;yellow&#39;, color: &#39;white&#39; }); 调用createContext方法会返回两个对象，一个是Provider，一个是Consumer。 那个Provider是一个特殊的组件。它可以用来给子树里的组件提供数据。一个例子： class Application extends React.Component { render() { &lt;ThemeContext.Provider value={{background: 'black', color: 'white'}}&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;Footer /&gt; &lt;/ThemeContext.Provider&gt; } } 上例展示了如何传递“theme” context的。当然这些值可以是动态的（比如，基于this.state）。 下一步就是使用Consumer。 const Header = () =&gt; { &lt;ThemeContext.Consumer&gt; {(context) =&gt; { return ( &lt;p style={{background: context.background, color: context.color}}&gt; Welcome! &lt;/p&gt; ); }} &lt;/ThemeContext.Consumer&gt; } 接下来，定义Header、Title组件。注意： Title组件用到了Consumer组件，表示要消费Provider传递的数据。Title组件是App的孙组件，但跳过了Header消费数据。 class Header extends React.Component { render () { return ( &lt;Title&gt;Hello React Context API&lt;/Title&gt; ); } } class Title extends React.Component { render () { return ( &lt;ThemeContext.Consumer&gt; {context =&gt; ( &lt;h1 style={{background: context.background, color: context.color}}&gt; {this.props.children} &lt;/h1&gt; )} &lt;/ThemeContext.Consumer&gt; ); } } 如果在render Consumer的时候没有嵌套在一个Provider里面。那么就会使用createContext方法调用的时候设置的默认值。 注意：Consumer必须可以访问到同一个Context组件。如果你要创建一个新的context，用的是同样的入参，那么这个新建的context的数据是不可访问的。因此，可以把Context当做一个组件，它可以创建一次，然后可以export，可以import。 这个新的语法用了function as child模式（有时也叫做render prop模式）。如果不是很熟悉这个模式，那么推荐你看一下这些文章。新的API不再要求你声明contextProps了。Context传递的数据和Context.Provider组件的value属性是一样的。对Provider数据的修改会引起所有的消费者（consumer）重绘。 新的声明周期方法参考这个RFC。新的声明周期方法会被引入，而旧的会被废弃。 这一改变主要是为了强制推行最佳实践。你可以看看这篇文章来了解一下为什么这些生命周期方法会变得很诡异。这些最佳模式在React 16的异步绘制模式(Async Mode)下显得非常重要。 要被废弃的方法：componentWillMount–&gt;使用componentDidMount代替componentWillUpdate–&gt;使用componentDidUpdate代替componentWillReceiveProps–&gt;使用一个新的方法：static getDerivedStateFromProps来代替。 不过这些并不会立刻发生，他们可以用到React 16.4。在React 17里将被彻底移除。如果你开启了StrictMode或者AsyncMode，可以通过这样的方式来使用，但是会收到警告 UNSAFE_componentWillMount UNSAFE_componentWillReceiveProps UNSAFE_componentWillUpdate static getDerivedStateFromProps当componentWillReceiveProps我们需要其他的方式根据props的变动更新state。社区决定引入一个新的static方法来处理这个问题。 什么是静态方法？一个静态方法就是存在于类内，而不是类的实例内的方法。静态方法访问不到this，并且在声明的时候有static关键字在前面修饰。 但是，问题来了。既然这个方法没有办法访问this，那么如何调用this.setState呢？答案就是，不调用。这个方法直接返回需要更新的state的数据，或者返回null，如果没有什么需要更新的话。 static getDerivedStateFromProps(nextProps, prevState) { if(nextProps.currentRow === prevState.lastRow) { return null; } return { lastRow: nextProps.currentRow, isCrollingDown: nextProps.curentRow &gt; prevState.lastRow } } 调用这个方法和之前调用this.setState的效果是一样的。只会修改这些返回的值，如果是null的话则不修改state。state的其他值都会保留。 值得注意是你需要定义初始state的值。无论是在constructor里，或者是类属性。否则会报警告。这个方法getDerivedStateFromProps()会在第一次挂载和重绘的时候都会调用到，因此你基本不用在constructor里根据传入的props来setState。 如果定义了getDerivedStateFromProps后，又定义了componentWillReceiveProps。那么，只有前者会被调用，并且你会收到一个警告。 一般你会使用一个回调来保证某些代码实在state更新之后才被调用的。那么，请把这些代码都移到componentDidUpdate里。如果你不喜欢使用static关键字，那么你可以这样： ComponentName.getDerivedStateFromProps = (nextProps, prevState) =&gt; { // Your code here } static mode严格模式是一个新的方式来确保你的代码是按照最佳实践开发的。它实际是一个在React.StrictMode下的组件。它可以用在你的组件树的任何一部分上。 import {StrictMode} from &#39;react&#39; class Application extends React.Component { render() { return ( &lt;StrictMode&gt; &lt;Context.Provider value={{background: 'black', color: 'white'}}&gt; &lt;Header /&gt; &lt;Main /&gt; &lt;Footer /&gt; &lt;/Context.Provider&gt; &lt;/StrictMode&gt; ); } } 如果一个在StricMode子树里的组件使用了componentWillMount方法，那么你会看到一个报错消息。 asyncMode异步模式在React.unsafe_AsyncMode下。使用AsncMode也会打开StrictMode模式下的警告。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简述HTTP协议]]></title>
    <url>%2F2018%2F04%2F02%2FHTTP%2F%E7%AE%80%E8%BF%B0HTTP%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[什么是HTTP协议协议是指计算机通信网络中两台计算机之间进行通信所必须共同遵守的规定或规则，超文本传输协议(HTTP)是一种通信协议，它允许将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器 1.超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的网络协议之一，所有的WWW文件必须遵循这个标准。 2.HTTP是客户端与服务器端的请求和应答的标准（TCP）。客户端是终端用户，服务器端是网站。通过使用Web浏览器、网络爬虫或者其它的工具，客户端发起一个到服务器上指定端口（默认端口为80）的HTTP请求。（我们称这个客户端）叫用户代理（user agent）。应答的服务器上存储着（一些）资源，比如HTML文件和图像。 3.由HTTP客户端发起一个请求，建立一个到服务器指定端口（默认是80端口）的TCP连接。HTTP服务器则在那个端口监听客户端发送过来的请求。一旦收到请求，服务器（向客户端）发回一个状态行，比如”HTTP/1.1 200 OK”，和（响应的）消息，消息的消息体可能是请求的文件、错误消息、或者其它一些信息。 4.HTTP使用TCP而不是UDP的原因在于（打开）一个网页必须传送很多数据，而TCP协议提供传输控制，按顺序组织数据，和错误纠正。 5.一次HTTP操作称为一个事务，其工作过程可分为四步： 1),首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作就开始了。 2),建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。 3),服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。 4),客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。 如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端，由显示屏输出。对于用户来说，这些过程是由HTTP自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 HTTP报文由从客户机到服务器的请求和从服务器到客户机的响应构成。 请求报文格式如下： 请求行 － 通用信息头 － 请求头 － 实体头 － 报文主体 请求行以方法字段开始，后面分别是 URL 字段和 HTTP 协议版本字段，并以 CRLF 结尾。SP 是分隔符。除了在最后的 CRLF 序列中 CF 和 LF 是必需的之外，其他都可以不要。有关通用信息头，请求头和实体头方面的具体内容可以参照相关文件。 应答报文格式如下： 状态行 － 通用信息头 － 响应头 － 实体头 － 报文主体 状态码元由3位数字组成，表示请求是否被理解或被满足。原因分析是对原文的状态码作简短的描述，状态码用来支持自动操作，而原因分析用来供用户使用。客户机无需用来检查或显示语法。有关通用信息头，响应头和实体头方面的具体内容可以参照相关文件。 7.通用头域包含请求和响应消息都支持的头域，通用头域包含Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via。对通用头域的扩展要求通讯双方都支持此扩展，如果存在不支持的通用头域，一般将会作为实体头域处理。 请求消息的第一行为：MethodSPRequest-URISPHTTP-VersionCRLFMethod表示对于Request-URI完成的方法，这个字段是大小写敏感的，包括OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACE。方法GET和HEAD应该被所有的通用WEB服务器支持，其他所有方法的实现是可选的。GET方法取回由Request-URI标识的信息。HEAD方法也是取回由Request-URI标识的信息，只是可以在响应时，不返回消息体。POST方法可以请求服务器接收包含在请求中的实体信息，可以用于提交表单，向新闻组、BBS、邮件群组和数据库发送消息。 响应消息的第一行的格式为：HTTP-VersionSPStatus-CodeSPReason-PhraseCRLF。HTTP-Version表示支持的HTTP版本，例如为HTTP/1.1。Status-Code是一个三个数字的结果代码。Reason-Phrase给Status-Code提供一个简单的文本描述。Status-Code主要用于机器自动识别，Reason-Phrase主要用于帮助用户理解。Status-Code的第一个数字定义响应的类别，后两个数字没有分类的作用。 请求消息和响应消息都可以包含实体信息，实体信息一般由实体头域和实体组成。实体头域包含关于实体的原信息，实体头包括Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header。extension-header允许客户端定义新的实体头，但是这些域可能无法被接受方识别。实体可以是一个经过编码的字节流，它的编码方式由Content-Encoding或Content-Type定义，它的长度由Content-Length或Content-Range定义。 原文地址]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Http 协议详解]]></title>
    <url>%2F2018%2F04%2F02%2FHTTP%2FHttp-%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[引言HTTP是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。它于1990年提出，经过几年的使用与发展，得到不断地完善和扩展。目前在WWW中使用的是HTTP/1.0的第六版，HTTP/1.1的规范化工作正在进行之中，而且HTTP-NG(Next Generation of HTTP)的建议已经提出。 HTTP协议的主要特点可概括如下：1.支持客户/服务器模式。2.简单快速：客户向服务器请求服务时，只需传送请求方法和路径。请求方法常用的有GET、HEAD、POST。每种方法规定了客户与服务器联系的类型不同。由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快。3.灵活：HTTP允许传输任意类型的数据对象。正在传输的类型由Content-Type加以标记4.无连接：无连接的含义是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。5.无状态：HTTP协议是无状态协议。无状态是指协议对于事务处理没有记忆能力。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。 HTTP协议详解之URL篇http(超文本传输协议) 是一个基于请求与响应模式的、无状态的、应用层的协议，常基于TCP的连接方式，HTTP1.1版本中给出一种持续连接的机制，绝大多数的Web开发，都是构建在HTTP协议之上的Web应用。 HTTP URL (URL是一种特殊类型的URI，包含了用于查找某个资源的足够的信息)的格式如下：http://host[&quot;:&quot;port][abs_path] http表示要通过HTTP协议来定位网络资源；host表示合法的Internet主机域名或者IP地址；port指定一个端口号，为空则使用缺省端口80；abs_path指定请求资源的URI；如果URL中没有给出abs_path，那么当它作为请求URI时，必须以“/”的形式给出，通常这个工作浏览器自动帮我们完成。 eg:1、输入：www.guet.edu.cn浏览器自动转换成：http://www.guet.edu.cn/2、http:192.168.0.116:8080/index.jsp HTTP协议详解之请求篇http请求由三部分组成，分别是：请求行、消息报头、请求正文 1、请求行以一个方法符号开头，以空格分开，后面跟着请求的URI和协议的版本，格式如下：Method Request-URI HTTP-Version CRLF其中 Method表示请求方法；Request-URI是一个统一资源标识符；HTTP-Version表示请求的HTTP协议版本；CRLF表示回车和换行（除了作为结尾的CRLF外，不允许出现单独的CR或LF字符）。 请求方法（所有方法全为大写）有多种，各个方法的解释如下：GET 请求获取Request-URI所标识的资源POST 在Request-URI所标识的资源后附加新的数据HEAD 请求获取由Request-URI所标识的资源的响应消息报头PUT 请求服务器存储一个资源，并用Request-URI作为其标识DELETE 请求服务器删除Request-URI所标识的资源TRACE 请求服务器回送收到的请求信息，主要用于测试或诊断CONNECT 保留将来使用OPTIONS 请求查询服务器的性能，或者查询与资源相关的选项和需求 应用示例GET方法：在浏览器的地址栏中输入网址的方式访问网页时，浏览器采用GET方法向服务器获取资源，eg:GET /form.html HTTP/1.1 (CRLF) POST方法要求被请求服务器接受附在请求后面的数据，常用于提交表单。eg：POST /reg.jsp HTTP/ (CRLF)Accept:image/gif,image/x-xbit,… (CRLF)…HOST:www.guet.edu.cn (CRLF)Content-Length:22 (CRLF)Connection:Keep-Alive (CRLF)Cache-Control:no-cache (CRLF)(CRLF) //该CRLF表示消息报头已经结束，在此之前为消息报头user=jeffrey&amp;pwd=1234 //此行以下为提交的数据 HEAD方法与GET方法几乎是一样的，对于HEAD请求的回应部分来说，它的HTTP头部中包含的信息与通过GET请求所得到的信息是相同的。利用这个方法，不必传输整个资源内容，就可以得到Request-URI所标识的资源的信息。该方法常用于测试超链接的有效性，是否可以访问，以及最近是否更新。 2、请求报头后述3、请求正文(略)HTTP协议详解之响应篇在接收和解释请求消息后，服务器返回一个HTTP响应消息。HTTP响应也是由三个部分组成，分别是：状态行、消息报头、响应正文 1.状态行格式如下：HTTP-Version Status-Code Reason-Phrase CRLF其中，HTTP-Version表示服务器HTTP协议的版本；Status-Code表示服务器发回的响应状态代码；Reason-Phrase表示状态代码的文本描述。 状态代码有三位数字组成，第一个数字定义了响应的类别，且有五种可能取值：1xx：指示信息–表示请求已接收，继续处理2xx：成功–表示请求已被成功接收、理解、接受3xx：重定向–要完成请求必须进行更进一步的操作4xx：客户端错误–请求有语法错误或请求无法实现5xx：服务器端错误–服务器未能实现合法的请求 常见状态代码、状态描述、说明：200 OK //客户端请求成功400 Bad Request //客户端请求有语法错误，不能被服务器所理解401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用403 Forbidden //服务器收到请求，但是拒绝提供服务404 Not Found //请求资源不存在，eg：输入了错误的URL500 Internal Server Error //服务器发生不可预期的错误503 Server Unavailable //服务器当前不能处理客户端的请求，一段时间后可能恢复正常eg：HTTP/1.1 200 OK （CRLF） 2.响应报头后述3.响应正文就是服务器返回的资源的内容HTTP协议详解之消息报头篇 HTTP消息由客户端到服务器的请求和服务器到客户端的响应组成。请求消息和响应消息都是由开始行（对于请求消息，开始行就是请求行，对于响应消息，开始行就是状态行），消息报头（可选），空行（只有CRLF的行），消息正文（可选）组成。 HTTP消息报头包括普通报头、请求报头、响应报头、实体报头。每一个报头域都是由名字+“：”+空格+值 组成，消息报头域的名字是大小写无关的。 普通报头在普通报头中，有少数报头域用于所有的请求和响应消息，但并不用于被传输的实体，只用于传输的消息。 eg：Cache-Control 用于指定缓存指令，缓存指令是单向的（响应中出现的缓存指令在请求中未必会出现），且是独立的（一个消息的缓存指令不会影响另一个消息处理的缓存机制），HTTP1.0使用的类似的报头域为Pragma。请求时的缓存指令包括：no-cache（用于指示请求或响应消息不能缓存）、no-store、max-age、max-stale、min-fresh、only-if-cached; 响应时的缓存指令包括：public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age、s-maxage. eg：为了指示IE浏览器（客户端）不要缓存页面，服务器端的JSP程序可以编写如下：response.sehHeader(“Cache-Control”,”no-cache”);//response.setHeader(“Pragma”,”no-cache”);作用相当于上述代码，通常两者//合用这句代码将在发送的响应消息中设置普通报头域：Cache-Control:no-cache Date普通报头域表示消息产生的日期和时间 Connection普通报头域允许发送指定连接的选项。例如指定连接是连续，或者指定“close”选项，通知服务器，在响应完成后，关闭连接 请求报头请求报头允许客户端向服务器端传递请求的附加信息以及客户端自身的信息。 常用的请求报头1.AcceptAccept请求报头域用于指定客户端接受哪些类型的信息。eg：Accept：image/gif，表明客户端希望接受GIF图象格式的资源；Accept：text/html，表明客户端希望接受html文本。2.Accept-CharsetAccept-Charset请求报头域用于指定客户端接受的字符集。eg：Accept-Charset:iso-8859-1,gb2312.如果在请求消息中没有设置这个域，缺省是任何字符集都可以接受。3.Accept-EncodingAccept-Encoding请求报头域类似于Accept，但是它是用于指定可接受的内容编码。eg：Accept-Encoding:gzip.deflate.如果请求消息中没有设置这个域服务器假定客户端对各种内容编码都可以接受。4.Accept-LanguageAccept-Language请求报头域类似于Accept，但是它是用于指定一种自然语言。eg：Accept-Language:zh-cn.如果请求消息中没有设置这个报头域，服务器假定客户端对各种语言都可以接受。5.AuthorizationAuthorization请求报头域主要用于证明客户端有权查看某个资源。当浏览器访问一个页面时，如果收到服务器的响应代码为401（未授权），可以发送一个包含Authorization请求报头域的请求，要求服务器对其进行验证。 Host（发送请求时，该报头域是必需的） Host请求报头域主要用于指定被请求资源的Internet主机和端口号，它通常从HTTP URL中提取出来的，eg： 我们在浏览器中输入：http://www.guet.edu.cn/index.html 浏览器发送的请求消息中，就会包含Host请求报头域，如下： Host：www.guet.edu.cn 此处使用缺省端口号80，若指定了端口号，则变成：Host：www.guet.edu.cn:指定端口号6.User-Agent我们上网登陆论坛的时候，往往会看到一些欢迎信息，其中列出了你的操作系统的名称和版本，你所使用的浏览器的名称和版本，这往往让很多人感到很神奇，实际上，服务器应用程序就是从User-Agent这个请求报头域中获取到这些信息。User-Agent请求报头域允许客户端将它的操作系统、浏览器和其它属性告诉服务器。不过，这个报头域不是必需的，如果我们自己编写一个浏览器，不使用User-Agent请求报头域，那么服务器端就无法得知我们的信息了。 响应报头响应报头允许服务器传递不能放在状态行中的附加响应信息，以及关于服务器的信息和对Request-URI所标识的资源进行下一步访问的信息。 常用的响应报头LocationLocation响应报头域用于重定向接受者到一个新的位置。Location响应报头域常用在更换域名的时候。ServerServer响应报头域包含了服务器用来处理请求的软件信息。与User-Agent请求报头域是相对应的。下面是Server响应报头域的一个例子：Server：Apache-Coyote/1.1WWW-AuthenticateWWW-Authenticate响应报头域必须被包含在401（未授权的）响应消息中，客户端收到401响应消息时候，并发送Authorization报头域请求服务器对其进行验证时，服务端响应报头就包含该报头域。eg：WWW-Authenticate:Basic realm=”Basic Auth Test!” //可以看出服务器对请求资源采用的是基本验证机制。 实体报头请求和响应消息都可以传送一个实体。一个实体由实体报头域和实体正文组成，但并不是说实体报头域和实体正文要在一起发送，可以只发送实体报头域。实体报头定义了关于实体正文（eg：有无实体正文）和请求所标识的资源的元信息。 常用的实体报头Content-EncodingContent-Encoding实体报头域被用作媒体类型的修饰符，它的值指示了已经被应用到实体正文的附加内容的编码，因而要获得Content-Type报头域中所引用的媒体类型，必须采用相应的解码机制。Content-Encoding这样用于记录文档的压缩方法，eg：Content-Encoding：gzipContent-LanguageContent-Language实体报头域描述了资源所用的自然语言。没有设置该域则认为实体内容将提供给所有的语言阅读者。eg：Content-Language:daContent-LengthContent-Length实体报头域用于指明实体正文的长度，以字节方式存储的十进制数字来表示。Content-TypeContent-Type实体报头域用语指明发送给接收者的实体正文的媒体类型。eg：Content-Type:text/html;charset=ISO-8859-1Content-Type:text/html;charset=GB2312Last-ModifiedLast-Modified实体报头域用于指示资源的最后修改日期和时间。ExpiresExpires实体报头域给出响应过期的日期和时间。为了让代理服务器或浏览器在一段时间以后更新缓存中(再次访问曾访问过的页面时，直接从缓存中加载，缩短响应时间和降低服务器负载)的页面，我们可以使用Expires实体报头域指定页面过期的时间。eg：Expires：Thu，15 Sep 2006 16:23:12 GMTHTTP1.1的客户端和缓存必须将其他非法的日期格式（包括0）看作已经过期。eg：为了让浏览器不要缓存页面，我们也可以利用Expires实体报头域，设置为0，jsp中程序如下：response.setDateHeader(“Expires”,”0”); HTTP协议相关技术补充1、基础：高层协议有：文件传输协议FTP、电子邮件传输协议SMTP、域名系统服务DNS、网络新闻传输协议NNTP和HTTP协议等 中介由三种：代理(Proxy)、网关(Gateway)和通道(Tunnel)，一个代理根据URI的绝对格式来接受请求，重写全部或部分消息，通过 URI的标识把已格式化过的请求发送到服务器。网关是一个接收代理，作为一些其它服务器的上层，并且如果必须的话，可以把请求翻译给下层的服务器协议。一 个通道作为不改变消息的两个连接之间的中继点。当通讯需要通过一个中介(例如：防火墙等)或者是中介不能识别消息的内容时，通道经常被使用。 代理(Proxy)：一个中间程序，它可以充当一个服务器，也可以充当一个客户机，为其它客户机建立请求。请求是通过可能的翻译在内部或经过传递到其它的 服务器中。一个代理在发送请求信息之前，必须解释并且如果可能重写它。代理经常作为通过防火墙的客户机端的门户，代理还可以作为一个帮助应用来通过协议处 理没有被用户代理完成的请求。网关(Gateway)：一个作为其它服务器中间媒介的服务器。与代理不同的是，网关接受请求就好象对被请求的资源来说它就是源服务器；发出请求的客户机并没有意识到它在同网关打交道。网关经常作为通过防火墙的服务器端的门户，网关还可以作为一个协议翻译器以便存取那些存储在非HTTP系统中的资源。 通道(Tunnel)：是作为两个连接中继的中介程序。一旦激活，通道便被认为不属于HTTP通讯，尽管通道可能是被一个HTTP请求初始化的。当被中继 的连接两端关闭时，通道便消失。当一个门户(Portal)必须存在或中介(Intermediary)不能解释中继的通讯时通道被经常使用。 2、协议分析的优势—HTTP分析器检测网络攻击以模块化的方式对高层协议进行分析处理，将是未来入侵检测的方向。HTTP及其代理的常用端口80、3128和8080在network部分用port标签进行了规定 3、HTTP协议Content Lenth限制漏洞导致拒绝服务攻击使用POST方法时，可以设置ContentLenth来定义需要传送的数据长度，例如ContentLenth:999999999，在传送完成前，内 存不会释放，攻击者可以利用这个缺陷，连续向WEB服务器发送垃圾数据直至WEB服务器内存耗尽。这种攻击方法基本不会留下痕迹。http://www.cnpaf.net/Class/HTTP/0532918532667330.html 4、利用HTTP协议的特性进行拒绝服务攻击的一些构思服务器端忙于处理攻击者伪造的TCP连接请求而无暇理睬客户的正常请求（毕竟客户端的正常请求比率非常之小），此时从正常客户的角度看来，服务器失去响应，这种情况我们称作：服务器端受到了SYNFlood攻击（SYN洪水攻击）。而Smurf、TearDrop等是利用ICMP报文来Flood和IP碎片攻击的。本文用“正常连接”的方法来产生拒绝服务攻击。19端口在早期已经有人用来做Chargen攻击了，即Chargen_Denial_of_Service，但是！他们用的方法是在两台Chargen 服务器之间产生UDP连接，让服务器处理过多信息而DOWN掉，那么，干掉一台WEB服务器的条件就必须有2个：1.有Chargen服务2.有HTTP 服务方法：攻击者伪造源IP给N台Chargen发送连接请求（Connect），Chargen接收到连接后就会返回每秒72字节的字符流（实际上根据网络实际情况，这个速度更快）给服务器。 5、Http指纹识别技术 Http指纹识别的原理大致上也是相同的：记录不同服务器对Http协议执行中的微小差别进行识别.Http指纹识别比TCP/IP堆栈指纹识别复杂许 多,理由是定制Http服务器的配置文件、增加插件或组件使得更改Http的响应信息变的很容易,这样使得识别变的困难；然而定制TCP/IP堆栈的行为 需要对核心层进行修改,所以就容易识别. 要让服务器返回不同的Banner信息的设置是很简单的,象Apache这样的开放源代码的Http服务器,用户可以在源代码里修改Banner信息,然 后重起Http服务就生效了；对于没有公开源代码的Http服务器比如微软的IIS或者是Netscape,可以在存放Banner信息的Dll文件中修 改,相关的文章有讨论的,这里不再赘述,当然这样的修改的效果还是不错的.另外一种模糊Banner信息的方法是使用插件。 常用测试请求：1：HEAD/Http/1.0发送基本的Http请求2：DELETE/Http/1.0发送那些不被允许的请求,比如Delete请求3：GET/Http/3.0发送一个非法版本的Http协议请求4：GET/JUNK/1.0发送一个不正确规格的Http协议请求Http指纹识别工具Httprint,它通过运用统计学原理,组合模糊的逻辑学技术,能很有效的确定Http服务器的类型.它可以被用来收集和分析不同Http服务器产生的签名。 6、其他：为了提高用户使用浏览器时的性能，现代浏览器还支持并发的访问方式，浏览一个网页时同时建立多个连接，以迅速获得一个网页上的多个图标，这样能更快速完成整个网页的传输。HTTP1.1中提供了这种持续连接的方式，而下一代HTTP协议：HTTP-NG更增加了有关会话控制、丰富的内容协商等方式的支持，来提供更高效率的连接。 原文地址]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6 核心内容 下]]></title>
    <url>%2F2018%2F03%2F30%2FJs%2FEs6-%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9-%E4%B8%8B%2F</url>
    <content type="text"><![CDATA[import export这两个家伙对应的就是es6自己的module功能。 我们之前写的Javascript一直都没有模块化的体系，无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程，再用一种简单的方法把这些小工程连接在一起。 这有可能导致两个问题：一方面js代码变得很臃肿，难以维护另一方面我们常常得很注意每个script标签在html中的位置，因为它们通常有依赖关系，顺序错了可能就会出bug 在es6之前为解决上面提到的问题，我们得利用第三方提供的一些方案，主要有两种CommonJS(服务器端)和AMD（浏览器端，如require.js）。 而现在我们有了es6的module功能，它实现非常简单，可以成为服务器和浏览器通用的模块解决方案。 ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。 传统写法首先我们回顾下require.js的写法。假设我们有两个js文件: index.js和content.js,现在我们想要在index.js中使用content.js返回的结果，我们要怎么做呢？首先定义： //content.js define(&#39;content.js&#39;, function(){ return &#39;A cat&#39;; }) 然后require： //index.js require([&#39;./content.js&#39;], function(animal){ console.log(animal); //A cat }) 那CommonJS是怎么写的呢？ //index.js var animal = require(&#39;./content.js&#39;) //content.js module.exports = &#39;A cat&#39; ES6的写法 //index.js import animal from &#39;./content&#39; //content.js export default &#39;A cat&#39; ES6 module的其他高级用法//content.js export default &#39;A cat&#39; export function say(){ return &#39;Hello!&#39; } export const type = &#39;dog&#39; 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类） //index.js import { say, type } from &#39;./content&#39; let says = say() console.log(`The ${type} says ${says}`) //The dog says Hello 这里输入的时候要注意：大括号里面的变量名，必须与被导入模块（content.js）对外接口的名称相同。 如果还希望输入content.js中输出的默认(default), 可以写在大括号外面。 //index.js import animal, { say, type } from &#39;./content&#39; let says = say() console.log(`The ${type} says ${says} to ${animal}`) //The dog says Hello to A cat 修改变量名此时我们不喜欢type这个变量名，因为它有可能重名，所以我们需要修改一下它的变量名。在es6中可以用as实现一键换名。 //index.js import animal, { say, type as animalType } from &#39;./content&#39; let says = say() console.log(`The ${animalType} says ${says} to ${animal}`) //The dog says Hello to A cat 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 //index.js import animal, * as content from &#39;./content&#39; let says = content.say() console.log(`The ${content.type} says ${says} to ${animal}`) //The dog says Hello to A cat 通常星号*结合as一起使用比较合适。 终极秘籍考虑下面的场景：上面的content.js一共输出了三个变量（default, say, type）,假如我们的实际项目当中只需要用到type这一个变量，其余两个我们暂时不需要。我们可以只输入一个变量： import { type } from &#39;./content&#39; 由于其他两个变量没有被使用，我们希望代码打包的时候也忽略它们，抛弃它们，这样在大项目中可以显著减少文件的体积。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Es6 核心内容上]]></title>
    <url>%2F2018%2F03%2F30%2FJs%2FEs6-%E6%A0%B8%E5%BF%83%E5%86%85%E5%AE%B9-%E4%B8%8A%2F</url>
    <content type="text"><![CDATA[在我们正式讲解ES6语法之前，我们得先了解下Babel。Babel Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看： 最常用的ES6特性let, const, class, extends, super, arrow functions, template string, destructuring, default, rest，arguments 这些是ES6最常用的几个语法，基本上学会它们，我们就可以走遍天下都不怕啦！我会用最通俗易懂的语言和例子来讲解它们，保证一看就懂，一学就会。 let ,const这两个的用途与var类似，都是用来声明变量的，但在实际运用中他俩都有各自的特殊用途。首先来看下面这个例子： var name = &#39;zach&#39; while (true) { var name = &#39;obama&#39; console.log(name) //obama break } console.log(name) //obama 使用var 两次输出都是obama，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。而let则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。 let name = &#39;zach&#39; while (true) { let name = &#39;obama&#39; console.log(name) //obama break } console.log(name) //zach 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子： var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。 var clickBoxs = document.querySelectorAll(&#39;.clickBox&#39;) for (var i = 0; i &lt; clickBoxs.length; i++){ clickBoxs[i].onclick = function(){ console.log(i) } } 我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。 function iteratorFactory(i){ var onclick = function(e){ console.log(i) } return onclick; } var clickBoxs = document.querySelectorAll(&#39;.clickBox&#39;) for (var i = 0; i &lt; clickBoxs.length; i++){ clickBoxs[i].onclick = iteratorFactory(i) } const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。 const PI = Math.PI PI = 23 //Module build failed: SyntaxError: /es6/app.js: &quot;PI&quot; is read-only 当我们尝试去改变用const声明的常量时，浏览器就会报错。 class, extends, super这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承…你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。 class Animal { constructor(){ this.type = &#39;animal&#39; } says(say){ console.log(this.type + &#39;says&#39; + say) } } let animal = new Animal() animal.says(&#39;hello&#39;) //animal says hello class Cat extends Animal{ constructor(){ super() this.type = &#39;cat&#39; } } let cat = new Cat(); cat.says(&#39;hello&#39;) 上面代码首先用class定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。简单地说，constructor内定义的方法和属性是实例对象自己的，而constructor外定义的方法和属性则是所有实例对象可以共享的。 Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。上面定义了一个Cat类，该类通过extends关键字，继承了Animal类的所有属性和方法。 super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 ES6的继承机制，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 arrow function(箭头函数)这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多: function(i){ return i + 1; } //ES5 (i) =&gt; i + 1 //ES6 简直是简单的不像话对吧…如果方程比较复杂，则需要用{}把代码包起来： function(x, y) { x++; y--; return x + y; } //es6 (x, y) =&gt; {x++; y--; return x+y} 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如： class Animal { constructor(){ this.type = &#39;animal&#39; } says(say){ setTimeout(function(){ console.log(this.type + &#39; says &#39; + say) }, 1000) } } var animal = new Animal() animal.says(&#39;hi&#39;) //undefined says hi 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种： 第一种是将this传给self,再用self来指代this says(say){ var self = this; setTimeout(function(){ console.log(self.type + &#39; says &#39; + say) }, 1000) 第二种方法是用bind(this),即 says(say){ setTimeout(function(){ console.log(this.type + &#39; says &#39; + say) }.bind(this), 1000) 但现在我们有了箭头函数，就不需要这么麻烦了： class Animal { constructor(){ this.type = &#39;animal&#39; } says(say){ setTimeout( () =&gt; { console.log(this.type + &#39; says &#39; + say) }, 1000) } } var animal = new Animal() animal.says(&#39;hi&#39;) //animal says hi 当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。 template string(字符串模板)这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。 //es5 $(&quot;#result&quot;).append( &quot;There are &lt;b&gt;&quot; + basket.count + &quot;&lt;/b&gt; &quot; + &quot;items in your basket, &quot; + &quot;&lt;em&gt;&quot; + basket.onSale + &quot;&lt;/em&gt; are on sale!&quot; ); //es6 $(&quot;#result&quot;).append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale! `); 用反引号（\）来标识起始，用${}`来引用变量，而且所有的空格和缩进都会被保留在输出之中，是不是非常爽？！ React Router从第1.0.3版开始也使用ES6语法了，比如这个例子： &lt;Link to={`/taco/${taco.name}`}&gt;{taco.name}&lt;/Link&gt; destructuring(解构赋值)ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 // es5 let cat = &#39;ken&#39; let dog = &#39;lili&#39; let zoo = {cat: cat, dog: dog} console.log(zoo) //Object {cat: &quot;ken&quot;, dog: &quot;lili&quot;} // es6 let cat = &#39;ken&#39; let dog = &#39;lili&#39; let zoo = {cat, dog} console.log(zoo) //Object {cat: &quot;ken&quot;, dog: &quot;lili&quot;} //反过来可以这样写 let dog = {type: &#39;animal&#39;, many: 2} let { type, many} = dog console.log(type, many) //animal 2 default,restdefault很简单，意思就是默认值。大家可以看下面的例子，调用animal()方法时忘了传参数，传统的做法就是加上这一句type = type || &#39;cat&#39; 来指定默认值。 //es5 function animal(type){ type = type || &#39;cat&#39; console.log(type) } animal() //es6 function animal(type = &#39;cat&#39;){ console.log(type) } animal() 最后一个rest语法也很简单，直接看例子： function animals(...types){ console.log(types) } animals(&#39;cat&#39;, &#39;dog&#39;, &#39;fish&#39;) //[&quot;cat&quot;, &quot;dog&quot;, &quot;fish&quot;] 如果不用es6中的属性，可以用ES5中的argumnets 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Node入门]]></title>
    <url>%2F2018%2F03%2F28%2FNode%2FNode%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[什么是Node.js按照 Node.js官方网站主页 的说法: Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient. Node.js’ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.从上面这段话来看：1.Node.js 不是 JavaScript 应用，不是语言（JavaScript 是语言），不是像 Rails(Ruby)、 Laravel(PHP) 或 Django(Python) 一样的框架，也不是像 Nginx 一样的 Web 服务器。Node.js 是 JavaScript 运行时环境 2.构建在 Chrome’s V8 这个著名的 JavaScript 引擎之上，Chrome V8 引擎以 C/C++ 为主，相当于使用JavaScript 写法，转成 C/C++ 调用，大大的降低了学习成本 3.事件驱动（event-driven），非阻塞 I/O 模型（non-blocking I/O model），简单点讲就是每个函数都是异步的，最后由 Libuv 这个 C/C++ 编写的事件循环处理库来处理这些 I/O 操作，隐藏了非阻塞 I/O 的具体细节，简化并发编程模型，让你可以轻松的编写高性能的Web应用，所以它是轻量（lightweight）且高效（efficient）的 4.使用 npm 作为包管理器，目前 npm 是开源库里包管理最大的生态，功能强大，截止到2017年12月，模块数量超过 60 万+ 大多数人都认为 Node.js 只能写网站后台或者前端工具，这其实是不全面的，Node.js的目标是让并发编程更简单，主要应用在以网络编程为主的 I/O 密集型应用。它是开源的，跨平台，并且高效（尤其是I/O处理），包括IBM、Microsoft、Yahoo、SAP、PayPal、沃尔玛及GoDaddy都是 Node.js 的用户。 基本原理下面是一张 Node.js 早期的架构图，来自 Node.js 之父 Ryan Dahl 的演讲稿，在今天依然不过时，它简要的介绍了 Node.js 是基于 Chrome V8引擎构建的，由事件循环（Event Loop）分发 I/O 任务，最终工作线程（Work Thread）将任务丢到线程池（Thread Pool）里去执行，而事件循环只要等待执行结果就可以了。 核心概念:1.Chrome V8 是 Google 发布的开源 JavaScript 引擎，采用 C/C++ 编写，在 Google 的 Chrome 浏览器中被使用。Chrome V8 引擎可以独立运行，也可以用来嵌入到 C/C++ 应用程序中执行。2.Event Loop 事件循环（由 libuv 提供）3.Thread Pool 线程池（由 libuv 提供） 梳理后可以这样理解：1.Chrome V8 是 JavaScript 引擎2.Node.js 内置 Chrome V8 引擎，所以它使用的 JavaScript 语法3.JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事4单线程就意味着，所有任务需要排队，前一个任务结束，才会执行后一个任务。如果前一个任务耗时很长，后一个任务就不得不一直等着。5.如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 I/O 很慢，不得不等着结果出来，再往下执行6.CPU 完全可以不管 I/O 设备，挂起处于等待中的任务，先运行排在后面的任务7.将等待中的 I/O 任务放到 Event Loop 里8.由 Event Loop 将 I/O 任务放到线程池里 只要有资源，就尽力执行 学习 Node.js 的三个境界1.打日志 console.log2.断点调试：断点调试：node debugger 或node inspector 或vscode3.测试驱动开发（tdd | bdd） 安装Node.js环境3m安装法 nvm（node version manager）【需要使用npm安装，替代品是yrm（支持yarn）】nrm（node registry manager）【需要使用npm安装，替代品是yrm（支持yarn）】npm（node packages manager）【内置，替代品是n或nvs（对win也支持）】 Node.js应用场景《Node.js in action》一书里说，Node.js 所针对的应用程序有一个专门的简称：DIRT。它表示数据密集型实时（data-intensive real-time）程序。因为 Node.js 自身在 I/O 上非常轻量，它善于将数据从一个管道混排或代理到另一个管道上，这能在处理大量请求时持有很多开放的连接，并且只占用一小部分内存。它的设计目标是保证响应能力，跟浏览器一样。 这话不假，但在今天来看，DIRT 还是范围小了。其实 DIRT 本质上说的 I/O 处理的都算，但随着大前端的发展，Node.js 已经不再只是 I/O 处理相关，而是更加的“Node”！ Node.js 使用场景主要分为4大类 1）跨平台：覆盖你能想到的面向用户的所有平台，传统的PC Web端，以及PC客户端 nw.js/electron 、移动端 cordova、HTML5、react-native、weex，硬件 ruff.io 等2）Web应用开发：网站、Api、RPC服务等3）前端：三大框架 React \ Vue \ Angular 辅助开发，以及工程化演进过程（使用Gulp /Webpack 构建 Web 开发工具）4）工具：npm上各种工具模块，包括各种前端预编译、构建工具 Grunt / Gulp、脚手架，命令行工具，各种奇技淫巧等 分类 描述 相关模块 网站 类似于 cnodejs.org 这样传统的网站 Express / Koa Api 同时提供给移动端，PC，H5 等前端使用的 HTTP Api 接口 Restify / HApi Api代理 为前端提供的，主要对后端Api接口进行再处理，以便更多的适应前端开发 Express / Koa IM即时聊天 实时应用，很多是基于 WebSocket协议的 Socket.io / sockjs 反向代理 提供类似于 nginx 反向代理功能，但对前端更友好 anyproxy / node-http-proxy / hiproxy 前端构建工具 辅助前端开发，尤其是各种预编译，构建相关的工具，能够极大的提高前端开发效率 Grunt / Gulp / Bower / Webpack / Fis3 / YKit 命令行工具 使用命令行是非常酷的方式，前端开发自定义了很多相关工具，无论是shell命令，node脚本，还是各种脚手架等，几乎每个公司\小组都会自己的命令行工具集 Cordova / Shell.js 操作系统 有实现，但估计不太会有人用 NodeOS 跨平台打包工具 使用 Web 开发技术开发PC客户端是目前最流行的方式，会有更多前端开发工具是采用这种方式的 PC端的electron、nw.js，比如钉钉PC客户端、微信小程序IDE、微信客户端，移动的Cordova，即老的Phonegap，还有更加有名的一站式开发框架Ionicframework P2P 区块链开发、BT客户端 webtorrent / ipfs 编辑器 Atom 和 VSCode 都是基于 electron 模块的 electron 物联网与硬件 ruff.io和很多硬件都支持node sdk ruff Node.js 应用场景非常丰富，比如 Node.js 可以开发操作系统，但一般我都不讲的，就算说了也没多大意义，难道大家真的会用吗？一般，我习惯将 Node.js 应用场景分为7个部分。 1）初衷，server端，不想成了前端开发的基础设施2）命令行辅助工具，甚至可以是运维3）移动端：cordova，pc端：nw.js和electron4）组件化，构建，代理5）架构，前后端分离、api proxy6）性能优化、反爬虫与爬虫7) 全栈最便捷之路 Node核心：异步流程控制Node.js是为异步而生的，它自己把复杂的事儿做了（高并发，低延时），交给用户的只是有点难用的Callback写法。也正是坦诚的将异步回调暴露出来，才有更好的流程控制方面的演进。也正是这些演进，让Node.js从DIRT（数据敏感实时应用）扩展到更多的应用场景，今天的Node.js已经不只是能写后端的JavaScript，已经涵盖了所有涉及到开发的各个方面，而Node全栈更是热门种的热门。 直面问题才能有更好的解决方式，Node.js的异步是整个学习Node.js过程中重中之重。 1) 异步流程控制学习重点2）Api写法：Error-first Callback 和 EventEmitter3）中流砥柱：Promise4）终极解决方案：Async/Await 异步流程控制学习重点我整理了一张图，更直观一些。从09年到现在，8年多的时间里，整个Node.js社区做了大量尝试，其中曲折足足够写一本书的了。大家先简单了解一下。 红色代表Promise，是使用最多的，无论async还是generator都可用蓝色是Generator，过度货绿色是Async函数，趋势 结论：Promise是必须会的，那你为什么不顺势而为呢？ 推荐：使用Async函数 + Promise组合，如下图所示。 其实，一般使用是不需要掌握上图中的所有技术的。对于初学者来说，先够用，再去深究细节。所以，精简一下，只了解3个就足够足够用了。 结论 1.Node.js SDK里callback写法必须会的。2.Node.js学习重点: Async函数与Promise 2.1中流砥柱：Promise 2.2终极解决方案：Async/Await Api写法：Error-first Callback 和 EventEmitterError-first Callback 定义错误优先的回调写法只需要注意2条规则即可：1.回调函数的第一个参数返回的error对象，如果error发生了，它会作为第一个err参数返回，如果没有，一般做法是返回null。2.回调函数的第二个参数返回的是任何成功响应的结果数据。如果结果正常，没有error发生，err会被设置为null，并在第二个参数就出返回成功结果数据。 下面让我们看一下调用函数示例，Node.js 文档里最常采用下面这样的回调方式： function(error,res){ //process the error and result } 这里的 callback 指的是带有2个参数的函数：”err”和 “res”。语义上讲，非空的“err”相当于程序异常；而空的“err”相当于可以正常返回结果“res”，无任何异常。 EventEmitter事件模块是 Node.js 内置的对观察者模式“发布/订阅”（publish/subscribe）的实现，通过EventEmitter属性，提供了一个构造函数。该构造函数的实例具有 on 方法，可以用来监听指定事件，并触发回调函数。任意对象都可以发布指定事件，被 EventEmitter 实例的 on 方法监听到。 在node 6之后，可以直接使用require(‘events’)类 var Emitter = require(&#39;events&#39;); var uilt = require(&#39;uilt&#39;); var myEmitter = function(){ util.inherits(MyEmitter, EventEmitter) const myEmitter = new MyEmitter(); myEmitter.on(&#39;event&#39;, (a, b) =&gt; { console.log(a, b, this); // Prints: a b {} }); myEmitter.emit(&#39;event&#39;, &#39;a&#39;, &#39;b&#39;); } 和jquery、vue里的Event是非常类似的。而且前端自己也有EventEmitter。 如何更好的查Node.js文档API是应用程序接口Application Programming Interface的简称。从Node.js异步原理，我们可以知道，核心在于 Node.js SDK 中API调用，然后交由EventLoop（Libuv）去执行，所以我们一定要熟悉Node.js的API操作。 Node.js的API都是异步的，同步的函数是奢求，要查API文档，在高并发场景下慎用。 笔者推荐使用 Dash 或 Zeal 查看离线文档，经常查看离线文档，对Api理解会深入很多，比IDE辅助要好，可以有效避免离开IDE就不会写代码的窘境。 中流砥柱：PromiseNode.js 因为采用了错误优先的回调风格写法，导致sdk里导出都是回调函数。如果组合调用的话，就会特别痛苦，经常会出现回调里嵌套回调的问题，大家都非常厌烦这种写法，称之为Callback Hell，即回调地狱。一个经典的例子来自著名的Promise模块q文档里。 step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // Do something with value4 }); }); }); }); 这里只是做4步，嵌套了4层回调，如果更多步骤呢？很多新手浅尝辄止，到这儿就望而却步，粉转黑。这明显不够成熟，最起码你要看看它的应对解决方案吧！ Node.js 约定所有Api都采用错误优先的回调方式，这部分场景都是大家直接调用接口，无太多变化。而Promise是对回调地狱的思考，或者说是改良方案。目前使用非常普遍，可以说是在async函数普及之前唯一一个通用性规范，甚至 Node.js 社区都在考虑 Promise 化，可见其影响之大。 Promise意味着[许愿|承诺]一个还没有完成的操作，但在未来会完成的。与Promise最主要的交互方法是通过将函数传入它的then方法从而获取得Promise最终的值或Promise最终最拒绝（reject）的原因。要点有三个： 递归，每个异步操作返回的都是promise对象状态机：三种状态转换，只在promise对象内部可以控制，外部不能改变状态全局异常处理 定义var promise = new promise(function(resolve,reject){ // do a thing, possibly async, then… if (/* everything turned out fine */) { resolve(&quot;Stuff worked!&quot;); //成功返回 } else { reject(Error(&quot;It broke&quot;));//失败返回 } }) 每个Promise定义都是一样的，在构造函数里传入一个匿名函数，参数是resolve和reject，分别代表成功和失败时候的处理。 调用promise.then(function(text){ console.log(text)// Stuff worked! return Promise.reject(new Error(&#39;我是故意的&#39;)) }).catch(function(err){ console.log(err) }) 它的主要交互方式是通过then函数，如果Promise成功执行resolve了，那么它就会将resolve的值传给最近的then函数，作为它的then函数的参数。如果出错reject，那就交给catch来捕获异常就好了。 Promise 的最大优势是标准化，各类异步工具库都按照统一规范实现，即使是async函数也可以无缝集成。所以用 Promise 封装 API 通用性强，用起来简单，学习成本低。在async函数普及之前，绝大部分应用都是采用Promise来做异步流程控制的，所以掌握Promise是Node.js学习过程中必须要掌握的重中之重。 Bluebird是 Node.js 世界里性能最好的Promise/a+规范的实现模块，Api非常齐全，功能强大，是原生Promise外的不二选择。 好处如下：1.避免Node.js内置Promise实现 问题，使用与所有版本兼容2.避免Node.js 4曾经出现的内存泄露问题3.内置更多扩展，timeout、 promisifyAll等，对Promise/A+规范提供 推荐学习资料 Node.js最新技术栈之Promise篇 https://cnodejs.org/topic/560dbc826a1ed28204a1e7de理解 Promise 的工作原理 https://cnodejs.org/topic/569c8226adf526da2aeb23fdPromise 迷你书 http://liubin.github.io/promises-book/ 终极解决方案：Async/AwaitAsync/Await是异步操作的终极解决方案，Koa 2在node 7.6发布之后，立马发布了正式版本，并且推荐使用async函数来编写Koa中间件。 这里给出一段Koa 2应用里的一段代码 exports.list = async (ctx, next) =&gt; { try { let students = await Student.getAllAsync(); await ctx.render(&#39;students/index&#39;, { students : students }) } catch (err) { return ctx.api_error(err); } }; 它做了3件事儿 1.通过await Student.getAllAsync();来获取所有的students信息。2.通过await ctx.render渲染页面3.由于是同步代码，使用try/catch做的异常处理 Async函数要点如下： Async函数语义上非常好Async不需要执行器，它本身具备执行能力，不像Generator需要co模块Async函数的异常处理采用try/catch和Promise的错误处理，非常强大Await接Promise，Promise自身就足够应对所有流程了，包括async函数没有纯并行处理机制，也可以采用Promise里的all和race来补齐Await释放Promise的组合能力，外加co和Promise的then，几乎没有不支持的场景 NodeJs框架分类 框架名称 特性 点评 Express 简单、实用，路由中间件等五脏俱全 最著名的Web框架 Derby.js &amp;&amp; Meteor 同构 前后端都放到一起，模糊了开发便捷，看上去更简单，实际上上对开发来说要求更高 Sails、Total 面向其他语言，Ruby、PHP等 借鉴业界优秀实现，也是 Node.js 成熟的一个标志 MEAN.js 面向架构 类似于脚手架，又期望同构，结果只是蹭了热点 Hapi和Restfy 面向Api &amp;&amp; 微服务 移动互联网时代Api的作用被放大，故而独立分类。尤其是对于微服务开发更是利器 ThinkJS 面向新特性 借鉴ThinkPHP，并慢慢走出自己的一条路，对于Async函数等新特性支持，无出其右，新版v3.0是基于Koa v2.0的作为内核的 Ko 专注于异步流程改进 下一代Web框架 Egg 基于Koa，在开发上有极大便利 企业级Web开发框架 对于框架选型 业务场景、特点，不必为了什么而什么，避免本末倒置自身团队能力、喜好，有时候技术选型决定团队氛围的，需要平衡激进与稳定出现问题的时候，有人能够做到源码级定制。Node.js 已经有8年历史，但模块完善程度良莠不齐，如果不慎踩到一个坑里，需要团队在无外力的情况能够搞定，否则会影响进度 Web编程核心 异步流程控制（前面讲过了）基本框架 Koa或Express，新手推荐Express，毕竟资料多，上手更容易。如果有一定经验，推荐Koa，其实这些都是为了了解Web编程原理，尤其是中间件机制理解。数据库 mongodb或mysql都行，mongoose和Sequelize、bookshelf，TypeOrm等都非常不错。对于事务，不是Node.js的锅，是你选的数据库的问题。另外一些偏门，想node连sqlserver等估计还不成熟，我是不会这样用的。模板引擎， ejs，jade，nunjucks。理解原理最好。尤其是extend，include等高级用法，理解布局，复用的好处。其实前后端思路都是一样的 作者:狼叔原文地址]]></content>
      <categories>
        <category>Node</category>
      </categories>
      <tags>
        <tag>Node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码分析 6 React合成事件系统]]></title>
    <url>%2F2018%2F03%2F27%2FReact%2FReact-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-6-React%E5%90%88%E6%88%90%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[React合成事件特点React自己实现了一套高效的事件注册，存储，分发和重用逻辑，在DOM事件体系基础上做了很大改进，减少了内存消耗，简化了事件逻辑，并最大化的解决了IE等浏览器的不兼容问题。与DOM事件体系相比，它有如下特点 1.React组件上声明的事件最终绑定到了document这个DOM节点上，而不是React组件对应的DOM节点。故只有document这个节点上面才绑定了DOM原生事件，其他节点没有绑定事件。这样简化了DOM原生事件，减少了内存开销 2.React以队列的方式，从触发事件的组件向父组件回溯，调用它们在JSX中声明的callback。也就是React自身实现了一套事件冒泡机制。我们没办法用event.stopPropagation()来停止事件传播，应该使用event.preventDefault() 3.React有一套自己的合成事件SyntheticEvent，不同类型的事件会构造不同的SyntheticEvent 4.React使用对象池来管理合成事件对象的创建和销毁，这样减少了垃圾的生成和新对象内存的分配，大大提高了性能 那么这些特性是如何实现的呢，下面和大家一起一探究竟。 React事件系统先看Facebook给出的React事件系统框图 浏览器事件（如用户点击了某个button）触发后，DOM将event传给ReactEventListener，它将事件分发到当前组件及以上的父组件。然后由ReactEventEmitter对每个组件进行事件的执行，先构造React合成事件，然后以queue的方式调用JSX中声明的callback进行事件回调。 涉及到的主要类如下 ReactEventListene:负责事件注册和事件分发。React将DOM事件全都注册到document这个节点上，这个我们在事件注册小节详细讲。事件分发主要调用dispatchEvent进行，从事件触发组件开始，向父元素遍历。我们在事件执行小节详细讲。 ReactEventEmitter：负责每个组件上事件的执行。 EventPluginHub：负责事件的存储，合成事件以对象池的方式实现创建和销毁，大大提高了性能。 SimpleEventPlugin等plugin：根据不同的事件类型，构造不同的合成事件。如focus对应的React合成事件为SyntheticFocusEvent 事件注册JSX中声明一个React事件十分简单，比如 render() { return ( &lt;div onClick = { (event) =&gt; {console.log(JSON.stringify(event))} } /&gt; ); } 那么它是如何被注册到React事件系统中的呢？ 还是先得从组件创建和更新的入口方法mountComponent和updateComponent说起。在这两个方法中，都会调用到_updateDOMProperties方法，对JSX中声明的组件属性进行处理。源码如下 _updateDOMProperties: function (lastProps, nextProps, transaction) { ... // 前面代码太长，省略一部分 else if (registrationNameModules.hasOwnProperty(propKey)) { // 如果是props这个对象直接声明的属性，而不是从原型链中继承而来的，则处理它 // nextProp表示要创建或者更新的属性，而lastProp则表示上一次的属性 // 对于mountComponent，lastProp为null。updateComponent二者都不为null。unmountComponent则nextProp为null if (nextProp) { // mountComponent和updateComponent中，enqueuePutListener注册事件 enqueuePutListener(this, propKey, nextProp, transaction); } else if (lastProp) { // unmountComponent中，删除注册的listener，防止内存泄漏 deleteListener(this, propKey); } } } 下面我们来看enqueuePutListener，它负责注册JSX中声明的事件。源码如下 // inst: React Component对象 // registrationName: React合成事件名，如onClick // listener: React事件回调方法，如onClick=callback中的callback // transaction: mountComponent或updateComponent所处的事务流中，React都是基于事务流的 function enqueuePutListener(inst, registrationName, listener, transaction) { if (transaction instanceof ReactServerRenderingTransaction) { return; } var containerInfo = inst._hostContainerInfo; var isDocumentFragment = containerInfo._node &amp;&amp; containerInfo._node.nodeType === DOC_FRAGMENT_TYPE; // 找到document var doc = isDocumentFragment ? containerInfo._node : containerInfo._ownerDocument; // 注册事件，将事件注册到document上 listenTo(registrationName, doc); // 存储事件,放入事务队列中 transaction.getReactMountReady().enqueue(putListener, { inst: inst, registrationName: registrationName, listener: listener }); } enqueuePutListener主要做两件事，一方面将事件注册到document这个原生DOM上（这就是为什么只有document这个节点有DOM事件的原因），另一方面采用事务队列的方式调用putListener将注册的事件存储起来，以供事件触发时回调。 注册事件的入口是listenTo方法, 它解决了不同浏览器间捕获和冒泡不兼容的问题。事件回调方法在bubble阶段被触发。如果我们想让它在capture阶段触发，则需要在事件名上加上capture。比如onClick在bubble阶段触发，而onCaptureClick在capture阶段触发。listenTo代码虽然比较长，但逻辑很简单，调用trapCapturedEvent和trapBubbledEvent来注册捕获和冒泡事件。trapCapturedEvent大家可以自行分析，我们仅分析trapBubbledEvent，如下 trapBubbledEvent: function (topLevelType, handlerBaseName, element) { if (!element) { return null; } return EventListener.listen( element, // 绑定到的DOM目标,也就是document handlerBaseName, // eventType ReactEventListener.dispatchEvent.bind(null, topLevelType)); // callback, document上的原生事件触发后回调 }, listen: function listen(target, eventType, callback) { if (target.addEventListener) { // 将原生事件添加到target这个dom上,也就是document上。 // 这就是只有document这个DOM节点上有原生事件的原因 target.addEventListener(eventType, callback, false); return { // 删除事件,这个由React自己回调,不需要调用者来销毁。但仅仅对于React合成事件才行 remove: function remove() { target.removeEventListener(eventType, callback, false); } }; } else if (target.attachEvent) { // attach和detach的方式 target.attachEvent(&#39;on&#39; + eventType, callback); return { remove: function remove() { target.detachEvent(&#39;on&#39; + eventType, callback); } }; } }, 在listen方法中，我们终于发现了熟悉的addEventListener这个原生事件注册方法。只有document节点才会调用这个方法，故仅仅只有document节点上才有DOM事件。这大大简化了DOM事件逻辑，也节约了内存。 事件存储事件存储由EventPluginHub来负责，它的入口在我们上面讲到的enqueuePutListener中的putListener方法，如下 /** * EventPluginHub用来存储React事件, 将listener存储到`listenerBank[registrationName][key]` * * @param {object} inst: 事件源 * @param {string} listener的名字,比如onClick * @param {function} listener的callback */ // putListener: function (inst, registrationName, listener) { // 用来标识注册了事件,比如onClick的React对象。key的格式为&#39;.nodeId&#39;, 只用知道它可以标示哪个React对象就可以了 var key = getDictionaryKey(inst); var bankForRegistrationName = listenerBank[registrationName] || (listenerBank[registrationName] = {}); // 将listener事件回调方法存入listenerBank[registrationName][key]中,比如listenerBank[&#39;onclick&#39;][nodeId] // 所有React组件对象定义的所有React事件都会存储在listenerBank中 bankForRegistrationName[key] = listener; //onSelect和onClick注册了两个事件回调插件, 用于walkAround某些浏览器兼容bug,不用care var PluginModule = EventPluginRegistry.registrationNameModules[registrationName]; if (PluginModule &amp;&amp; PluginModule.didPutListener) { PluginModule.didPutListener(inst, registrationName, listener); } }, var getDictionaryKey = function (inst) { return &#39;.&#39; + inst._rootNodeID; }; 由上可见，事件存储在了listenerBank对象中，它按照事件名和React组件对象进行了二维划分，比如nodeId组件上注册的onClick事件最后存储在listenerBank.onclick[nodeId]中 事件执行事件分发当事件触发时，document上addEventListener注册的callback会被回调。从前面事件注册部分发现，此时回调函数为ReactEventListener.dispatchEvent，它是事件分发的入口方法。下面我们来详细分析 // topLevelType：带top的事件名，如topClick。不用纠结为什么带一个top字段，知道它是事件名就OK了 // nativeEvent: 用户触发click等事件时，浏览器传递的原生事件 dispatchEvent: function (topLevelType, nativeEvent) { // disable了则直接不回调相关方法 if (!ReactEventListener._enabled) { return; } var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent); try { // 放入批处理队列中,React事件流也是一个消息队列的方式 ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping); } finally { TopLevelCallbackBookKeeping.release(bookKeeping); } } 可见我们仍然使用批处理的方式进行事件分发，handleTopLevelImpl才是事件分发的真正执行者，它是事件分发的核心，体现了React事件分发的特点，如下 // document进行事件分发,这样具体的React组件才能得到响应。因为DOM事件是绑定到document上的 function handleTopLevelImpl(bookKeeping) { // 找到事件触发的DOM和React Component var nativeEventTarget = getEventTarget(bookKeeping.nativeEvent); var targetInst = ReactDOMComponentTree.getClosestInstanceFromNode(nativeEventTarget); // 执行事件回调前,先由当前组件向上遍历它的所有父组件。得到ancestors这个数组。 // 因为事件回调中可能会改变Virtual DOM结构,所以要先遍历好组件层级 var ancestor = targetInst; do { bookKeeping.ancestors.push(ancestor); ancestor = ancestor &amp;&amp; findParent(ancestor); } while (ancestor); // 从当前组件向父组件遍历,依次执行注册的回调方法. 我们遍历构造ancestors数组时,是从当前组件向父组件回溯的,故此处事件回调也是这个顺序 // 这个顺序就是冒泡的顺序,并且我们发现不能通过stopPropagation来阻止&#39;冒泡&#39;。 for (var i = 0; i &lt; bookKeeping.ancestors.length; i++) { targetInst = bookKeeping.ancestors[i]; ReactEventListener._handleTopLevel(bookKeeping.topLevelType, targetInst, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent)); } } 从上面的事件分发中可见，React自身实现了一套冒泡机制。从触发事件的对象开始，向父元素回溯，依次调用它们注册的事件callback 事件callback 调用事件处理由_handleTopLevel完成。它其实是调用ReactBrowserEventEmitter.handleTopLevel() ，如下 // React事件调用的入口。DOM事件绑定在了document原生对象上,每次事件触发,都会调用到handleTopLevel handleTopLevel: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) { // 采用对象池的方式构造出合成事件。不同的eventType的合成事件可能不同 var events = EventPluginHub.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget); // 批处理队列中的events runEventQueueInBatch(events); } handleTopLevel方法是事件callback调用的核心。它主要做两件事情，一方面利用浏览器回传的原生事件构造出React合成事件，另一方面采用队列的方式处理events。先看如何构造合成事件。 构造合成事件 // 构造合成事件 extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) { var events; // EventPluginHub可以存储React合成事件的callback,也存储了一些plugin,这些plugin在EventPluginHub初始化时就注册就来了 var plugins = EventPluginRegistry.plugins; for (var i = 0; i &lt; plugins.length; i++) { var possiblePlugin = plugins[i]; if (possiblePlugin) { // 根据eventType构造不同的合成事件SyntheticEvent var extractedEvents = possiblePlugin.extractEvents(topLevelType, targetInst, nativeEvent, nativeEventTarget); if (extractedEvents) { // 将构造好的合成事件extractedEvents添加到events数组中,这样就保存了所有plugin构造的合成事件 events = accumulateInto(events, extractedEvents); } } } return events; }, EventPluginRegistry.plugins默认包含五种plugin，他们是在EventPluginHub初始化阶段注入进去的，且看代码 // 将eventPlugin注册到EventPluginHub中 ReactInjection.EventPluginHub.injectEventPluginsByName({ SimpleEventPlugin: SimpleEventPlugin, EnterLeaveEventPlugin: EnterLeaveEventPlugin, ChangeEventPlugin: ChangeEventPlugin, SelectEventPlugin: SelectEventPlugin, BeforeInputEventPlugin: BeforeInputEventPlugin }); 不同的plugin针对不同的事件有特殊的处理，此处我们不展开讲了，下面仅分析SimpleEventPlugin中方法即可。 我们先看SimpleEventPlugin如何构造它所对应的React合成事件。 // 根据不同事件类型,比如click,focus构造不同的合成事件SyntheticEvent, 如SyntheticKeyboardEvent SyntheticFocusEvent extractEvents: function (topLevelType, targetInst, nativeEvent, nativeEventTarget) { var dispatchConfig = topLevelEventsToDispatchConfig[topLevelType]; if (!dispatchConfig) { return null; } var EventConstructor; // 根据事件类型，采用不同的SyntheticEvent来构造不同的合成事件 switch (topLevelType) { ... // 省略一些事件，我们仅以blur和focus为例 case &#39;topBlur&#39;: case &#39;topFocus&#39;: EventConstructor = SyntheticFocusEvent; break; ... // 省略一些事件 } // 从event对象池中取出合成事件对象,利用对象池思想,可以大大降低对象创建和销毁的时间,提高性能。这是React事件系统的一大亮点 var event = EventConstructor.getPooled(dispatchConfig, targetInst, nativeEvent, nativeEventTarget); EventPropagators.accumulateTwoPhaseDispatches(event); return event; }, 这里我们看到了event对象池这个重大特性，采用合成事件对象池的方式，可以大大降低销毁和创建合成事件带来的性能开销。 对象创建好之后，我们还会将它添加到events这个队列中，因为事件回调的时候会用到这个队列。添加到events中使用的是accumulateInto方法。它思路比较简单，将新创建的合成对象的引用添加到之前创建好的events队列中即可，源码如下 function accumulateInto(current, next) { if (current == null) { return next; } // 将next添加到current中,返回一个包含他们两个的新数组 // 如果next是数组,current不是数组,采用push方法,否则采用concat方法 // 如果next不是数组,则返回一个current和next构成的新数组 if (Array.isArray(current)) { if (Array.isArray(next)) { current.push.apply(current, next); return current; } current.push(next); return current; } if (Array.isArray(next)) { return [current].concat(next); } return [current, next]; } 批量处理合成事件我们上面分析过了，React以队列的形式处理合成事件。方法入口为runEventQueueInBatch，如下 function runEventQueueInBatch(events) { // 先将events事件放入队列中 EventPluginHub.enqueueEvents(events); // 再处理队列中的事件,包括之前未处理完的。先入先处理原则 EventPluginHub.processEventQueue(false); } /** * syntheticEvent放入队列中,等到processEventQueue再获得执行 */ enqueueEvents: function (events) { if (events) { eventQueue = accumulateInto(eventQueue, events); } }, /** * 分发执行队列中的React合成事件。React事件是采用消息队列方式批处理的 * * simulated：为true表示React测试代码，我们一般都是false */ processEventQueue: function (simulated) { // 先将eventQueue重置为空 var processingEventQueue = eventQueue; eventQueue = null; if (simulated) { forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseSimulated); } else { // 遍历处理队列中的事件, // 如果只有一个元素,则直接executeDispatchesAndReleaseTopLevel(processingEventQueue) // 否则遍历队列中事件,调用executeDispatchesAndReleaseTopLevel处理每个元素 forEachAccumulated(processingEventQueue, executeDispatchesAndReleaseTopLevel); } // This would be a good time to rethrow if any of the event handlers threw. ReactErrorUtils.rethrowCaughtError(); }, 合成事件处理也分为两步，先将我们要处理的events队列放入eventQueue中，因为之前可能就存在还没处理完的合成事件。然后再执行eventQueue中的事件。可见，如果之前有事件未处理完，这里就又有得到执行的机会了。 事件执行的入口方法为executeDispatchesAndReleaseTopLevel，如下 var executeDispatchesAndReleaseTopLevel = function (e) { return executeDispatchesAndRelease(e, false); }; var executeDispatchesAndRelease = function (event, simulated) { if (event) { // 进行事件分发, EventPluginUtils.executeDispatchesInOrder(event, simulated); if (!event.isPersistent()) { // 处理完,则release掉event对象,采用对象池方式,减少GC // React帮我们处理了合成事件的回收机制，不需要我们关心。但要注意，如果使用了DOM原生事件，则要自己回收 event.constructor.release(event); } } }; // 事件处理的核心 function executeDispatchesInOrder(event, simulated) { var dispatchListeners = event._dispatchListeners; var dispatchInstances = event._dispatchInstances; if (Array.isArray(dispatchListeners)) { // 如果有多个listener,则遍历执行数组中event for (var i = 0; i &lt; dispatchListeners.length; i++) { // 如果isPropagationStopped设成true了,则停止事件传播,退出循环。 if (event.isPropagationStopped()) { break; } // 执行event的分发,从当前触发事件元素向父元素遍历 // event为浏览器上传的原生事件 // dispatchListeners[i]为JSX中声明的事件callback // dispatchInstances[i]为对应的React Component executeDispatch(event, simulated, dispatchListeners[i], dispatchInstances[i]); } } else if (dispatchListeners) { // 如果只有一个listener,则直接执行事件分发 executeDispatch(event, simulated, dispatchListeners, dispatchInstances); } // 处理完event,重置变量。因为使用的对象池,故必须重置,这样才能被别人复用 event._dispatchListeners = null; event._dispatchInstances = null; } executeDispatchesInOrder会先得到event对应的listeners队列，然后从当前元素向父元素遍历执行注册的callback。且看executeDispatch function executeDispatch(event, simulated, listener, inst) { var type = event.type || &#39;unknown-event&#39;; event.currentTarget = EventPluginUtils.getNodeFromInstance(inst); if (simulated) { // test代码使用,支持try-catch,其他就没啥区别了 ReactErrorUtils.invokeGuardedCallbackWithCatch(type, listener, event); } else { // 事件分发,listener为callback,event为参数,类似listener(event)这个方法调用 // 这样就回调到了我们在JSX中注册的callback。比如onClick={(event) =&gt; {console.log(1)}} // 这样应该就明白了callback怎么被调用的,以及event参数怎么传入callback里面的了 ReactErrorUtils.invokeGuardedCallback(type, listener, event); } event.currentTarget = null; } // 采用func(a)的方式进行调用， // 故ReactErrorUtils.invokeGuardedCallback(type, listener, event)最终调用的是listener(event) // event对象为浏览器传递的DOM原生事件对象，这也就解释了为什么React合成事件回调中能拿到原生event的原因 function invokeGuardedCallback(name, func, a) { try { func(a); } catch (x) { if (caughtError === null) { caughtError = x; } } } 总结React事件系统还是相当麻烦的，主要分为事件注册，事件存储和事件执行三大部分。了解了React事件系统源码，就能够轻松回答我们文章开头所列出的React事件几大特点了。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React源码分析 5 组件通信，ref,key,ReactDOM]]></title>
    <url>%2F2018%2F03%2F27%2FReact%2FReact-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-5-%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1%EF%BC%8Cref-key-ReactDOM%2F</url>
    <content type="text"><![CDATA[组件之间通信父组件向子组件通信React规定了明确的单向数据流，利用props将数据从父组件传递给子组件。故我们可以利用props，让父组件给子组件通信。故父组件向子组件通信还是很容易实现的。引申一点，父组件怎么向孙子组件通信呢？可以利用props进行层层传递，使用ES6的…运算符可以用很简洁的方式把props传递给孙子组件。这里我们就不举例了。 要注意的一点是，setProps,replaceProps两个API已经被废弃了，React建议我们在顶层使用ReactDOM.reader()进行props更新。 子组件向父组件通信React数据流是单向的，只能从父组件传递到子组件。那么子组件怎么向父组件通信呢？其实仍然可以利用props。父组件利用props传递方法给子组件，子组件回调这个方法的同时，将数据传递进去，使得父组件的相关方法得到回调，这个时候就可以把数据从子组件传递给父组件了。看一个例子。 class Parent extends React.Component { handleChildMsg(msg) { // 父组件处理消息 console.log(&quot;parent: &quot; + msg); } render() { return ( &lt;div&gt; &lt;Child transferMsg = {msg =&gt; this.handleChildMsg(msg)} /&gt; &lt;/div&gt; ); } } class Child extends React.Component { componentDidMount() { // 子组件中调用父组件的方法，将数据以参数的方式传递给父组件，这样父组件方法就得到回调了，也收到数据了 this.props.transferMsg(&quot;child has mounted&quot;); } render() { return ( &lt;div&gt;child&lt;/div&gt; ) } } 这个例子应该很清楚了，通过回调的方式，可以将数据从子组件传递给父组件。引申一下，孙子组件怎么把数据传递给父组件呢？同样可以利用props层层回调。利用ES6的…运算符也可以用比较简洁的方式完成props层层回调。 兄弟组件通信 - 发布/订阅兄弟组件可以利用父组件进行中转，将数据先由child1传给parent，然后parent传给child2. 这个方法显然耦合比较严重，传递次数过多，容易引发父组件不必要的生命周期回调，甚至影响其他子组件，故强烈建议不要使用这个方式。 我们可以利用观察者模式来解决这个问题。观察者模式采用发布/订阅的方法，可以将消息发送者和接收者完美解耦。React中可以引入eventProxy模块，利用eventProxy.trigger()方法发布消息，eventProxy.on()方法监听并接收消息。eventProxy我们就不展开讲了。下面看一个例子 import eventProxy from &#39;../eventProxy&#39; class Child1 extends React.Component { componentDidMount() { // 发布者，发出消息 eventProxy.trigger(&#39;msg&#39;, &#39;child1 has been mounted&#39;); } render() { return ( &lt;div&gt;child1&lt;/div&gt; ); } } class Child2 extends React.Component { componentDidMount() { // 订阅者，监听并接收消息 eventProxy.on(&#39;msg&#39;, (msg) =&gt; {console.log(&#39;msg: &#39; + msg)}); } render() { return ( &lt;div&gt;child2&lt;/div&gt; ); } } 嵌套层级深组件 - context祖父组件和孙子组件通信时，我们有时候还是觉得通过props有点繁琐了。此时可以考虑使用context全局变量。 使用方法：1.祖父组件中定义getChildContext()方法，将要传递给孙子的数据放在其中2.祖父组件中childContextTypes申明要传递的数据类型3.孙子组件中contextTypes申明可以接收的数据类型4.孙子组件通过this.context访问祖父传递进来的数据。 采用全局变量的方式，容易导致数据混乱，分不清数据是从哪儿来的，不容易控制。建议少用这种方式。 Redux还可以利用Flux和Redux架构来进行组件通信，这个我们以后再专门详细分析。 refs用法我们在getRender()返回的JSX中，可以在标签中加入ref属性，然后通过refs.ref就可以访问到我们的Component了，例如。 class Parent extends React.Component { getRender() { &lt;div&gt; &lt;Child ref = &#39;child&#39; /&gt; &lt;/div&gt; } componentDidMount() { // 通过refs可以拿到子元素,然后就可以访问到子元素的方法了 let child = this.refs.child; child.test(); } } class Child extends React.Component { test() { console.log(&quot;child method called by ref&quot;); } } attachRef 将子组件引用保存到父组件refs对象中refs的用法很简单，只需要JSX中定义好ref属性即可。那么首先一个问题来了，refs这个对象在哪儿定义的呢？还记得createClass方法的constructor吧，它里面会定义并初始化refs对象。源码如下 createClass: function (spec) { // 自定义React类的构造方法，通过它创建一个React.Component对象 var Constructor = identity(function (props, context, updater) { // Wire up auto-binding if (this.__reactAutoBindPairs.length) { bindAutoBindMethods(this); } this.props = props; this.context = context; // refs初始化为一个空对象 this.refs = emptyObject; this.updater = updater || ReactNoopUpdateQueue; // 调用getInitialState初始化state this.state = null; var initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; }); ... } 从上面代码可见，每次创建自定义组件的时候，都会初始化一个为空的refs对象。那么第二个问题来了，ref字符串所指向的对象的引用，是什么时候加入到refs对象中的呢？答案就在ReactCompositeComponent的attachRef方法中，源码如下 attachRef: function(ref, component) { // getPublicInstance返回我们的父组件 var inst = this.getPublicInstance(); var publicComponentInstance = component.getPublicInstance(); var refs = inst.refs === emptyObject ? (inst.refs = {}) : inst.refs; // 将子元素的引用，以ref属性为key,保存到父元素的refs对象中 refs[ref] = publicComponentInstance; }, attachRef方法又是什么时候被调用的呢？我们这儿就不源码分析了。大概说下，mountComponent中，如果element的ref属性不为空，则会以transaction事务的方式调用attachRefs方法，而attachRefs方法中则会调用attachRef方法，将子组件的引用保存到父组件的refs对象中。 detachRef 从父组件refs对象中删除子组件引用对内存管理有些了解的同学肯定会有疑惑，既然父组件的refs中保存了子组件引用，那么当子组件被unmountComponent而销毁时，子组件的引用仍然保存在refs对象中，岂不是会导致内存泄漏？React当然不会有这个bug了，秘密就在detachRef方法中，源码如下 detachRef: function(ref) { var refs = this.getPublicInstance().refs; // 从refs对象中删除key为ref子元素,防止内存泄漏 delete refs[ref]; }, 代码很简单，delete掉ref字符串指向的成员即可。至于detachRef的调用链，我们还得从unmountComponent方法说起。unmountComponent会调用detachRefs方法，而detachRefs中则会调用detachRef，从而将子元素引用从refs中释放掉，防止内存泄漏。也就是说在unmountComponent时，React自动帮我们完成了子元素ref删除，防止内存泄漏。 key当我们的子组件是一个数组时，比如类似于Android中的ListView，一个列表中有很多样式一致的项，此时给每个项加上key这个属性就很有作用了。key可以标示当前项的唯一性。 对于数组，其内部包含长度不确定的子项。当组件state变化时，需要重新渲染组件。那么有个问题来了，React是更新组件，还是先销毁再新建组件呢。key就是用来解决这个问题的。如果前后两次key不变，则只需要更新，否则先销毁再更新。 对于子项的key，必须是唯一不重复的。并且尽量传不变的属性，千万不要传无意义的index或者随机值。这样才能尽量以更新的方式来重新渲染。React源码中判断更新方式的源码如下 function shouldUpdateReactComponent(prevElement, nextElement) { // 前后两次ReactElement中任何一个为null，则必须另一个为null才返回true。这种情况一般不会碰到 var prevEmpty = prevElement === null || prevElement === false; var nextEmpty = nextElement === null || nextElement === false; if (prevEmpty || nextEmpty) { return prevEmpty === nextEmpty; } var prevType = typeof prevElement; var nextType = typeof nextElement; // React DOM diff算法 if (prevType === &#39;string&#39; || prevType === &#39;number&#39;) { // 如果前后两次为数字或者字符,则认为只需要update(处理文本元素)，返回true return (nextType === &#39;string&#39; || nextType === &#39;number&#39;); } else { // 如果前后两次为DOM元素或React元素,则必须type和key不变(key用于listView等组件,很多时候我们没有设置key，故只需type相同)才update,否则先unmount再重新mount。返回false return ( nextType === &#39;object&#39; &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key ); } } 看到key这个属性的重要性了吧。对于数组组件，我们一定要在每个子项上设置一个key，这样可以大大提高DOM diff的性能。 那为什么数组组件之外的其他组件，不用设置key呢？因为他们的type或者在父组件中的位置不同，完全可以区分开，所以不需要key就可以完全确定是哪个组件 无状态组件无状态组件其实本质上就是一个函数，传入props即可，没有state，也没有生命周期方法。组件本身对应的就是render方法。例子如下 function Title({color = &#39;red&#39;, text = &#39;标题&#39;}) { let style = { &#39;color&#39;: color } return ( &lt;div style = {style}&gt;{text}&lt;/div&gt; ) } 无状态组件不会创建对象，故比较省内存。没有复杂的生命周期方法调用，故流程比较简单。没有state，也不会重复渲染。它本质上就是一个函数而已。 对于没有状态变化的组件，React建议我们使用无状态组件。总之，能用无状态组件的地方，就用无状态组件。 react DOMReact通过findDOMNode()可以找到组件实例对应的DOM节点，但需要注意的是，我们只能在render()之后，也就是componentDidMount()和componentDidUpdate()中调用。因为只有render后，DOM对象才生成了。 class example extends React.Component { componentDidMount() { // 只有render后才生成了DOM node，才能调用findDOMNode let dom = ReactDOM.findDOMNode(this); } } 那为什么render后DOM才生成呢，我们可以从源码角度来分析。React源码分析3 — React组件插入DOM流程一文中，我们知道mountComponent解析得到了markup，也就是React组件对应的HTML，会由_mountImageIntoNode方法插入到真实DOM中，故这个事务结束后，才生成了真正的DOM。故肯定只有render之后，才有真实的DOM可以被访问。 那为什么componentDidMount()能访问DOM呢？它不是也在mountComponent()方法流程中吗？这是因为React采用异步事务的方式来调用componentDidMount的，它把componentDidMount放到一个事务队列中，只有当前mountComponent这个事务处理完了，才会回过头去处理componentDidMount，故在componentDidMount中可以拿到真实的DOM。这个设计得给React点赞。这一点可以从源码来分析。 mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) { // 省略一段代码 ... if (inst.componentDidMount) { // 调用componentDidMount，以事务的形式。放到queue中，异步的方式，有那么点Android MessageQueue的感觉 transaction.getReactMountReady().enqueue(inst.componentDidMount, inst); } return markup; }, 另外值得注意的是，React不建议我们碰底层的DOM，因为React有一套性能比较高的DOM diff方式来更新真实DOM。并且容易导致DOM引用忘记释放等内存泄漏问题。一句话，除非不得已，不要碰DOM。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码分析 4 setState机制]]></title>
    <url>%2F2018%2F03%2F27%2FReact%2FReact-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-4-setState%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[概述React作为一门前端框架，虽然只是focus在MVVM中的View部分，但还是实现了View和model的绑定。修改数据的同时，可以实现View的刷新。这大大简化了我们的逻辑，只用关心数据流的变化，同时减少了代码量，使得后期维护也更加方便。这个特性则要归功于setState()方法。React中利用队列机制来管理state，避免了很多重复的View刷新。下面我们来从源码角度探寻下setState机制。 setState和replaceState我们都知道setState是以修改和新增的方式改变state的，不会改变没有涉及到的state。而replaceState则用新的state完全替换掉老state。比如 this.state = { title: &quot;example&quot;, desc: &quot;this is an example for react&quot; }; setState({ title: &quot;new example&quot; }); console.log(&quot;setState: &quot; + JSON.stringify(this.state)); // 1 replaceState({ title: &quot;new example&quot; }) console.log(&quot;replaceState: &quot; + JSON.stringify(this.state)); // 2 打印如下: setState: {&quot;title&quot;:&quot;new example&quot;,&quot;desc&quot;:&quot;this is an example for react&quot;} replaceState: {&quot;title&quot;:&quot;new example&quot;} 可见，setState不会影响没有涉及到的state，而replaceState则是完完全全的替换。下面让我们进入源码来探寻究竟吧。 setStatesetState方法入口如下 ReactComponent.prototype.setState = function (partialState, callback) { // 将setState事务放入队列中 this.updater.enqueueSetState(this, partialState); if (callback) { this.updater.enqueueCallback(this, callback, &#39;setState&#39;); } }; 取名为partialState，有部分state的含义，可见只是影响涉及到的state，不会伤及无辜。enqueueSetState是state队列管理的入口方法，比较重要，我们之后再接着分析。 replaceStatereplaceState: function (newState, callback) { this.updater.enqueueReplaceState(this, newState); if (callback) { this.updater.enqueueCallback(this, callback, &#39;replaceState&#39;); } }, replaceState中取名为newState，有完全替换的含义。同样也是以队列的形式来管理的。 equeueSetStateenqueueSetState: function (publicInstance, partialState) { // 先获取ReactComponent组件对象 var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, &#39;setState&#39;); if (!internalInstance) { return; } // 如果_pendingStateQueue为空,则创建它。可以发现队列是数组形式实现的 var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []); queue.push(partialState); // 将要更新的ReactComponent放入数组中 enqueueUpdate(internalInstance); } 其中getInternalInstanceReadyForUpdate源码如下，解释都在代码注释中 function getInternalInstanceReadyForUpdate(publicInstance, callerName) { // 从map取出ReactComponent组件,还记得mountComponent时把ReactElement作为key，将ReactComponent存入了map中了吧，ReactComponent是React组件的核心，包含各种状态，数据和操作方法。而ReactElement则仅仅是一个数据类。 var internalInstance = ReactInstanceMap.get(publicInstance); if (!internalInstance) { return null; } return internalInstance; } enqueueUpdate源码如下 function enqueueUpdate(component) { ensureInjected(); // 如果不是正处于创建或更新组件阶段,则处理update事务 if (!batchingStrategy.isBatchingUpdates) { batchingStrategy.batchedUpdates(enqueueUpdate, component); return; } // 如果正在创建或更新组件,则暂且先不处理update,只是将组件放在dirtyComponents数组中 dirtyComponents.push(component); } enqueueUpdate包含了React避免重复render的逻辑。mountComponent和updateComponent方法在执行的最开始，会调用到batchedUpdates进行批处理更新，此时会将isBatchingUpdates设置为true，也就是将状态标记为现在正处于更新阶段了。之后React以事务的方式处理组件update，事务处理完后会调用wrapper.close(), 而TRANSACTION_WRAPPERS中包含了RESET_BATCHED_UPDATES这个wrapper，故最终会调用RESET_BATCHED_UPDATES.close(), 它最终会将isBatchingUpdates设置为false。这个过程比较麻烦，想更清晰的了解的话，建议自行分析源码。 故getInitialState，componentWillMount， render，componentWillUpdate 中setState都不会引起updateComponent。但在componentDidMount和componentDidUpdate中则会。 batchedUpdates: function (callback, a, b, c, d, e) { var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates; // 批处理最开始时，将isBatchingUpdates设为true，表明正在更新 ReactDefaultBatchingStrategy.isBatchingUpdates = true; // The code is written this way to avoid extra allocations if (alreadyBatchingUpdates) { callback(a, b, c, d, e); } else { // 以事务的方式处理updates，后面详细分析transaction transaction.perform(callback, null, a, b, c, d, e); } } var RESET_BATCHED_UPDATES = { initialize: emptyFunction, close: function () { // 事务批更新处理结束时，将isBatchingUpdates设为了false ReactDefaultBatchingStrategy.isBatchingUpdates = false; } }; var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; 事务transaction事务通过wrapper进行封装。一个wrapper包含一对initialize和close方法。比如RESET_BATCHED_UPDATES var RESET_BATCHED_UPDATES = { // 初始化调用 initialize: emptyFunction, // 事务执行完成，close时调用 close: function () { ReactDefaultBatchingStrategy.isBatchingUpdates = false; } }; transcation被包装在wrapper中，比如 var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; transaction是通过transaction.perform(callback, args…)方法进入的，它会先调用注册好的wrapper中的initialize方法，然后执行perform方法中的callback，最后再执行close方法。 下面分析transaction.perform(callback, args…) perform: function (method, scope, a, b, c, d, e, f) { var errorThrown; var ret; try { this._isInTransaction = true; errorThrown = true; // 先运行所有wrapper中的initialize方法 this.initializeAll(0); // 再执行perform方法传入的callback ret = method.call(scope, a, b, c, d, e, f); errorThrown = false; } finally { try { if (errorThrown) { // 最后运行wrapper中的close方法 try { this.closeAll(0); } catch (err) {} } else { // 最后运行wrapper中的close方法 this.closeAll(0); } } finally { this._isInTransaction = false; } } return ret; }, initializeAll: function (startIndex) { var transactionWrappers = this.transactionWrappers; // 遍历所有注册的wrapper for (var i = startIndex; i &lt; transactionWrappers.length; i++) { var wrapper = transactionWrappers[i]; try { this.wrapperInitData[i] = Transaction.OBSERVED_ERROR; // 调用wrapper的initialize方法 this.wrapperInitData[i] = wrapper.initialize ? wrapper.initialize.call(this) : null; } finally { if (this.wrapperInitData[i] === Transaction.OBSERVED_ERROR) { try { this.initializeAll(i + 1); } catch (err) {} } } } }, closeAll: function (startIndex) { var transactionWrappers = this.transactionWrappers; // 遍历所有wrapper for (var i = startIndex; i &lt; transactionWrappers.length; i++) { var wrapper = transactionWrappers[i]; var initData = this.wrapperInitData[i]; var errorThrown; try { errorThrown = true; if (initData !== Transaction.OBSERVED_ERROR &amp;&amp; wrapper.close) { // 调用wrapper的close方法，如果有的话 wrapper.close.call(this, initData); } errorThrown = false; } finally { if (errorThrown) { try { this.closeAll(i + 1); } catch (e) {} } } } this.wrapperInitData.length = 0; runBatchedUpdates更新组件前面分析到enqueueUpdate中调用transaction.perform(callback, args…)后，小伙伴们肯定会发现，callback还是enqueueUpdate方法啊，那岂不是死循环了？不是说好的setState会调用updateComponent，从而自动刷新View的吗？别急，我们还是要先从transaction事务说起。 我们的wrapper中注册了两个wrapper，如下 var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]; RESET_BATCHED_UPDATES用来管理isBatchingUpdates状态，我们前面在分析setState是否立即生效时已经讲解过了。那FLUSH_BATCHED_UPDATES用来干嘛呢？ var FLUSH_BATCHED_UPDATES = { initialize: emptyFunction, close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates) }; var flushBatchedUpdates = function () { // 循环遍历处理完所有dirtyComponents while (dirtyComponents.length || asapEnqueued) { if (dirtyComponents.length) { var transaction = ReactUpdatesFlushTransaction.getPooled(); // close前执行完runBatchedUpdates方法，这是关键 transaction.perform(runBatchedUpdates, null, transaction); ReactUpdatesFlushTransaction.release(transaction); } if (asapEnqueued) { asapEnqueued = false; var queue = asapCallbackQueue; asapCallbackQueue = CallbackQueue.getPooled(); queue.notifyAll(); CallbackQueue.release(queue); } } }; FLUSH_BATCHED_UPDATES会在一个transaction的close阶段运行runBatchedUpdates，从而执行update。 function runBatchedUpdates(transaction) { var len = transaction.dirtyComponentsLength; dirtyComponents.sort(mountOrderComparator); for (var i = 0; i &lt; len; i++) { // dirtyComponents中取出一个component var component = dirtyComponents[i]; // 取出dirtyComponent中的未执行的callback,下面就准备执行它了 var callbacks = component._pendingCallbacks; component._pendingCallbacks = null; var markerName; if (ReactFeatureFlags.logTopLevelRenders) { var namedComponent = component; if (component._currentElement.props === component._renderedComponent._currentElement) { namedComponent = component._renderedComponent; } } // 执行updateComponent ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction); // 执行dirtyComponent中之前未执行的callback if (callbacks) { for (var j = 0; j &lt; callbacks.length; j++) { transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance()); } } } } runBatchedUpdates循环遍历dirtyComponents数组，主要干两件事。首先执行performUpdateIfNecessary来刷新组件的view，然后执行之前阻塞的callback。下面来看performUpdateIfNecessary。 performUpdateIfNecessary: function (transaction) { if (this._pendingElement != null) { // receiveComponent会最终调用到updateComponent，从而刷新View ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context); } if (this._pendingStateQueue !== null || this._pendingForceUpdate) { // 执行updateComponent，从而刷新View。这个流程在React生命周期中讲解过 this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context); } }, 最后惊喜的看到了receiveComponent和updateComponent吧。receiveComponent最后会调用updateComponent，而updateComponent中会执行React组件存在期的生命周期方法，如componentWillReceiveProps， shouldComponentUpdate， componentWillUpdate，render, componentDidUpdate。 从而完成组件更新的整套流程。 总结setState流程还是很复杂的，设计也很精巧，避免了重复无谓的刷新组件。它的主要流程如下 enqueueSetState将state放入队列中，并调用enqueueUpdate处理要更新的Component 如果组件当前正处于update事务中，则先将Component存入dirtyComponent中。否则调用batchedUpdates处理。 batchedUpdates发起一次transaction.perform()事务 开始执行事务初始化，运行，结束三个阶段1.初始化：事务初始化阶段没有注册方法，故无方法要执行2.运行：执行setSate时传入的callback方法，一般不会传callback参数3.结束：更新isBatchingUpdates为false，并执行FLUSH_BATCHED_UPDATES这个wrapper中的close方法 FLUSH_BATCHED_UPDATES在close阶段，会循环遍历所有的dirtyComponents，调用updateComponent刷新组件，并执行它的pendingCallbacks, 也就是setState中设置的callback。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码分析 3 React生命周期详解]]></title>
    <url>%2F2018%2F03%2F26%2FReact%2FReact-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-3-React%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[React生命周期流程调用流程可以参看上图。分为实例化，存在期和销毁三个不同阶段。介绍生命周期流程的文章很多，相信大部分同学也有所了解，我们就不详细分析了。很多同学肯定有疑问，这些方法在React内部是在哪些方法中被调用的呢，他们触发的时机又是什么时候呢。下面我们来详细分析。 实例化生命周期getDefaultProps在React.creatClass()初始化组件类时，会调用getDefaultProps()，将返回的默认属性挂载到defaultProps变量下 这里要提的一点是，初始化组件类只运行一次。可以把它简单类比为Java中的Class对象。初始化组件类就是ClassLoader加载Class对象的过程。类对象的初始化不要错误理解成了实例对象的初始化。一个React组件类可能会在JSX中被多次调用，产生多个组件对象，但它只有一个类对象，也就是类加载后getDefaultProps就不会再调用了。 getlnitialState这个方法在创建组件实例对象的时候被调用，具体代码位于React.creatClass()的Constructor函数中。 每次创建React实例对象时，它都会被调用。 mountComponentcomponentWillMount，render，componentDidMount都是在mountComponent中被调用.它是在渲染新的ReactComponent中被调用的。输入ReactComponent，返回组件对应的HTML。把这个HTML插入到DOM中，就可以生成组件对应的DOM对象了。所以mountComponent尤其关键。 和Java中的多态一样，不同的React组件的mountComponent实现都有所区别。下面我们来重点分析React自定义组件类，也就是ReactCompositeComponent的mountComponent。 mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) { this._context = context; this._mountOrder = nextMountID++; this._nativeParent = nativeParent; this._nativeContainerInfo = nativeContainerInfo; // 做propTypes是否合法的判断，这个只在开发阶段有用 var publicProps = this._processProps(this._currentElement.props); var publicContext = this._processContext(context); var Component = this._currentElement.type; // 初始化公共类 var inst = this._constructComponent(publicProps, publicContext); var renderedElement; // inst或者inst.render为空对应的是stateless组件，也就是无状态组件 // 无状态组件没有实例对象，它本质上只是一个返回JSX的函数而已。是一种轻量级的React组件 if (!shouldConstruct(Component) &amp;&amp; (inst == null || inst.render == null)) { renderedElement = inst; warnIfInvalidElement(Component, renderedElement); inst = new StatelessComponent(Component); } // 设置变量 inst.props = publicProps; inst.context = publicContext; inst.refs = emptyObject; inst.updater = ReactUpdateQueue; this._instance = inst; // 存储实例对象的引用到map中，方便以后查找 ReactInstanceMap.set(inst, this); // 初始化state，队列等 var initialState = inst.state; if (initialState === undefined) { inst.state = initialState = null; } this._pendingStateQueue = null; this._pendingReplaceState = false; this._pendingForceUpdate = false; var markup; if (inst.unstable_handleError) { // 挂载时出错，进行一些错误处理，然后performInitialMount，初始化挂载 markup = this.performInitialMountWithErrorHandling(renderedElement, nativeParent, nativeContainerInfo, transaction, context); } else { // 初始化挂载 markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context); } if (inst.componentDidMount) { // 调用componentDidMount，以事务的形式 transaction.getReactMountReady().enqueue(inst.componentDidMount, inst); } return markup; }, mountComponent先做实例对象的props,state等初始化，然后调用performInitialMount初始化挂载，完成后调用componentDidMount。这个调用链还是很清晰的。下面我们重点来分析performInitialMountWithErrorHandling和performInitialMount performInitialMountWithErrorHandling: function (renderedElement, nativeParent, nativeContainerInfo, transaction, context) { var markup; var checkpoint = transaction.checkpoint(); try { // 放到try-catch中，如果没有出错则调用performInitialMount初始化挂载。可见这里没有什么特别的操作，也就是做一些错误处理而已 markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context); } catch (e) { // handleError，卸载组件，然后重新performInitialMount初始化挂载 transaction.rollback(checkpoint); this._instance.unstable_handleError(e); if (this._pendingStateQueue) { this._instance.state = this._processPendingState(this._instance.props, this._instance.context); } checkpoint = transaction.checkpoint(); this._renderedComponent.unmountComponent(true); transaction.rollback(checkpoint); markup = this.performInitialMount(renderedElement, nativeParent, nativeContainerInfo, transaction, context); } return markup; }, 可见performInitialMountWithErrorHandling只是多了一层错误处理而已，关键还是在performInitialMount中。 performInitialMount: function (renderedElement, nativeParent, nativeContainerInfo, transaction, context) { var inst = this._instance; if (inst.componentWillMount) { // render前调用componentWillMount inst.componentWillMount(); // 将state提前合并，故在componentWillMount中调用setState不会触发重新render，而是做一次state合并。这样做的目的是减少不必要的重新渲染 if (this._pendingStateQueue) { inst.state = this._processPendingState(inst.props, inst.context); } } // 如果不是stateless，即无状态组件，则调用render，返回ReactElement if (renderedElement === undefined) { renderedElement = this._renderValidatedComponent(); } // 得到组件类型，如空组件ReactNodeTypes.EMPTY，自定义React组件ReactNodeTypes.COMPOSITE，DOM原生组件ReactNodeTypes.NATIVE this._renderedNodeType = ReactNodeTypes.getType(renderedElement); // 由ReactElement生成ReactComponent，这个方法在之前讲解过。根据不同type创建不同Component对象 // 参考 http://blog.csdn.net/u013510838/article/details/55669769 this._renderedComponent = this._instantiateReactComponent(renderedElement); // 递归渲染，渲染子组件 var markup = ReactReconciler.mountComponent(this._renderedComponent, transaction, nativeParent, nativeContainerInfo, this._processChildContext(context)); return markup; }, performInitialMount中先调用componentWillMount()，再将setState()产生的state改变进行state合并，然后调用_renderValidatedComponent()返回ReactElement，它会调用render()方法。然后由ReactElement创建ReactComponent。最后进行递归渲染。下面来看renderValidatedComponent() _renderValidatedComponent: function () { var renderedComponent; ReactCurrentOwner.current = this; try { renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext(); } finally { ReactCurrentOwner.current = null; } !( return renderedComponent; }, _renderValidatedComponentWithoutOwnerOrContext: function () { var inst = this._instance; // 调用render方法，得到ReactElement。JSX经过babel转译后其实就是createElement()方法。这一点在前面也讲解过 var renderedComponent = inst.render(); return renderedComponent; }, 存在期生命周期组件实例对象已经生成时，我们可以通过setState()来更新组件。setState机制后面会有单独文章分析，现在只用知道它会调用updateComponent()来完成更新即可。下面来分析updateComponent updateComponent: function(transaction, prevParentElement, nextParentElement, prevUnmaskedContext, nextUnmaskedContext ) { var inst = this._instance; var willReceive = false; var nextContext; var nextProps; // context对象如果有改动,则检查propTypes等,这在开发阶段可以报错提醒 if (this._context === nextUnmaskedContext) { nextContext = inst.context; } else { nextContext = this._processContext(nextUnmaskedContext); willReceive = true; } // 如果父元素类型相同,则跳过propTypes类型检查 if (prevParentElement === nextParentElement) { nextProps = nextParentElement.props; } else { nextProps = this._processProps(nextParentElement.props); willReceive = true; } // 调用componentWillReceiveProps,如果通过setState进入的updateComponent，则没有这一步 if (willReceive &amp;&amp; inst.componentWillReceiveProps) { inst.componentWillReceiveProps(nextProps, nextContext); } // 提前合并state,componentWillReceiveProps中调用setState不会重新渲染,在此处做合并即可,因为后面也是要调用render的 // 这样可以避免没必要的渲染 var nextState = this._processPendingState(nextProps, nextContext); // 调用shouldComponentUpdate给shouldUpdate赋值 // 如果通过forceUpdate进入的updateComponent，即_pendingForceUpdate不为空，则不用判断shouldComponentUpdate. var shouldUpdate = true; if (!this._pendingForceUpdate &amp;&amp; inst.shouldComponentUpdate) { shouldUpdate = inst.shouldComponentUpdate(nextProps, nextState, nextContext); } // 如果shouldUpdate为true,则会执行渲染,否则不会 this._updateBatchNumber = null; if (shouldUpdate) { this._pendingForceUpdate = false; // 执行更新渲染,后面详细分析 this._performComponentUpdate( nextParentElement, nextProps, nextState, nextContext, transaction, nextUnmaskedContext ); } else { // shouldUpdate为false,则不会更新渲染 this._currentElement = nextParentElement; this._context = nextUnmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; } }, updateComponent中，先调用componentWillReceiveProps，然后合并setState导致的state变化。然后调用shouldComponentUpdate判断是否需要更新渲染。如果需要，则调用_performComponentUpdate执行渲染更新，下面接着分析performComponentUpdate。 _performComponentUpdate: function(nextElement,nextProps,nextState,nextContext,transaction, unmaskedContext ) { var inst = this._instance; // 判断是否已经update了 var hasComponentDidUpdate = Boolean(inst.componentDidUpdate); var prevProps; var prevState; var prevContext; if (hasComponentDidUpdate) { prevProps = inst.props; prevState = inst.state; prevContext = inst.context; } // render前调用componentWillUpdate if (inst.componentWillUpdate) { inst.componentWillUpdate(nextProps, nextState, nextContext); } // state props等属性设置到内部变量inst上 this._currentElement = nextElement; this._context = unmaskedContext; inst.props = nextProps; inst.state = nextState; inst.context = nextContext; // 内部会调用render方法，重新解析ReactElement并得到HTML this._updateRenderedComponent(transaction, unmaskedContext); // render后调用componentDidUpdate if (hasComponentDidUpdate) { transaction.getReactMountReady().enqueue( inst.componentDidUpdate.bind(inst, prevProps, prevState, prevContext), inst ); } }, _performComponentUpdate会调用componentWillUpdate，然后在调用updateRenderedComponent进行更新渲染，最后调用componentDidUpdate。下面来看看updateRenderedComponent中怎么调用render方法的。 _updateRenderedComponent: function(transaction, context) { var prevComponentInstance = this._renderedComponent; var prevRenderedElement = prevComponentInstance._currentElement; // _renderValidatedComponent内部会调用render,得到ReactElement var nextRenderedElement = this._renderValidatedComponent(); // 判断是否做DOM diff。React为了简化递归diff,认为组件层级不变,且type和key不变(key用于listView等组件,很多时候我们没有设置type)才update,否则先unmount再重新mount if (shouldUpdateReactComponent(prevRenderedElement, nextRenderedElement)) { // 递归updateComponent,更新子组件的Virtual DOM ReactReconciler.receiveComponent(prevComponentInstance, nextRenderedElement, transaction, this._processChildContext(context)); } else { var oldNativeNode = ReactReconciler.getNativeNode(prevComponentInstance); // 不做DOM diff,则先卸载掉,然后再加载。也就是先unMountComponent,再mountComponent ReactReconciler.unmountComponent(prevComponentInstance, false); this._renderedNodeType = ReactNodeTypes.getType(nextRenderedElement); // 由ReactElement创建ReactComponent this._renderedComponent = this._instantiateReactComponent(nextRenderedElement); // mountComponent挂载组件,得到组件对应HTML var nextMarkup = ReactReconciler.mountComponent(this._renderedComponent, transaction, this._nativeParent, this._nativeContainerInfo, this._processChildContext(context)); // 将HTML插入DOM中 this._replaceNodeWithMarkup(oldNativeNode, nextMarkup, prevComponentInstance); } }, _renderValidatedComponent: function() { var renderedComponent; ReactCurrentOwner.current = this; try { renderedComponent = this._renderValidatedComponentWithoutOwnerOrContext(); } finally { ReactCurrentOwner.current = null; } return renderedComponent; }, _renderValidatedComponentWithoutOwnerOrContext: function() { var inst = this._instance; // 看到render方法了把，应该放心了把~ var renderedComponent = inst.render(); return renderedComponent; }, 和mountComponent中一样，updateComponent也是用递归的方式将各子组件进行update的。这里要特别注意的是DOM diff。DOM diff是React中渲染加速的关键所在，它会帮我们算出virtual DOM中真正变化的部分，并对这部分进行原生DOM操作。为了避免循环递归对比节点的低效率，React中做了假设，即只对层级不变，type不变，key不变的组件进行Virtual DOM更新。这其中的关键是shouldUpdateReactComponent，下面分析 function shouldUpdateReactComponent(prevElement, nextElement) { var prevEmpty = prevElement === null || prevElement === false; var nextEmpty = nextElement === null || nextElement === false; if (prevEmpty || nextEmpty) { return prevEmpty === nextEmpty; } var prevType = typeof prevElement; var nextType = typeof nextElement; // React DOM diff算法 // 如果前后两次为数字或者字符,则认为只需要update(处理文本元素) // 如果前后两次为DOM元素或React元素,则必须在同一层级内,且type和key不变(key用于listView等组件,很多时候我们没有设置type)才update,否则先unmount再重新mount if (prevType === &#39;string&#39; || prevType === &#39;number&#39;) { return (nextType === &#39;string&#39; || nextType === &#39;number&#39;); } else { return ( nextType === &#39;object&#39; &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key ); } } 销毁前面提到过，更新组件时，如果不满足DOM diff条件，会先unmountComponent, 然后再mountComponent，下面我们来分析下unmountComponent时都发生了什么事。和mountComponent的多态一样，不同type的ReactComponent也会有不同的unmountComponent行为。我们来分析下React自定义组件，也就是ReactCompositeComponent中的unmountComponent。 unmountComponent: function(safely) { if (!this._renderedComponent) { return; } var inst = this._instance; // 调用componentWillUnmount if (inst.componentWillUnmount &amp;&amp; !inst._calledComponentWillUnmount) { inst._calledComponentWillUnmount = true; // 安全模式下，将componentWillUnmount包在try-catch中。否则直接componentWillUnmount if (safely) { var name = this.getName() + &#39;.componentWillUnmount()&#39;; ReactErrorUtils.invokeGuardedCallback(name, inst.componentWillUnmount.bind(inst)); } else { inst.componentWillUnmount(); } } // 递归调用unMountComponent来销毁子组件 if (this._renderedComponent) { ReactReconciler.unmountComponent(this._renderedComponent, safely); this._renderedNodeType = null; this._renderedComponent = null; this._instance = null; } // reset等待队列和其他等待状态 this._pendingStateQueue = null; this._pendingReplaceState = false; this._pendingForceUpdate = false; this._pendingCallbacks = null; this._pendingElement = null; // reset内部变量,防止内存泄漏 this._context = null; this._rootNodeID = null; this._topLevelWrapper = null; // 将组件从map中移除,还记得我们在mountComponent中将它加入了map中的吧 ReactInstanceMap.remove(inst); }, 可见，unmountComponent还是比较简单的，它就做三件事1.调用componentWillUnmount()2.递归调用unmountComponent(),销毁子组件3.将内部变量置空，防止内存泄漏 总结React自定义组件创建期，存在期，销毁期三个阶段的生命周期调用上面都讲完了。三个入口函数mountComponent，updateComponent，unmountComponent尤其关键。大家如果有兴趣，还可以自行分析ReactDOMEmptyComponent，ReactDOMComponent和ReactDOMTextComponent的这三个方法。 深入学习React生命周期源码可以帮我们理清各个方法的调用顺序，明白它们都是什么时候被调用的，哪些条件下才会被调用等等。阅读源码虽然有点枯燥，但能够大大加深对上层API接口的理解，并体会设计者设计这些API的良苦用心。 React组件生命周期过程说明实例化首次实例化 getDefaultPropsgetInitialStatecomponentWillMountrendercomponentDidMount实例化完成后的更新 getInitialStatecomponentWillMountrendercomponentDidMount存在期组件已存在时的状态改变 componentWillReceivePropsshouldComponentUpdatecomponentWillUpdaterendercomponentDidUpdate销毁&amp;清理期componentWillUnmount说明生命周期共提供了10个不同的API。 1.getDefaultProps作用于组件类，只调用一次，返回对象用于设置默认的props，对于引用值，会在实例中共享。 2.getInitialState作用于组件的实例，在实例创建时调用一次，用于初始化每个实例的state，此时可以访问this.props。 3.componentWillMount在完成首次渲染之前调用，此时仍可以修改组件的state。 4.render必选的方法，创建虚拟DOM，该方法具有特殊的规则： 只能通过this.props和this.state访问数据可以返回null、false或任何React组件只能出现一个顶级组件（不能返回数组）不能改变组件的状态不能修改DOM的输出5.componentDidMount真实的DOM被渲染出来后调用，在该方法中可通过this.getDOMNode()访问到真实的DOM元素。此时已可以使用其他类库来操作这个DOM。 在服务端中，该方法不会被调用。 6.componentWillReceiveProps组件接收到新的props时调用，并将其作为参数nextProps使用，此时可以更改组件props及state。 componentWillReceiveProps: function(nextProps) { if (nextProps.bool) { this.setState({ bool: true }); } } 7.shouldComponentUpdate组件是否应当渲染新的props或state，返回false表示跳过后续的生命周期方法，通常不需要使用以避免出现bug。在出现应用的瓶颈时，可通过该方法进行适当的优化。 在首次渲染期间或者调用了forceUpdate方法后，该方法不会被调用 8.componentWillUpdate接收到新的props或者state后，进行渲染之前调用，此时不允许更新props或state。 9.componentDidUpdate完成渲染新的props或者state后调用，此时可以访问到新的DOM元素。 10.componentWillUnmount组件被移除之前被调用，可以用于做一些清理工作，在componentDidMount方法中添加的所有任务都需要在该方法中撤销，比如创建的定时器或添加的事件监听器。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码分析 2 React组件插入Dom流程]]></title>
    <url>%2F2018%2F03%2F26%2FReact%2FReact-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-2-React%E6%8F%92%E5%85%A5Dom%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[简介React广受好评的一个重要原因就是组件化开发，一方面分模块的方式便于协同开发，降低耦合，后期维护也轻松；另一方面使得一次开发，多处复用成为现实，甚至可以直接复用开源React组件。开发完一个组件后，我们需要插入DOM中，一般使用如下代码 ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById(&#39;example&#39;) ); 经过babel转码后为 ReactDOM.render( React.createElement( &#39;h1&#39;, // type, DOM原生组件的type为string，React自定义组件type为Object null, // config，会设置到ref，key，props中 &#39;Hello, world!&#39; // children，子组件.这儿为文本组件 ), document.getElementById(&#39;example&#39;) ) 那么React底层是怎么将组件插入DOM中的呢。本文来详细分析它的前因后果。 ReactMount._renderSubtreeIntoContainer()ReactDOM.render()实际调用ReactMount.render(),接着调用到ReactMount._renderSubtreeIntoContainer(). 这个调用链比较简单，不分析了。下面重点分析_renderSubtreeIntoContainer(). 我们去除掉开发调试阶段的报错代码（比如 “development” !== ‘production’）。 /** * 将ReactElement插入DOM中，并返回ReactElement对应的ReactComponent。 * ReactElement是React元素在内存中的表示形式，可以理解为一个数据类，包含type，key，refs，props等成员变量 * ReactComponent是React元素的操作类，包含mountComponent(), updateComponent()等很多操作组件的方法 * * @param {parentComponent} 父组件，对于第一次渲染，为null * @param {nextElement} 要插入到DOM中的组件，对应上面例子中的&lt;h1&gt;Hello, world!&lt;/h1&gt;经过babel转译后的元素 * @param {container} 要插入到的容器，对应上面例子中的document.getElementById(&#39;example&#39;)获取的DOM对象 * @param {callback} 第一次渲染为null * * @return {component} 返回ReactComponent，对于ReactDOM.render()调用，不用管返回值。 */ _renderSubtreeIntoContainer: function (parentComponent, nextElement, container, callback) { // 刚开始一段开发阶段的报错代码，省去 ... // 包装ReactElement，将nextElement挂载到wrapper的props属性下，这段代码不是很关键 var nextWrappedElement = ReactElement(TopLevelWrapper, null, null, null, null, null, nextElement); // 获取要插入到的容器的前一次的ReactComponent，这是为了做DOM diff // 对于ReactDOM.render()调用，prevComponent为null var prevComponent = getTopLevelWrapperInContainer(container); if (prevComponent) { // 从prevComponent中获取到prevElement这个数据对象。一定要搞清楚ReactElement和ReactComponent的作用，他们很关键 var prevWrappedElement = prevComponent._currentElement; var prevElement = prevWrappedElement.props; // DOM diff精髓，同一层级内，type和key不变时，只用update就行。否则先unmount组件再mount组件 // 这是React为了避免递归太深，而做的DOM diff前提假设。它只对同一DOM层级，type相同，key(如果有)相同的组件做DOM diff，否则不用比较，直接先unmount再mount。这个假设使得diff算法复杂度从O(n^3)降低为O(n). // shouldUpdateReactComponent源码请看后面的分析 if (shouldUpdateReactComponent(prevElement, nextElement)) { var publicInst = prevComponent._renderedComponent.getPublicInstance(); var updatedCallback = callback &amp;&amp; function () { callback.call(publicInst); }; // 只需要update，调用_updateRootComponent，然后直接return了 ReactMount._updateRootComponent(prevComponent, nextWrappedElement, container, updatedCallback); return publicInst; } else { // 不做update，直接先卸载再挂载。即unmountComponent,再mountComponent。mountComponent在后面代码中进行 ReactMount.unmountComponentAtNode(container); } } var reactRootElement = getReactRootElementInContainer(container); var containerHasReactMarkup = reactRootElement &amp;&amp; !!internalGetID(reactRootElement); var containerHasNonRootReactChild = hasNonRootReactChild(container); var shouldReuseMarkup = containerHasReactMarkup &amp;&amp; !prevComponent &amp;&amp; !containerHasNonRootReactChild; // 初始化，渲染组件，然后插入到DOM中。_renderNewRootComponent很关键，后面详细分析 var component = ReactMount._renderNewRootComponent(nextWrappedElement, container, shouldReuseMarkup, parentComponent != null ? parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context) : emptyObject)._renderedComponent.getPublicInstance(); // render方法中带入的回调，ReactDOM.render()调用时一般不传入 if (callback) { callback.call(component); } return component; }, shouldUpdateReactComponent()源码如下： function shouldUpdateReactComponent(prevElement, nextElement) { // 前后两次ReactElement中任何一个为null，则必须另一个为null才返回true。这种情况一般不会碰到 var prevEmpty = prevElement === null || prevElement === false; var nextEmpty = nextElement === null || nextElement === false; if (prevEmpty || nextEmpty) { return prevEmpty === nextEmpty; } var prevType = typeof prevElement; var nextType = typeof nextElement; // React DOM diff算法 if (prevType === &#39;string&#39; || prevType === &#39;number&#39;) { // 如果前后两次为数字或者字符,则认为只需要update(处理文本元素)，返回true return (nextType === &#39;string&#39; || nextType === &#39;number&#39;); } else { // 如果前后两次为DOM元素或React元素,则必须type和key不变(key用于listView等组件,很多时候我们没有设置key，故只需type相同)才update,否则先unmount再重新mount。返回false return ( nextType === &#39;object&#39; &amp;&amp; prevElement.type === nextElement.type &amp;&amp; prevElement.key === nextElement.key ); } } ReactMount._renderNewRootComponent _renderNewRootComponent: function (nextElement, container, shouldReuseMarkup, context) { ReactBrowserEventEmitter.ensureScrollValueMonitoring(); // 初始化ReactComponent，根据ReactElement中不同的type字段，创建不同类型的组件对象，即ReactComponent // 前一篇文章中已经分析了。http://blog.csdn.net/u013510838/article/details/55669769 var componentInstance = instantiateReactComponent(nextElement); // 处理batchedMountComponentIntoNode方法调用，将ReactComponent插入DOM中，后面详细分析 ReactUpdates.batchedUpdates(batchedMountComponentIntoNode, componentInstance, container, shouldReuseMarkup, context); var wrapperID = componentInstance._instance.rootID; instancesByReactRootID[wrapperID] = componentInstance; return componentInstance; }, batchedMountComponentIntoNode以transaction事务的形式调用mountComponentIntoNode，源码分析如下。 function mountComponentIntoNode(wrapperInstance, container, transaction, shouldReuseMarkup, context) { var markerName; // 一段log，可以不管 if (ReactFeatureFlags.logTopLevelRenders) { var wrappedElement = wrapperInstance._currentElement.props; var type = wrappedElement.type; markerName = &#39;React mount: &#39; + (typeof type === &#39;string&#39; ? type : type.displayName || type.name); console.time(markerName); } // 调用对应ReactComponent中的mountComponent方法来渲染组件，这个是React生命周期的重要方法。后面详细分析。 // mountComponent返回React组件解析的HTML。不同的ReactComponent的mountComponent策略不同，可以看做多态 // 上面的&lt;h1&gt;Hello, world!&lt;/h1&gt;, 对应的是ReactDOMTextComponent，最终解析成的HTML为 // &lt;h1 data-reactroot=&quot;&quot;&gt;Hello, world!&lt;/h1&gt; var markup = ReactReconciler.mountComponent(wrapperInstance, transaction, null, ReactDOMContainerInfo(wrapperInstance, container), context); if (markerName) { console.timeEnd(markerName); } wrapperInstance._renderedComponent._topLevelWrapper = wrapperInstance; // 将解析出来的HTML插入DOM中 ReactMount._mountImageIntoNode(markup, container, wrapperInstance, shouldReuseMarkup, transaction); } _mountImageIntoNode源码如下 _mountImageIntoNode: function (markup, container, instance, shouldReuseMarkup, transaction) { // 对于ReactDOM.render()调用，shouldReuseMarkup为false if (shouldReuseMarkup) { ... } if (transaction.useCreateElement) { // 清空container的子节点，这个地方不明白为什么这么做 while (container.lastChild) { container.removeChild(container.lastChild); } DOMLazyTree.insertTreeBefore(container, markup, null); } else { // 将markup这个HTML设置到container这个DOM元素的innerHTML属性上，这样就插入到了DOM中了 setInnerHTML(container, markup); // 将instance这个ReactComponent渲染后的对象，即Virtual DOM，保存到container这个DOM元素的firstChild这个原生节点上。简单理解就是将Virtual DOM保存到内存中，这样可以大大提高交互效率 ReactDOMComponentTree.precacheNode(instance, container.firstChild); } } 总结ReactDOM.render(）是渲染React组件并插入到DOM中的入口方法，它的执行流程大概为 1.React.createElement(),创建ReactElement对象。他的重要的成员变量有type,key,ref,props。这个过程中会调用getInitialState(), 初始化state，只在挂载的时候才调用。后面update时不再调用了。 2.instantiateReactComponent()，根据ReactElement的type分别创建ReactDOMComponent， ReactCompositeComponent，ReactDOMTextComponent等对象 3.mountComponent(), 调用React生命周期方法解析组件，得到它的HTML。 4._mountImageIntoNode(), 将HTML插入到DOM父节点中，通过设置DOM父节点的innerHTML属性。 5.缓存节点在React中的对应对象，即Virtual DOM。 !()[] 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 源码分析 1 组件和对象的创建（createClass，createElement)]]></title>
    <url>%2F2018%2F03%2F25%2FReact%2FReact-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1-%E7%BB%84%E4%BB%B6%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%EF%BC%88createClass%EF%BC%8CcreateElement%2F</url>
    <content type="text"><![CDATA[React受大家欢迎的一个重要原因就是可以自定义组件。这样的一方面可以复用开发好的组件，实现一处开发，处处调用，另外也能使用别人开发好的组件，提高封装性。另一方面使得代码结构很清晰，组件间耦合减少，方便维护。ES5创建组件时，调用React.createClass()即可. ES6中使用class myComponent extends React.Component, 其实内部还是调用createClass创建组件。 组件创建我们可以简单类比为Java中ClassLoader加载class。下面来分析下createClass的源码，我们省去了开发阶段错误提示的相关代码，如propType的检查。（if (“development” !== ‘production’) {}代码段都不进行分析了，这些只在开发调试阶段调用） 组件创建createClass: function (spec) { var Constructor = function (props, context, updater) { // 触发自动绑定 if (this.__reactAutoBindPairs.length) { bindAutoBindMethods(this); } // 初始化参数 this.props = props; this.context = context; this.refs = emptyObject; // 本组件对象的引用，可以利用它来调用组件的方法 this.updater = updater || ReactNoopUpdateQueue; // 调用getInitialState()来初始化state变量 this.state = null; var initialState = this.getInitialState ? this.getInitialState() : null; this.state = initialState; }; // 继承父类 Constructor.prototype = new ReactClassComponent(); Constructor.prototype.constructor = Constructor; Constructor.prototype.__reactAutoBindPairs = []; injectedMixins.forEach(mixSpecIntoComponent.bind(null, Constructor)); mixSpecIntoComponent(Constructor, spec); // 调用getDefaultProps，并挂载到组件类上。defaultProps是类变量，使用ES6写法时更清晰 if (Constructor.getDefaultProps) { Constructor.defaultProps = Constructor.getDefaultProps(); } // React中暴露给应用调用的方法，如render componentWillMount。 // 如果应用未设置，则将他们设为null for (var methodName in ReactClassInterface) { if (!Constructor.prototype[methodName]) { Constructor.prototype[methodName] = null; } } return Constructor; }, createClass主要做的事情有1.定义构造方法Constructor，构造方法中进行props，refs等的初始化，并调用getInitialState来初始化state2.调用getDefaultProps，并放在defaultProps类变量上。这个变量不属于某个单独的对象。可理解为static 变量3.将React中暴露给应用，但应用中没有设置的方法，设置为null。 对象的创建JSX中创建React元素最终会被babel转译为createElement(type, config, children), babel根据JSX中标签的首字母来判断是原生DOM组件，还是自定义React组件。如果首字母大写，则为React组件。这也是为什么ES6中React组件类名必须大写的原因。如下面代码 &lt;div className=&quot;title&quot; ref=&quot;example&quot;&gt; &lt;span&gt;123&lt;/span&gt; // 原生DOM组件，首字母小写 &lt;ErrorPage title=&#39;123456&#39; desc={[]}/&gt; // 自定义组件，首字母大写 &lt;/div&gt; 转译完成后 React.createElement( &#39;div&#39;, // type,标签名,原生DOM对象为String { className: &#39;title&#39;, ref: &#39;example&#39; }, // config，属性 React.createElement(&#39;span&#39;, null, &#39;123&#39;), // children，子元素 React.createElement( // type,标签名,React自定义组件的type不为String. // _errorPage2.default为从其他文件中引入的React组件 _errorPage2.default, { title: &#39;123456&#39;, desc: [] } ) // children，子元素 ) 下面来分析下createElement的源码 ReactElement.createElement = function (type, config, children) { var propName; // 初始化参数 var props = {}; var key = null; var ref = null; var self = null; var source = null; // 从config中提取出内容，如ref key props if (config != null) { ref = config.ref === undefined ? null : config.ref; key = config.key === undefined ? null : &#39;&#39; + config.key; self = config.__self === undefined ? null : config.__self; source = config.__source === undefined ? null : config.__source; // 提取出config中的prop，放入props变量中 for (propName in config) { if (config.hasOwnProperty(propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) { props[propName] = config[propName]; } } } // 处理children，挂到props的children属性下 // 入参的前两个为type和config，后面的就都是children参数了。故需要减2 var childrenLength = arguments.length - 2; if (childrenLength === 1) { // 只有一个参数时，直接挂到children属性下，不是array的方式 props.children = children; } else if (childrenLength &gt; 1) { // 不止一个时，放到array中，然后将array挂到children属性下 var childArray = Array(childrenLength); for (var i = 0; i &lt; childrenLength; i++) { childArray[i] = arguments[i + 2]; } props.children = childArray; } // 取出组件类中的静态变量defaultProps，并给未在JSX中设置值的属性设置默认值 if (type &amp;&amp; type.defaultProps) { var defaultProps = type.defaultProps; for (propName in defaultProps) { if (props[propName] === undefined) { props[propName] = defaultProps[propName]; } } } // 返回一个ReactElement对象 return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props); }; 下面来看ReactElement源码 var ReactElement = function (type, key, ref, self, source, owner, props) { var element = { // This tag allow us to uniquely identify this as a React Element $$typeof: REACT_ELEMENT_TYPE, // ReactElement对象上的四个变量，特别关键 type: type, key: key, ref: ref, props: props, // Record the component responsible for creating this element. _owner: owner }; return element; } 可以看到仅仅是给ReactElement对象内的成员变量赋值而已，不在赘述。 流程如如下 组件对象初始化在mountComponent()挂载组件中，会进行组件渲染，调用到instantiateReactComponent()方法。这个过程我们在React生命周期方法中再详细讲述，这里有个大体了解即可。instantiateReactComponent()根据ReactElement中不同的type字段，创建不同类型的组件对象。源码如下 // 初始化组件对象，node是一个ReactElement对象，是节点元素在React中的表示 function instantiateReactComponent(node) { var instance; var isEmpty = node === null || node === false; if (isEmpty) { // 空对象 instance = ReactEmptyComponent.create(instantiateReactComponent); } else if (typeof node === &#39;object&#39;) { // 组件对象，包括DOM原生的和React自定义组件 var element = node; // 根据ReactElement中的type字段区分 if (typeof element.type === &#39;string&#39;) { // type为string则表示DOM原生对象，比如div span等。可以参看上面babel转译的那段代码 instance = ReactNativeComponent.createInternalComponent(element); } else if (isInternalComponentType(element.type)) { // 保留给以后版本使用，此处暂时不会涉及到 instance = new element.type(element); } else { // React自定义组件 instance = new ReactCompositeComponentWrapper(element); } } else if (typeof node === &#39;string&#39; || typeof node === &#39;number&#39;) { // 元素是一个string时，对应的比如&lt;span&gt;123&lt;/span&gt; 中的123 // 本质上它不是一个ReactElement，但为了统一，也按照同样流程处理，称为ReactDOMTextComponent instance = ReactNativeComponent.createInstanceForText(node); } else { // 无处理 } // 初始化参数，这两个参数是DOM diff时用到的 instance._mountIndex = 0; instance._mountImage = null; return instance; } 故我们可以看到有四种创建组件元素的方式，同时对应四种ReactElement1.ReactEmptyComponent.create(), 创建空对象ReactDOMEmptyComponent2.ReactNativeComponent.createInternalComponent(), 创建DOM原生对象 ReactDOMComponent3.new ReactCompositeComponentWrapper(), 创建React自定义对象ReactCompositeComponent4.ReactNativeComponent.createInstanceForText(), 创建文本对象 ReactDOMTextComponent 下面分别分析这几种对象，和创建他们的过程。 ReactDOMEmptyComponent由ReactEmptyComponent.create()创建，最终生成ReactDOMEmptyComponent对象，源码如下 var emptyComponentFactory; var ReactEmptyComponentInjection = { injectEmptyComponentFactory: function (factory) { emptyComponentFactory = factory; } }; var ReactEmptyComponent = { create: function (instantiate) { return emptyComponentFactory(instantiate); } }; ReactEmptyComponent.injection = ReactEmptyComponentInjection; ReactInjection.EmptyComponent.injectEmptyComponentFactory(function (instantiate) { // 前面比较绕，关键就是这句话，创建ReactDOMEmptyComponent对象 return new ReactDOMEmptyComponent(instantiate); }); // 各种null，就不分析了 var ReactDOMEmptyComponent = function (instantiate) { this._currentElement = null; this._nativeNode = null; this._nativeParent = null; this._nativeContainerInfo = null; this._domID = null; }; ReactDOMComponent由ReactNativeComponent.createInternalComponent()创建。这里注意原生组件不代表是DOM组件，而是React封装过的Virtual DOM对象。React并不直接操作原生DOM。 大家可以自己看ReactDOMComponent的源码。重点看下ReactDOMComponent.Mixin ReactDOMComponent.Mixin = { mountComponent: function (transaction, nativeParent, nativeContainerInfo, context) {}, _createOpenTagMarkupAndPutListeners: function (transaction, props){}, _createContentMarkup: function (transaction, props, context) {}, _createInitialChildren: function (transaction, props, context, lazyTree) {} receiveComponent: function (nextElement, transaction, context) {}, updateComponent: function (transaction, prevElement, nextElement, context) {}, _updateDOMProperties: function (lastProps, nextProps, transaction) {}, _updateDOMChildren: function (lastProps, nextProps, transaction, context) {}, getNativeNode: function () {}, unmountComponent: function (safely) {}, getPublicInstance: function () {} } 其中暴露给外部的比较关键的是mountComponent，receiveComponen， updateComponent，unmountComponent。他们会引发React生命周期方法的调用，下一节再讲。 ReactCompositeComponent由new ReactCompositeComponentWrapper()创建，重点看下ReactCompositeComponentMixin var ReactCompositeComponentMixin = { // new对应的方法，创建ReactCompositeComponent对象 construct: function(element) {}, mountComponent, // 初始挂载组件时被调用，仅一次 performInitialMountWithErrorHandling, // 和performInitialMount相近，只是多了错误处理 performInitialMount, // 执行mountComponent的渲染阶段，会调用到instantiateReactComponent，从而进入初始化React组件的入口 getNativeNode, unmountComponent, // 卸载组件，内存释放等工作 receiveComponent, performUpdateIfNecessary, updateComponent, // setState后被调用，重新渲染组件 attachRef, // 将ref指向组件对象，这样我们就可以利用它调用对象内的方法了 detachRef, // 将组件的引用从全局对象refs中删掉，这样我们就不能利用ref找到组件对象了 instantiateReactComponent， // 初始化React组件的入口，在mountComponent时的渲染阶段会被调用 } ReactDOMTextComponent 由ReactNativeComponent.createInstanceForText()创建，我们也不细细分析了，主要入口代码如下，大家可以自行分析。 var ReactDOMTextComponent = function (text) { this._currentElement = text; this._stringText = &#39;&#39; + text; }; _assign(ReactDOMTextComponent.prototype, { mountComponent, receiveComponent, getNativeNode, unmountComponent } 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[javascript实用技巧]]></title>
    <url>%2F2018%2F03%2F23%2FJs%2Fjavascript%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[更短的数组去重写法[...new Set([2,&quot;12&quot;,2,12,1,2,1,6,12,13,6])] //[2, &quot;12&quot;, 12, 1, 6, 13] //es6的新特性 对象深浅拷贝1.深拷贝和浅拷贝只针对像Object, Array这样的引用类型数据。 2.浅拷贝是对对象引用地址进行拷贝，并没有开辟新的栈，也就是拷贝后的结果是两个对象指向同一个引用地址，修改其中一个对象的属性，则另一个对象的属性也会改变。 3.深拷贝则是开启一个新的栈，两个对象对应两个不同的引用地址，修改一个对象的属性，不会改变另一个对象的属性。 浅拷贝 var myInfo={name:&#39;守候&#39;,sex:&#39;男&#39;}; var newInfo=myInfo; newInfo.sex=&#39;女&#39;; console.log(myInfo) //{name: &quot;守候&quot;, sex: &quot;女&quot;} 假-深拷贝假-深拷贝这个是自己随性命名的，大家看看就好，别当真！ var myInfo={name:&#39;守候&#39;,sex:&#39;男&#39;}; var newInfo=Object.assign({},myInfo) newInfo.sex=&#39;女&#39;; 真-深拷贝真-深拷贝这个是自己随性命名的，大家看看就好，别当真！看着深浅拷贝，区别写法很简单，但是那个上面的深拷贝写法是有问题的。看下面案例 var arr=[{a:1,b:2},{a:3,b:4}] var newArr=Object.assign([],arr) //截断数组 newArr.length=1 console.log(newArr)//[{a:1,b:2}] console.log(arr)//[{a:1,b:2},{a:3,b:4}] //操作newArr，这里看着对arr没影响，实际上已经挖了一个坑，下面就跳进去 newArr[0].a=123 //修改newArr[0]这个对象，也是影响了arr[0]这个对象 console.log(arr[0])//{a: 123, b: 2} //利用递归来实现深拷贝，如果对象属性的值是引用类型（Array,Object），那么对该属性进行深拷贝，直到遍历到属性的值是基本类型为止。 function deepClone(obj){ if(!obj&amp;&amp; typeof obj!== &#39;object&#39;){ return; } var newObj= obj.constructor === Array ? [] : {}; for(var key in obj){ if(obj[key]){ if(obj[key] &amp;&amp; typeof obj[key] === &#39;object&#39;){ newObj[key] = obj[key].constructor === Array ? [] : {}; //递归 newObj[key] = deepClone(obj[key]); }else{ newObj[key] = obj[key]; } } } return newObj; } var arr=[{a:1,b:2},{a:3,b:4}] var newArr=deepClone(arr) console.log(arr[0])//{a:1,b:2} newArr[0].a=123 console.log(arr[0])//{a:1,b:2} 还有一个方法就是简单粗暴法，我现在在用的一个方法！原理很简单，就是先把对象转成字符串，再把字符串转成对象！也能实现同样效果 var newArr2=JSON.parse(JSON.stringify(arr)); console.log(arr[0])//{a:1,b:2} newArr2[0].a=123 console.log(arr[0])//{a:1,b:2} 上面所说的浅拷贝，真假深拷贝（自己随性命名的），这几种情况，在开发上都有可能要用到，至于要使用哪一种方式，视情况而定！ 使用事件委托一个简单的需求，比如想给ul下面的li加上点击事件，点击哪个li，就显示那个li的innerHTML。这个貌似很简单！代码如下！ &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul-test&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oUl=document.getElementById(&quot;ul-test&quot;); var oLi=oUl.getElementsByTagName(&quot;li&quot;); for(var i=0,len=oLi.length;i&lt;len;i++){ oLi[i].addEventListener(&quot;click&quot;,function(){ alert(this.innerHTML) }) } &lt;/script&gt; &lt;/html&gt; 很简单，这样就实现了，实际上这里有坑，也待优化！1.for循环，循环的是li，10个li就循环10次，绑定10次事件，100个就循环了100次，绑定100次事件！2.如果li不是本来就在页面上的，是未来元素，是页面加载了，再通过js动态加载进来了，上面的写法是无效的，点击li是没有反应的！所以就者需要用事件委托（即使不考虑上面的第二种情况，也是建议使用事件委托）！代码如下 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul-test&quot;&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;li&gt;9&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oUl=document.getElementById(&quot;ul-test&quot;); oUl.addEventListener(&quot;click&quot;,function(ev){ var ev=ev||window.event; var target=ev.target||ev.srcElement; //如果点击的最底层是li元素 if(target.tagName.toLowerCase()===&#39;li&#39;){ alert(target.innerHTML) } }) &lt;/script&gt; &lt;/html&gt; 这样写，即使是动态添加进来的li点击也有反应，还有一个就是ul只有一个，事件绑定在ul上，无论li多少个，都是添加一次事件！但是也是可能会有问题，如果li下面还有子元素，那么点击的时候，target可能不是li，而是鼠标点击那个位置的最底层元素！如下图，如果鼠标点击白色区域，那个target就是body元素,鼠标点击绿色区域target就是div元素，鼠标点击蓝色区域target就是ul，点击橙色就是li。 使用对象作为函数参数大家试想下这样一个函数–函数接受几个参数，但是这几个参数都不是必填的，函数该怎么处理？是不是下面这样 function personInfo(name,phone,card){ ... } //以上函数，可以任意传参数。比如我想传card等于1472586326。这下是不是这样写 personInfo(&#39;&#39;,&#39;&#39;,&#39;1472586326&#39;) 有没有觉得上面写法奇怪，不太优雅？下面这里看着舒服一点！ function personInfo(opt){ ... } personInfo({card:&#39;1472586326&#39;}) 再想一下，如果一个函数，参数很多，怎么处理？ function test(arg1,arg2,arg3,arg4,arg5,arg6,arg7){ ... } 密集恐惧症复发没有复发？下面这样看着会舒服一点！ function personInfo(opt){ ... } 最后再想一下，如果需求改了，操作函数也要改！函数也要增加一个参数。 //原来函数 function personInfo(name,phone,card){ ... } //修改后 function personInfo(name,age,phone,card){ ... } 这样就是参数修改一次，函数的参数就要修改一次！如果是用对象，就不会出现这样问题！ //修改前后都是这样，变得是函数的操作内容和调用时候的传参！ function personInfo(opt){ ... } 看了上面的几个栗子，总结来说，就是当函数的参数不固定的时候，参数多(三个或者三个以上)的时候，建议用一个对象记录参数，这样会比较方便，也为以后如果参数要改留了条后路！ 使用push和apply合并数组合并数组这个已经是老生常谈的话题了，方法也是多种多样！ concatvar arr1=[1,2,3,4,5],arr2=[6,7,8,9,10]; arr1=arr1.concat(arr2) console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] concat会一个全新的数组，表示arr1和arr2两个数组的组合，并让arr1和arr2不变。简单吧？但如果arr1和arr2的长度都很长，那就产生了一个很长很长的数组，内存又被占用了那么多。但是数组长度没限制！ forvar arr1=[1,2,3,4,5],arr2=[6,7,8,9,10]; for(var i=0,len=arr2.length;i&lt;len;i++){ arr1.push(arr2[i]) } console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 这里是往arr1循环添加arr2的元素，但是有一个情况，arr1的长度远小于arr2的长度，是不是循环arr1性能更好，循环次数更少。处理这个很简单，但是万一不知道arr1和arr2到底哪个长度更少呢？而且，for循环不够优雅！（当然，这个可以用迭代方法来替代） reducevar arr1=[1,2,3,4,5],arr2=[6,7,8,9,10]; arr1 = arr2.reduce((fcoll,item) =&gt; { coll.push( item ); return coll; }, arr1 ); console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 逼格高了一点，而且用ES6的箭头函数还可以减少一些代码量，但它仍然需要一个函数，每个元素都需要调用一次。 push.applyvar arr1=[1,2,3,4,5],arr2=[6,7,8,9,10]; arr1.push.apply(arr1,arr2); console.log(arr1)//[1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 逼格看着高，代码少，也不会产生新的数组，也不难理解，就是调用arr1.push这个函数实例的apply方法，同时把arr2当作参数传入，这样arr1.push这个方法就会遍历arr2数组的所有元素，达到合并的效果。相当于arr1.push.apply(arr1,[6,7,8,9,10]);，最后相当于arr1.push(6,7,8,9,10)。遗憾的就是，这个方法对数组长度有限制，网上说法是不同浏览器，不同的长度限制，一般不超过10万！ toFixed保留整数在开发上，经常会遇到最多保留多少位小数或者类似的问题，针对这个，使用toFixed可以很简单的解决问题，但是如果数据是要和后台交互的，而且后台存储的数据一般是保存数字类型，而使用toFixed后生成的是一个字符串，这下，就需要把toFixed生成的是一个字符串转成数字类型，转发很多。今天我说一个最简单–+。代码如下 var a=123.36896335.toFixed(2) console.log(a)//&#39;123.37&#39; a=+a console.log(a)//123.37 PS：a=a|0和~~a也可以实现，但是生成的是一个整数，如下 var a=123.36896335.toFixed(2) console.log(a)//&#39;123.37&#39; a=a|0 console.log(a)//123 //---------------------------------分割线 var a=123.36896335.toFixed(2) console.log(a)//&#39;123.37&#39; a=~~a console.log(a)//123 其它类型数据转布尔数据下面的转换，大家一看就明白了，不多说。 console.log(!!&#39;123&#39;) //true !!12 //true !!-1 //true !![] //true !!&#39;&#39; //false !!null //false 缓存变量var arr=[1,2,3,4,5,6] for(var i=0,i&lt;arr.length;i++){ ... } //------------------------分割线 var arr=[1,2,3,4,5,6] for(var i=0,len=arr.length;i&lt;len;i++){ ... } 第一段就是每一次循环的时候，都要查询一次arr.length。第二段代码就是缓存了arr.length，每次对比len就好，理论上是第二段代码的写法比较好，性能比较高！但是随着浏览器的发展，这个细节的性能上的影响貌似远远小于预期，现在还是建议缓存！我写了下面的测试用例(谷歌浏览器测试)！ 元素事件这里我用jquery来讲解，比较容易理解，原生js也是这个道理！如下代码 $(&#39;.div1&#39;).click(function(){ ... }) //--------------------------分割线 var $div1=$(&#39;.div1&#39;); $div1.click(function(){ ... }) 上面的代码，改变的也是缓存了$(‘.div1’)，但是这里就建议是第二种写法了，因为第一种点击一次就要查询一次.div1，Dom的操作还是能减少就减少！ 使用innerHTML添加元素比如有一个需求，往ul里面添加10个li，两种方法，如下代码 &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;ul id=&quot;ul-test&quot;&gt; &lt;/ul&gt; &lt;/body&gt; &lt;script type=&quot;text/javascript&quot;&gt; var oUl=document.getElementById(&quot;ul-test&quot;); //createElement方式 console.time(); for(var i=0;i&lt;10;i++){ var oLi=document.createElement(&#39;li&#39;); oLi.innerHTML=i; oUl.appendChild(oLi); } console.timeEnd(); //innerHTML方式 console.time(); var _html=&#39;&#39;; for(var i=0;i&lt;10;i++){ _html+=&#39;&lt;li&gt;&#39;+i+&#39;&lt;/li&gt;&#39; } oUl.innerHTML=_html; console.timeEnd(); &lt;/script&gt; &lt;/html&gt; 大家把代码用浏览器打开，发现基本是第二种方式更快，第8点也说了，DOM操作能少就少！第一种要操作10次DOM，第二种只需要操作1次DOM。还有一个就是，这个只是很简单的li,如果是下面的列表呢？用第一种方式，得createElement多少次，innerHTML多少次，appendChild多少次？代码多，各个节点的逻辑和嵌套关系也乱！用第二种方式就是一个拼接字符串的操作，比第一种方式好多了，如果用es6的模板字符串，就更简单了！ 将参数转成数组函数里的arguments，虽然拥有length属性，但是arguments不是一个数组，是一个类数组，没有push,slice等方法。有些时候，需要把arguments转成数组，转的方法也不止一个，推荐的是是下面的写法！ var _arguments=Array.prototype.slice.apply(arguments) 函数节流这里拿一个栗子说，比如mousemove,onscroll,onresize这些事件触发的时候，可能已经触发了60次事件，这样很消耗性能，而且实际上，我们并不需要这么频繁的触发，只要大约100毫秒触发一次就好！那么这样就需要函数节流了！ 普通写法 var count = 0; function beginCount() { count++; console.log(count); } document.onmousemove = function () { beginCount(); }; 节流写法 var count = 0; function beginCount() { count++; console.log(count); } function delayFn(method, thisArg) { clearTimeout(method.props); method.props = setTimeout(function () { method.call(thisArg) },100) } document.onmousemove = function () { delayFn(beginCount) }; 第二种节流方法 function delayFn2 (fn, delay, mustDelay){ var timer = null; var t_start; return function(){ var context = this, args = arguments, t_cur = +new Date(); //先清理上一次的调用触发（上一次调用触发事件不执行） clearTimeout(timer); //如果不存触发时间，那么当前的时间就是触发时间 if(!t_start){ t_start = t_cur; } //如果当前时间-触发时间大于最大的间隔时间（mustDelay），触发一次函数运行函数 if(t_cur - t_start &gt;= mustDelay){ fn.apply(context, args); t_start = t_cur; } //否则延迟执行 else { timer = setTimeout(function(){ fn.apply(context, args); }, delay); } }; } var count=0; function fn1(){ count++; console.log(count) } //100ms内连续触发的调用，后一个调用会把前一个调用的等待处理掉，但每隔200ms至少执行一次 document.onmousemove=delayFn2(fn1,100,200) 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[快应用快速入门]]></title>
    <url>%2F2018%2F03%2F22%2FQuickApp%2F%E5%BF%AB%E5%BA%94%E7%94%A8%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[QuickApp作为一个前端工程师，毕竟要顺流技术的发展。 3月20日，小米、中兴、华为、金立、联想、魅族、努比亚、OPPO、vivo、一加，共十家手机厂商在北京联合召开快应用标准启动发布会，手机厂商与中国信息通信研究院、电信终端产业协会、中国软件行业协会及数百家知名移动互联网应用企业共襄盛举，共同见证移动应用新生态的到来。 既然是国内厂商发布的，所以只针对安卓用户。 怎么感觉都是在对微信小程序一家独大的应对。 废话少说开撸吧。 快应用开发者文档 https://doc.quickapp.cn/ 看了这个就是表示入门了 快应用开发者论坛 http://bbs.quickapp.cn/ 搭建环境安装nodejs需安装6.0以上版本的nodejs，请从NodeJS官网下载，推荐v6.11.3 LTS 注意: 不要使用8.0.*版本．这个版本内部ZipStream实现与node-archive包不兼容，会引起报错 安装hap-toolkit (快应用命令)npm install - g hap-toolkit 在命令行中执行hap -V会输出版本信息表示hap-toolkit安装成功，如下命令所示： hap -V 目前版本是0.0.26 创建新的项目hap init &lt;ProjectName&gt; 成功后即显示项目目录结构 ├── node_modules npm 包 ├── sign rpk包签名模块 │ └── debug 调试环境 │ ├── certificate.pem 证书文件 │ └── private.pem 私钥文件 ├── src 项目资源文件夹 │ ├── Common 公用的资源文件和组件文件 │ │ └── logo.png manifest.json中配置的icon │ ├── Demo 页面目录 │ | └── index.ux 页面文件，文件名不必与父文件夹相同 │ ├── app.ux APP文件（用于包括公用资源） │ └── manifest.json 项目配置文件（如：应用描述、接口申明、页面路由等） └── package.json 定义项目需要的各种模块及配置信息，npm install根据这个配置文件，自动下载所需的运行和开发环境 编译项目1.在项目根目录下，运行如下命令安装依赖包（webpack，babel等） npm install 在项目的根目录下，运行如下命令进行编译打包，生成rpk包npm run build 编译打包成功后，项目根目录下会生成文件夹：build、dist build：临时产出，包含编译后的页面js，图片等 dist：最终产出，包含rpk文件。其实是将build目录下的资源打包压缩为一个文件，后缀名为rpk，这个rpk文件就是项目编译后的最终产出 3.自动重新编译 npm run watch 注意：npm run watch后还需要另外运行npm run server来运行server才能实现热更新 注意：如果报错遇到Cannot find module ‘…/webpack.config.js’，请重新执行一次hap update –force。这是由于高版本的npm在npm install时，会校验并删除了node_modules下部分文件夹，导致报错。而hap update –force会重新复制hap-toolkit文件夹到node_modules中 调试需要安装两个APP应用程序(必须！需要在真机上调试预览) 快应用调试器平台预览版 二维码预览在终端输入,启动本地服务器 npm run server 自定义端口（如：8080） npm run server -- --port 8080 在调试器APP选择扫描二维码； 如果提示安装失败，建议重新起一遍npm run server 重新来过。 本地安装选择dist目录下的.rpk文件传输到手机 在调试器中选择手动安装找到你的.rpk即可安装出现了这个，代表你安装成功，这就是Demo效果 应用上传流程 http://bbs.quickapp.cn/posts/detail?id=249 账号注册流程 http://bbs.quickapp.cn/posts/detail?id=248]]></content>
      <categories>
        <category>quickApp</category>
      </categories>
      <tags>
        <tag>quickApp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[助你理解React高阶组件]]></title>
    <url>%2F2018%2F03%2F21%2FReact%2F%E5%8A%A9%E4%BD%A0%E7%90%86%E8%A7%A3React%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[高阶组件高阶组件（HOC）是react中对组件逻辑进行重用的高级技术。但高阶组件本身并不是React API。它只是一种模式，这种模式是由react自身的组合性质必然产生的。 具体而言，高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件 高阶组件在React第三方库中很常见，比如Redux的connect方法和Relay的createContainer. 使用高阶组件（HOC）解决交叉问题不要改变原始组件，使用组合约定：将不相关的props属性传递给包裹组件约定：最大化使用组合约定：包装显示名字以便于调试 函数模拟高阶组件我们通过普通函数来理解什么是高阶组件哦~ 1.最普通的方法，一个welcome，一个goodbye。两个函数先从localStorage读取了username，然后对username做了一些处理。 function welcome(){ let username = localStorage.getItem(&#39;username&#39;); console.log(&#39;welcome &#39; + username); } function goodbey() { let username = localStorage.getItem(&#39;username&#39;); console.log(&#39;goodbey &#39; + username); } welcome(); goodbey(); 2.我们发现两个函数有一句代码是一样的，这叫冗余唉。不好不好~（你可以把那一句代码理解成平时的一大堆代码） 我们要写一个中间函数，读取username,他来负责把username传递给两个函数。 function welcome(username) { console.log(&#39;welcome &#39; + username); } function goodbey(username) { console.log(&#39;goodbey &#39; + username); } function wrapWithUsername(wrappedFunc) { let newFunc = () =&gt; { let username = localStorage.getItem(&#39;username&#39;); wrappedFunc(username); }; return newFunc; } welcome = wrapWithUsername(welcome); goodbey = wrapWithUsername(goodbey); welcome(); goodbey(); 好了，我们里面的wrapWithUsername函数就是一个“高阶函数”。他做了什么？他帮我们处理了username，传递给目标函数。我们调用最终的函数welcome的时候，根本不用关心username是怎么来的。我们增加个用户study函数。 function study(username){ console.log(&#39;study&#39; + username); } study = wrapWithUsername(study); study(); 这里你是不是理解了为什么说wrapWithUsername是高阶函数？我们只需要知道，用wrapWithUsername包装我们的study函数后，study函数第一个参数是username。 我们写平时写代码的时候，不用关心wrapWithUsername内部是如何实现的。 高阶组件就是一个没有副作用的纯函数。我们把上一节的函数统统改成react组件。 最普通的组件哦。welcome函数转为react组件。 import React, {Component} from &#39;react&#39; class Welcome extends Component { constructor(props) { super(props); this.state = { username: &#39;&#39; } } componentWillMount() { let username = localStorage.getItem(&#39;username&#39;); this.setState({ username: username }) } render() { return ( &lt;div&gt;welcome {this.state.username}&lt;/div&gt; ) } } export default Welcome; 2.goodbey函数转为react组件。 import React, {Component} from &#39;react&#39; class Goodbye extends Component { constructor(props) { super(props); this.state = { username: &#39;&#39; } } componentWillMount() { let username = localStorage.getItem(&#39;username&#39;); this.setState({ username: username }) } render() { return ( &lt;div&gt;goodbye {this.state.username}&lt;/div&gt; ) } } export default Goodbye; 3.现在你是不是更能看到问题所在了？两个组件大部分代码都是重复的唉。按照上一节wrapWithUsername函数的思路，我们来写一个高阶组件(高阶组件就是一个函数，且该函数接受一个组件作为参数，并返回一个新的组件)。 import React, {Component} from &#39;react&#39; export default (WrappedComponent) =&gt; { class NewComponent extends Component { constructor() { super(); this.state = { username: &#39;&#39; } } componentWillMount() { let username = localStorage.getItem(&#39;username&#39;); this.setState({ username: username }) } render() { return &lt;WrappedComponent username={this.state.username}/&gt; } } return NewComponent } 这样我们就能简化Welcome组件和Goodbye组件。 //welcome import React, {Component} from &#39;react&#39;; import wrapWithUsername from &#39;wrapWithUsername&#39;; class Welcome extends Component { render() { return ( &lt;div&gt;welcome {this.props.username}&lt;/div&gt; ) } } Welcome = wrapWithUsername(Welcome); export default Welcome; //goodbye import React, {Component} from &#39;react&#39;; import wrapWithUsername from &#39;wrapWithUsername&#39;; class Goodbye extends Component { render() { return ( &lt;div&gt;goodbye {this.props.username}&lt;/div&gt; ) } } Goodbye = wrapWithUsername(Goodbye); export default Goodbye; 看到没有，高阶组件就是把username通过props传递给目标组件了。目标组件只管从props里面拿来用就好了。 到这里位置，高阶组件就讲完了。你再返回去理解下定义，是不是豁然开朗 你现在理解react-redux的connect函数~把redux的state和action创建函数，通过props注入给了Component。你在目标组件Component里面可以直接用this.props去调用redux state和action创建函数了。 ConnectedComment = connect(mapStateToProps, mapDispatchToProps)(Component); 相当于这样 // connect是一个返回函数的函数（就是个高阶函数） const enhance = connect(mapStateToProps, mapDispatchToProps); // 返回的函数就是一个高阶组件，该高阶组件返回一个与Redux store // 关联起来的新组件 const ConnectedComment = enhance(Component); antd的Form也是一样的 const WrappedNormalLoginForm = Form.create()(NormalLoginForm); 注意事项不要再render函数中使用高阶组件React使用的差异算法（称为协调）使用组件标识确定是否更新现有的子对象树或丢掉现有的子树并重新挂载。如果render函数返回的组件和之前render函数返回的组件是相同的，React就递归的比较新子对象树和旧子对象树的差异，并更新旧子对象树。如果他们不相等，就会完全卸载掉旧的之对象树。 必须将静态方法做拷贝有时，给组件定义静态方法是十分有用的。例如，Relay的容器就开放了一个静态方法 getFragment便于组合GraphQL的代码片段。 Refs属性不能传递一般来说，高阶组件可以传递所有的props属性给包裹的组件，但是不能传递refs引用。因为并不是像key一样，refs是一个伪属性，React对它进行了特殊处理。如果你向一个由高阶组件创建的组件的元素添加ref应用，那么ref指向的是最外层容器组件实例的，而不是包裹组件。 原文地址]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端深海]]></title>
    <url>%2F2018%2F03%2F20%2FRecord%2F%E5%89%8D%E7%AB%AF%E6%B7%B1%E6%B5%B7%2F</url>
    <content type="text"><![CDATA[前端工程师所需知识]]></content>
      <tags>
        <tag>Record</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React的Diff算法]]></title>
    <url>%2F2018%2F03%2F20%2FReact%2FReact%E7%9A%84Diff%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[React 是 Facebook 开发的构建用户界面的类库.它从设计之初就将性能作为重点.这篇文章我展示 diff 算法和渲染过程怎样工作, 你可以借鉴优化自己的应用. Diff 算法在深入实现的细节之前, 需要了解一下 React 怎样工作的. class MyComponent extends React.Component{ render() { if (this.props.first) { return &lt;div className=&quot;first&quot;&gt;&lt;span&gt;A Span&lt;/span&gt;&lt;/div&gt;; } else { return &lt;div className=&quot;second&quot;&gt;&lt;p&gt;A Paragraph&lt;/p&gt;&lt;/div&gt;; } } } 任何时间, 你描述的是你的 UI 看起来是什么样子.需要特别注意, render 执行的结果得到的不是真正的 DOM 节点.结果仅仅是轻量级的 JavaScript 对象, 我们称之为 virtual DOM. React 要从这个表现形式当中尝试找到前一个渲染结果到后一个的最小步数.比如, 当我们挂载了 , 然后用 替换, 然后又取消挂载,这样一个过程的 DOM 的指令是这样的: 从没有到第一步创建节点: A Span 第一步到第二步替换属性: className=”first” 到 className=”second”替换节点: A Span 到 A Paragraph 第二步到没有删除节点: A Paragraph 按照层级找到两棵任意的树之间最小的修改是一个复杂度为 O(n^3) 的问题.你可以想象, 我们的例子里这不是容易处理的.React 用了一种简单但是强大的技巧, 达到了接近 O(n) 的复杂度. React 仅仅是尝试把树按照层级分解. 这彻底简化了复杂度,而且也不会失去很多, 因为 Web 应用很少有 component 移动到树的另一个层级去.它们大部分只是在相邻的子节点之间移动. 列表假设我们有个 component, 一个循环渲染了 5 个 component,随后又在列表中间插入一个新的 component.只知道这些信息, 要弄清两个 component 的列表怎么对应很难. 默认情况下, React 会将前一个列表第一个 component 和后一个第一个关联起来, 后面也是.你可以写一个 key 属性帮助 React 来处理它们之间的对应关系.实际中, 在子元素中找到唯一的 key 通常很容易. ComponentsReact app 通常由用户定义的 component 组合而成,通常结果是一个主要是很多 div 组成的树.这个信息也被 React 的 diff 算法考虑进去, React 只会匹配相同 class 的 component. 比如, 如果有个 被 替换掉了,React 会删除掉 header 再创建一个 example block.我们不需要化宝贵的时间去匹配两个不大可能有相似之处的 component. 事件代理往 DOM 节点上绑事件慢得人心碎啊, 而且很费内存. 作为替代, React 部署了种流行技术, 叫做”事件代理“.React 走得更远, 重新实现了一遍符合 W3C 规范的事件系统.意味着 IE8 事件处理的 bug 成为过去了, 所有事件名称跨浏览器保持一致. 这里解释一下怎么实现的. 事件 listener 被绑定到整个文档的根节点上.当事件被触发, 浏览器会给出一个触发的目标的 DOM 节点.为了在 DOM 的层级传播事件, React 不会迭代 virtual DOM 的层级.而是, 我们依靠每个 React component 各自独立的 id 来编码这个层级.我们能通过简单的字符串操作来获取所有父级 component 的父级内容.把事件 listener 存储在 hash map 当中, 我们发现性能比放到 virtual DOM 还要好. 这个例子展示了, 当一个事件广播到整个 virtual DOM 时发生什么. // dispatchEvent(&#39;click&#39;, &#39;a.b.c&#39;, event) clickCaptureListeners[&#39;a&#39;](event); clickCaptureListeners[&#39;a.b&#39;](event); clickCaptureListeners[&#39;a.b.c&#39;](event); clickBubbleListeners[&#39;a.b.c&#39;](event); clickBubbleListeners[&#39;a.b&#39;](event); clickBubbleListeners[&#39;a&#39;](event); 浏览器为每个事件和每个 listener 创建一个新的事件对象.这个事件对象的属性很不错, 你能获取到事件的引用, 甚至修改掉.然而这也意味着高额的内存分配.React 在启动时就为那些对象分配了一个内存池.任何时候需要用到事件对象, 就可以从这个内存池进行复用.这一点非常显著地减轻了垃圾回收的负担. 渲染合并操作你调用 component 的 setState 方法的时候, React 将其标记为 dirty.到每一个事件循环结束, React 检查所有标记 dirty 的 component 重新绘制. 这里的”合并操作”是说, 在一个事件循环当中, DOM 只会被更新一次.这个特性是构建高性能应用的关键, 而且用通常的 JavaScript 代码难以实现.而在 React 应用里, 你默认就能实现. 子树渲染操作调用 setState 方法时, component 会重新构建包括子节点的 virtual DOM.如果你在根节点调用 setState, 整个 React 的应用都会被重新渲染. 所有的 component, 即便没有更新, 都会调用他们的 render 方法.这个听起来可怕, 性能像是很低, 但实际上我们不会触碰真实的 DOM, 运行起来没那样的问题. 首先, 我们讨论的是展示用户界面. 因为屏幕空间有限, 通常你需要一次渲染成百上千条指令.JavaScript 对于能处理的整个界面, 在业务逻辑上已经足够快了. 另一点, 在写 React 代码时, 每当有数据更新, 你不是都调用根节点的 setState.你会在需要接收对应更新的 component 上调用, 或者在上面的几个 component.你很少要一直到根节点上. 就是说界面更新只出现在用户产生交互的局部. 选择性子树渲染最后, 你还有可能去掉一些子树的重新渲染.如果你在 component 上实现以下方法的话: boolean shouldComponentUpdate(object nextProps, object nextState) 根据 component 的前一个和下一个 props/state,你可以告诉 React 这个 component 没有更新, 也不需要重新绘制.实现得好的话, 可以带来巨大的性能提升. 要用这个方法, 你要能够对 JavaScript Object 进行比对.这件有很多细节的因素, 比如对比应该是深度的还是浅层的,如果要深的, 我们是用不可变数据结构, 还是进行深度拷贝… 而且你要注意, 这个函数每次都会被调用, 所以你要确保运行起来花的时间更少,比 React 的做法时间少, 还有比计算 component 需要的时间少,即便重新绘制并不是必要的. 结论帮助 React 变快的技术并不新颖. 长久以来, 我们到知道触碰 DOM 是费时的,你应该合并处理读和写的操作, 事件代理会更快… 人们还是会经常讨论他们, 因为在实际当中用 JavaScript 进行实现很是挺难的.React 突出的一个原因是这些优化默认就启动了.这就让你避免掉不小心把 app 写得很慢. React 消耗性能的模型很简单, 很好理解: 每次调用 setState 会重新计算整个子树.如果你想要提高性能, 尽量少调用 setState,还有用 shouldComponentUpdate 减少大的子树的重新计算. react的一大特点就是虚拟DOM的diff算法，下图为diff实现流程图。传统算法的理解画的流程图React 通过制定大胆的策略，将 O(n^3) 复杂度的问题转换成 O(n) 复杂度的问题。 原文地址 更多关于React源码链接react源码分析react源码剖析（这篇文章对图中移位算法有详细解释）论文算法详解]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Html5]]></title>
    <url>%2F2018%2F03%2F19%2FHTML5%2FHtml5%2F</url>
    <content type="text"><![CDATA[html5特性用于媒介回放的 video 和 audio 元素Video支持的视频格式Ogg = 带有 Theora 视频编码和 Vorbis 音频编码的 Ogg 文件（.ogg） MPEG4 = 带有 H.264 视频编码和 AAC 音频编码的 MPEG 4 文件(.mp4) WebM = 带有 VP8 视频编码和 Vorbis 音频编码的 WebM 文件(.mkv) &lt;video src=&quot;movie.ogg&quot; controls=&quot;controls&quot;&gt; &lt;/video&gt; controls 属性供添加播放、暂停和音量控件。 包含宽度和高度属性也是不错的主意。如果有不支持video的浏览器器则使用下面代码 &lt;video src=&quot;movie.ogg&quot; width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; Your browser does not support the video tag. &lt;/video&gt; video 元素允许多个 source 元素。source 元素可以链接不同的视频文件。浏览器将使用第一个可识别的格式： &lt;video width=&quot;320&quot; height=&quot;240&quot; controls=&quot;controls&quot;&gt; &lt;source src=&quot;movie.ogg&quot; type=&quot;video/ogg&quot;&gt; &lt;source src=&quot;movie.mp4&quot; type=&quot;video/mp4&quot;&gt; Your browser does not support the video tag. &lt;/video&gt; IE8不支持video元素，在 IE 9 中，将提供对使用 MPEG4 的 video 元素的支持。 video标签属性：autoplay 自动播放controls 显示控件width 设置播放器的宽度height 设置播放器高度loop 如果设置为True则循环播放preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。src 要播放的视频的 URL video方法，属性及事件：paly() 视频播放pasue() 视频暂停load() 视频加载 audioaudio支持的音频格式Ogg Vorbis （.ogg）Mp3 (.mp3)Wav (.wav) audio标签的属性autoplay 自动播放controls 音频控件loop 循环播放preload 如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。src 要播放的音频的 URL html5拖放（drag和drop) 浏览器支持Internet Explorer 9、Firefox、Opera 12、Chrome 以及 Safari 5 支持拖放。 注释：在 Safari 5.1.2 中不支持拖放。 一个简单地例子 &lt;!DOCTYPE HTML&gt; &lt;html&gt; &lt;head&gt; &lt;script type=&quot;text/javascript&quot;&gt; function allowDrop(ev){ ev.preventDefault(); } function drag(ev){ ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id); } function drop(ev){ ev.preventDefault(); var data=ev.dataTransfer.getData(&quot;Text&quot;); ev.target.appendChild(document.getElementById(data)); } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;div id=&quot;div1&quot; ondrop=&quot;drop(event)&quot; ondragover=&quot;allowDrop(event)&quot;&gt;&lt;/div&gt; &lt;img id=&quot;drag1&quot; src=&quot;img_logo.gif&quot; draggable=&quot;true&quot; ondragstart=&quot;drag(event)&quot; width=&quot;336&quot; height=&quot;69&quot; /&gt; &lt;/body&gt; &lt;/html&gt; 设置元素为可拖放首先，为了使元素可拖动，把 draggable 属性设置为 true ： &lt;img draggable=&quot;true&quot; /&gt; 拖动什么 - ondragstart 和 setData()然后，规定当元素被拖动时，会发生什么。在上面的例子中，ondragstart 属性调用了一个函数，drag(event)，它规定了被拖动的数据。dataTransfer.setData() 方法设置被拖数据的数据类型和值： function drag(ev){ ev.dataTransfer.setData(&quot;Text&quot;,ev.target.id); } 在这个例子中，数据类型是 “Text”，值是可拖动元素的 id (“drag1”)。 放到何处 - ondragoverondragover 事件规定在何处放置被拖动的数据。 默认地，无法将数据/元素放置到其他元素中。如果需要设置允许放置，我们必须阻止对元素的默认处理方式。 这要通过调用 ondragover 事件的 event.preventDefault() 方法： event.preventDefault() 进行放置 - ondrop当放置被拖数据时，会发生 drop 事件。 在上面的例子中，ondrop 属性调用了一个函数，drop(event)： function drop(ev){ev.preventDefault();var data=ev.dataTransfer.getData(“Text”);ev.target.appendChild(document.getElementById(data));} 代码解释：1.调用 preventDefault() 来避免浏览器对数据的默认处理（drop 事件的默认行为是以链接形式打开）2.通过 dataTransfer.getData(“Text”) 方法获得被拖的数据。该方法将返回在 setData() 方法中设置为相同类型的任何数据。3.被拖数据是被拖元素的 id (“drag1”)4.把被拖元素追加到放置元素（目标元素）中 Canvas(画布)什么是 Canvas？HTML5 的 canvas 元素使用 JavaScript 在网页上绘制图像。 画布是一个矩形区域，您可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 创建 Canvas 元素向 HTML5 页面添加 canvas 元素。 规定元素的 id、宽度和高度： &lt;canvas id=&quot;myCanvas&quot; width=&quot;200&quot; height=&quot;100&quot;&gt;&lt;/canvas&gt; 通过 JavaScript 来绘制canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成： &lt;script type=&quot;text/javascript&quot;&gt; var c=document.getElementById(&quot;myCanvas&quot;); var cxt=c.getContext(&quot;2d&quot;); cxt.fillStyle=&quot;#FF0000&quot;; cxt.fillRect(0,0,150,75); &lt;/script&gt; JavaScript 使用 id 来寻找 canvas 元素： var c=document.getElementById(&quot;myCanvas&quot;); 然后，创建 context 对象： var cxt=c.getContext(&quot;2d&quot;); getContext(&quot;2d&quot;) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。 下面的两行代码绘制一个红色的矩形： cxt.fillStyle=&quot;#FF0000&quot;; cxt.fillRect(0,0,150,75); fillStyle 方法将其染成红色，fillRect 方法规定了形状、位置和尺寸。 SVG什么是SVG？SVG 指可伸缩矢量图形 (Scalable Vector Graphics)SVG 用于定义用于网络的基于矢量的图形SVG 使用 XML 格式定义图形SVG 图像在放大或改变尺寸的情况下其图形质量不会有损失SVG 是万维网联盟的标准 SVG 的优势与其他图像格式相比（比如 JPEG 和 GIF），使用 SVG 的优势在于： SVG 图像可通过文本编辑器来创建和修改SVG 图像可被搜索、索引、脚本化或压缩SVG 是可伸缩的SVG 图像可在任何的分辨率下被高质量地打印SVG 可在图像质量不下降的情况下被放大 例子&lt;!DOCTYPE html&gt; &lt;html&gt; &lt;body&gt; &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; height=&quot;190&quot;&gt; &lt;polygon points=&quot;100,10 40,180 190,60 10,60 160,180&quot; style=&quot;fill:lime;stroke:purple;stroke-width:5;fill-rule:evenodd;&quot; /&gt; &lt;/svg&gt; &lt;/body&gt; &lt;/html&gt; Canvas 与 SVG 的比较下表列出了 canvas 与 SVG 之间的一些不同之处。 Canvas 依赖分辨率 不支持事件处理器 弱的文本渲染能力 能够以 .png 或 .jpg 格式保存结果图像 最适合图像密集型的游戏，其中的许多对象会被频繁重绘 SVG 不依赖分辨率 支持事件处理器 最适合带有大型渲染区域的应用程序（比如谷歌地图） 复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快） 不适合游戏应用 Html5地理定位HTML5 Geolocation API 用于获得用户的地理位置。 鉴于该特性可能侵犯用户的隐私，除非用户同意，否则用户位置信息是不可用的。 &lt;script&gt; var x=document.getElementById(&quot;demo&quot;); function getLocation() { if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition); } else{x.innerHTML=&quot;Geolocation is not supported by this browser.&quot;;} } function showPosition(position) { x.innerHTML=&quot;Latitude: &quot; + position.coords.latitude + &quot;&lt;br /&gt;Longitude: &quot; + position.coords.longitude; } &lt;/script&gt; 上面代码解释：检测是否支持地理定位如果支持，则运行 getCurrentPosition() 方法。如果不支持，则向用户显示一段消息。如果getCurrentPosition()运行成功，则向参数showPosition中规定的函数返回一个coordinates对象showPosition() 函数获得并显示经度和纬度 处理错误： function showError(error) { switch(error.code) { case error.PERMISSION_DENIED:// 用户不允许地理定位 x.innerHTML=&quot;User denied the request for Geolocation.&quot; break; case error.POSITION_UNAVAILABLE://无法获取当前位置 x.innerHTML=&quot;Location information is unavailable.&quot; break; case error.TIMEOUT:// 超时处理 x.innerHTML=&quot;The request to get user location timed out.&quot; break; case error.UNKNOWN_ERROR: // 错误处理 x.innerHTML=&quot;An unknown error occurred.&quot; break; } } HTML 5 Web 存储HTML5 提供了两种在客户端存储数据的新方法： localStorage - 没有时间限制的数据存储sessionStorage - 针对一个 session 的数据存储 localStorage 方法localStorage 方法存储的数据没有时间限制。第二天、第二周或下一年之后，数据依然可用。 如何创建和访问 localStorage： &lt;script type=&quot;text/javascript&quot;&gt; localStorage.lastname=&quot;Smith&quot;; document.write(localStorage.lastname); &lt;/script&gt; sessionStorage 方法sessionStorage 方法针对一个 session 进行数据存储。当用户关闭浏览器窗口后，数据会被删除。 如何创建并访问一个 sessionStorage： &lt;script type=&quot;text/javascript&quot;&gt; sessionStorage.lastname=&quot;Smith&quot;; document.write(sessionStorage.lastname); &lt;/script&gt; HTML 5 应用程序缓存什么是应用程序缓存（Application Cache）？HTML5 引入了应用程序缓存，这意味着 web 应用可进行缓存，并可在没有因特网连接时进行访问。 应用程序缓存为应用带来三个优势： 离线浏览 - 用户可在应用离线时使用它们速度 - 已缓存资源加载得更快减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源。 Cache Manifest 基础如需启用应用程序缓存，请在文档的 标签中包含 manifest 属性： &lt;!DOCTYPE HTML&gt; &lt;html manifest=&quot;demo.appcache&quot;&gt; ... &lt;/html&gt; Manifest 文件manifest 文件是简单的文本文件，它告知浏览器被缓存的内容（以及不缓存的内容）。 manifest 文件可分为三个部分： CACHE MANIFEST - 在此标题下列出的文件将在首次下载后进行缓存NETWORK - 在此标题下列出的文件需要与服务器的连接，且不会被缓存FALLBACK - 在此标题下列出的文件规定当页面无法访问时的回退页面（比如 404 页面） 更新缓存一旦应用被缓存，它就会保持缓存直到发生下列情况： 用户清空浏览器缓存manifest 文件被修改（参阅下面的提示）由程序来更新应用缓存 实例 - 完整的 Manifest 文件CACHE MANIFEST #2012-02-21 v1.0.0/theme.css/logo.gif/main.js NETWORK:login.asp FALLBACK:/html5/ /404.html 重要的提示：以 “#” 开头的是注释行，但也可满足其他用途。应用的缓存会在其 manifest 文件更改时被更新。如果您编辑了一幅图片，或者修改了一个 JavaScript 函数，这些改变都不会被重新缓存。更新注释行中的日期和版本号是一种使浏览器重新缓存文件的办法。 注释：浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。 HTML 5 Web Workers什么是 Web Worker？当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。 web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。 Web Workers 和 DOM由于 web worker 位于外部文件中，它们无法访问下例 JavaScript 对象：window 对象document 对象parent 对象 HTML 5 服务器发送事件Server-Sent 事件 - 单向消息传递Server-Sent 事件指的是网页自动获取来自服务器的更新。 以前也可能做到这一点，前提是网页不得不询问是否有可用的更新。通过服务器发送事件，更新能够自动到达。 例子：Facebook/Twitter 更新、估价更新、新的博文、赛事结果等 var source=new EventSource(&quot;demo_sse.php&quot;); source.onmessage=function(event) { document.getElementById(&quot;result&quot;).innerHTML+=event.data + &quot;&lt;br /&gt;&quot;; }; EventSource 对象在上面的例子中，我们使用 onmessage 事件来获取消息。不过还可以使用其他事件： onopen 当通往服务器的连接被打开onmessage 当接收到消息onerror 当错误发生 html5表单HTML5 新的 Input 类型HTML5 拥有多个新的表单输入类型。这些新特性提供了更好的输入控制和验证。 本章全面介绍这些新的输入类型： email 在提交表单时，会自动验证 email 域的值。url 在提交表单时，会自动验证 url 域的值。number number类型用于应该包含数值的输入域。range range 类型显示为滑动条。Date pickers (date, month, week, time, datetime, datetime-local) 日期选择器search 搜索域，比如站点搜索或 Google 搜索。color HTML5 表单元素 HTML5 的新的表单元素：datalist datalist 元素规定输入域的选项列表。`htmlWebpage: `提示：option 元素永远都要设置 value 属性。 keygen keygen 元素的作用是提供一种验证用户的可靠方法。output output 元素用于不同类型的输出，比如计算或脚本输出： HTML5 表单属性新的 form 属性：autocomplete autocomplete 属性规定 form 或 input 域应该拥有自动完成功能。novalidate 新的 input 属性：autocompleteautofocus autofocus 属性规定在页面加载时，域自动地获得焦点。formform overrides (formaction, formenctype, formmethod, formnovalidate, formtarget) 允许您重写 form 元素的某些属性设定height 和 width height 和 width 属性规定用于 image 类型的 input 标签的图像高度和宽度。list list 属性规定输入域的 datalist。datalist 是输入域的选项列表。min, max 和 step step 属性为输入域规定合法的数字间隔multiple multiple 属性适用于以下类型的 标签：email 和 file。pattern (regexp) pattern 属性规定用于验证 input 域的模式（pattern）。placeholder 属性提供一种提示（hint），描述输入域所期待的值。required 属性规定必须在提交之前填写输入域（不能为空）。]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[20个超级实用的css代码]]></title>
    <url>%2F2018%2F03%2F18%2FCSS3%2F20%E4%B8%AA%E8%B6%85%E7%BA%A7%E5%AE%9E%E7%94%A8%E7%9A%84css%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[原文地址 大家非常的清楚CSS是我们Web制作中不可或缺的一部分。HTML提供了Web制作的结构，但他不能让我们实现美丽的页面制作，此时我们需要CSS的帮助。CSS虽然能帮我们完善Web制作的效果，但其在不同的浏览器下是有不可预知的效果，为了让你的CSS能解决这些不一致下，今天给大家介绍25个CSS技巧代码，我相信这些对你肯家有很大的作用。 使用text-indent来隐藏文本这个常用在图片替换文本中，最常见的就是使用使用图片来替换Logo，这个是非常有用的，使用“text-indent”我们可以达到图片替换文本的效果，而且方便搜索引擎的优化，还能支持阅读器阅读网页内容： h1 { text-indent:-9999px; margin:0 auto; width:400px; height:100px; background:transparent url(&quot;images/logo.jpg&quot;) no-repeat scroll; } 根据文件格式设置链接图标这个技巧主要是针对用户体验，让用户能很清楚点击的链接是有关于什么方面的内容，比如说，点击某个链接会到跳到站外。换句话说使用属性选择器器，给不同的链接设置不同的图标，让用户很轻松的明白相应的链接是有关于什么方面的内容： a[href^=&quot;http:&quot;] { display:inline-block; padding-right:14px; background:transparent url(/Images/ExternalLink.gif) center right no-repeat; } a[href^=&quot;mailto:&quot;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/MailTo.gif) center left no-repeat; } a[href$=&#39;.pdf&#39;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/PDFIcon.gif) center left no-repeat; } a[href$=&#39;.swf&#39;], a[href$=&#39;.fla&#39;], a[href$=&#39;.swd&#39;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/FlashIcon.gif) center left no-repeat; } a[href$=&#39;.xls&#39;], a[href$=&#39;.csv&#39;], a[href$=&#39;.xlt&#39;], a[href$=&#39;.xlw&#39;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/ExcelIcon.gif) center left no-repeat; } a[href$=&#39;.ppt&#39;], a[href$=&#39;.pps&#39;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/PowerPointIcon.gif) center left no-repeat; } a[href$=&#39;.doc&#39;], a[href$=&#39;.rtf&#39;], a[href$=&#39;.txt&#39;], a[href$=&#39;.wps&#39;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/WordDocIcon.gif) center left no-repeat; } a[href$=&#39;.zip&#39;], a[href$=&#39;.gzip&#39;], a[href$=&#39;.rar&#39;] { display:inline-block; padding-left:20px; line-height:18px; background:transparent url(/Images/ZIPIcon.gif) center left no-repeat; } 在IE浏览器中删除textarea的滚动条IE浏览器中textarea默认就有滚动条出现，为了达到所有浏览器默认下一致的效果，其实我们可以使用代码让他达到一致的效果： textarea{ overflow:auto; } 段落首字下沉有杂志排版中我们常看到第一个段落的首字下沉的效果，其实这种效果实现是相当的容易： p:first-letter{ display:block; margin:5px 0 0 5px; float:left; color:#FF3366; font-size:60px; font-family:Georgia; } 所有浏览器下的CSS透明度 .transparent { zoom: 1; filter: alpha(opacity=50); opacity: 0.5; } 但是使用opacity会影响其后代元素的透明度，我们可以考虑使用： .transparent { /* Fallback for web browsers that doesn&#39;t support RGBa */ background: rgb(0, 0, 0); /* RGBa with 0.6 opacity */ background: rgba(0, 0, 0, 0.6); /* For IE 5.5 - 7*/ filter:progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000); /* For IE 8*/ -ms-filter: &quot;progid:DXImageTransform.Microsoft.gradient(startColorstr=#99000000, endColorstr=#99000000)&quot;; } Reset Cssbody,ul,ol,dl,dd,dir,h1,h2,h3,h4,h5,h6,p,pre,blockquote,hr,figure{ margin:0; padding:0; font-size: 100%; vertical-align:baseline; } table { border-collapse:collapse; border-spacing:0; } article, aside, dialog, figure, footer, header, hgroup, nav, section { display:block; } /* * Corrects inline-block display not defined in IE6/7/8/9 &amp; FF3 */ audio, canvas, video { display: inline-block; *display: inline; *zoom: 1; } /* * Prevents modern browsers from displaying &#39;audio&#39; without controls */ audio:not([controls]) { display: none; } /* * Addresses styling for &#39;hidden&#39; attribute not present in IE7/8/9, FF3, S4 * Known issue: no IE6 support */ [hidden] { display: none; } 图片预加载#preloader { /* Images you want to preload*/ background-image: url(image1.jpg); background-image: url(image2.jpg); background-image: url(image3.jpg); width: 0px; height: 0px; display: inline; } 基本的CSS Sprite按钮a { display: block; background: url(sprite.png) no-repeat; height: 30px; width: 250px; } a:hover { background-position: 0 -30px; } Google Font API&lt;head&gt; Inconsolata:italic|Droid+Sans&quot; &lt;/head&gt; body { font-family: &#39;Tangerine&#39;, &#39;Inconsolata&#39;, &#39;Droid Sans&#39;, serif; font-size: 48px; } 浏览器的专用hack浏览器的兼容问题向来都是很烦的事情，特别是在IE下的兼容问题。但有时我们为了达到一致的效果，不得不使用浏览器的兼容： /* IE 6 */ * html .yourclass { } /* IE 7 */ *+html .yourclass{ } /* IE 7 and modern browsers */ html&gt;body .yourclass { } /* Modern browsers (not IE 7) */ html&gt;/**/body .yourclass { } /* Opera 9.27 and below */ html:first-child .yourclass { } /* Safari */ html[xmlns*=&quot;&quot;] body:last-child .yourclass { } /* Safari 3+, Chrome 1+, Opera 9+, Fx 3.5+ */ body:nth-of-type(1) .yourclass { } /* Safari 3+, Chrome 1+, Opera 9+, Fx 3.5+ */ body:first-of-type .yourclass { } /* Safari 3+, Chrome 1+ */ @media screen and (-webkit-min-device-pixel-ratio:0) { .yourclass { } } 固定页脚固定页脚在屏幕的底部，在现代浏览器来说是一件非常容易的事情，但是在IE6下还是需要特殊的处理： #footer { position:fixed; left:0px; bottom:0px; height:30px; width:100%; background:#999; } /* IE 6 */ * html #footer { position:absolute; top:expression((0-(footer.offsetHeight)+(document.documentElement.clientHeight ? document.documentElement.clientHeight : document.body.clientHeight)+(ignoreMe = document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop))+&#39;px&#39;); } 翻转图片翻转图像随着CSS3的transform越来越实用，不需要重新加载图片，就可以实现一个图片的旋转。常见的是一个三角型效果，我们想让他在不同状态展示不同的风格： img.flip { -moz-transform: scaleX(-1); -o-transform: scaleX(-1); -webkit-transform: scaleX(-1); transform: scaleX(-1); filter: FlipH; -ms-filter: &quot;FlipH&quot;; } clearfixclearfix主要是使用他来清除浮动，只需要添加这个类名无需加上任何HTML标记，就可以达到清除浮动的效果： .clearfix:before, .clearfix:after { content: &quot; &quot;; display:table; } .clearfix:after { clear:both; overflow:hidden; } .clearfix { zoom: 1; } 圆角随着CSS3的属性的出现，我们制作圆角效果就不需要在像以前那样的辛苦了，可以使用CSS3的border-radius来实现，只是在IE-6-8下无法实现，我们来看现代浏览器下如何制作圆角： .round{ -moz-border-radius: 10px; -webkit-border-radius: 10px; -khtml-border-radius: 10px; /* for old Konqueror browsers */ border-radius: 10px; /* future proofing */ } !important!important有时可以帮我们做很多事，他可以覆盖任何相同的样式，换句话说他可以改为样式的权重： p{ font-size:20px !important; } @font-face@font-face也是CSS3的属性之一，他能在所有浏览器下运行。最大的作用就是让用户没有字体的浏览下也能支持网页字体，具体使用： @font-face { font-family: &#39;Graublau Web&#39;; src: url(&#39;GraublauWeb.eot&#39;); src: local(&#39;☺&#39;), url(&#39;GraublauWeb.woff&#39;) format(&#39;woff&#39;), url(&#39;GraublauWeb.ttf&#39;) format(&#39;truetype&#39;); } h2 { font-family:&#39;Graublau Web&#39;; } 页面水平居中如何使一个网站的页面水平居中显示，我想这个不用我说大家也知道，因为大家肯定使用过多次了。 .wrapper { width:960px; margin:0 auto; } 最小高度min-height在IE6浏览器下是不支持最小高度这个属性的，为了解决这个问题，我们可以使用下面这样的代码来处理： .box { min-height:500px; height:auto !important; height:500px; } 垂直居中水平居中处理起来相当的简单的，但是垂直居中处理起来还是相当的烦，特别是要兼容IE的浏览器情况下： div { height: 100px; line-height: 100px; white-space: nowrap; } img { vertical-align: middle; } .for_ie6 { display: inline-block; } .for_ie6 { display: inline; } ::selection有很多朋友肯定不知道这个属性的作用。它可以改变选择的文本的背景色和前景色，突出你的浏览器中的选择文本效果： ::selection { color: #000000; background-color: #FF0000; } ::-moz-selection { color: #000000; background: #FF0000; }]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题（含人事方面）]]></title>
    <url>%2F2018%2F03%2F13%2FInterview%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%EF%BC%88%E5%90%AB%E4%BA%BA%E4%BA%8B%E6%96%B9%E9%9D%A2%EF%BC%89%2F</url>
    <content type="text"><![CDATA[前端方面1.隐藏html元素的两种方式？它们的区别是什么？【display: none】：隐藏元素及元素内的所有内容，并且该元素的位置、宽高等其他属性值一并“消失”；【visibility: hidden】：隐藏元素及元素内的所有内容，但是该元素的位置、宽高等属性值仍然还在。 2.$.each和$(selector).each()的区别？ $.each和$(selector).each()不同，后者专用于jQuery对象的遍历，前者可用于遍历任何集合（无论是数组还是对象），如果是数组，回调函数每次传入数组的索引值和对应值（值亦可以通过this关键字获取，但JavaScript总会包装this值作为一个对象），方法会返回被遍历对象的第一参数。 3.$.ajax的必要参数是什么？ Success和complete那个先执行？ Function) success - 当请求成功时调用的函数。这个函数会得到一个参数：从服务器返回的数据（根据“dataType”进行了格式化）。 Function) complete - 当请求完成时调用的函数。这个函数会得到两个参数：XMLHttpRequest对象和一个描述请求成功的类型的字符串。 jquery中各个事件执行顺序如下： 1.ajaxStart(全局事件) 2.beforeSend 3.ajaxSend(全局事件) 4.success 5.ajaxSuccess(全局事件) 6.error 7.ajaxError (全局事件) 8.complete 9.ajaxComplete(全局事件) 10.ajaxStop(全局事件) 4.列举浏览器对象模型BOM里常用的4个对象，并列举window对象的常用方法至少5个。Window document location screen history navigator 方法：Alert() confirm() prompt() open() close() 5.简述列举文档对象模型DOM里document的常用的查询访问节点的方法并做简单说明。1.通过ID,使用 getElementById() 获得标签节点 2.通过标签的名称,使用getElementsByTagName() 获得元素节点或标签节点 注意：以上的查找方式都会忽略文档的结构 3.通过使用一个元素节点的 parentNode、firstChild 以及 lastChild 属性 4.节点名称nodeName a)如果节点是标签，nodeName是标签名称 b)如果节点是属性，nodeName是属性名称 c)如果节点是文本节点，nodeName是#text d)如果节点是文档，nodeName是#document 5.节点值nodeValue6.节点类型nodeType 6.Ajax的优缺点是什么（至少各3个）？同步异步的区别？ ajax的优点 1.异步的与服务器通信2.无刷新更新数据3.基于标准广泛支持4.前后端负载平衡5.界面与应用分离 ajax的缺点 1.AJAX干掉了Back和History功能，即对浏览器机制的破坏。2.AJAX的安全问题。3.对搜索引擎支持较弱。4.破坏程序的异常处理机制。5.违背URL和资源定位的初衷。6.AJAX不能很好支持移动设备。7.客户端过肥，太多客户端代码造成开发上的成本。 同步与异步的区别 1、同步发送方发出数据后，等接收方发回响应以后才发下一个数据包的通讯方式。 例如：用户填写所有信息后，提交给服务器，等待服务器的回应（检验数据），是一次性的。信息错误又要重新填写！ 2、异步是指：发送方发出数据后，不等接收方发回响应，接着发送下个数据包的通讯方式。 例如：当用户填写完一条信息后，该信息会自动向服务器提交，然后服务器响应客户端，在此过程中，用户依然在填写表格的信息，即向服务器请求多次，节省了用户的时间，提高了用户的体验。 3、区别： 同步请求比着异步请求少了个XMLhttpRequest对象。在用户体验方面，异步的用户体验更好一些。 7.前端开发的优化问题。（1） 减少http请求次数：css spirit,data uri（2） JS，CSS源码压缩（3） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数（4） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能（5） 用setTimeout来避免页面失去响应（6） 用hash-table来优化查找（7） 当需要设置的样式很多时设置className而不是直接操作style（8） 少用全局变量（9） 缓存DOM节点查找的结果（10） 避免使用CSS Expression（11） 图片预载（12） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢 8.什么是闭包？简言之，闭包是由函数引用其周边状态（词法环境）绑在一起形成的（封装）组合结构。在 JavaScript 中，闭包在每个函数被创建时形成。 这是基本原理，但为什么我们关心这些？实际上，由于闭包与它的词法环境绑在一起，因此 闭包让我们能够从一个函数内部访问其外部函数的作用域。 要使用闭包，只需要简单地将一个函数定义在另一个函数内部，并将它暴露出来。要暴露一个函数，可以将它返回或者传给其他函数。 内部函数将能够访问到外部函数作用域中的变量，即使外部函数已经执行完毕。 闭包的用途之一是实现对象的私有数据。 9.Doctype作用？标准模式和兼容模式各有什么区别？DOCTYPE是document type(文档类型)的简写,用来告诉浏览器的解析器使用哪种HTML或XHTML规范解析页面。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 为什么HTML5只要写&lt;!DOCTYPE HTML&gt; HTML 4.01 基于 SGML，需要对 DTD 进行引用，才能告知浏览器文档所使用的文档类型 。HTML 5 不基于 SGML，因此不需要对 DTD 进行引用，但是需要 doctype 来规范浏览器的行为。SGML是标准通用标记语言,简单的说，就是比HTML,XML更老的标准，这两者都是由SGML发展而来的。但是，HTML5不是的。 标准模式与兼容模式（怪异模式）各有什么区别? Standards（标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而Quirks（兼容）模式（也就是松散呈现模式或者怪异模式）用于呈现为传统浏览器而设计的网页。 标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。简单说就是尽可能的显示能显示的东西给用户看。 具体区别：1.盒模型 在严格模式中 ：width是内容宽度 ，元素真正的宽度 = width; 在兼容模式中 ：width则是=width+padding+border 2.兼容模式下可设置百分比的高度和行内元素的高宽 在Standards模式下，给span等行内元素设置wdith和height都不会生效，而在兼容模式下，则会生效。 在standards模式下，一个元素的高度是由其包含的内容来决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。 3.用margin:0 auto设置水平居中在IE下会失效 使用margin:0 auto在standards模式下可以使元素水平居中，但在兼容模式下却会失效（用text-align属性解决） body{text-align:center};#content{text-align:left} 4.兼容模式下Table中的字体属性不能继承上层的设置，white-space:pre会失效，设置图片的padding会失效 10.常见的浏览器内核有哪些？Trident-IE浏览器内核Gecko-火狐浏览器内核MozillaBlink(Webkit的分支)-谷歌浏览器内核Presto，现为Blink-Opera浏览器内核 11.HTML5的新特性？1.语意特性,添加&lt;header&gt;&lt;header/&gt;&lt;nav&gt;&lt;nav&gt;等标签2.多媒体， 用于媒介回放的 video 和 audio 元素3.图像效果，用于绘画的 canvas 元素，svg元素等4.离线 &amp; 存储,对本地离线存储的更好的支持,local Store,Cookies等5.设备兼容特性 ，HTML5提供了前所未有的数据与应用接入开放接口。使外部应用可以直接与浏览器内部的数据直接相连，6.连接特性，更有效的连接工作效率，使得基于页面的实时聊天，更快速的网页游戏体验，更优化的在线交流得到了实现。HTML5拥有更有效的服务器推送技术，Server-Sent Event和WebSockets就是其中的两个特性，这两个特性能够帮助我们实现服务器将数据“推送”到客户端的功能7.性能与集成特性，HTML5会通过XMLHttpRequest2等技术，帮助您的Web应用和网站在多样化的环境中更快速的工作 12.如何处理HTML5新标签的浏览器兼容问题？document.createElement（‘新标签’）; / /新增创建新标签再者还有一种办法就是用框架的方法，用到条件注释加JS代码实现 &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 直接加入这一句代码就可实现兼容问题，关于条件注意中的 &lt;!--if lt IE9&gt; 13.如何区分HTML和HTML5？1.在文档类型声明上 html: &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot; http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; HTML5: &lt;!DOCTYPE html&gt; 由这两者对比可见：在文档声明上，html有很长的一段代码，并且很难记住这段代码，想必很多人都是靠工具直接生成的吧？而html5却是不同，只有简简单单的声明，这也方便人们的记忆，更加精简。 2.在结构语义上 html4.0：没有体现结构语义化的标签，我们通常都是这样来命名的 &lt;divid=&quot;header&quot;&gt;&lt;/div&gt; 这样表示网站的头部。 html5：在语义上却有很大的优势。提供了一些新的html5标签，比如: &lt;header&gt; 、&lt;nav&gt;、&lt;article&gt;、&lt;aside&gt;、&lt;footer&gt;.. 3.强大的HTML5的新功能 （1）强大的绘图功能（2）新增视频标签 14.描述cookie，sessionStorage和localStorage的区别？三者的异同 特性 Cookie localStorage sessionStorage数据的生命期 一般由服务器生成，可设置失效时间。如果在浏览器端生成Cookie，默认是关闭浏览器后失效 除非被清除，否则永久保存 仅在当前会话下有效，关闭页面或浏览器后被清除存放数据大小 4K左右 一般为5MB与服务器端通信 每次都会携带在HTTP头中，如果使用cookie保存过多数据会带来性能问题 仅在客户端（即浏览器）中保存，不参与和服务器的通信易用性 需要程序员自己封装，源生的Cookie接口不友好 源生接口可以接受，亦可再次封装来对Object和Array有更好的支持 15.如何实现浏览器内多个标签页之间的通信？本题主要考察数据存储的知识，数据存储有本地和服务器存储两种方式。这里主要讲解用本地存储方式解决。即调用 localStorage、Cookie等本地存储方式。 第一种——调用localStorage第二种——调用cookie+setInterval() 16.Strong和em的异同？在浏览器中，&lt;em&gt; 默认用斜体表示，&lt;strong&gt; 用粗体表示。从样式表现上，&lt;strong&gt; 更加突出，更容易吸引眼光。显然，这种视觉上的差异设计是有目的的。 em 表示内容的着重点（stress emphasis），放置的位置会改变所在句子的含义。strong 表示内容的重要性（strong importance），强调句子的重要性而不会改变所在句子的语意。 17.简述src和href的区别？href 时指向网络资源所在位置，建立和当前元素（锚点）或当前文档（链接）之间的链接，用于超链接。src 时指向外部的资源位置，指向的内容将会嵌入到文档中当前标签所在位置；在请求 src 资源时会将其指向的资源下载并应用到文档内，例如 js 脚本，img 图片和 frame 等元素。 当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执行完毕 ，图片和框架等元素也是如此，类似于将所指向资源嵌入当前标签内。这也是为什么将 js 脚本放在底部而不是头部。 18.Css选择器的优先级是怎样定义的？关于优先级的规定，常用的方法是给不同的选择器分配权值： id选择器优先级很高，权值为100 class、属性和伪类选择器的权值为10 标签选择器权值为1 在比较样式的优先级时，只需统计选择符中的id、class和标签名的个数，然后把相应的权值相加即可，最后根据结果排出优先级 权值较大的优先级越高 权值相同的，后定义的优先级较高 样式值含有!important，优先级最高 19.超链接访问过后hover样式就不出现的问题是什么？如何解决？被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A（link,visited,hover,active） 20.行内样式和块级元素的区别是什么？块级元素会独占一行,默认情况下,其宽度自动填满其父元素宽度.行内元素不会独占一行,相邻的行内元素会排列在同一行里,直到一行排不下,才会换行,其宽度随元素的内容而变化.块级元素可以设置width,height属性.行内元素设置width,height属性无效. 20.行内元素可以的padding和margin可设置么？只能设置左右的padding和margin。 21.Css中可以让文字在垂直和水平方向上重叠的两个属性是什么？text-align: center; vertical-align: middle; 22.Px和em,rem的区别？px像素（Pixel）。相对长度单位。像素px是相对于显示器屏幕分辨率而言的。(引自CSS2.0手册) em是相对长度单位。相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。(引自CSS2.0手册) EM特点 em的值并不是固定的； em会继承父级元素的字体大小。 所以我们在写CSS的时候，需要注意两点： body选择器中声明Font-size=62.5%； 将你的原来的px数值除以10，然后换上em作为单位； 重新计算那些被放大的字体的em数值。避免字体大小的重复声明。 rem是CSS3新增的一个相对单位（root em，根em），这个单位引起了广泛关注。这个单位与em有什么区别呢？ 区别在于使用rem为元素设定字体大小时，仍然是相对大小，但相对的只是HTML根元素。这个单位可谓集相对大小和绝对大小的优点于一身，通过它既可以做到只修改根元素就成比例地调整所有字体大小，又可以避免字体大小逐层复合的连锁反应 23.说出你熟悉的两个css预处理器的区别？Sass与less下面从特性上比较三者异同：1.变量： Sass声明变量必须是『$』开头，后面紧跟变量名和变量值，而且变量名和变量值需要使用冒号：分隔开。Less 声明变量用『@』开头，其余等同 Sass。Stylus 中声明变量没有任何限定，结尾的分号可有可无，但变量名和变量值之间必须要有『等号』。但需要注意的是，如果用“@”符号来声明变量，Stylus会进行编译，但不会赋值给变量。就是说，Stylus 不要使用『@』声明变量。Stylus 调用变量的方法和Less、Sass完全相同。2.作用域： css 预编译器把变量赋予作用域，也就是存在生命周期。就像 js 一样，它会先从局部作用域查找变量，依次向上级作用域查找。 Sass：三者最差，不存在全局变量的概念。也就是说在 Sass 中定义了相同名字的变量时你就要小心蛋疼了。Less：我认为跟 JS 一样，逐级查找，向上冒泡。Stylus：完全等同 Less。Stylus 和 Sass 则更倾向于指令式。 3.嵌套： 十分真诚的说，三种 css 预编译器的「选择器嵌套」在使用上来说没有任何区别（也可能是我没发现）。Sass 除了常规的采用『&amp;』替代父级选择器之外，还提供了「奇葩的属性嵌套」： /*style.sass*/ .footer { font: { family: 微软雅黑; size: 5rem; weight: bolder; } } 4.继承： css 属性的继承是一个非常重要的特性，好消息是三种预编译器都对此做出了改善。 Sass和Stylus的继承非常像，能把一个选择器的所有样式继承到另一个选择器上。使用『@extend』开始，后面接被继承的选择器。 .shit { margin: 10px 5px; padding: 2px; } p { @extend .shit;/*继承.block*/ border: 1px solid #aaa; } ul,li { @extend .shit; /*继承.block*/ color: #aaa; } 将被编译成标准 css： .shit,p,ul,ol { margin: 10px 5px; padding:2px; } p { border: 1px solid #aaa } ul,li { color:#aaa; } Less 继承：与前两者继承方式有所区别，它不是在选择器上继承，而是将Mixins中的样式嵌套到每个选择器里面。然而这样会带来一个明显的缺点：每个选择器中会出现重复的样式。 5.导入@Import： CSS中，不建议用@import导入css，因为会增加http请求。但 CSS 预处理器中的导入和CSS的有hhe很大区别，它是将不同 css 是在语义上导入，最终编译结果会生成一个CSS文件。 值得注意的是，如果不同文件相互引入的时候，出现相同变量名时可能会引起错误。所以我的建议是单独有一个 var.sass/less/styl 文件来记录所有你定义的变量。 Less 为@Import 扩展了语法，而 Sass 和 Stylus 并没有。具体扩展的 import 语法请见：Less 的 Import 扩展 24.“user strict”有什么作用？ - 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; - 消除代码运行的一些不安全之处，保证代码运行的安全； - 提高编译器效率，增加运行速度； - 为未来新版本的Javascript做好铺垫。 25.JavaScript如何实现继承？继承 26.对this指针的理解，可以列举几种情况？this指的是：调用函数的那个对象。 a. 纯粹的函数调用，属于全局性调用，因此this就代表全局对象Global。 b. 作为对象方法的调用，这时this就指这个上级对象。 c. 作为构造函数调用，就是通过这个函数new一个新对象（object）。这时，this就指这个新对象。 d. apply与call的调用，它们的作用是改变函数的调用对象，它的第一个参数就表示改变后的调用这个函数的对象。 27.Mvvm框架和mvc有什么不同？在MVC里，View是可以直接访问Model的！从而，View里会包含Model信息，不可避免的还要包括一些业务逻辑。 MVC模型关注的是Model的不变，所以，在MVC模型里，Model不依赖于View，但是 View是依赖于Model的。不仅如此，因为有一些业务逻辑在View里实现了，导致要更改View也是比较困难的，至少那些业务逻辑是无法重用的。MVVM在概念上是真正将页面与数据逻辑分离的模式，它把数据绑定工作放到一个JS里去实现，而这个JS文件的主要功能是完成数据的绑定，即把model绑定到UI的元素上。有人做过测试：使用Angular（MVVM）代替Backbone（MVC）来开发，代码可以减少一半。此外，MVVM另一个重要特性，双向绑定。它更方便你同时维护页面上都依赖于某个字段的N个区域，而不用手动更新它们。 28.如何获取JavaScript变量的类型？1、typeoftypeof 是一个操作符，其右侧跟一个一元表达式，并返回这个表达式的数据类型。返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。 2、instanceofinstanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。 在这里需要特别注意的是：instanceof 检测的是原型，我们用一段伪代码来模拟其内部执行过程： instanceof (A,B) = { var L = A.__proto__; var R = B.prototype; if(L === R) { // A的内部属性 __proto__ 指向 B 的原型对象 return true; } return false; } 3、constructor当一个函数 F被定义时，JS引擎会为F添加 prototype 原型，然后再在 prototype上添加一个 constructor 属性，并让其指向 F 的引用。如下所示： 可以看出，F 利用原型对象上的 constructor 引用了自身，当 F 作为构造函数来创建对象时，原型上的 constructor 就被遗传到了新创建的对象上， 从原型链角度讲，构造函数 F 就是新对象的类型。这样做的意义是，让新对象在诞生以后，就具有可追溯的数据类型。 null 和 undefined 是无效的对象，因此是不会有 constructor 存在的，这两种类型的数据需要通过其他方式来判断。 函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object 4、toStringtoString() 是 Object 的原型方法，调用该方法，默认返回当前对象的 [[Class]] 。这是一个内部属性，其格式为 [object Xxx] ，其中 Xxx 就是对象的类型。 对于 Object 对象，直接调用 toString() 就能返回 [object Object] 。而对于其他对象，则需要通过 call / apply 来调用才能返回正确的类型信息。 29.JavaScript如何模拟块级作用域？用匿名的函数表达式立即执行 的方式来 模仿块级作用域 (function() { // 这里是块级作用域 })(); 这样就是私有作用域，在匿名函数中定义的私有变量，都会在执行结束时被销毁。在一个由很多开发人员共同参与的大型应用程序中，过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域，每个开发人员既可以使用自己的变量，又不必担心搞乱全局作用域。 30.JavaScript如何模拟私有变量？基于闭包的实现方式另外一种比较普遍的方式是利用JavaScript的闭包特性。构造函数内定义局部变量和特权函数，其实例只能通过特权函数访问此变量，如下： function Person(name){ var _name = name; this.getName = function(){ return _name; } } var person = new Person(&#39;Joe&#39;); 这种方式的优点是实现了私有属性的隐藏，Person 的实例并不能直接访问_name属性，只能通过特权函数getName获取： alert(person._name); // undefined alert(person.getName()); //&#39;Joe&#39; 使用闭包和特权函数实现私有属性的定义和访问是很多开发者采用的方式，Douglas Crockford也曾在博客中提到过这种方式。但是这种方式存在一些缺陷： 私有变量和特权函数只能在构造函数中创建。通常来讲，构造函数的功能只负责创建新对象，方法应该共享于prototype上。特权函数本质上是存在于每个实例中的，而不是prototype上，增加了资源占用。 31.Call（）和apply（）的区别？call 和 apply 就是为了改变函数体内部 this 的指向。 区别是从第二个参数起，call 需要把参数按顺序传递进去，而 apply 则是把参数放在数组里。 当参数明确时用call与apply都行, 当参数不明确时可用apply给合arguments 32.get和post的区别？GET后退按钮/刷新无害，POST数据会被重新提交（浏览器应该告知用户数据会被重新提交）。GET书签可收藏，POST为书签不可收藏。GET能被缓存，POST不能缓存 。GET编码类型application/x-www-form-url，POST编码类型encodedapplication/x-www-form-urlencoded 或 multipart/form-data。为二进制数据使用多重编码。GET历史参数保留在浏览器历史中。POST参数不会保存在浏览器历史中。GET对数据长度有限制，当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）。POST无限制。GET只允许 ASCII 字符。POST没有限制。也允许二进制数据。与 POST 相比，GET 的安全性较差，因为所发送的数据是 URL 的一部分。在发送密码或其他敏感信息时绝不要使用 GET ！POST 比 GET 更安全，因为参数不会被保存在浏览器历史或 web 服务器日志中。GET的数据在 URL 中对所有人都是可见的。POST的数据不会显示在 URL 中。 33.描述下标准盒模型？ content-box（标准盒模型） width = 内容的宽度 height = 内容的高度 border-box（怪异盒模型） width = border + padding + 内容的宽度 height = border + padding + 内容的高度 34.Css3有哪些新特性？ CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);// 旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是 ::selection. 媒体查询，多栏布局 border-image 35.文档流将窗体自上而下分成一行行, 并在每行中按从左至右的顺序排放元素,即为文档流.(自己的理解是从头到尾按照文档的顺序，该在什么位置就在什么位置，也可以按照上面的意思理解，自上而下，自左到右的顺序)。文档流是文档中可显示对象 在排列时所占用的位置。 36.在移动端与pc端做项目有什么区别?On事件的不同 ；先说布局方面： js事件不同：click事件在移动端反应有300ms延迟，点击反应慢还会出现点透的bug。应尝试使用touch事件，或者使用fastclick.js库，也可以使用zeptojs中的tap事件。 调试页面：使用chrome的模拟移动端工具，有时还要使用eruda、weinre真机调试工具。微信开发或者小程序请选择微信开发者工具。 需要设置viewport：在header里使用&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, user-scalable=no&quot;&gt;来控制屏幕全屏显示，且不能被缩放。 字体规则：pc端使用的px在移动屏幕上不能很好的适应多分辨率，移动端改用rem字体单位。令 html{ font-size:62.5%; }，则1rem=10px。然后使用css3的媒体查询控制不同分辨率下html显示的倍数。 最小点击区域44px：移动端是有最小点击识别区的，元素大小低于这个值时被点击是不会触发click事件的。 可以调用硬件功能：可以通过设置a标签href类型来实现拨打电话、发送短信和邮件等功能。可以通过&lt;input type=&quot;file&quot;&gt;的accept 属性，调用本地图片或拍照。还可以使用html5的运动传感器数据事件实现微信摇一摇功能。 37.什么面向对象面向对象的三个基本特征是：封装、继承、多态。 38.Html5有哪些标签：header、footer、section、nav、audio、canvas 37.一个页面从输入URL到页面加载显示完成，这个过程都发生什么1、首先，在浏览器地址栏中输入url2、浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。3、在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。4、浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。5、握手成功后，浏览器向服务器发送http请求，请求数据包。6、服务器处理收到的请求，将数据返回至浏览器7、浏览器收到HTTP响应8、读取页面内容，浏览器渲染，解析html源码9、生成Dom树、解析css样式、js交互10、客户端和服务器交互11、ajax查询]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js面试题汇总]]></title>
    <url>%2F2018%2F03%2F12%2FInterview%2Fjs%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[闭包是什么？闭包的用处。 闭包是内部函数对外部函数作用域的引用。而在函数外部引用函数内部变量，可以通过闭包实现。闭包的用处往往是在模块封装的时候。可以将模块内部公有部分暴露出来。(闭包是基础性的问题，这里只是简要的阐述了一下它的概念) 闭包详解(阮一峰) 原型以及原型链js与常用的编程语言不一样，他是靠原型继承的，并不是类。使用造零件的方式进行类比，通过类继承的方式就是通过一个模型盒铸件，而原型的方式，则是从另一个零件克隆一份，在这基础上进行修改。而那份被克隆的零件就是原型 原型及原型链详解。原型链就是它们之间产生的联系，往往可以通过画图来阐述： 垃圾回收机制和内存泄漏js引擎有自己的一套垃圾回收的机制，主要的回收机制有两种标记清除和循环引用。标记清除，即是在局部变量在使用过程中打上标记，一旦离开了执行环境，标记将会被清除，这是垃圾回收器将会知道，该变量已经不使用，可回收。而循环引用是在较早版本的IE浏览器中被使用，即初始化的变量引用数为0，一旦被赋值给另一个变量，引用就加1；而另一个变量一旦被赋予其他值，则该值的引用数减一。垃圾回收器会去判断该变量的引用数是否为0，为0，则会被回收掉。这个机制会存在循环引用的问题，即两个变量相互引用。垃圾回收 内存泄漏的问题。可以罗列为： 无意识的变量使用 function func(){ i = 2; } 这种方式在严格模式下是不生效的。 闭包导致的问题 其实，闭包导致的内存泄漏主要是在IE引用dom元素的时候。IE中的部分dom元素并非原生的，而是COM。这时使用，往往会导致循环引用，而导致内存泄漏。还有就是无意识的使用闭包导致的问题。1. 在函数内部添加时间时，会造成dom元素的引用，而导致内存泄漏；2. 在删除dom时，在之前不小心添加了事件等情况内存泄漏 柯里化js的柯里化就是将函数的部分参数分成多次进行调用。例子：柯里化 异步面试之中主要会问你何为异步？其实，js是一门单线程的语言，正常的方式是整个程序按照顺序一步一步的执行下去，这就是所谓的同步模式，但是往往js中会有许多的任务耗时比较长(比如说ajax请求)等，如果按照同步的方式，往往会导致浏览器的无响应。这时，就需要通过异步的形式。异步模式：js的任务往往具备一个或多个回调函数，在执行的过程中，后一个任务无需前一个任务执行返回结果，而是继续执行，之后前一个任务可以调用回调函数，将结果返回回来。异步 setTimeout和setInterval的区别，以及setTimeout的原理，setInterval会造成什么问题首先，我们来应该了解一下setTimeout的原理。浏览器是一个事件为主体的事物。总是有一个队列在不停的循环。当使用setTimeout时，浏览器会创建一个定时器，然后将函数中的回调函数放入handle队列里面。然后浏览器会不停的循环整个handle，一旦handle中的内容满足条件，就会调用其中的回调函数。setTimeout的满足条件就是它后面的设置的时间差。 setTimeout和setInterval之间的区别主要是setTimeout是一个延迟函数，只执行一次，而setInterval会间隔一定的时间反复的执行。setTimeout和setInterval的区别 setInterval的原理，其实与之前的setTimeout的原理有点类似。只是在每个Event Loop之后，都会去检测是否满足条件，如果满足条件的话，就执行回调函数，如果不满足，放入下一轮的event loop中。主要的问题就是，如果一个setInterval中的回调函数不能够被执行，会引起系统阻塞的问题，之后的所有的定时器都会积累起来，之后就会直接执行，没有时间间隔。setInterval机制 function interval(func, wait){ var interv = function(){ func.call(null); setTimeout(interv, wait); }; setTimeout(interv, wait); } interval(() =&gt; { console.log(1); }, 1000); //1 1 1 postmessage和iframe怎么结合使用postmessage是html5新出的一个API，可以解决多窗口、页面与新标签、窗口和iframe之间的消息通信的跨域问题。使用方法就是postmessage(data, origin)，其中data指的就是需要传递的数据，origin指的是具体的数据源地址(包括协议+域名+端口)。然后window对message事件进行监听。postMessage解决跨域 js模板引擎js模版引擎，其实就是预处理器，将一些字符串去匹配数据，然后将数据插入到固定的html模版之中。js的模版引擎主要是使用正则表达式去过滤一些字符串，然后将里面的每个语句片段都放到固定的数组之中，然后在对数组进行解析，之后拼成一个固定的js代码，将内容返回出来。著名的模版引擎ejs。js模版引擎原理解析 WebSocket？长轮询和短轮询webSocket是一种网络通信协议，基于TCP/IP的另一种通信协议(还有一种是http协议)。它与http的主要区别就是，http是单向通信的，客户端可以向服务器发送请求，但是，服务端如果有消息，无法向客户端推送。在没有websock之前，都是通过http定期发送请求的方式——轮询。轮询的效率是相对较低的。websock协议 之后的长轮询和短轮询呢？这个问题还得更实际的场景相结合起来。首先，我们在写电商网站的时候，商品的库存是实时变化的，这时，你要和服务器同步这个变化，才能够使得信息正确。那么，最简单的方式就是我们写一个ajax请求，不断的去给服务器请求，同步这个数据。而服务器每次接收到请求就返回一次信息。这就是所谓的短轮询，这种方式其实非常的消耗服务器的资源，试想服务器每次接收到请求就要去查询数据库，获取信息，而往往库存是没有这么快改变的。那么，或许长轮询可以更加方便地解决这个问题。我们可以写一个ajax请求，同时给这个请求设置超时机制，一旦超时之后，再次重新发送。而服务器每次接收到这个请求，只需要将之挂起，等检测到库存变化时，在响应这个请求，这样就有效的降低了轮询的次数。同样的问题，服务器的资源还是会有所损耗，毕竟一个请求相当于一个线程。对于大型的电商网站来说，这不是一种好的解决方式。长轮询、短轮询、长链接、短链接 cookie、LocalStorage 和 SessionStorage 的概念以及它们之间的区别首先，cookie是我们比较熟悉的，是浏览器与服务器之间数据传递的方式，之前通常也会用来做一些数据的缓存，例如：用户的用户名等。但是cookie在做数据缓存的时候往往有缺点： cookie数据最多只能缓存4kb，大于4kb的cookie会被浏览器默认弃用cookie在做数据缓存时，往往会将数据发送给服务器，但是，有的时候这些数据并不需要发送给服务器cookie在每个域中的数量是有限的，往往超过一定数量，那么之前的cookie将被抛弃html5新特性中就带来了相应的客户端storage，就是localStorage和sessionStorage。localStorage是本地存储，数据不会发送给服务器，同时它的缓存大小大约在5M左右，数据是永久存储的，除非手动删除。sessionStorage则是会话存储，大部分的特性和localStorage一样，但是，sessionStorage中的内容会在浏览器或者页面关闭之后被清除掉。cookie、LocalStorage和SessionStorage 浏览器事件代理的原理其实，事件代理和事件委托是同一个概念。举个例子说明或许会更加形象。场景是：DOM结构为一个列表，而你需要在点击每个li标签时，在控制台输出它的内容。这时，你或许会在每个li上面添加点击事件，然后输出每个li的内容。但是，往往这样子做，会使得整个应用的性能降低，而且使得添加过程繁琐，不灵活。我们可以使用事件代理的方式，在整个列表的ul上面去添加点击事件，然后在内部使用target(真实点击元素)来使其输出它的内容。这样，我们就可以只写一个事件，而完成多个li之间的内容输出。事件代理的原理是使用了事件冒泡的特性。但是，有时候有些事件没有冒泡机制，如focus，blurs等，就不能使用事件代理，还有些类似于mouseover等事件，会导致实时的触发，也不宜使用事件代理事件代理 前端安全 XSS，CSRF ？避免方法？XSS，被称为跨站脚本攻击，主要分为三种反射型、存储型和DOM型。反射型主要是一些恶意链接的发送，存储型主要出现在评论等，可以插入到服务器数据库中，这种攻击比较持久；DOM型非常的少见。XSS主要是盗取用户的cookie等数据。CSRF，被称为跨站伪造请求攻击，主要与xss相结合XSS和CSRF 前端性能优化的方法同源和跨域面向对象和继承object.create的实现原理object的深拷贝和浅拷贝面向切面编程和函数式编程原文链接]]></content>
      <categories>
        <category>Interview</category>
      </categories>
      <tags>
        <tag>Interview</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2F2018%2F03%2F11%2F%E6%80%A7%E8%83%BD%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端优化的目的是什么？ 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。 总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。 页面级优化减少http请求减少http请求数的主要途径包括： (1). 从设计实现层面简化页面 如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。 (2). 合理设置 HTTP缓存 缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据 (如图 1.1)，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据 (如图 1.2)。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 ) (3). 资源合并与压缩 如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。 (4). CSS Sprites 合并 CSS图片，减少请求数的又一个好办法。 (5). Inline Images 使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。 (6). Lazy Load Images（自己对这一块的内容还是不了解） 这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。 有啊首页 曾经的做法是在加载的时候把第一屏之后的图片地址缓存在 Textarea标签中，待用户往下滚屏的时候才 “惰性” 加载。 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，在 这里有比较详细的介绍 (这里是译文和 更详细的例子 )，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）将 CSS放在 HEAD中如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。 异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）减少不必要的 HTTP跳转对于以目录形式访问的 HTTP链接，很多人都会忽略链接最后是否带 ’/&#39;，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了 301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无 ’/&#39;结尾的方式访问的，于是服务器有了一次跳转 避免重复的资源请求这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求 代码级优化JavascriptDOM DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。如果脚本中包含了大量的 DOM操作则需要注意以下几点： HTML Collection（HTML收集器，返回的是一个数组内容信息） 在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。 因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。 reflow(回流)和 repaint(重绘)简要：整个在浏览器的渲染过程中（页面初始化，用户行为改变界面样式，动画改变界面样式等）reflow(回流)和repaint(重绘) 会大大影响web性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少reflow和repaint。 什么是reflow和repain reflow：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。 reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。 repaint：如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow 下面情况会导致reflow发生 1：改变窗口大小 2：改变文字大小 3：内容的改变，如用户在输入框中敲字 4：激活伪类，如:hover 5：操作class属性 6：脚本操作DOM 7：计算offsetWidth和offsetHeight 8：设置style属性 那么为了减少回流要注意哪些方式呢？ 1：不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸 2：尽量通过class来设计元素样式，切忌用style 3：实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute 4：权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。 5：不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed， 6：这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 7：css里不要有表达式expression 8：减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。 9：避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。 10: 尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。 11：请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。 如果我们要经常去获取和操作这些值，则可以先将这些值缓存起来例如： var windowHeight = window.innerHeight;//reflow for(i=0;i&lt;10;i++){ $body.height(windowHeight++); 一系列关于windowHeight的操作....... } (2). 慎用 withwith(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。 因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。 (3). 避免使用 eval和 Function 每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。 eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。 Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。 此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。 (4). 减少作用域链查找（这方面设计到一些内容的相关问题） 前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。 低效率的写法： // 全局变量 var globalVar = 1; function myCallback(info){ for( var i = 100000; i--;){ //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次 globalVar += i; } } 更高效的写法： // 全局变量 var globalVar = 1; function myCallback(info){ //局部变量缓存全局变量 var localVar = globalVar; for( var i = 100000; i--;){ //访问局部变量是最快的 localVar += i; } //本例中只需要访问 2次全局变量在函数中只需要将 globalVar中内容的值赋给localVar 中区 globalVar = localVar; } 此外，要减少作用域链查找还应该减少闭包的使用。 (5). 数据访问 Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量： a. 对任何对象属性的访问超过 1次 b. 对任何数组成员的访问次数超过 1次 另外，还应当尽可能的减少对对象以及数组深度查找。 (6). 字符串拼接 在 Javascript中使用”+” 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。 不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。 CSS选择符在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如#toc A { color: #444; } 这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项 HTML对 HTML本身的优化现如今也越来越多的受人关注了，详情可以参见这篇总结性文章 Image压缩一个非常实用的Image压缩的网站 图片压缩是个技术活，不过现如今这方面的工具也非常多，压缩之后往往能带来不错的效果，具体的压缩原理以及方法在《 Even Faster Web Sites》第10 章有很详细的介绍，有兴趣的可以去看看。 《高性能网站建设指南》提出的规则 规则1——-减少HTTP请求 规则2——-使用内容发布网络 规则3——-添加Expires头控制缓存 规则4——-压缩组件 规则5——-将样式表放在顶部 规则6——-将脚步放在底部 规则7——-避免css表达式 规则8——-使用外部javaScript和CSS 规则9——-减少DNS查找 规则10——-精简javaScript 规则11——-避免重定向 规则12——-删除重复脚步 规则13——-配置ETag 规则14——-使Ajax可缓存]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax已死，Fetch永生]]></title>
    <url>%2F2018%2F03%2F10%2Fstudy%2FAjax%E5%B7%B2%E6%AD%BB%EF%BC%8CFetch%E6%B0%B8%E7%94%9F%2F</url>
    <content type="text"><![CDATA[由于 Fetch API 是基于 Promise 设计，有必要先学习一下 Promise，推荐阅读 MDN Promise 教程。旧浏览器不支持 Promise，需要使用 polyfill es6-promise 。 本文不是 Fetch API 科普贴，其实是讲异步处理和 Promise 的。Fetch API 很简单，看文档很快就学会了。推荐 MDN Fetch 教程 和 万能的WHATWG Fetch 规范 Why FetchXMLHttpRequest 是一个设计粗糙的 API，不符合关注分离（Separation of Concerns）的原则，配置和调用方式非常混乱，而且基于事件的异步模型写起来也没有现代的 Promise，generator/yield，async/await 友好。 Fetch 的出现就是为了解决 XHR 的问题，拿例子说明： 使用 XHR 发送一个 json 请求一般是这样： var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, url); xhr.responseType = &#39;json&#39;; xhr.onload = function() { console.log(xhr.response); }; xhr.onerror = function() { console.log(&quot;Oops, error&quot;); }; xhr.send(); 使用 Fetch 后，顿时看起来好一点 fetch(url).then(function(response) { return response.json(); }).then(function(data) { console.log(data); }).catch(function(e) { console.log(&quot;Oops, error&quot;); }); 使用 ES6 的 箭头函数 后： fetch(url).then(response =&gt; response.json()) .then(data =&gt; console.log(data)) .catch(e =&gt; console.log(&quot;Oops, error&quot;, e)) 现在看起来好很多了，但这种 Promise 的写法还是有 Callback 的影子，而且 promise 使用 catch 方法来进行错误处理的方式有点奇怪。不用急，下面使用 async/await 来做最终优化 注：async/await 是非常新的 API，属于 ES7，目前尚在 Stage 1(提议) 阶段，这是它的完整规范。使用 Babel 开启 runtime 模式后可以把 async/await 无痛编译成 ES5 代码。也可以直接使用 regenerator 来编译到 ES5。 try { let response = await fetch(url); let data = await response.json(); console.log(data); } catch(e) { console.log(&quot;Oops, error&quot;, e); } // 注：这段代码如果想运行，外面需要包一个 async function duang~~ 的一声，使用 await 后，写异步代码就像写同步代码一样爽。await 后面可以跟 Promise 对象，表示等待 Promise resolve() 才会继续向下执行，如果 Promise 被 reject() 或抛出异常则会被外面的 try…catch 捕获。 Promise，generator/yield，await/async 都是现在和未来 JS 解决异步的标准做法，可以完美搭配使用。这也是使用标准 Promise 一大好处。最近也把项目中使用第三方 Promise 库的代码全部转成标准 Promise，为以后全面使用 async/await 做准备。 另外，Fetch 也很适合做现在流行的同构应用，有人基于 Fetch 的语法，在 Node 端基于 http 库实现了 node-fetch，又有人封装了用于同构应用的 isomorphic-fetch。 注：同构(isomorphic/universal)就是使前后端运行同一套代码的意思，后端一般是指 NodeJS 环境。 总结一下，Fetch 优点主要有： 语法简洁，更加语义化 基于标准 Promise 实现，支持 async/await 同构方便，使用 isomorphic-fetch Fetch 启用方法先看一下 Fetch 原生支持率： 原生支持率并不高，幸运的是，引入下面这些 polyfill 后可以完美支持 IE8+ ： 由于 IE8 是 ES3，需要引入 ES5 的 polyfill: es5-shim,es5-sham 引入 Promise 的 polyfill: es6-promise 引入 fetch 探测库：fetch-detector 引入 fetch 的 polyfill: fetch-ie8 可选：如果你还使用了 jsonp，引入 fetch-jsonp 可选：开启 Babel 的 runtime 模式，现在就使用 async/await Fetch polyfill 的基本原理是探测是否存在 window.fetch 方法，如果没有则用 XHR 实现。这也是 github/fetch 的做法，但是有些浏览器（Chrome 45）原生支持 Fetch，但响应中有中文时会乱码，老外又不太关心这种问题，所以我自己才封装了 fetch-detector 和 fetch-ie8 只在浏览器稳定支持 Fetch 情况下才使用原生 Fetch。这些库现在 每天有几千万个请求都在使用，绝对靠谱！ 终于，引用了这一堆 polyfill 后，可以愉快地使用 Fetch 了。但要小心，下面有坑： Fetch 常见坑 Fetch 请求默认是不带 cookie 的，需要设置 fetch(url, {credentials: ‘include’}) 服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。 竟然没有提到 IE，这实在太不科学了，现在来详细说下 IE IE 使用策略所有版本的 IE 均不支持原生 Fetch，fetch-ie8 会自动使用 XHR 做 polyfill。但在跨域时有个问题需要处理。 IE8, 9 的 XHR 不支持 CORS 跨域，虽然提供 XDomainRequest，但这个东西就是玩具，不支持传 Cookie！如果接口需要权限验证，还是乖乖地使用 jsonp 吧，推荐使用 fetch-jsonp。如果有问题直接提 issue，我会第一时间解决。 Fetch 和标准 Promise 的不足由于 Fetch 是典型的异步场景，所以大部分遇到的问题不是 Fetch 的，其实是 Promise 的。ES6 的 Promise 是基于 Promises/A+ 标准 ，为了保持 简单简洁 ，只提供极简的几个 API。如果你用过一些牛 X 的异步库，如 jQuery(不要笑) 、Q.js 或者 RSVP.js，可能会感觉 Promise 功能太少了。 没有 DeferredDeferred 可以在创建 Promise 时可以减少一层嵌套，还有就是跨方法使用时很方便。ECMAScript 11 年就有过 Deferred 提案，但后来没被接受。其实用 Promise 不到十行代码就能实现 Deferred：es6-deferred。现在有了 async/await，generator/yield 后，deferred 就没有使用价值了。 没有获取状态方法：isRejected，isResolved标准 Promise 没有提供获取当前状态 rejected 或者 resolved 的方法。只允许外部传入成功或失败后的回调。我认为这其实是优点，这是一种声明式的接口，更简单。 缺少其它一些方法：always，progress，finallyalways 可以通过在 then 和 catch 里重复调用方法实现。finally 也类似。progress 这种进度通知的功能还没有用过，暂不知道如何替代。 不能中断，没有 abort、terminate、onTimeout 或 cancel 方法Fetch 和 Promise 一样，一旦发起，不能中断，也不会超时，只能等待被 resolve 或 reject。幸运的是，whatwg 目前正在尝试解决这个问题 whatwg/fetch#27 相关资源WHATWG Fetch 规范Fetch API阮一峰async 原文地址]]></content>
      <tags>
        <tag>Fetch</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分布式版本管理系统使用]]></title>
    <url>%2F2018%2F03%2F09%2FTools%2FGit%E5%88%86%E5%B8%83%E5%BC%8F%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[#快速开始 安装windows安装在Windows上使用Git，可以从Git官网直接下载安装程序，（网速慢的同学请移步国内镜像），然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name &quot;Your Name&quot; $ git config --global user.email &quot;email@example.com&quot; mac安装如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 新建本地仓库使用Git前，需要先建立一个仓库(repository)。您可以使用一个已经存在的目录作为Git仓库或创建一个空目录。 使用您当前目录作为Git仓库，我们只需使它初始化。 git init XXX 添加新文件我们有一个仓库，但什么也没有，可以使用add命令添加文件。 git add filename 可以使用add… 继续添加任务文件。 提交版本现在我们已经添加了这些文件，我们希望它们能够真正被保存在Git仓库。 为此，我们将它们提交到仓库。 git commit -m &quot;Adding files&quot; 如果您不使用-m，会出现编辑器来让你写自己的注释信息。 当我们修改了很多文件，而不想每一个都add，想commit自动来提交本地修改，我们可以使用-a标识。 git commit -a -m &quot;Changed some files&quot; git commit 命令的-a选项可将所有被修改或者已删除的且已经被git管理的文档提交到仓库中。 千万注意，-a不会造成新文件被提交，只能修改 发布版本我们先从服务器克隆一个库并上传。 git clone ssh://example.com/~/www/project.git 现在我们修改之后可以进行推送到服务器。 git push ssh://example.com/~/www/project.git 取回更新如果您已经按上面的进行push，下面命令表示，当前分支自动与唯一一个追踪分支进行合并。 git pull 从非默认位置更新到指定的url。 git pull http://git.example.com/project.git 删除如何你想从资源库中删除文件，我们使用rm。 git rm file 分布与合并分支在本地完成，速度快。要创建一个新的分支，我们使用branch命令。 git branch test branch命令不会将我们带入分支，只是创建一个新分支。所以我们使用checkout命令来更改分支。 git checkout test 第一个分支，或主分支，被称为”master”。 git checkout master 对其他分支的更改不会反映在主分支上。如果想将更改提交到主分支，则需切换回master分支，然后使用合并。 git checkout master git merge test 如果您想删除分支，我们使用-d标识。 git branch -d test]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-router学习]]></title>
    <url>%2F2018%2F03%2F08%2FReact%2FReact-router%2FReact-router%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[React-router API接口demo 地址 组件RouterReact Router 的重要组件。它能保持 UI 和 URL 的同步。 Props children(required)一个或多个的 Route 或 PlainRoute。当 history 改变时， &lt;Router&gt; 会匹配出 Route 的一个分支，并且渲染这个分支中配置的组件，渲染时保持父 route 组件嵌套子 route 组件。 routeschildren 的别名。 historyRouter 监听的 history 对象，由 history 包提供。关于history的五个函数 createElement(Component, props) 当 route 准备渲染 route 组件的一个分支时，就会用这个函数来创建 element。当你使用某种形式的数据进行抽象时，你可以想要获取创建 element 的控制权，例如在这里设置组件监听 store 的变化，或者使用 props 为每个组件传入一些应用模块。 stringifyQuery(queryObject) 一个用于把 Link 或调用 transitionTo 函数的对象转化成 URL query 字符串的函数。 parseQueryString(queryString) 一个用于把 query 字符串转化成对象，并传递给 route 组件 props 的函数。 onError(error) 当路由匹配到时，也有可能会抛出错误，此时你就可以捕获和处理这些错误。通常，它们会来自那些异步的特性，如 route.getComponents，route.getIndexRoute，和 route.getChildRoutes。 onUpdate() 当 URL 改变时，需要更新路由的 state 时会被调用。 Link允许用户浏览应用的主要方式。&lt;Link&gt; 以适当的 href 去渲染一个可访问的锚标签。 &lt;Link&gt; 可以知道哪个 route 的链接是激活状态的，并可以自动为该链接添加 activeClassName 或 activeStyle。 Propsto跳转链接的路径，如 /users/123。 query已经转化成字符串的键值对的对象。 hashURL 的 hash 值，如 #a-hash。&lt;font color = &quot;red&quot;&gt;注意：React Router 目前还不能管理滚动条的位置，并且不会自动滚动到 hash 对应的元素上。如果需要管理滚动条位置，可以使用 scroll-behavior 这个库。&lt;/font&gt; state保存在 location 中的 state activeClassName当某个 route 是激活状态时，&lt;Link&gt; 可以接收传入的 className。失活状态下是默认的 class。 activeStyle当某个 route 是激活状态时，可以将样式添加到链接元素上。 onClick(e)自定义点击事件的处理方法。如处理 &lt;a&gt; 标签一样 - 调用 e.preventDefault()来防止过度的点击，同时 e.stopPropagation()可以阻止冒泡的事件。 其他你也可以在 &lt;a&gt; 标签上传入一些你想要的 props，如 title，id，className 等等。 示例如 &lt;Route path=&quot;/users/:userId&quot; /&gt; 这样的 route： &lt;Link to={`/users/${user.id}`} activeClassName=&quot;active&quot;&gt;{user.name}&lt;/Link&gt; // 变成它们其中一个依赖在 History 上，当这个 route 是 // 激活状态的 &lt;a href=&quot;/users/123&quot; class=&quot;active&quot;&gt;Michael&lt;/a&gt; &lt;a href=&quot;#/users/123&quot;&gt;Michael&lt;/a&gt; // 修改 activeClassName &lt;Link to={`/users/${user.id}`} activeClassName=&quot;current&quot;&gt;{user.name}&lt;/Link&gt; // 当链接激活时，修改它的样式 &lt;Link to=&quot;/users&quot; style={{color: 'white'}} activeStyle={{color: 'red'}}&gt;Users&lt;/Link&gt; IndexLink如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。 这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。 &lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt; Home &lt;/IndexLink&gt; 上面代码中，根路由只会在精确匹配时，才具有activeClassName。 另一种方法是使用Link组件的onlyActiveOnIndex属性，也能达到同样效果。 &lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex={true}&gt; Home &lt;/Link&gt; RoutingContext在 context 中给定路由的 state、设置 history 对象和当前的 location，&lt;RoutingContext&gt; 就会去渲染组件树。 组件配置routeRoute 是用于声明路由映射到应用程序的组件层。 PropspathURL 中的路径。 它会组合父 route 的路径，除非它是从 / 开始的， 将它变成一个绝对路径。 注意：在动态路由中，绝对路径可能不适用于 route 配置中。 如果它是 undefined，路由会去匹配子 route。 component当匹配到 URL 时，单个的组件会被渲染。它可以 被父 route 组件的 this.props.children 渲染。 const routes = ( &lt;Route component={App}&gt; &lt;Route path=&quot;groups&quot; component={Groups}/&gt; &lt;Route path=&quot;users&quot; component={Users}/&gt; &lt;/Route&gt; ) class App extends React.Component { render () { return ( &lt;div&gt; {/* 这会是 &lt;Users&gt; 或 &lt;Groups&gt; */} {this.props.children} &lt;/div&gt; ) } } componentsRoute 可以定义一个或多个已命名的组件，当路径匹配到 URL 时， 它们作为 name:component 对的一个对象去渲染。它们可以被 父 route 组件的 this.props[name]渲染。 // 想想路由外部的 context — 如果你可拔插 // `render` 的部分，你可能需要这么做： // &lt;App main={&lt;Users /&gt;} sidebar={&lt;UsersSidebar /&gt;} /&gt; const routes = ( &lt;Route component={App}&gt; &lt;Route path=&quot;groups&quot; components={{main: Groups, sidebar: GroupsSidebar}}/&gt; &lt;Route path=&quot;users&quot; components={{main: Users, sidebar: UsersSidebar}}&gt; &lt;Route path=&quot;users/:userId&quot; component={Profile}/&gt; &lt;/Route&gt; &lt;/Route&gt; ) class App extends React.Component { render () { const { main, sidebar } = this.props return ( &lt;div&gt; &lt;div className=&quot;Main&quot;&gt; {main} &lt;/div&gt; &lt;div className=&quot;Sidebar&quot;&gt; {sidebar} &lt;/div&gt; &lt;/div&gt; ) } } class Users extends React.Component { render () { return ( &lt;div&gt; {/* 当路径是 &quot;/users/123&quot; 是 `children` 会是 &lt;Profile&gt; */} {/* UsersSidebar 也可以获取作为 this.props.children 的 &lt;Profile&gt; ， 所以这有点奇怪，但你可以决定哪一个可以 继续这种嵌套 */} {this.props.children} &lt;/div&gt; ) } } getComponent(location, callback)与 component 一样，但是是异步的，对于 code-splitting 很有用。 callback signaturecb(err, component) &lt;Route path=&quot;courses/:courseId&quot; getComponent={(location, cb) =&gt; { // 做一些异步操作去查找组件 cb(null, Course) }}/&gt; getComponents(location, callback)与 component 一样，但是是异步的，对于 code-splitting 很有用。 callback signaturecb(err, components) &lt;Route path=&quot;courses/:courseId&quot; getComponent={(location, cb) =&gt; { // 做一些异步操作去查找组件 cb(null, {sidebar: CourseSidebar, content: Course}) }}/&gt; childrenRoute 可以被嵌套，this.props.children 包含了从子 route 组件创建的元素。由于这是路由设计中非常重要的部分，请参考 Route 配置。 两个路由钩子：&lt;font color = &quot;red&quot;&gt;onEnter(nextState, replaceState, callback?)&lt;/font&gt; 当 route 即将进入时调用。它提供了下一个路由的 state，一个函数重定向到另一个路径。this 会触发钩子去创建 route 实例。当 callback 作为函数的第三个参数传入时，这个钩子将是异步执行的，并且跳转会阻塞直到 callback 被调用。 &lt;font color = &quot;red&quot;&gt;onLeave()&lt;/font&gt;当 route 即将退出时调用。 PlainRouteroute 定义的一个普通的 JavaScript 对象。 Router 把 JSX 的 &lt;Route&gt; 转化到这个对象中，如果你喜欢，你可以直接使用它们。 所有的 props 都和 &lt;Route&gt; 的 props 一样，除了那些列在这里的。 propschildRoutes子 route 的一个数组，与在 JSX route 配置中的 children 一样。 &lt;font color = &quot;red&quot;&gt;getChildRoutes(location, callback)&lt;/font&gt; 与 childRoutes 一样，但是是异步的，并且可以接收 location。对于 code-splitting 和动态路由匹配很有用（给定一些 state 或 session 数据会返回不同的子 route）。 callback signaturecb(err, routesArray) let myRoute = { path: &#39;course/:courseId&#39;, childRoutes: [ announcementsRoute, gradesRoute, assignmentsRoute ] } // 异步的子 route let myRoute = { path: &#39;course/:courseId&#39;, getChildRoutes(location, cb) { // 做一些异步操作去查找子 route cb(null, [ announcementsRoute, gradesRoute, assignmentsRoute ]) } } // 可以根据一些 state // 跳转到依赖的子 route &lt;Link to=&quot;/picture/123&quot; state={{ fromDashboard: true }}/&gt; let myRoute = { path: &#39;picture/:id&#39;, getChildRoutes(location, cb) { let { state } = location if (state &amp;&amp; state.fromDashboard) { cb(null, [dashboardPictureRoute]) } else { cb(null, [pictureRoute]) } } } indexRouteindex route。这与在使用 JSX route 配置时指定一个 子集一样。 &lt;font color = &quot;red&quot;&gt;getIndexRoute(location, callback)&lt;/font&gt;与 indexRoute 一样，但是是异步的，并且可以接收 location。与 getChildRoutes 一样，对于 code-splitting 和动态路由匹配很有用 callback signaturecb(err, route) // 例如： let myIndexRoute = { component: MyIndex } let myRoute = { path: &#39;courses&#39;, indexRoute: myIndexRoute } // 异步的 index route let myRoute = { path: &#39;courses&#39;, getIndexRoute(location, cb) { // 做一些异步操作 cb(null, myIndexRoute) } } Redirect在应用中 &lt;Redirect&gt; 可以设置重定向到其他 route 而不改变旧的 URL。 Propsfrom你想由哪个路径进行重定向，包括动态段。 to你想重定向的路径。 query默认情况下，query 的参数只会经过，但如果你需要你可以指定它们。 // 我们需要从 `/profile/123` 改变到 `/about/123` // 并且由 `/get-in-touch` 重定向到 `/contact` &lt;Route component={App}&gt; &lt;Route path=&quot;about/:userId&quot; component={UserProfile}/&gt; {/* /profile/123 -&gt; /about/123 */} &lt;Redirect from=&quot;profile/:userId&quot; to=&quot;about/:userId&quot; /&gt; &lt;/Route&gt; 注意，在 route 层 &lt;Redirect&gt; 可以被放在任何地方，尽管正常的优先 规则仍适用。如果你喜欢将下一个重定向到它各自的 route 上，from 的路径会匹配到一个与 path 一样的正常路径。 &lt;Route path=&quot;course/:courseId&quot;&gt; &lt;Route path=&quot;dashboard&quot; /&gt; {/* /course/123/home -&gt; /course/123/dashboard */} &lt;Redirect from=&quot;home&quot; to=&quot;dashboard&quot; /&gt; &lt;/Route&gt; IndexRoute当用户在父 route 的 URL 时， Index Routes 允许你为父 route 提供一个默认的 “child”， 并且为使&lt;IndexLink&gt; 能用提供了约定 ####Props与 Route 的 props 一样，除了 path。 IndexRedirectIndex Redirects 允许你从一个父 route 的 URL 重定向到其他 route。 它们被用于允许子 route 作为父 route 的默认 route， 同时保持着不同的 URL。 Props与 Redirect 的 props 一样，除了 from。 Route Components当 route 匹配到 URL 时会渲染一个 route 的组件。路由会在渲染时将以下属性注入组件中： historyRouter 的 history history。对于跳转很有用的 this.props.history.pushState(state, path, query) location当前的 location。 paramsURL 的动态段。 route渲染组件的 route。 routeParamsthis.props.params 是直接在组件中指定 route 的一个子集。例如，如果 route 的路径是 users/:userId 而 URL 是 /users/123/portfolios/345，那么 this.props.routeParams 会是 {userId: &#39;123&#39;}，并且 this.props.params 会是 {userId: &#39;123&#39;, portfolioId: 345}。 children匹配到子 route 的元素将被渲染。如果 route 有已命名的组件，那么此属性会是 undefined，并且可用的组件会被直接替换到 this.props 上。 示例render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;groups&quot; component={Groups} /&gt; &lt;Route path=&quot;users&quot; component={Users} /&gt; &lt;/Route&gt; &lt;/Router&gt; ), node) class App extends React.Component { render() { return ( &lt;div&gt; {/* 这可能是 &lt;Users&gt; 或 &lt;Groups&gt; */} {this.props.children} &lt;/div&gt; ) } } 已命名的组件当一个 route 有一个或多个已命名的组件时，其子元素的可用性是通过 this.props 命名的。因此 this.props.children 将会是 undefined。那么所有的 route 组件都可以参与嵌套。 示例// 注释里的内容有效，为了解决博客打包未知错误 /*render(( &lt;Router&gt; &lt;Route path=&quot;/&quot; component={App}&gt; &lt;Route path=&quot;groups&quot; components={{main: Groups, sidebar: GroupsSidebar}} /&gt; &lt;Route path=&quot;users&quot; components={{main: Users, sidebar: UsersSidebar}}&gt; &lt;Route path=&quot;users/:userId&quot; component={Profile} /&gt; &lt;/Route&gt; &lt;/Route&gt; &lt;/Router&gt; ), node) class App extends React.Component { render() { // 在父 route 中，被匹配的子 route 变成 props return ( &lt;div&gt; &lt;div className=&quot;Main&quot;&gt; {// 这可能是 &lt;Groups&gt; 或 &lt;Users&gt;} {this.props.main} &lt;/div&gt; &lt;div className=&quot;Sidebar&quot;&gt; {// 这可能是 &lt;GroupsSidebar&gt; 或 &lt;UsersSidebar&gt;} {this.props.sidebar} &lt;/div&gt; &lt;/div&gt; ) } } class Users extends React.Component { render() { return ( &lt;div&gt; {// 如果在 &quot;/users/123&quot; 路径上这会是 &lt;Profile&gt; } {// UsersSidebar 也会获取到作为 this.props.children 的 &lt;Profile&gt; 。 你可以把它放这渲染 } {this.props.children} &lt;/div&gt; ) } }*/ Mixins生命周期在组件中添加一个钩子，当路由要从 route 组件的配置中跳转出来时被调用，并且有机会去取消这次跳转。主要用于表单的部分填写。 在常规的跳转中， routerWillLeave 会接收到一个单一的参数：我们正要跳转的 location。去取消此次跳转，返回 false。 提示用户确认，返回一个提示信息（字符串）。在 web 浏览器 beforeunload 事件发生时，routerWillLeave 不会接收到一个 location 的对象（假设你正在使用 useBeforeUnload history 的增强方法）。在此之上，我们是不可能知道要跳转的 location，因此 outerWillLeave 必须在用户关闭标签之前返回一个提示信息。 生命周期方法routerWillLeave(nextLocation) 当路由尝试从一个 route 跳转到另一个并且渲染这个组件时被调用。 arguments nextLocation - 下一个 location History Mixins在组件中添加路由的 history 对象。常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。 browserHistory(Browser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。) hashHistory(路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path) createMemoryHistory(主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。) 你可以从 React Router 中引入它们： // JavaScript 模块导入（译者注：ES6 形式） import { browserHistory } from &#39;react-router&#39; 然后将它们传递给: render( &lt;Router history={browserHistory} routes={routes} /&gt;, document.getElementById(&#39;app&#39;) ) 实现示例 import React from &#39;react&#39; import { render } from &#39;react-dom&#39; import { browserHistory, Router, Route, IndexRoute } from &#39;react-router&#39; import App from &#39;../components/App&#39; import Home from &#39;../components/Home&#39; import About from &#39;../components/About&#39; import Features from &#39;../components/Features&#39; render( &lt;Router history={browserHistory}&gt; &lt;Route path=&#39;/&#39; component={App}&gt; &lt;IndexRoute component={Home} /&gt; &lt;Route path=&#39;about&#39; component={About} /&gt; &lt;Route path=&#39;features&#39; component={Features} /&gt; &lt;/Route&gt; &lt;/Router&gt;, document.getElementById(&#39;app&#39;) ) 注意：你的 route components 不需要这个 mixin，它在 this.props.history 中已经是可用的了。这是为了组件更深次的渲染树中需要访问路由的 history 对象。 MethodspushState(state, pathname, query)跳转至一个新的 URL。 arguments state - location 的 state。 pathname - 没有 query 完整的 URL。*query - 通过路由字符串化的一个对象。 replaceState(state, pathname, query)在不影响 history 长度的情况下（如一个重定向），用新的 URL 替换当前这个。 参数 state - location 的 state。 pathname - 没有 query 完整的 URL。 query - 通过路由字符串化的一个对象。 go(n)在 history 中后退。 goForward()在 history 中前进。 createPath(pathname, query)使用路由配置，将 query 字符串化加到路径名中。 createHref(pathname, query)使用路由配置，创建一个 URL。例如，它会在 pathname 的前面加上 #/ 给 hash history。 isActive(pathname, query, indexOnly)根据当前路径是否激活返回 true 或 false。通过 pathname 匹配到 route 分支下的每个 route 将会是 true（子 route 是激活的情况下，父 route 也是激活的），除非 indexOnly 已经指定了，在这种情况下，它只会匹配到具体的路径。参数 pathname - 没有 query 完整的 URL。 query - 如果没有指定，那会是一个包含键值对的对象，并且在当前的 query 中是激活状态的 - 在当前的 query 中明确是 undefined 的值会丢失相应的键或 undefined*indexOnly - 一个 boolean（默认：false）。 示例import { History } from &#39;react-router&#39; React.createClass({ mixins: [ History ], render() { return ( &lt;div&gt; &lt;div onClick={() =&gt; this.history.pushState(null, &#39;/foo&#39;)}&gt;Go to foo&lt;/div&gt; &lt;div onClick={() =&gt; this.history.replaceState(null, &#39;bar&#39;)}&gt;Go to bar without creating a new history entry&lt;/div&gt; &lt;div onClick={() =&gt; this.history.goBack()}&gt;Go back&lt;/div&gt; &lt;/div&gt; ) } }) 在应用中少数组件由于 History mixin 的缘故而用得不爽，此时有以下几个选项： 让 this.props.history 通过 route 组件到达需要它的组件中。 使用 context import { PropTypes } from &#39;react-router&#39; class MyComponent extends React.Component { doStuff() { this.context.history.pushState(null, &#39;/some/path&#39;) } } MyComponent.contextTypes = { history: PropTypes.history } 确保你的 history 是一个 module 创建一个高阶的组件，我们可能用它来结束跳转和阻止 history，只是没有时间去思考所有的方法。 function connectHistory(Component) { return React.createClass({ mixins: [ History ], render() { return &lt;Component {...this.props} history={this.history} /&gt; } }) } // 其他文件 import connectHistory from &#39;./connectHistory&#39; class MyComponent extends React.Component { doStuff() { this.props.history.pushState(null, &#39;/some/where&#39;) } } export default connectHistory(MyComponent) RouteContext MixinsRouteContext mixin 提供了一个将 route 组件设置到 context 中的便捷方法。这对于 route 渲染元素并且希望用 生命周期 mixin 来阻止跳转是很有必要的。 简单地将 this.context.route 添加到组件中。 表单处理Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？ 下面是一个表单。 &lt;form onSubmit={this.handleSubmit}&gt; &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt; &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt; &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt; &lt;/form&gt; 第一种方法是使用browserHistory.push import { browserHistory } from &#39;react-router&#39; // ... handleSubmit(event) { event.preventDefault() const userName = event.target.elements[0].value const repo = event.target.elements[1].value const path = `/repos/${userName}/${repo}` browserHistory.push(path) }, 第二种方法是使用context对象。 export default React.createClass({ // ask for `router` from context contextTypes: { router: React.PropTypes.object }, handleSubmit(event) { // ... this.context.router.push(path) }, }) UtilitiesuseRoutes(createHistory)返回一个新的 createHistory 函数，它可以用来创建读取 route 的 history 对象。 listen((error, nextState) =&gt; {}) listenBeforeLeavingRoute(route, (nextLocation) =&gt; {}) (location, (error, redirectLocation, nextState) =&gt; {}) isActive(pathname, query, indexOnly=false) matchmatch(location, cb)这个函数被用于服务端渲染。它在渲染之前会匹配一组 route 到一个 location，并且在完成时调用 callback(error, redirectLocation, renderProps)。 传给回调函数去 match 的三个参数如下： error：如果报错时会出现一个 Javascript 的 Error 对象，否则是 undefined。 redirectLocation：如果 route 重定向时会有一个 Location 对象，否则是 undefined。 renderProps：当匹配到 route 时 props 应该通过路由的 context，否则是 undefined。 如果这三个参数都是 undefined，这就意味着在给定的 location 中没有 route 被匹配到。 &lt;font color = &quot;red&quot;r&gt;注意：你可能不想在浏览器中用它，除非你做的是异步 route 的服务端渲染。&lt;/font&gt; createRoutes(routes)创建并返回一个从给定对象 route 的数组，它可能是 JSX 的 route，一个普通对象的 route，或是其他的数组。 paramsroutes一个或多个的 Route 或 PlainRoute。 更多资源react-router中文文档阮一峰React-router]]></content>
      <categories>
        <category>React-router</category>
      </categories>
      <tags>
        <tag>React-router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你还在用for循环大法吗？]]></title>
    <url>%2F2018%2F03%2F07%2FJs%2F%E4%BD%A0%E8%BF%98%E5%9C%A8%E7%94%A8for%E5%BE%AA%E7%8E%AF%E5%A4%A7%E6%B3%95%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[文章主要介绍了数组Array.prototype方法的使用，需要的朋友可以参考下，如果你是大神，请直接无视。 在ES5中，一共有9个Array方法 http://kangax.github.io/compat-table/es5/ Array.prototype.indexOf Array.prototype.lastIndexOf Array.prototype.every Array.prototype.some Array.prototype.forEach Array.prototype.map Array.prototype.filter Array.prototype.reduce Array.prototype.reduceRight 在ES6即将普及的时代，我相信这些方法对FE开发者是非常实用的必备技能，接下来我将通过实例帮大家替换for循环大法，更高效的来操作数组。 indexOfindexOf()方法返回在该数组中第一个找到的元素位置，如果它不存在则返回-1。 使用for： ar arr = [&#39;apple&#39;,&#39;orange&#39;,&#39;pear&#39;], found = false; for(var i= 0, l = arr.length; i&lt; l; i++){ if(arr[i] === &#39;orange&#39;){ found = true; } } console.log(&quot;found:&quot;,found); 使用indexOf： var arr = [&#39;apple&#39;,&#39;orange&#39;,&#39;pear&#39;]; console.log(&quot;found:&quot;, arr.indexOf(&quot;orange&quot;) != -1); lastindexOfastIndexOf() 方法返回在该数组中最后一个找到的元素位置，和 indexof相反。 every()every()可是检测数组中的每一项是否符合条件 使用for： /* * 是否全部大于0 */ var ary = [12,23,24,42,1]; var result = function(){ for (var i = 0; i &lt; ary.length; i++) { if(ary[i] &lt; 0){ return false; } } return true; //需全部满足 } console.log(result()) //全部满足,返回true 使用every： var ary = [12,23,24,42,1]; var result = ary.every(function(item, index){ return item &gt; 0 }) console.log(result) some()some()可以检测数组中是否有某一项符合条件 使用for /* * 是否存在小于0的项 */ var ary = [12,23,-24,42,1]; var result = function(){ for (var i = 0; i &lt; ary.length; i++) { if(ary[i] &lt; 0){ return true; } } return false; //只需满足一个 } console.log(result()) //有一项小于0，返回true 使用some var ary = [12,23,-24,42,1]; var result = ary.some(function(item, index){ return item &lt; 0 }) console.log(result) forEach()forEach为每个元素执行对应的方法 使用for： var arr = [1,2,3,4,5,6,7,8]; for(var i= 0, l = arr.length; i&lt; l; i++){ console.log(arr[i]); } 使用forEach()： var arr = [1,2,3,4,5,6,7,8]; arr.forEach(function(item,index){ console.log(item); }); forEach是用来替换for循环的 map()map()对数组的每个元素进行一定操作（映射）后，会返回一个新的数组， 使用for： var oldArr = [{first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;},{first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;},{first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;}]; function getNewArr(){ var newArr = []; for(var i= 0, l = oldArr.length; i&lt; l; i++){ var item = oldArr[i]; item.full_name = [item.first_name,item.last_name].join(&quot; &quot;); newArr[i] = item; } return newArr; } console.log(getNewArr()); 使用map： var oldArr = [{first_name:&quot;Colin&quot;,last_name:&quot;Toh&quot;},{first_name:&quot;Addy&quot;,last_name:&quot;Osmani&quot;},{first_name:&quot;Yehuda&quot;,last_name:&quot;Katz&quot;}]; function getNewArr(){ return oldArr.map(function(item,index){ item.full_name = [item.first_name,item.last_name].join(&quot; &quot;); return item; }); } console.log(getNewArr()); map()是处理服务器返回数据时是一个非常实用的函数。 forEach 与map的区别： 语法：forEach和map都支持2个参数：一个是回调函数（item,index,list）和上下文； forEach：用来遍历数组中的每一项；这个方法执行是没有返回值的，对原来数组也没有影响；数组中有几项，那么传递进去的匿名回调函数就需要执行几次；每一次执行匿名函数的时候，还给其传递了三个参数值：数组中的当前项item,当前项的索引index,原始数组list；理论上这个方法是没有返回值的，仅仅是遍历数组中的每一项，不对原来数组进行修改；但是我们可以自己通过数组的索引来修改原来的数组； forEach方法中的this是ary,匿名回调函数中的this默认是window； var ary = [12,23,24,42,1]; var res = ary.forEach(function (item,index,input) { input[index] = item*10; }) console.log(res);//--&gt;undefined; console.log(ary);//--&gt;会对原来的数组产生改变； map： 和forEach非常相似，都是用来遍历数组中的每一项值的，用来遍历数组中的每一项； 区别：map的回调函数中支持return返回值；return的是啥，相当于把数组中的这一项变为啥（并不影响原来的数组，只是相当于把原数组克隆一份，把克隆的这一份的数组中的对应项改变了）； 不管是forEach还是map 都支持第二个参数值，第二个参数的意思是把匿名回调函数中的this进行修改。 var ary = [12,23,24,42,1]; var res = ary.map(function (item,index,input) { return item*10; }) console.log(res);//--&gt;[120,230,240,420,10]; console.log(ary);//--&gt;[12,23,24,42,1]； filter该filter()方法创建一个新的匹配过滤条件的数组。使用for： var arr = [ {&quot;name&quot;:&quot;apple&quot;, &quot;count&quot;: 2}, {&quot;name&quot;:&quot;orange&quot;, &quot;count&quot;: 5}, {&quot;name&quot;:&quot;pear&quot;, &quot;count&quot;: 3}, {&quot;name&quot;:&quot;orange&quot;, &quot;count&quot;: 16}, ]; var newArr = []; for(var i= 0, l = arr.length; i&lt; l; i++){ if(arr[i].name === &quot;orange&quot; ){ newArr.push(arr[i]); } } console.log(&quot;Filter results:&quot;,newArr); 使用 filter()： var arr = [ {&quot;name&quot;:&quot;apple&quot;, &quot;count&quot;: 2}, {&quot;name&quot;:&quot;orange&quot;, &quot;count&quot;: 5}, {&quot;name&quot;:&quot;pear&quot;, &quot;count&quot;: 3}, {&quot;name&quot;:&quot;orange&quot;, &quot;count&quot;: 16}, ]; var newArr = arr.filter(function(item){ return item.name === &quot;orange&quot;; }); console.log(&quot;Filter results:&quot;,newArr); reduce()reduce()可以实现一个累加器的功能，将数组的每个值（从左到右）将其降低到一个值。 说实话刚开始理解这句话有点难度，它太抽象了。 场景： 统计一个数组中有多少个不重复的单词使用for： var arr = [&quot;apple&quot;,&quot;orange&quot;,&quot;apple&quot;,&quot;orange&quot;,&quot;pear&quot;,&quot;orange&quot;]; function getWordCnt(){ var obj = {}; for(var i= 0, l = arr.length; i&lt; l; i++){ var item = arr[i]; obj[item] = (obj[item] +1 ) || 1; } return obj; } console.log(getWordCnt()); 让我先解释一下我自己对reduce的理解。reduce(callback, initialValue)会传入两个变量。回调函数(callback)和初始值(initialValue)。假设函数它有个传入参数，prev和next,index和array。prev和next你是必须要了解的。一般来讲prev是从数组中第一个元素开始的，next是第二个元素。但是当你传入初始值(initialValue)后，第一个prev将是initivalValue，next将是数组中的第一个元素。 /* * 二者的区别，在console中运行一下即可知晓 */ var arr = [&quot;apple&quot;,&quot;orange&quot;]; function noPassValue(){ return arr.reduce(function(prev,next){ console.log(&quot;prev:&quot;,prev); console.log(&quot;next:&quot;,next); return prev + &quot; &quot; +next; }); } function passValue(){ return arr.reduce(function(prev,next){ console.log(&quot;prev:&quot;,prev); console.log(&quot;next:&quot;,next); prev[next] = 1; return prev; },{}); } console.log(&quot;No Additional parameter:&quot;,noPassValue()); console.log(&quot;----------------&quot;); console.log(&quot;With {} as an additional parameter:&quot;,passValue()); reduceRight() reduceRight的语法以及回调函数的规则和reduce方法是一样的，区别就是在与reduce是升序，即角标从0开始，而reduceRight是降序，即角标从arr.length-1开始。 方法可应用于字符串。 /* * 使用此方法反转字符串中的字符 */ var word = &quot;retupmoc&quot;; function AppendToArray(previousValue, currentValue) { return previousValue + currentValue; } var result = [].reduceRight.call(word, AppendToArray, &quot;the &quot;); console.log(result); // the computer isArray()isArray()是Array对象的一个静态函数，用来判断一个对象是不是数组 var ary1 = []; var res1 = Array.isArray(ary1); // Output: true console.log(res1) var ary2 = new Array(); var res2 = Array.isArray(ary2); // Output: true console.log(res2) var ary3 = [1, 2, 3]; var res3 = Array.isArray(ary3); // Output: true console.log(res3) var ary4 = new Date(); var res4 = Array.isArray(ary4); // Output: false console.log(res4) 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flex和grid布局]]></title>
    <url>%2F2018%2F03%2F06%2FCSS3%2Fflex%E5%92%8Cgrid%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[网页布局（layout）是 CSS 的一个重点应用。 布局的传统解决方案，基于盒状模型，依赖 display 属性 + position属性 + float属性。它对于那些特殊布局非常不方便，比如，垂直居中就不容易实现。 Flex 布局2009年，W3C 提出了一种新的方案—-Flex 布局，可以简便、完整、响应式地实现各种页面布局。目前，它已经得到了所有浏览器的支持，这意味着，现在就能很安全地使用这项功能。 原文地址Demo地址 容器属性flex-direction属性flex-direction属性决定主轴的方向（即项目的排列方向）。 .box{ flex-direction: row | row-reverse | column | column-reverse } row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿。 flex-wrap属性默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。 .box{ flex-wrap: nowrap | wrap | wrap-reverse; } nowrap（默认）：不换行。wrap：换行，第一行在上方。wrap-reverse：换行，第一行在下方。 flex-flow属性flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。 .box { flex-flow: &lt;flex-direction&gt; || &lt;flex-wrap&gt;; } justify-content属性justify-content属性定义了项目在主轴上的对齐方式。 .box { justify-content: flex-start | flex-end | center | space-between | space-around; } flex-start（默认值）：左对齐flex-end：右对齐center： 居中space-between：两端对齐，项目之间的间隔都相等。space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性align-items属性定义项目在交叉轴上如何对齐 .box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：交叉轴的起点对齐。flex-end：交叉轴的终点对齐。center：交叉轴的中点对齐。baseline: 项目的第一行文字的基线对齐。stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-centet属性align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 .box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start：与交叉轴的起点对齐。flex-end：与交叉轴的终点对齐。center：与交叉轴的中点对齐。space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。stretch（默认值）：轴线占满整个交叉轴。 项目属性以下设置在项目上。 order属性order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。 .item { order: &lt;integer&gt;; } flex-grow属性flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。 .item { flex-grow: &lt;number&gt;; /* default 0 */ } 如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。 flex-shrink属性flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。 .item { flex-shrink: &lt;number&gt;; /* default 1 */ } 如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。 负值对该属性无效。 flex-basis属性flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。 .item { flex-basis: &lt;length&gt; | auto; /* default auto */ } 它可以设为跟width或height属性一样的值（比如350px），则项目将占据固定空间。 flex属性flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 .item { flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ] } 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 align-self属性align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch .item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } 该属性可能取6个值，除了auto，其他都与align-items属性完全一致。 Grid布局原文地址 Grid 布局是网站设计的基础，CSS Grid 是创建网格布局最强大和最简单的工具。 CSS Grid 今年也获得了主流浏览器（Safari，Chrome，Firefox，Edge）的原生支持，所以我相信所有的前端开发人员都必须在不久的将来学习这项技术。 CSS Grid(网格) 布局（又称为 “Grid(网格)” ），是一个二维的基于网格的布局系统它的目标是完全改变我们基于网格的用户界面的布局方式。CSS 一直用来布局我们的网页，但一直以来都存在这样或那样的问题。一开始我们用表格（table），然后是浮动（float），再是定位（postion）和内嵌块（inline-block），但是所有这些方法本质上都是只是 hack 而已，并且遗漏了很多重要的功能（例如垂直居中）。Flexbox 的出现很大程度上改善了我们的布局方式，但它的目的是为了解决更简单的一维布局，而不是复杂的二维布局（实际上 Flexbox 和 Grid 能结合在一起工作，而且配合得非常好）。Grid(网格) 布局是第一个专门为解决布局问题而创建的 CSS 模块，我们终于不需要想尽办法hack 页面布局样式了。 网格容器(Grid Container)应用 display: grid 的元素。这是所有网格项（Grid Items）的直接父级元素。在这个例子中，container 就是 网格容器(Grid Container)。 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item item-1&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item-2&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item item-3&quot;&gt;&lt;/div&gt; &lt;/div&gt; display grid ：生成一个块级网格inline-grid ：生成一个内联网格subgrid ：如果你的网格容器本身是另一个网格的网格项（即嵌套网格），你可以使用这个属性来表示 你希望它的行/列的大小继承自它的父级网格容器，而不是自己指定的。 如果你想要设置为网格容器元素本身已经是网格项（嵌套网格布局），用这个属性指明这个容器内部的网格项的行列尺寸直接继承其父级的网格容器属性。 .container { display: grid | inline-grid | subgrid; } 注意：在网格容器(Grid Container) 上使用column，float，clear， vertical-align不会产生任何效果。 grid-template-columns / grid-template-rows使用空格分隔的值列表，用来定义网格的列和行。这些值表示 网格轨道(Grid Track) 大小，它们之间的空格表示网格线。 值：– ： 可以是长度值，百分比，或者等份网格容器中可用空间（使用 fr 单位）– ：你可以选择的任意名称 .container { grid-template-columns: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; grid-template-rows: &lt;track-size&gt; ... | &lt;line-name&gt; &lt;track-size&gt; ...; } 示例： .container{ grid-template-columns: 40px 50px auto 50px 40px; grid-template-rows: 25% 100px auto; } 但是你可以明确的指定网格线(Grid Line)名称，即 值。请注意网格线名称的括号语法： .container { grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]; grid-template-rows: [row1-start] 25% [row1-end] 100px [third-line] auto [last-line]; } 请注意，一条网格线(Grid Line)可以有多个名称。例如，这里的第二条 行网格线(row grid lines) 将有两个名字：row1-end 和row2-start ： .container{ grid-template-rows: [row1-start] 25% [row1-end row2-start] 25% [row2-end]; } 如果你的定义包含多个重复值，则可以使用 repeat() 表示法来简化定义： .container { grid-template-columns: repeat(3, 20px [col-start]) 5%; } //等价于 .container { grid-template-columns: 20px [col-start] 20px [col-start] 20px [col-start] 5%; } fr 单元允许你用等分网格容器剩余可用空间来设置 网格轨道(Grid Track) 的大小 。例如，下面的代码会将每个网格项设置为网格容器宽度的三分之一： .container { grid-template-columns: 1fr 1fr 1fr; } 剩余可用空间是除去所有非灵活网格项之后计算得到的。在这个例子中，可用空间总量减去 50px 后，再给 fr 单元的值3等分： .container { grid-template-columns: 1fr 50px 1fr 1fr; } grid-template-areas通过引用 grid-area 属性指定的 网格区域(Grid Area) 名称来定义网格模板。重复网格区域的名称导致内容跨越这些单元格。一个点号（.）代表一个空的网格单元。这个语法本身可视作网格的可视化结构。 ：由网格项的 grid-area 指定的网格区域名称.（点号） ：代表一个空的网格单元none：不定义网格区域 .container { grid-template-areas: &quot; | . | none | ...&quot; &quot;...&quot;; } 示例： .item-a { grid-area: header; } .item-b { grid-area: main; } .item-c { grid-area: sidebar; } .item-d { grid-area: footer; } .container { grid-template-columns: 50px 50px 50px 50px; grid-template-rows: auto; grid-template-areas: &quot;header header header header&quot; &quot;main main . sidebar&quot; &quot;footer footer footer footer&quot;; } 上面的代码将创建一个 4 列 3 行的网格。整个顶行将由 header 区域 组成。中间一排将由两个 main 区域，一个是空单元格，一个 sidebar 区域组成。最后一行全是 footer 区域组成。 你可以使用任意数量的相邻的 点. 来声明单个空单元格。 只要这些点.之间没有空隙隔开，他们就表示一个单一的单元格。 grid-template用于定义 grid-template-rows，grid-template-columns ，grid-template-areas 缩写 (shorthand) 属性。 none：将所有三个属性设置为其初始值subgrid：将grid-template-rows，grid-template-columns 的值设为 subgrid，grid-template-areas设为初始值 / ：将 grid-template-columns 和 grid-template-rows 设置为相应地特定的值，并且设置grid-template-areas为none .container { grid-template: none | subgrid | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt;; } 示例： .container { grid-template: [row1-start] &quot;header header header&quot; 25px [row1-end] [row2-start] &quot;footer footer footer&quot; 25px [row2-end] / auto 50px auto; } //等价于 .container { grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; grid-template-areas: &quot;header header header&quot; &quot;footer footer footer&quot;; } 由于 grid-template 不会重置 隐式 网格属性（grid-auto-columns， grid-auto-rows， 和 grid-auto-flow），这可能是你想在大多数情况下做的，建议使用grid 属性 而不是grid-template。 grid-column-gap / grid-row-gap指定网格线(grid lines)的大小。你可以把它想象为设置列/行之间间距的宽度。 ：长度值 .container { grid-column-gap: &lt;line-size&gt;; grid-row-gap: &lt;line-size&gt;; } 示例： .container { grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-column-gap: 10px; grid-row-gap: 15px; } 只能在 列/行 之间创建间距，网格外部边缘不会有这个间距。 grid-gapgrid-column-gap 和 grid-row-gap的缩写语法 ：长度值 .container { grid-gap: &lt;grid-row-gap&gt; &lt;grid-column-gap&gt;; } 示例:如果grid-row-gap没有定义，那么就会被设置为等同于 grid-column-gap 的值。例如下面的代码是等价的： .container{ grid-template-columns: 100px 50px 100px; grid-template-rows: 80px auto 80px; grid-gap: 10px 15px; } //等价于 .container{ /* 设置 [`grid-column-gap`](http://www.css88.com/archives/8510#prop-grid-column-row-gap) 和 [`grid-row-gap`](http://www.css88.com/archives/8510#prop-grid-column-row-gap) */ grid-column-gap: 10px; grid-column-gap: 10px; /* 等价于 */ grid-gap: 10px 10px; /* 等价于 */ grid-gap: 10px; } justify-items沿着 行轴线(row axis) 对齐 网格项(grid items) 内的内容（相反的属性是 align-items 沿着列轴线对齐）。该值适用于容器内的所有网格项。 start：将内容对齐到网格区域(grid area)的左侧end：将内容对齐到网格区域的右侧center：将内容对齐到网格区域的中间（水平居中）stretch：填满网格区域宽度（默认值） .container { justify-items: start | end | center | stretch; } align-items沿着 列轴线(column axis) 对齐 网格项(grid items) 内的内容（相反的属性是 justify-items 沿着行轴线对齐）。该值适用于容器内的所有网格项。 start：将内容对齐到网格区域(grid area)的顶部end：将内容对齐到网格区域的底部center：将内容对齐到网格区域的中间（垂直居中）stretch：填满网格区域高度（默认值） .container { align-items: start | end | center | stretch; } justify-content有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 px 这样的非灵活单位设置大小，在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 行轴线(row axis) 对齐网格（相反的属性是 align-content ，沿着列轴线对齐网格）。 start：将网格对齐到 网格容器(grid container) 的左边end：将网格对齐到 网格容器 的右边center：将网格对齐到 网格容器 的中间（水平居中）stretch：调整 网格项(grid items) 的宽度，允许该网格填充满整个 网格容器 的宽度space-around：在每个网格项之间放置一个均匀的空间，左右两端放置一半的空间space-between：在每个网格项之间放置一个均匀的空间，左右两端没有空间space-evenly：在每个栅格项目之间放置一个均匀的空间，左右两端放置一个均匀的空间 .container { justify-content: start | end | center | stretch | space-around | space-between | space-evenly; } align-content有时，你的网格合计大小可能小于其 网格容器(grid container) 大小。 如果你的所有 网格项(grid items) 都使用像 px 这样的非灵活单位设置大小，在这种情况下，您可以设置网格容器内的网格的对齐方式。 此属性沿着 列轴线(column axis) 对齐网格（相反的属性是 justify-content ，沿着行轴线对齐网格）。 start：将网格对齐到 网格容器(grid container) 的顶部end：将网格对齐到 网格容器 的底部center：将网格对齐到 网格容器 的中间（垂直居中）stretch：调整 网格项(grid items) 的高度，允许该网格填充满整个 网格容器 的高度space-around：在每个网格项之间放置一个均匀的空间，上下两端放置一半的空间space-between：在每个网格项之间放置一个均匀的空间，上下两端没有空间space-evenly：在每个栅格项目之间放置一个均匀的空间，上下两端放置一个均匀的空间 .container { align-content: start | end | center | stretch | space-around | space-between | space-evenly; } grid-auto-columns / grid-auto-rows指定任何自动生成的网格轨道(grid tracks)（又名隐式网格轨道）的大小。在你明确定位的行或列（通过 grid-template-rows / grid-template-columns），超出定义的网格范围时，隐式网格轨道被创建了。 ：可以是长度值，百分比，或者等份网格容器中可用空间（使用 fr 单位） .container { grid-auto-columns: &lt;track-size&gt; ...; grid-auto-rows: &lt;track-size&gt; ...; } 为了说明如何创建隐式网格轨道，请考虑一下以下的代码： .container { grid-template-columns: 60px 60px; grid-template-rows: 90px 90px } 但现在想象一下，你使用 grid-column 和 grid-row 来定位你的网格项（grid items），像这样： .item-a { grid-column: 1 / 2; grid-row: 2 / 3; } .item-b { grid-column: 5 / 6; grid-row: 2 / 3; } 因为我们引用的网格线不存在，所以创建宽度为 0 的隐式网格轨道以填补空缺。我们可以使用 grid-auto-columns 和 grid-auto-rows 来指定这些隐式轨道的大小： .container { grid-auto-columns: 60px; } grid-auto-flow如果你有一些没有明确放置在网格上的网格项(grid items)，自动放置算法 会自动放置这些网格项。该属性控制自动布局算法如何工作。 row：告诉自动布局算法依次填充每行，根据需要添加新行column：告诉自动布局算法依次填入每列，根据需要添加新列dense：告诉自动布局算法在稍后出现较小的网格项时，尝试填充网格中较早的空缺 .container { grid-auto-flow: row | column | row dense | column dense } grid在一个声明中设置所有以下属性的简写： grid-template-rows, grid-template-columns, grid-template-areas, grid-auto-rows, grid-auto-columns, 和 grid-auto-flow 。它还将grid-column-gap 和 grid-column-gap设置为初始值，即使它们不可以通过grid属性显式地设置。 none：将所有子属性设置为其初始值 / ：将 grid-template-rows 和 grid-template-columns 分别设置为指定值，将所有其他子属性设置为其初始值 [ [ / ] ] ：分别接受所有与 grid-auto-flow ，grid-auto-rows 和 grid-auto-columns 相同的值。如果省略了 grid-auto-columns ，它被设置为由 grid-auto-rows 指定的值。如果两者都被省略，他们就会被设置为初始值 .container { grid: none | &lt;grid-template-rows&gt; / &lt;grid-template-columns&gt; | &lt;grid-auto-flow&gt; [&lt;grid-auto-rows&gt; [/ &lt;grid-auto-columns&gt;]]; } 示例： .container { grid: 200px auto / 1fr auto 1fr; } //等价于 .container { grid-template-rows: 200px auto; grid-template-columns: 1fr auto 1fr; grid-template-areas: none; } .container { grid: column 1fr / auto; } //等价于 .container { grid-auto-flow: column; grid-auto-rows: 1fr; grid-auto-columns: auto; } 它也接受一个更复杂但相当方便的语法来一次设置所有内容。您可以 grid-template-areas，grid-template-rows和grid-template-columns，并所有其他的子属性都被设置为它们的初始值。这么做可以在它们网格区域内相应地指定网格线名字和网格轨道的大小。用最简单的例子来描述： .container { grid: [row1-start] &quot;header header header&quot; 1fr [row1-end] [row2-start] &quot;footer footer footer&quot; 25px [row2-end] / auto 50px auto; } //等价于 .container { grid-template-areas: &quot;header header header&quot; &quot;footer footer footer&quot;; grid-template-rows: [row1-start] 1fr [row1-end row2-start] 25px [row2-end]; grid-template-columns: auto 50px auto; } 网格项(Grid Item)网格容器（Grid Container）的子元素（例如直接子元素）。这里 item 元素就是网格项(Grid Item)，但是 sub-item 不是。 &lt;div class=&quot;container&quot;&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;div class=&quot;item&quot;&gt; &lt;p class=&quot;sub-item&quot;&gt;&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;item&quot;&gt;&lt;/div&gt; &lt;/div&gt; grid-column-start / grid-column-end / grid-row-start / grid-row-end通过指定 网格线(grid lines) 来确定网格内 网格项(grid item) 的位置。 grid-column-start / grid-row-start 是网格项目开始的网格线，grid-column-end / grid-row-end 是网格项结束的网格线。 ：可以是一个数字引用一个编号的网格线，或者一个名字来引用一个命名的网格线span ：该网格项将跨越所提供的网格轨道数量span ：该网格项将跨越到它与提供的名称位置auto ：表示自动放置，自动跨度，默认会扩展一个网格轨道的宽度或者高度 .item { grid-column-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-column-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-start: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto grid-row-end: &lt;number&gt; | &lt;name&gt; | span &lt;number&gt; | span &lt;name&gt; | auto } 示例： .item-a { grid-column-start: 2; grid-column-end: five; grid-row-start: row1-start grid-row-end: 3 } .item-b { grid-column-start: 1; grid-column-end: span col4-start; grid-row-start: 2 grid-row-end: span 2 } 如果没有声明指定 grid-column-end / grid-row-end，默认情况下，该网格项将占据1个轨道。 项目可以相互重叠。您可以使用 z-index 来控制它们的重叠顺序。 grid-column / grid-row分别为 grid-column-start + grid-column-end 和 grid-row-start + grid-row-end 的缩写形式。 / ：每个网格项都接受所有相同的值，作为普通书写的版本，包括跨度 .item { grid-column: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;; grid-row: &lt;start-line&gt; / &lt;end-line&gt; | &lt;start-line&gt; / span &lt;value&gt;; } 示例： .item-c { grid-column: 3 / span 2; grid-row: third-line / 4; } 如果没有声明分隔线结束位置，则该网格项默认占据 1 个网格轨道。 grid-area为网格项提供一个名称，以便可以 被使用网格容器 grid-template-areas 属性创建的模板进行引用。 另外，这个属性可以用作grid-row-start + grid-column-start + grid-row-end + grid-column-end 的缩写。 ：你所选的名称 / / / ：数字或分隔线名称 .item { grid-area: &lt;name&gt; | &lt;row-start&gt; / &lt;column-start&gt; / &lt;row-end&gt; / &lt;column-end&gt;; } justify-self沿着 行轴线(row axis) 对齐 网格项 内的内容（ 相反的属性是 align-self ，沿着列轴线(column axis)对齐）。此值适用于单个网格项内的内容。 start：将内容对齐到网格区域的左侧end：将内容对齐到网格区域的右侧center：将内容对齐到网格区域的中间（水平居中）stretch：填充整个网格区域的宽度（这是默认值） 示例： .item-a { justify-self: start; } align-self沿着 列轴线(column axis) 对齐 网格项 内的内容（ 相反的属性是 justify-self ，沿着 行轴线(row axis) 对齐）。此值适用于单个网格项内的内容。 start：将内容对齐到网格区域的顶部end：将内容对齐到网格区域的底部center：将内容对齐到网格区域的中间（垂直居中）stretch：填充整个网格区域的高度（这是默认值） .item{ align-self: start | end | center | stretch; } 要为网格中的所有网格项设置 列轴线(column axis) 上的对齐方式，也可以在 网格容器 上设置 align-items 属性。 网格线(Grid Line)构成网格结构的分界线。它们既可以是垂直的（“列网格线(column grid lines)”），也可以是水平的（“行网格线(row grid lines)”），并位于行或列的任一侧。例如，这里的黄线就是一条列网格线。 网格轨道(Grid Track)两条相邻网格线之间的空间。你可以把它们想象成网格的列或行。下图是第二条和第三条 行网格线 之间的 网格轨道(Grid Track)。 网格单元格(Grid Cell)两个相邻的行和两个相邻的列网格线之间的空间。这是 Grid(网格) 系统的一个“单元”。下图是第1至第2条 行网格线 和第2至第3条 列网格线 交汇构成的 网格单元格(Grid Cell)。 网格区域(Grid Area)4条网格线包围的总空间。一个 网格区域(Grid Area) 可以由任意数量的 网格单元格(Grid Cell) 组成。下图是 行网格线1和3，以及列网格线1和3 之间的网格区域。 更多关于 CSS Grid 布局的优秀文章5分钟学会 CSS Grid 布局CSS Grid 布局完全指南(图解 Grid 详细教程)如何使用 CSS Grid 快速而又灵活的布局]]></content>
      <categories>
        <category>Css3</category>
      </categories>
      <tags>
        <tag>Css3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[看漫画，学习Redux]]></title>
    <url>%2F2018%2F03%2F05%2FReact%2FRedux%2F%E7%9C%8B%E6%BC%AB%E7%94%BB%EF%BC%8C%E5%AD%A6%E4%B9%A0Redux%2F</url>
    <content type="text"><![CDATA[React 只是 DOM 的一个抽象层，并不是 Web 应用的完整解决方案。有两个方面，它没涉及。 代码结构 组件之间的通信 对于大型的复杂应用来说，这两方面恰恰是最关键的。因此，只用 React 没法写大型应用。 为了解决这个问题，2014年 Facebook 提出了Flux架构的概念，引发了很多的实现。2015年，Redux 出现，将 Flux 与函数式编程结合一起，很短时间内就成为了最热门的前端架构。 Redux 的设计思想很简单，就两句话。 （1）Web 应用是一个状态机，视图与状态是一一对应的。 （2）所有的状态，保存在一个对象里面。 Flux 架构已然让人觉得有些迷惑，而比 Flux 更让人摸不着头脑的是 Flux 与 Redux 的区别。Redux 是一个基于 Flux 思想的新架构方式，本文将探讨它们的区别。 为什么要改变 Flux？Redux 解决的问题和 Flux 一样，但 Redux 能做的还有更多。和 Flux 一样，Redux 让应用的状态变化变得更加可预测。如果你想改变应用的状态，就必须 dispatch 一个 action。你没有办法直接改变应用的状态，因为保存这些状态的东西（称为 store）只有 getter 而没有 setter。对于 Flux 和 Redux 来说，这些概念都是相似的。 那么为什么要新设计一种架构呢？Redux 的创造者 Dan Abramov 发现了改进 Flux 架构的可能。他想要一个更好的开发者工具来调试 Flux 应用。他发现如果稍微对 Flux 架构进行一些调整，就可以开发出一款更好用的开发者工具，同时依然能享受 Flux 架构带给你的可预测性。 确切的说，他想要的开发者工具包含了代码热替换（hot reload）和时间旅行（time travel）功能。然而要想在 Flux 架构上实现这些功能，确实有些麻烦。 问题1：store 的代码无法被热替换，除非清空当前的状态在 Flux 中，store 包含了两样东西： 改变状态的逻辑 当前的状态 在一个 store 中同时保存这两样东西将会导致代码热替换功能出现问题。当你热替换掉 store 的代码想要看看新的状态改变逻辑是否生效时，你就丢失了 store 中保存的当前状态。此外，你还把 store 与 Flux 架构中其它组件产生关系的事件系统搞乱了。 解决方案 将这两样东西分开处理。让一个对象来保存状态，这个对象在热替换代码的时候不会受到影响。让另一个对象包含所有改变状态的逻辑，这个对象可以被热替换因为它不用关心任何保存状态相关的事情。 问题2：每次触发 action 时状态对象都被直接改写了时间旅行调试法的特性是：你能掌握状态对象的每一次变化，这样的话，你就能轻松的跳回到这个对象之前的某个状态（想象一个撤销功能）。 要实现这样的功能，每次状态改变之后，你都需要把旧的状态保存在一个数组中。但是由于 JavaScript 的对象引用特性，简单的把一个对象放进数组中并不能实现我们需要的功能。这样做不能创建一个快照（snapshot），而只是创建了一个新的指针指向同一个对象。 所以要想实现时间旅行特性，每一个状态改变的版本都需要保存在不同的 JavaScript 对象中，这样你才不会不小心改变了某个历史版本的状态。 解决方案 当一个 action 需要 store 响应时，不要直接修改 store 中的状态，而是将状态拷贝一份并在这份拷贝的状态上做出修改。 问题3：没有合适的位置引入第三方插件当你在写一些调试性工具时，你希望它们能够更加通用。一个使用该工具的用户应该可以直接引入这个工具而不需要做额外的包装或桥接。 要实现这样的特性，Flux 架构需要一个扩展点。 一个简单的例子就是日志。比如说你希望 console.log() 每一个触发的 action 同时 console.log() 这个 action 被响应完成后的状态。在 Flux 中，你只能订阅（subscribe） dispatcher 的更新和每一个 store 的变动。但是这样就侵入了业务代码，这样的日志功能不是一个第三方插件能够轻易实现的。 解决方案 将这个架构的部分功能包装进其他的对象中将使得我们的需求变得更容易实现。这些「其他对象」在架构原有的功能基础之上添加了自己的功能。你可以把这种扩展点看做是一个增强器（enhancers）或者高阶对象（higher order objects），亦或者中间件（middleware）。 此外，使用一个树形结构来组织所有改变状态的逻辑，这样当状态发生改变的时候 store 只会触发一个事件来通知视图层（view），而这一个事件会被整棵树中的所有逻辑处理（译者注：「处理」不代表一定会改变状态，这些改变状态的逻辑本质上是函数，函数内部会根据 action 的类型等来确定是否对状态进行改变）。 注意：就上述这些问题和解决方案来说，我主要在关注开发者工具这一使用场景。实际上，对 Flux 做出的这些改变在其他场景中也非常有帮助。在上述三点之外，Flux 和 Redux 还有更多的不同点。比如，相比于 Flux，Redux 精简了整个架构的冗余代码，并且复用 store 的逻辑变得更加简单。这里有一个 Redux 优点的列表可供参考。 那么让我们来看看 Redux 是怎么让这些特性变为现实的。 新的角色从 Flux 演进到 Redux，整个架构中的角色发生了些许的变化。 Action creatorsRedux 保留了 Flux 中 action creator 的概念。每当你想要改变应用中的状态时，你就要 dispatch 一个 action，这也是唯一改变状态的方法。 就像我在这篇关于 Flux 的文章中提到的一样，我把 action creator 看做是一个报务员（负责发电报的人，telegraph operator），你找到 action creator 告诉他你大致上想要传达什么信息，action creator 则会把这些信息格式化为一种标准的格式，以便系统中的其他部分能够理解。 与 Flux 不同的是，Redux 中的 action creator 不会直接把 action 发送给 dispatcher，而是返回一个格式化好的 JavaScript 对象。 The store我把 Flux 中的 store 描述为一种过度控制的官僚机制。不能简单直接的修改状态，而是要求所有的状态改变都必须由 store 亲自产生，还必须要经历 action 分发那种套路。在 Redux 中，store 依然是这么的充满控制欲和官僚主义，但是又有些不一样。 在 Flux 中，你可以拥有多个 store，每一个 store 都有自己的统治权。每个 store 都保存着自己对应的那部分状态，以及所有修改这些状态的逻辑。 而 Redux 中的 store 更喜欢将权力下放，而且不得不这么做。因为在 Redux 中，你只能有一个 store……所以如果你打算像 Flux 那样 store 完全独立处理自己的事情，那么 Redux 中的 store 将变得工作量巨大。 因此，Redux 中的 store 首先会保存整个应用的所有状态，然后将判断哪一部分状态需要改变的任务分配下去。而以根 reducer（root reducer）为首的 reducer 们将会承担这个任务。 你可能发现这里好像没有 dispatcher 什么事，看起来有点越权，但 store 已经完全接管了 dispatch 相关的工作。 The reducers当 store 需要知道一个 action 触发后状态需要怎么改变时，他会去询问 reducer。根 reducer 会根据状态对象的键（key）将整个状态树进行拆分，然后将拆分后的每一块子状态传到知道该怎么响应的子 reducer 那里进行处理。 我把 reducers 看做是有点格外热衷复印的白领。他们不希望把任何事搞砸，因此他们不会修改任何传递给他们的文件。取而代之的是，他们会对这些文件进行复印，然后在复印件上进行修改。（译者注：当然，当这些修改后的复印件定稿后，他们也不会再去修改这些复印件。） 这是 Redux 的核心思想之一。不直接修改整个应用的状态树，而是将状态树的每一部分进行拷贝并修改拷贝后的部分，然后将这些部分重新组合成一颗新的状态树。 子 reducers 会把他们创建的副本传回给根 reducer，而根 reducer 会把这些副本组合起来形成一颗新的状态树。最后根 reducer 将新的状态树传回给 store，store 再将新的状态树设为最终的状态。 如果你有一个小型应用，你可能只有一个 reducer 对整个状态树进行拷贝并作出修改。又或者你有一个超大的应用，你可能会有若干个 reducers 对整个状态树进行修改。这也是 Flux 和 Redux 的另一处区别。在 Flux 中，store 并不需要与其他 store 产生关联，而且 store 的结构是扁平的。而在 Redux 中，reducers 是有层级结构的。这种层级结构可以有若干层，就像组件的层级结构那样。 The views: 智能组件（smart components）和木偶组件(dumb components)Flux 拥有控制型视图（controller views） 和常规型视图（regular views）。控制型视图就像是一个经理一样，管理着 store 和子视图（child views）之间的通信。 在 Redux 中，也有一个类似的概念：智能组件和木偶组件。（译者注：在最新的 Redux 文档中，它们分别叫做容器型组件 Container component 和展示型组件 Presentational component）智能组件的职责就像经理一样，但是比起 Flux 中的角色，Redux 对经理的职责有更多的定义： 智能组件负责所有的 action。如果智能组件里包含的一个木偶组件需要触发一个 action，智能组件会通过 props 传给一个 function 给木偶组件，而木偶组件可以把这个 function 当做一个回调。智能组件不能定义 CSS 样式。智能组件几乎不会产生自己的 DOM 节点，他的工作是组织若干的木偶组件，由木偶组件来生成最终的 DOM 节点。木偶组件不会直接依赖 action 的触发，因为所有的 action 都会当做 props 传下来。这意味着木偶组件可以被任何一个逻辑不同的 App 拿去使用。同时木偶组件也需要有一定的样式来让自己变得好看一些（当然你可以让木偶组件接受某些 props 作为设置样式的变量）。 视图层绑定 要把 store 绑定到视图上，Redux 需要一点帮助。如果你在使用 React，那么你需要使用 react-redux。 视图绑定工作有点像为组件树服务的 IT 部门。IT 部门确保所有的组件都正确的绑定到 store 上，并处理各种技术上的细节，以确保余下层级的组件对绑定相关的操作毫无感知。 视图层绑定引入了三个概念： 组件： 这个组件需要包裹在整个组件树的最外层。这个组件让根组件的所有子孙组件能够轻松的使用 connect() 方法绑定 store。connect()：这是 react-redux 提供的一个方法。如果一个组件想要响应状态的变化，就把自己作为参数传给 connect() 的结果（译者注：connect() 返回的依然是一个函数），connect() 方法会处理与 store 绑定的细节，并通过 selector 确定该绑定 store 中哪一部分的数据。selector：这是你自己编写的一个函数。这个函数声明了你的组件需要整个 store 中的哪一部分数据作为自己的 props。 根组件所有的 React 应用都存在一个根组件（root component）。他其实就是整个组件树最外层的那个组件，但是在 Redux 中，根组件还要承担额外的任务。 根组件承担的角色有点像企业中的高管，他将整个团队整合到一起来完成某项任务。他会创建 store，并告诉 store 使用哪些 reducers，并最终完成视图层的绑定。 当完成整个应用的初始化工作后，根组件的就不再插手整个应用的运行过程了。每一次重新渲染（re-render）都没有根组件什么事，这些活儿都由根组件下面的子组件完成，当然也少不了视图层绑定的功劳。 Redux 完成的运行流程让我们看看上述各个部分是怎样组合成一个可以运行的应用的。 配置环节应用中的不同部分需要在配置环节中整合到一起。 准备好 store 根组件会创建 store，并通过 createStore(reducer) 方法告诉 store 该使用哪个根 reducer。与此同时，根 reducer 也通过 combineReducers() 方法组建了一只向自己汇报的 reducer 团队。 设置 store 和组件之间的通信 根组件将它所有的子组件包裹在 组件中，并建立了 Provider 与 store 之间的联系。 Provider 本质上创建了一个用于更新视图组件的网络。那些智能组件通过 connect() 方法连入这个网络，以此确保他们能够获取到状态的更新。 准备好 action callback 为了让木偶组件更好的处理 action，智能组件可以用 bindActionCreators() 方法来创建 action callback。这样做之后，智能组件就能给木偶组件传入一个回调（callback）。对应的 action 会在木偶组件调用这个回调时被自动 dispatch。（译者注：使用 bindActionCreators() 使得木偶组件无需关心 action 的 type 等信息，只用调用 props 中的某个方法传入需要的参数作为 action 的 payload 即可） 数据流现在我们的应用已经配置完成，用户可以开始操作了。让我们触发一个 action，看看数据是怎样流动的。 (1) 视图发出了一个 action，action creator 将这个 action 格式化并返回 (2) 这个 action 要么被自动 dispatch（如果我们在配置阶段使用了 bindActionCreators()），要么由视图层手动 dispatch。 (3) store 接受到这个 action 后，将当前的状态树和这个 action 传给根 reducer。 (4) 根 reducer 将整个状态树切分成一个个小块，然后将某一个小块分发给知道怎么处理这部分内容的子 reducer。 (5) 子 reducer 将传入的一小块状态树进行拷贝，然后在副本上进行修改，并最终将修改后的副本返回根 reducer。 (6) 当所有的子 reducer 返回他们修改的副本之后，根 reducer 将这些部分再次组合起来形成一颗新的状态树。然后根 reducer 将这个新的状态树交还给 store，store 再把自己的状态置为这个最新的状态树。 (7) store 告诉视图层绑定：「状态更新啦」 (8) 视图层绑定让 store 把更新的状态传过来 (9) 视图层绑定触发了一个重新渲染的操作（re-render） 这就是我所理解的 Redux，希望对你有所帮助。 更多资源Redux 官方文档Redux 官方文档中文版The Evolution of Flux FrameworksSmart and Dumb ComponentsThe upsides of using ReduxThe downsides of using Redux如何评价数据流管理架构 Redux? 原文地址]]></content>
      <categories>
        <category>Redux</category>
      </categories>
      <tags>
        <tag>Redux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native学习资源大汇聚]]></title>
    <url>%2F2018%2F03%2F04%2Freact-native%2Freact-native%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%E5%A4%A7%E6%B1%87%E8%81%9A%2F</url>
    <content type="text"><![CDATA[React Native 学习资源 React Native着力于提高多平台开发的开发效率 —— 仅需学习一次，编写任何平台。(Learn once, write anywhere)。 本文汇集了React-Native各类学习资源，方便大家学习，同时还有 [Awesome React Native系列]，请收下！( https://github.com/jondot/awesome-react-native)。 教程构建 Facebook F8 2016 App / React Native 开发指南 http://f8-app.liaohuqiu.net/ React-Native入门指南 https://github.com/vczero/react-native-lesson 30天学习React Native教程 https://github.com/fangwei716/30-days-of-react-native React-Native视频教程(部分免费) https://egghead.io/technologies/react React Native 开发培训视频教程（中文|免费） https://www.gitbook.com/book/unbug/react-native-training/details react-native 官方api文档 http://facebook.github.io/react-native/docs/getting-started.html react-native中文文档(极客学院) http://wiki.jikexueyuan.com/project/react-native/ react-native中文文档(react native中文网，人工翻译，官网完全同步) http://react-native.cn/docs/getting-started.html react-native第一课 http://html-js.com/article/2783 深入浅出 React Native：使用 JavaScript 构建原生应用 http://zhuanlan.zhihu.com/FrontendMagazine/19996445 React Native通信机制详解 http://blog.cnbang.net/tech/2698/ React Native布局篇 https://segmentfault.com/a/1190000002658374 React Native 基础练习指北（一） https://segmentfault.com/a/1190000002645929React Native 基础练习指北（二） https://segmentfault.com/a/1190000002647733 Diary of Building an iOS App with React Native http://herman.asia/building-a-flashcard-app-with-react-native React Native For Beginners – The Next Big Thing? https://devdactic.com/react-native-for-beginners/ How To Implement A Tab Bar With React Native https://devdactic.com/react-native-tab-bar/ tcomb-form-native使用视频教程(需翻墙) https://react.rocks/example/tcomb-form-native React Native分享记录 https://segmentfault.com/a/1190000002678782 React Native构建本地视图组件 https://www.dobest.me/article/11 react-native-android-lession(安卓系列教程) https://github.com/yipengmu/react-native-android-lession React Native模块桥接详解 https://www.dobest.me/article/14 React Native: 配置和起步 http://www.liaohuqiu.net/cn/posts/react-native-1/ React Native: Android 的打包 http://www.liaohuqiu.net/cn/posts/react-native-android-package/ ReactNative之原生模块开发并发布——iOS篇 http://www.liuchungui.com/blog/2016/05/02/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-iospian/ ReactNative之原生模块开发并发布——android篇 http://www.liuchungui.com/blog/2016/05/08/reactnativezhi-yuan-sheng-mo-kuai-kai-fa-bing-fa-bu-androidpian/ react-native的第一课 https://github.com/coderyi/blog/blob/master/articles/2016/0122_react-native_first_lesson.md React-Native专题系列文章 http://www.lcode.org/react-native/ react native redux FeInn 从0到1让你学会搭建一个APP https://github.com/febobo/react-native-redux-FeInn react.jsreact.js中文文档 http://reactjs.cn/ react.js入门教程(gitbook) https://hulufei.gitbooks.io/react-tutorial/content/introduction.html react.js快速入门教程 - 阮一峰 http://www.ruanyifeng.com/blog/2015/03/react.html react.js视频教程 http://react-china.org/t/reactjs/584 React Native之React速学教程https://github.com/crazycodeboy/RNStudyNotes/tree/master/React%20Native%E4%B9%8BReact%E9%80%9F%E5%AD%A6%E6%95%99%E7%A8%8B ES6深入浅出ES6（一）：ES6是什么 http://www.infoq.com/cn/articles/es6-in-depth-an-introduction 深入浅出ES6（二）：迭代器和for-of循环 http://www.infoq.com/cn/articles/es6-in-depth-iterators-and-the-for-of-loop 深入浅出ES6（三）：生成器 Generators http://www.infoq.com/cn/articles/es6-in-depth-generators 深入浅出ES6（四）：模板字符串 http://www.infoq.com/cn/articles/es6-in-depth-template-string 深入浅出ES6（五）：不定参数和默认参数 http://www.infoq.com/cn/articles/es6-in-depth-rest-parameters-and-defaults 深入浅出ES6（六）：解构Destructuring http://www.infoq.com/cn/articles/es6-in-depth-destructuring 深入浅出ES6（七）：箭头函数Arrow Functions http://www.infoq.com/cn/articles/es6-in-depth-arrow-functions 深入浅出ES6（八）：Symbols http://www.infoq.com/cn/articles/es6-in-depth-symbols 深入浅出ES6（九）：学习Babel和Broccoli，马上就用ES6 http://www.infoq.com/cn/articles/es6-in-depth-babel-and-broccoli 深入浅出ES6（十）：集合 http://www.infoq.com/cn/articles/es6-in-depth-collections 深入浅出ES6（十一）：生成器Generators，续篇 http://www.infoq.com/cn/articles/es6-in-depth-generators-continued 深入浅出ES6（十二）：代理Proxies http://www.infoq.com/cn/articles/es6-in-depth-proxies-and-reflect/ 深入浅出ES6（十三）：类Class http://www.infoq.com/cn/articles/es6-in-depth-classes 深入浅出ES6（十四）：let和const http://www.infoq.com/cn/articles/es6-in-depth-let-and-const 深入浅出ES6（十五）：子类Subclassing http://www.infoq.com/cn/articles/es6-in-depth-subclassing 深入浅出ES6（十六）：模块Modules http://www.infoq.com/cn/articles/es6-in-depth-modules 深入浅出ES6（十七）：展望未来 http://www.infoq.com/cn/articles/es6-in-depth-the-future 系列教程深入浅出React（一）：React的设计哲学 - 简单之美 http://www.infoq.com/cn/articles/react-art-of-simplity 深入浅出React（二）：React开发神器Webpack http://www.infoq.com/cn/articles/react-and-webpack 深入浅出React（三）：理解JSX和组件 http://www.infoq.com/cn/articles/react-jsx-and-component 深入浅出React（四）：虚拟DOM Diff算法解析 http://www.infoq.com/cn/articles/react-dom-diff 深入浅出React（五）：使用Flux搭建React应用程序架构 http://www.infoq.com/cn/articles/react-flux react-webpack-cookbook中文版 http://fakefish.github.io/react-webpack-cookbook/ Flex 布局语法教程 http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html React 初探 http://www.alloyteam.com/2015/04/react-explore/ React虚拟DOM浅析 http://www.alloyteam.com/2015/10/react-virtual-analysis-of-the-dom/ react组件间通信 http://www.alloyteam.com/2015/07/react-zu-jian-jian-tong-xin/ React 数据流管理架构之 Redux 介绍 http://www.alloyteam.com/2015/09/react-redux/ React服务器端渲染实践小结 http://www.alloyteam.com/2015/10/8783/ React Native Android 踩坑之旅 http://www.alloyteam.com/2015/10/react-native-android-steps-on-tour/ React Native 之 JSBridge http://www.alloyteam.com/2015/05/react-native-zhi-jsbridge/ React Native 研究与实践教程 https://github.com/crazycodeboy/RNStudyNotes React Native探索系列教程React Native探索（一）：背景、规划和风险 http://www.infoq.com/cn/articles/react-native-overview React Native探索（二）：布局篇 http://www.infoq.com/cn/articles/react-native-layout React Native探索（三）：与 react-web 的融合 http://www.infoq.com/cn/articles/react-native-web 开源APP研究源码也是一个很好的学习方式 官方演示App https://github.com/facebook/react-native/tree/master/Examples Facebook F8 App https://github.com/fbsamples/f8app GitHub Popular(一个用来查看GitHub最受欢迎与最热项目的App)已上架https://github.com/crazycodeboy/GitHubPopular 奇舞周刊 iOS 版（上架应用） https://github.com/fakefish/Weekly75 react-native-dribbble-app https://github.com/catalinmiron/react-native-dribbble-app Gank.io客户端 https://github.com/Bob1993/React-Native-Gank Mdcc客户端(优质) https://github.com/Bob1993/mdcc-client Leanote for iOS(云笔记) https://github.com/leanote/leanote-ios-rn ReactNativeRubyChina https://github.com/henter/ReactNativeRubyChina HackerNews-React-Native https://github.com/iSimar/HackerNews-React-Native React-Native新闻客户端 https://github.com/tabalt/ReactNativeNews newswatch(新闻客户端) https://github.com/bradoyler/newswatch-react-native buyscreen(购买页面) https://github.com/appintheair/react-native-buyscreen V2EX客户端 https://github.com/samuel1112/v2er react-native-todo https://github.com/joemaddalone/react-native-todo react-native-beer https://github.com/muratsu/react-native-beer react-native-stars https://github.com/86/react-native-stars 模仿天猫首页的app https://github.com/hugohua/react-native-demo ReactNativeChess https://github.com/csarsam/ReactNativeChess react native 编写的音乐软件 https://github.com/Johnqing/miumiu react-native-pokedex https://github.com/ababol/react-native-pokedex CNode-React-Native https://github.com/SFantasy/CNode-React-Native 8tracks电台客户端 https://github.com/voronianski/EightTracksReactNative React-Native实现的计算器 https://github.com/yoxisem544/Calculator-using-React-Native 房产搜索app https://github.com/jawee/react-native-PropertyFinder 知乎专栏app https://github.com/LeezQ/react-native-zhihu-app ForeignExchangeApp https://github.com/peralmq/ForeignExchangeApp Segmentfault 客户端 https://github.com/fakefish/sf-react-native 糗事百科app https://github.com/stormhouse/QiuShiReactNative 孢子社区app https://github.com/Hi-Rube/baoz-ReactNative 深JS app https://github.com/fraserxu/shenjs Den - 房屋销售app* https://github.com/asamiller/den Noder-cnodejs客户端 https://github.com/soliury/noder-react-native 知乎日报Android版 https://github.com/race604/ZhiHuDaily-React-Native ziliun-react-native https://github.com/sonnylazuardi/ziliun-react-native react-native-weather-app https://github.com/shevawen/react-native-weather-app React Native Sample App(Navigation,Flux) https://github.com/taskrabbit/ReactNativeSampleApp TesterHome社区app https://github.com/qddegtya/A-ReactNative-TesterHome Finance - 股票报价app https://github.com/7kfpun/FinanceReactNative shopping - 购物app https://github.com/bigsui/shopping-react-native zhuiyuan - 追源cms app https://github.com/kazaff/ZhuiYuanDemo uestc-bbs-react-native - UESTC清水河畔RN客户端(with Redux) https://github.com/just4fun/uestc-bbs-react-native react-native-nw-react-calculator(iOS/Android、Web、桌面多端) https://github.com/benoitvallon/react-native-nw-react-calculator react-native-nba-app https://github.com/wwayne/react-native-nba-app 开源中国的Git@OSC客户端 http://git.oschina.net/rplees/react-native-gitosc rn_bycloud 帮瀛律师端app https://github.com/liuchungui/rn_bycloud ReactNativeRollingExamples https://github.com/joggerplus/ReactNativeRollingExamples Reading App Write In React-Native（Studying and Programing https://github.com/attentiveness/reading 数独 - 重拾纯粹数独的乐趣 https://github.com/nihgwu/react-native-sudoku Shop-React-Native https://github.com/EleTeam/Shop-React-Native 掘金客户端 https://github.com/wangdicoder/JueJinClient cnblogs 客户端 https://github.com/togayther/react-native-cnblogs 图书《React Native入门与实战》 http://item.jd.com/11844102.html 《React Native开发指南》 http://www.ituring.com.cn/book/1846 《React Native跨平台移动应用开发》 http://item.jd.com/10372998311.html 《React Native：用JavaScript开发移动应用》 http://item.jd.com/11785195.html 组件React-native组件库（比较全的组件库） https://js.coach/ React Native Modules http://reactnativemodules.com/ 最佳轮播类组件 https://github.com/leecade/react-native-swiper react-native-simple-router https://github.com/react-native-simple-router-community/react-native-simple-router react-native-router-flux https://github.com/aksonov/react-native-router-flux 下拉刷新组件 https://github.com/jsdf/react-native-refreshable-listview 模态框 https://github.com/brentvatne/react-native-modal react-native-navbar https://github.com/react-native-fellowship/react-native-navbar 滚动轮播组件 https://github.com/appintheair/react-native-looped-carousel HTML显示组件 https://github.com/jsdf/react-native-htmlview Material React Native (MRN) - Material Design组件库 https://github.com/binggg/mrn react-native-gitfeed - GitHub客户端(iOS/Android) https://github.com/xiekw2010/react-native-gitfeed React-Native-Elements - React Native样式组件库 https://github.com/react-native-community/React-Native-Elements Shoutem UI - React Native样式组件库 https://github.com/shoutem/ui 工具react-native-snippets(代码提示) https://github.com/Shrugs/react-native-snippets react-native-babel(使用ES6+) https://github.com/roman01la/react-native-babel sqlite for react-native https://github.com/almost/react-native-sqlite gulp-react-native-css(就像写css一样写React Style) https://github.com/soliury/gulp-react-native-css rnpm(React Native Package Manager) https://github.com/rnpm/rnpm Pepperoni - React Native项目初始化套件 https://github.com/futurice/pepperoni-app-kit Deco IDE - React Native IDE https://www.decosoftware.com/ ignite - React Native CLI项目生成器 https://github.com/infinitered/ignite 资源网站React-native官网 http://facebook.github.io/react-native/ React-China社区 http://react-china.org/ React Native中文社区 http://bbs.react-native.cn/ React-native组件库（比较全的组件库） http://react.parts/ React Native Modules http://reactnativemodules.com/ Use React Native 资讯站(使用技巧及新闻) http://www.reactnative.com/ 11款React Native开源移动 UI 组件 http://www.oschina.net/news/61214/11-react-native-ui-components 稀土掘金的 React 标签 http://gold.xitu.io/#/tag/React.js http://gold.xitu.io/#/tag/React%20Native 业界讨论跨平台开发时代的 (再次) 到来？（ Xamarin，NativeScript 和 React Native 对比） http://onevcat.com/2015/03/cross-platform/ 谈谈 React Native - 唐巧 http://blog.devtang.com/blog/2015/02/01/talk-about-react-native/ 如何评价React-Native? https://www.zhihu.com/question/27852694/answer/43990708 React Native概述：背景、规划和风险 http://div.io/topic/938 Native与Web的融合 - Qcon中React-Native演讲 http://www.infoq.com/cn/presentations/the-fusion-of-native-and-web 使用React Native一年后的感受http://www.dobest.me/blog/2016/06/12/%E4%BD%BF%E7%94%A8React%20Native%E4%B8%80%E5%B9%B4%E5%90%8E%E7%9A%84%E6%84%9F%E5%8F%97/ Weex &amp; ReactNative &amp; JSPatch大对比 http://awhisper.github.io/2016/07/22/Weex-ReactNative-JSPatch/ weex&amp;ReactNative对比 https://zhuanlan.zhihu.com/p/21677103 原文地址]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[学习react.js比你想象的简单]]></title>
    <url>%2F2018%2F03%2F03%2FReact%2F%E5%AD%A6%E4%B9%A0react-js%E6%AF%94%E4%BD%A0%E6%83%B3%E8%B1%A1%E7%9A%84%E7%AE%80%E5%8D%95%2F</url>
    <content type="text"><![CDATA[原文地址 学习 React.js 比你想象的要简单 React 全部都是组件化的React 是围绕可重用组件的概念设计的。你定义小组件并将它们组合在一起形成更大的组件。 无论大小，所有组件都是可重用的，甚至在不同的项目中也是如此。 React 组件最简单的形式，就是一个普通的 JavaScript 函数： function Button (props) { // 这里返回一个 DOM 元素，例如： return &lt;button type=&quot;submit&quot;&gt;{props.label}&lt;/button&gt;; } // 将按钮组件呈现给浏览器 ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode) 例 1：编辑上面的代码并按 Ctrl+Enter 键执行（译者注：译文暂时没有这个功能，请访问原文使用此功能，下同） 括号中的 button 标签将稍后解释。现在不要担心它们。ReactDOM 也将稍后解释，但如果你想测试这个例子和所有接下来的例子，上述 render 函数是必须的。（React 将要接管和控制的是 ReactDOM.render 的第 2 个参数即目标 DOM 元素）。在 jsComplete REPL 中，你可以使用特殊的变量 mountNode。 例 1 的注意事项： 组件名称首字母大写，Button。必须要这样做是因为我们将处理 HTML 元素和 React 元素的混合。小写名称是为 HTML 元素保留的。事实上，将 React 组件命名为 “button” 然后你就会发现 ReactDOM 会忽略这个函数，仅仅是将其作为一个普通的空 HTML 按钮来渲染。 每个组件都接收一个属性列表，就像 HTML 元素一样。在 React 中，这个列表被称为属性。虽然你可以将一个函数随意命名。 在上面 Button 函数组件的返回输出中，我们奇怪地写了段看上去像 HTML 的代码。这实际上既不是 JavaScript 也不是 HTML，老实说，这甚至不是 React.js。然而它非常流行，以至于成为 React 应用程序中的默认值。这就是所谓的 JSX，这是一个JavaScript 的扩展。JSX 也是一个折中方案！继续尝试并在上面的函数中返回其他 HTML 元素，看看它们是如何被支持的（例如，返回一个文本输入元素）。 JSX 输出的是什么？上面的例 1 可以用没有 JSX 的纯 React.js 编写，如下： function Button (props) { return React.createElement( &quot;button&quot;, { type: &quot;submit&quot; }, props.label ); } // 要使用 Button，你可以这么做 ReactDOM.render( React.createElement(Button, { label: &quot;Save&quot; }), mountNode ); 例 2：不使用 JSX 编写 React 组件 在 React 顶级 API 中，createElement 函数是主函数。这是你需要学习的 7 个 API 中的 1 个。React 的 API 就是这么小。 就像 DOM 自身有一个 document.createElement 函数来创建一个由标签名指定的元素一样，React 的 createElement 函数是一个高级函数，有和 document.createElement 同样的功能，但它也可以用于创建一个表示 React 组件的元素。当我们使用上面例 2 中的按钮组件时，我们使用的是后者。 不像 document.createElement，React 的 createElement 在接收第二个参数后，接收一个动态参数，它表示所创建元素的子元素。所以 createElement 实际上创建了一个树。 这里就是这样的一个例子： const InputForm = React.createElement( &quot;form&quot;, { target: &quot;_blank&quot;, action: &quot;https://google.com/search&quot; }, React.createElement(&quot;div&quot;, null, &quot;Enter input and click Search&quot;), React.createElement(&quot;input&quot;, { className: &quot;big-input&quot; }), React.createElement(Button, { label: &quot;Search&quot; }) ); // InputForm 使用 Button 组件，所以我们需要这样做： function Button (props) { return React.createElement( &quot;button&quot;, { type: &quot;submit&quot; }, props.label ); } // 然后我们可以通过 .render 方法直接使用 InputForm ReactDOM.render(InputForm, mountNode); 例 3：React 创建元素的 API上面例子中的一些事情值得注意： InputForm 不是一个 React 组件；它仅仅是一个 React 元素。这就是为什么我们可以在 ReactDOM.render 中直接使用它并且可以在调用时不使用 的原因。 React.createElement 函数在前两个参数后接收了多个参数。从第3个参数开始的参数列表构成了创建元素的子项列表。 我们可以嵌套 React.createElement 调用，因为它是 JavaScript。 当这个元素不需要属性时，React.createElement 的第二个参数可以为空或者是一个空对象。 我们可以在 React 组件中混合 HTML 元素。你可以将 HTML 元素作为内置的 React 组件。 React 的 API 试图和 DOM API 一样，这就是为什么我们在 input 元素中使用 className 代替 class 的原因。我们都希望如果 React 的 API 成为 DOM API 本身的一部分，因为，你知道，它要好得多。 上述的代码是当你引入 React 库的时候浏览器是怎样理解的。浏览器不会处理任何 JSX 业务。然而，我们更喜欢看到和使用 HTML，而不是那些 createElement 调用（想象一下只使用 document.createElement 构建一个网站！）。这就是 JSX 存在的原因。取代上述调用 React.createElement 的方式，我们可以使用一个非常简单类似于 HTML 的语法： const InputForm = &lt;form target=&quot;_blank&quot; action=&quot;https://google.com/search&quot;&gt; &lt;div&gt;Enter input and click Search&lt;/div&gt; &lt;input className=&quot;big-input&quot; name=&quot;q&quot; /&gt; &lt;Button label=&quot;Search&quot; /&gt; &lt;/form&gt;; // InputForm “仍然”使用 Button 组件，所以我们也需要这样。 // JXS 或者普通的表单都会这样做 function Button (props) { // 这里返回一个 DOM 元素。例如： return &lt;button type=&quot;submit&quot;&gt;{props.label}&lt;/button&gt;; } // 然后我们可以直接通过 .render 使用 InputForm ReactDOM.render(InputForm, mountNode); 例 4：为什么在 React 中 JSX 受欢迎（和例 3 相比）注意上面的几件事： 这不是 HTML 代码。比如，我们仍然可以使用 className 代替 class。 我们仍在考虑怎样让上述的 JavaScript 看起来像是 HTML。看一下我在最后是怎样添加的。 我们在上面（例 4）中写的就是 JSX。然而，我们要将编译后的版本（例 3）给浏览器。要做到这一点，我们需要使用一个预处理器将 JSX 版本转换为 React.createElement 版本。这就是 JSX。这是一种折中的方案，允许我们用类似 HTML 的语法来编写我们的 React 组件，这是一个很好的方法。 “Flux” 在头部作为韵脚来使用，但它也是一个非常受欢迎的 应用架构，由 Facebook 推广。最出名的是 Redux，Flux 和 React 非常合适。 JSX，可以单独使用，不仅仅适用于 React。 你可以在 JavaScript 的任何地方使用 JSX在 JSX 中，你可以在一对花括号内使用任何 JavaScript 表达式。 const RandomValue = () =&gt; &lt;div&gt; { Math.floor(Math.random() * 100) } &lt;/div&gt;; // 使用： ReactDOM.render(&lt;RandomValue /&gt;, mountNode); 例 5：在 JSX 中使用 JavaScript 表达式 任何 JavaScript 表达式可以直接放在花括号中。这相当于在 JavaScript 中插入 ${} 模板。 这是 JSX 内唯一的约束：只有表达式。例如，你不能使用 if 语句，但三元表达式是可以的。 JavaScript 变量也是表达式，所以当组件接受属性列表时（不包括 RandomValue 组件，props 是可选择的），你可以在花括号里使用这些属性。我们在上述（例 1）的 Button 组件是这样使用的。 JavaScript 对象也是表达式。有些时候我们在花括号中使用 JavaScript 对象，这看起来像是使用了两个花括号，但是在花括号中确实只有一个对象。其中一个用例就是将 CSS 样式对象传递给响应中的特殊样式属性： const ErrorDisplay = ({message}) =&gt; &lt;div style={ { color: &#39;red&#39;, backgroundColor: &#39;yellow&#39; } }&gt; {message} &lt;/div&gt;; // 使用 ReactDOM.render( &lt;ErrorDisplay message=&quot;These aren&#39;t the droids you&#39;re looking for&quot; /&gt;, mountNode ); 例 6：一个对象传递特殊的 React 样式参数注意我解构的只是在属性参数之外的信息。这只是 JavaScript。还要注意上面的样式属性是一个特殊的属性（同样，它不是 HTML，它更接近 DOM API）。我们使用一个对象作为样式属性的值并且这个对象定义样式就像我们使用 JavaScript 你可以在 JSX 中使用 React 元素。因为这也是一个表达式（记住，一个 React 元素只是一个函数调用）： const MaybeError = ({errorMessage}) =&gt; &lt;div&gt; {errorMessage &amp;&amp; &lt;ErrorDisplay message={errorMessage} /&gt;} &lt;/div&gt;; // MaybeError 组件使用 ErrorDisplay 组件 const ErrorDisplay = ({message}) =&gt; &lt;div style={ { color: &#39;red&#39;, backgroundColor: &#39;yellow&#39; } }&gt; {message} &lt;/div&gt;; // 现在我们使用 MaybeError 组件： ReactDOM.render( &lt;MaybeError errorMessage={Math.random() &gt; 0.5 ? &#39;Not good&#39; : &#39;&#39;} /&gt;, mountNode ); 例 7：一个 React 元素是一个可以通过 {} 使用的表达式 上述 MaybeError 组件只会在有 errorMessage 传入或者另外有一个空的 div 才会显示 ErrorDisplay 组件。React 认为 {true}、 {false}{undefined} 和 {null} 是有效元素，不呈现任何内容。 我们也可以在 JSX 中使用所有的 JavaScript 的集合方法（map、reduce 、filter、 concat 等）。因为他们返回的也是表达式： const Doubler = ({value=[1, 2, 3]}) =&gt; &lt;div&gt; {value.map(e =&gt; e * 2)} &lt;/div&gt;; // 使用下面内容 ReactDOM.render(&lt;Doubler /&gt;, mountNode); 例 8：在 {} 中使用数组 请注意我是如何给出上述 value 属性的默认值的，因为这全部都只是 JavaScript。注意我只是在 div 中输出一个数组表达式。React 是完全可以的。它只会在文本节点中放置每一个加倍的值。 你可以使用 JavaScript 类写 React 组件简单的函数组件非常适合简单的需求，但是有的时候我们需要的更多。React 也支持通过使用 JavaScript 类来创建组件。这里 Button 组件（在例 1 中）就是使用类的语法编写的。 class Button extends React.Component { render() { return &lt;button&gt;{this.props.label}&lt;/button&gt;; } } // 使用（相同的语法） ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode); 例 9：使用 JavaScript 类创建组件 类的语法是非常简单的：定义一个扩展的 React.Component 类（另一个你需要学习的 React 的顶级 API）。该类定义了一个单一的实例函数 —— render()，并使函数返回虚拟 DOM 对象。每一次我们使用基于类的 Button 组件（例如，通过 ）,React 将从这个基于类的组件中实例化对象，并在 DOM 树中使用该对象。 这就是为什么上面的例子中我们可以在 JSX 中使用 this.props.label 渲染输出的原因，因为每一个组件都有一个特殊的称为 props 的 实例 属性，这让所有的值传递给该组件时被实例化。 由于我们有一个与组件的单个使用相关联的实例，所以我们可以按照自己的意愿定制该实例。例如，我们可以通过使用常规 JavaScript 构造函数来构造它： class Button extends React.Component { constructor(props) { super(props); this.id = Date.now(); } render() { return &lt;button id={this.id}&gt;{this.props.label}&lt;/button&gt;; } } // 使用 ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode); 例 10：自定义组件实例我们也可以定义类的原型并且在任何我们希望的地方使用，包括在返回的 JSX 输出的内部： class Button extends React.Component { clickCounter = 0; handleClick = () =&gt; { console.log(`Clicked: ${++this.clickCounter}`); }; render() { return ( &lt;button id={this.id} onClick={this.handleClick}&gt; {this.props.label} &lt;/button&gt; ); } } // 使用 ReactDOM.render(&lt;Button label=&quot;Save&quot; /&gt;, mountNode); 例 11：使用类的属性（通过单击保存按钮进行测试） 注意上述例 11 中的几件事情handleClick 函数使用 JavaScript 新提出的 class-field syntax 语法。这仍然是 stage-2，但是这是访问组件安装实例（感谢箭头函数）最好的选择（因为很多原因）。然而，你需要使用类似 Babel 的编译器解码为 stage-2（或者仅仅是类字段语法）来让上述代码工作。 jsComplete REPL 有预编译功能。 // 错误： onClick={this.handleClick()} // 正确： onClick={this.handleClick} React 中的事件：两个重要的区别当处理 React 元素中的事件时，我们与 DOM API 的处理方式有两个非常重要的区别： 所有 React 元素属性（包括事件）都使用 camelCase 命名，而不是 lowercase。例如是 onClick 而不是 onclick。 我们将实际的 JavaScript 函数引用传递给事件处理程序，而不是字符串。例如是 onClick={handleClick} 而不是 onClick=”handleClick”。 React 用自己的对象包装 DOM 对象事件以优化事件处理的性能，但是在事件处理程序内部，我们仍然可以访问 DOM 对象上所有可以访问的方法。React 将经过包装的事件对象传递给每个调用函数。例如，为了防止表单提交默认提交操作，你可以这样做 class Form extends React.Component { handleSubmit = (event) =&gt; { event.preventDefault(); console.log(&#39;Form submitted&#39;); }; render() { return ( &lt;form onSubmit={this.handleSubmit}&gt; &lt;button type=&quot;submit&quot;&gt;Submit&lt;/button&gt; &lt;/form&gt; ); } } // 使用 ReactDOM.render(&lt;Form /&gt;, mountNode); 例 12：使用包装过的对象 每一个 React 组件都有一个故事：第 1 部分以下仅适用于类组件（扩展 React.Component）。函数组件有一个稍微不同的故事。 首先，我们定义了一个模板来创建组件中的元素。然后，我们在某处使用 React。例如，在 render 内部调用其他的组件，或者直接使用 ReactDOM.render。然后，React 实例化一个对象然后给它设置 props 然后我们可以通过 this.props 访问。这些属性都是我们在第 2 步传入的。因为这些全部都是 JavaScript，constructor 方法将会被调用（如果定义的话）。这是我们称之为的第一个：组件生命周期方法。接下来 React 计算渲染之后的输出方法（虚拟 DOM 节点）。因为这是 React 第一次渲染元素，React 将会与浏览器连通（代表我们使用 DOM API）来显示元素。这整个过程称为 mounting。接下来 React 调用另一个生命周期函数，称为 componentDidMount。我们可以这样使用这个方法，例如：在 DOM 上做一些我们现在知道的在浏览器中存在的东西。在此生命周期方法之前，我们使用的 DOM 都是虚拟的。一些组件的故事到此结束，其他组件得到卸载浏览器 DOM 中的各种原因。在后一种情况发生时，会调用另一个生命周期的方法，componentWillUnmount。任何 mounted 的元素的状态都可能会改变。该元素的父级可能会重新渲染。无论哪种情况，mounted 的元素都可能接收到不同的属性集。React 的魔力就是这儿，我们实际上需要的正是 React 的这一点！在这一点之前，说实话，我们并不需要 React。组价的故事还在继续，但是在此之前，我们需要理解我所说的这种状态。React 组件可以具有私有状态以下只适用于类组件。我有没有提到有人叫表象而已的部件 dumb？ 状态类是任何 React 类组件中的一个特殊字段。React 检测每一个组件状态的变化，但是为了 React 更加有效，我们必须通过 React 的另一个 API 改变状态字段，这就是我们要学习的另一个 API —— this.setState： class CounterButton extends React.Component { state = { clickCounter: 0, currentTimestamp: new Date(), }; handleClick = () =&gt; { this.setState((prevState) =&gt; { return { clickCounter: prevState.clickCounter + 1 }; }); }; componentDidMount() { setInterval(() =&gt; { this.setState({ currentTimestamp: new Date() }) }, 1000); } render() { return ( &lt;div&gt; &lt;button onClick={this.handleClick}&gt;Click&lt;/button&gt; &lt;p&gt;Clicked: {this.state.clickCounter}&lt;/p&gt; &lt;p&gt;Time: {this.state.currentTimestamp.toLocaleString()}&lt;/p&gt; &lt;/div&gt; ); } } // 使用 ReactDOM.render(&lt;CounterButton /&gt;, mountNode); 例 13：setState 的 API这可能是最重要的一个例子因为这将是你完全理解 React 基础知识的方式。这个例子之后，还有一些小事情需要学习，但从那时起主要是你和你的 JavaScript 技能。 让我们来看一下例 13，从类开始，总共有两个，一个是一个初始化的有初始值为 0 的 clickCounter 对象和一个从 new Date() 开始的 currentTimestamp。 另一个类是 handleClick 函数，在渲染方法中我们给按钮元素传入 onClick 事件。通过使用 setState 的 handleClick 方法修改了组件的实例状态。要注意到这一点。 另一个我们修改状态的地方是在一个内部的定时器，开始在内部的 componentDidMount 生命周期方法。它每秒钟调用一次并且执行另一个函数调用 this.setState。在渲染方法中，我们使用具有正常读语法的状态上的两个属性（没有专门的 API）。现在，注意我们更新状态使用两种不同的方式： 1.通过传入一个函数然后返回一个对象。我们在 handleClick 函数内部这样做。2.通过传入一个正则对象，我们在在区间回调中这样做。 这两种方式都是可以接受的，但是当你同时读写状态时，第一种方法是首选的（我们这样做）。在区间回调中，我们只向状态写入而不读它。当有问题时，总是使用第一个函数作为参数语法。伴随着竞争条件这更安全，因为 setstate 实际上是一个异步方法。我们应该怎样更新状态呢？我们返回一个有我们想要更新的的值的对象。注意，在调用 setState 时，我们全部都从状态中传入一个属性或者全都不。这完全是可以的因为 setState 实际上 合并 了你通过它（返回值的函数参数）与现有的状态，所以，没有指定一个属性在调用 setState 时意味着我们不希望改变属性（但不删除它）。 React 将要反应React 的名字是从状态改变的反应中得来的（虽然没有反应，但也是在一个时间表中）。这里有一个笑话，React 应该被命名为Schedule！ 然而，当任何组件的状态被更新时，我们用肉眼观察到的是对该更新的反应，并自动反映了浏览器 DOM 中的更新（如果需要的话）。将渲染函数的输入视为两种： 1.通过父元素传入的属性2.以及可以随时更新的内部私有状态 当渲染函数的输入改变时，输出可能也会改变。React 保存了渲染的历史记录，当它看到一个渲染与前一个不同时，它将计算它们之间的差异，并将其有效地转换为在 DOM 中执行的实际 DOM 操作。 React 是你的代码您可以将 React 看作是我们用来与浏览器通信的代理。以上面的当前时间戳显示为例。取代每一秒我们都需要手动去浏览器调用 DOM API 操作来查找和更新 p#timestamp 元素，我们仅仅改变组件的状态属性，React 做的工作代表我们与浏览器的通信。我相信这就是为什么 React 这么受欢迎的真正原因；我们只是不喜欢和浏览器先生谈话（以及它所说的 DOM 语言的很多方言），并且 React 自愿传递给我们，免费的！ 每一个 React 组件都有一个故事：第 2 部分 现在我们知道了一个组件的状态，当该状态发生变化的时候，我们来了解一下关于这个过程的最后几个概念。 当组件的状态被更新时，或者它的父进程决定更改它传递给组件的属性时，组件可能需要重新渲染。 如果后者发生，React 会调用另一个生命周期方法：componentWillReceiveProps。 如果状态对象或传递的属性改变了，React 有一个重要的决定要做：组件是否应该在 DOM 中更新？这就是为什么它调用另一个重要的生命周期方法 shouldComponentUpdate 的原因 。此方法是一个实际问题，因此，如果需要自行定制或优化渲染过程，则必须通过返回 true 或 false 来回答这个问题。 如果没有自定义 shouldComponentUpdate，React 的默认事件在大多数情况下都能处理的很好。 首先，这个时候会调用另一生命周期的方法：componentWillUpdate。然后，React 将计算新渲染过的输出，并将其与最后渲染的输出进行对比。 如果渲染过的输出和之前的相同，React 不进行处理（不需要和浏览器先生对话）。 如果有不同的地方，React 将不同传达给浏览器，像我们之前看到的那样。 在任何情况下，一旦一个更新程序发生了，无论以何种方式（即使有相同的输出），React 会调用最后的生命周期方法：componentDidUpdate。 生命周期方法是逃生舱口。如果你没有做什么特别的事情，你可以在没有它们的情况下创建完整的应用程序。它们非常方便地分析应用程序中正在发生的事情，并进一步优化 React 更新的性能。 信不信由你，通过上面所学的知识（或部分知识），你可以开始创建一些有趣的 React 应用程序。如果你渴望更多，看看我的 Pluralsight 的 React.js 入门课程。]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[5分钟上手TypeScript]]></title>
    <url>%2F2018%2F03%2F02%2FTs%2F5%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8BTypeScript%2F</url>
    <content type="text"><![CDATA[让我们使用TypeScript来创建一个简单的Web应用。安装TypeScript有两种主要的方式来获取TypeScript工具： 通过npm（Node.js包管理器） 安装Visual Studio的TypeScript插件 Visual Studio 2017和Visual Studio 2015 Update 3默认包含了TypeScript。 如果你的Visual Studio还没有安装TypeScript，你可以下载它。 针对使用npm的用户： npm install -g typescript 构建你的第一个TypeScript文件在编辑器，将下面的代码输入到greeter.ts文件里： function greeter(person) { return &quot;Hello, &quot; + person; } let user = &quot;Jane User&quot;; document.body.innerHTML = greeter(user); 编译代码我们使用了.ts扩展名，但是这段代码仅仅是JavaScript而已。 你可以直接从现有的JavaScript应用里复制/粘贴这段代码。 在命令行上，运行TypeScript编译器： tsc greeter.ts 输出结果为一个greeter.js文件，它包含了和输入文件中相同的JavsScript代码。 一切准备就绪，我们可以运行这个使用TypeScript写的JavaScript应用了！接下来让我们看看TypeScript工具带来的高级功能。 给 person函数的参数添加: string类型注解，如下： function greeter(person: string) { return &quot;Hello, &quot; + person; } let user = &quot;Jane User&quot;; document.body.innerHTML = greeter(user); 类型注解TypeScript里的类型注解是一种轻量级的为函数或变量添加约束的方式。 在这个例子里，我们希望 greeter函数接收一个字符串参数。 然后尝试把 greeter的调用改成传入一个数组: function greeter(person: string) { return &quot;Hello, &quot; + person; } let user = [0, 1, 2]; document.body.innerHTML = greeter(user); 重新编译，你会看到产生了一个错误。 greeter.ts(7,26): error TS2345: Argument of type &#39;number[]&#39; is not assignable to parameter of type &#39;string&#39;. 类似地，尝试删除greeter调用的所有参数。 TypeScript会告诉你使用了非期望个数的参数调用了这个函数。 在这两种情况中，TypeScript提供了静态的代码分析，它可以分析代码结构和提供的类型注解。 要注意的是尽管有错误，greeter.js文件还是被创建了。 就算你的代码里有错误，你仍然可以使用TypeScript。但在这种情况下，TypeScript会警告你代码可能不会按预期执行 接口让我们开发这个示例应用。这里我们使用接口来描述一个拥有firstName和lastName字段的对象。 在TypeScript里，只在两个类型内部的结构兼容那么这两个类型就是兼容的。 这就允许我们在实现接口时候只要保证包含了接口要求的结构就可以，而不必明确地使用 implements语句。 interface Person { firstName: string; lastName: string; } function greeter(person: Person) { return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName; } let user = { firstName: &quot;Jane&quot;, lastName: &quot;User&quot; }; document.body.innerHTML = greeter(user); 类最后，让我们使用类来改写这个例子。 TypeScript支持JavaScript的新特性，比如支持基于类的面向对象编程。 让我们创建一个Student类，它带有一个构造函数和一些公共字段。 注意类和接口可以一起共作，程序员可以自行决定抽象的级别。 还要注意的是，在构造函数的参数上使用public等同于创建了同名的成员变量。 class Student { fullName: string; constructor(public firstName, public middleInitial, public lastName) { this.fullName = firstName + &quot; &quot; + middleInitial + &quot; &quot; + lastName; } } interface Person { firstName: string; lastName: string; } function greeter(person : Person) { return &quot;Hello, &quot; + person.firstName + &quot; &quot; + person.lastName; } let user = new Student(&quot;Jane&quot;, &quot;M.&quot;, &quot;User&quot;); document.body.innerHTML = greeter(user); 重新运行tsc greeter.ts，你会看到生成的JavaScript代码和原先的一样。 TypeScript里的类只是JavaScript里常用的基于原型面向对象编程的简写。 运行TypeScript Web应用在greeter.html里输入如下内容： &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt;&lt;title&gt;TypeScript Greeter&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;script src=&quot;greeter.js&quot;&gt;&lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 在浏览器里打开greeter.html运行这个应用！可选地：在Visual Studio里打开greeter.ts或者把代码复制到TypeScript playground。 将鼠标悬停在标识符上查看它们的类型。 注意在某些情况下它们的类型可以被自动地推断出来。 重新输入一下最后一行代码，看一下自动补全列表和参数列表，它们会根据DOM元素类型而变化。 将光标放在 greeter函数上，点击F12可以跟踪到它的定义。 还有一点，你可以右键点击标识，使用重构功能来重命名。 这些类型信息以及工具可以很好的和JavaScript一起工作。 原文地址]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>TS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native使用过程中的报错（持续更新中）]]></title>
    <url>%2F2018%2F03%2F01%2Freact-native%2Freact-native%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E6%8A%A5%E9%94%99%EF%BC%88%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ReactNative 遇到的报错react-native 矢量库 react-native-vector-icons的报错解决解决方法：将项目目录下 node_modules/react-native/local-cli/core/fixtures/files/package.json删除如果还出现这个错误 解决方案：删除重新安装react-native-vector-icons 安装完成后执行 react-native link 继续修改问题1的错误 unRecognized font family ‘XXXXX’解决方案： react-native开发踩坑之 ios上react-native-vector-icons 的error：unRecognized font family ‘FontAwesome’接下来解释一下，首先看第一步：把node_modules/react-native-vector-icons下的fonts文件添加到工程中，这时候往往忽略了一个重点，后面那一句 Make sure your app is checked under “Add to targets” and that “Create groups” is checked if you add the whole folder 这一句很关键，意思是确认必须要确认是Add to targets和Create groups，一开始我是直接右键把fonts目录add到工程的，根本没看到这两个玩意，结果就是失败，有点奇怪，后来我仔细看了一下这个步骤描述， drag the folder Fonts to your project in Xcode ReactNative Ios报出 ‘React/RCTBundleURLProvider.h’ file not found错误我在创建react-native项目时 npm了一个第三方库 结果一打开 xcode 竟然报错 React/RCTBundleURLProvider.h’ file not found； 然后 我试了各种网上的方法试了一遍， 还是不行 就在我要放弃的时候 ，突然想到把网上的方法 结合一下 试试，结果好了。 以下就是我的解决方法 1.打开Mac里面的终端，进入项目所在的文件夹目录；2.把项目里面的 node_modules 文件夹删除掉，然后执行 npm install 命令3.npm install安装完成后， 执行react-native upgrade命令4.npm start5.打开xcode (如果还报错)6.左侧点击跟项目目录 -&gt; 选择右侧 Build Settings -&gt; 选择 All &amp; Combined -&gt; 搜索框输入 Always Search User Paths -&gt; 将 Always Search User Paths 设置为 Yes -&gt; Clean -&gt; Build RN SectionList 遇到 missing keys for items, make sure to specify a key property on each item 的 问题解决它警告我们每个item 要有不同的key 默认情况下每行都需要提供一个不重复的key属性。你也可以提供一个keyExtractor函数来生成key。把这个属性添加到 里面 keyExtractor = {this._extraUniqueKey} _extraUniqueKey(item ,index){ eturn &quot;index&quot;+index+item; } 这是每个item要设置key, 同样每个子控件也不能放过， 一定要设置它的key， 要不然这个屎黄色一直伴着你 多烦~~ react-native 运行时，出现如下报错：首先试试react-native start 或 npm start 看看是否报错，如果报错出现ERROR:Metro Bundler can’t listen on port 8081 则是8081端口号被占用 解决方案：执行sudo lsof -i :8081 kill -9 进程号 更多ReactNative问题总结集合，请移步大佬链接react-native 问题]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react开发环境搭建]]></title>
    <url>%2F2018%2F02%2F28%2FReact%2Freact%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[使用creat-react-app搭建基于webpack的react开发环境 facebook官方文档Quick Start: npm install -g create-react-app //安装create-react-app，yarn命令(需要安装yarn) yarn add create-react-app create-react-app myapp //使用命令创建react应用 myapp为文件名称 cd myapp //进入文件目录 npm start //yarn start 启动应用 npm test or yarn test //测试 npm run build or yarn build //打包编译 上述命令即可快速创建react开发环境 打开http://localhost:3000/ 查看 环境配置介绍：项目结构：生成项目后，脚手架为了“优雅”… …隐藏了所有的webpack相关的配置文件，此时查看myapp文件夹目录，会发现找不到任何webpack配置文件。执行以下命令： npm run eject 再查看myapp 文件夹，可以看到完整的项目结构： myapp/ node_modules/ package.json .gitignore config/ paths.js polyfills env.js webpack.config.dev.js webpack.config.prod.js public/ index.html / 入口html文件 / scripts **build.js** **start.js** test.js src/ App.js index.js / 主入口文件 / 加粗文件为主要配置文件。 二、项目配置介绍此处需要有npm、webpack的基础知识，充电传送门：webpack学习教程 查看package.json文件的scripts， &quot;scripts&quot;: { &quot;start&quot;: &quot;node scripts/start.js&quot;, &quot;build&quot;: &quot;node scripts/build.js&quot;, &quot;test&quot;: &quot;node scripts/test.js --env=jsdom&quot; }, 可知，运行时是直接执行scripts文件目录下的js文件。其中start.js为开发环境，build.js为打包脚本。 开发环境，代理请求查看start.js, Facebook基本为每项配置都写了详尽的注释，start.js脚本启动了dev-server, 这里需要了解的是 function addMiddleware(devServer){ ... ... 这个函数调用http-proxy-middleware模块，将代理请求，代理地址在package.json中添加 } 在package.json中添加字段proxy，开发环境下dev-server将会自动转发请求： &quot;proxy&quot;: &quot;http://aaa.bbb.com&quot; SASS、LESS等CSS预处理器配置Facebook官方在create-react-app升级到某一版本，突然丢掉了默认对sass、less等预处理器的支持，官方文档说明 于是，只能自己动手，在config目录下，webpack.config.dev.js 和 webpack.config.prod.js文件，没有抽出 loader、postcss之类一般共用的配置，于是，在两个文件夹都要一起配置，也可以抽出共用部分，以便维护。 这里以webpack.config.dev.js举例，webpack.config.prod.js一样配置即可： SASS-loader：1、命令行，在当前目录执行： npm install --save node-sass-chokidar //or yarn add node-sass-chokidar 然后在package.json修改为 &quot;scripts&quot;: { &quot;build-css&quot;: &quot;node-sass-chokidar src/ -o src/&quot;, &quot;watch-css&quot;: &quot;npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive&quot;, &quot;start&quot;: &quot;react-scripts start&quot;, &quot;build&quot;: &quot;react-scripts build&quot;, &quot;test&quot;: &quot;react-scripts test --env=jsdom&quot;, 把index.css改为index.scss 执行 npm run watch-css 就可以发现sass文件被编译成了css文件（自动生成的css文件所以引用的部分不作修改） 如果你发现在执行watch-css 命令时 不能同时执行npm start,可以采用另外一种方式： npm install --save npm-run-all //yarn add npm-run-all（ 这是watch-css和build-css的合集） 同样修改package.json中的 &quot;scripts&quot;: { &quot;build-css&quot;: &quot;node-sass-chokidar src/ -o src/&quot;, &quot;watch-css&quot;: &quot;npm run build-css &amp;&amp; node-sass-chokidar src/ -o src/ --watch --recursive&quot;, &quot;start-js&quot;: &quot;node scripts/start.js&quot;, &quot;start&quot;: &quot;npm-run-all -p watch-css start-js&quot;, &quot;build-js&quot;: &quot;node scripts/build.js&quot;, &quot;build&quot;: &quot;npm-run-all build-css build-js&quot;, &quot;test&quot;: &quot;node scripts/test.js --env=jsdom&quot; }, 这样就可以只需执行npm start 编辑查看了 2、找到webpack.config.dev.js文件中 loaders中的第一项exclude（值为数组），排除scss文件，否则将被’url-loader’捕获。 { exclude: [ /\.html$/, /\.(js|jsx)(\?.*)?$/, /\.css$/, /\.json$/, /\.svg$/, /\.scss$/ //....新增项! ] 3、loaders新增一项： { test: /\.scss$/, loader: &#39;style!css!postcss!sass?outputStyle=expanded&#39; }, 至此，SASS文件就可以正常打包了（此处针对SCSS文件，如用到SASS，可将SCSS的正则修改下），LESS文件类似，不再赘述。 使用and-mobile UI工具 可以快速开发react应用and-mobile入口 antd-mobile的引入及配置在命令行执行： npm install antd-mobile --save 按需引入 为减少打包后体积以及方便书写，可用babel-plugin-import插件，配置后引入模块可如下： import {Picker} from &#39;antd-mobile&#39;; 自动引入CSS和JS，无需再引入整个antd-mobile的整个CSS文件 使用如下： npm install babel-plugin-import --save-dev 安装完毕后，在根目录新建文件，命名: .babelrc.js { &quot;presets&quot;: [ &quot;es2015&quot;, &quot;react&quot; ], &quot;plugins&quot;: [ [ &quot;import&quot;, { &quot;libraryName&quot;: &quot;antd-mobile&quot;, &quot;style&quot;: &quot;css&quot; } ] ] } 在文件内输入以上内容，为babel的配置。 然后！！！最重要的一步，把package.json中的babel配置给删掉，尤其是：react-app！！！ webpack.config.dev.js和webpack.config.prod.js中，都需要为resolve的extensions新增一项’.web.js‘ antd-mobile的web版的文件后缀为.web.js … 基于create-react-app的打包后文件根路径修改找到react-script模块文件夹config下面 paths.js 或node_modules\react-scripts\config\ paths.js45行到 49行 function getServedPath(appPackageJson) { const publicUrl = getPublicUrl(appPackageJson); const servedUrl = envPublicUrl || (publicUrl ? url.parse(publicUrl).pathname : &#39;./&#39;); // 配置文件跟路径&#39;/&#39;前面加. return ensureSlash(servedUrl, true); } react段位排行要求知乎大神总结倔强青铜初入峡谷的初始段位，默认召唤师已经有了ES6，nodejs的基础使用create-react-app建立React开发环境学习React世界里的基本玩法，例如组件化，JSX，事件监听，内部state，组件的props、生命周期函数等这篇文章主要介绍React青铜升白银需要的基础知识，看完你就白银啦 秩序白银到了白银段位，基本都是有了基本的操作，不会出现呆萌的站在地方塔下被打死的情况了我们需要买一个皮肤来提升页面美观并且多加练习学习使用蚂蚁金服ant-design的使用 荣耀黄金到了这个阶段，召唤师对React有了基本的认识，想进一步的提升段位，我们需要提高自己的大局观学习使用React-Router4来让我们有多面作战能力学会使用BrowserRouter，Router，Link等组件学会使用Redux和队友配合，修炼大局观了解单项数据流开发模式和Redux的各种概念,如dispatch,action,reducers使用react-redux更好的和Redux配合有大局观意识，上铂金也是很 easy 了 尊贵铂金很多召唤师卡在铂金上不去，因为铂金想上钻石，需要了解更多的细节和原理React原理剖析对自己技能的原理有深刻的了解，上钻石必备 永恒钻石钻石段位开始了征兆模式，召唤师的技能池要足够深才能更进一步，对自己擅长技能的理解也要更深刻Redux中间件机制，实现自己的中间件常见的React 性能优化方式服务端渲染Redux之外其他的数据解决方案如mobx，dva 至尊星耀这个段位已经是独当一面的强者了，目标仅限于 React 这个库很难更近一层，需要了解更底层的原理Redux原理剖析+实现自己的ReduxReact-Router+实现自己的React-RouterWebppack工作机制和原理剖析Babel工作机制和原理剖析 最强王者达到最强王者已经是顶尖召唤师，在整个 React 峡谷都是鼎鼎大名的存在，听说上面还有传说中的荣耀王者的段位，我这辈子是达不到了，也没法教你们了，囧这个阶段，我只推荐《程序员健康指南》一本书，保持身心健康，成为荣耀王者是早晚的事原文链接]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript奇技淫巧44招]]></title>
    <url>%2F2018%2F02%2F27%2FJs%2FJavaScript%E5%A5%87%E6%8A%80%E6%B7%AB%E5%B7%A745%E6%8B%9B%2F</url>
    <content type="text"><![CDATA[原文地址 首次为变量赋值时务必使用var关键字变量没有声明而直接赋值得话，默认会作为一个新的全局变量，要尽量避免使用全局变量。 使用===取代====和!=操作符会在需要的情况下自动转换数据类型。但===和!==不会，它们会同时比较值和数据类型，这也使得它们要比==和!=快。 [10] === 10 // is false [10] == 10 // is true &#39;10&#39; == 10 // is true &#39;10&#39; === 10 // is false [] == 0 // is true [] === 0 // is false &#39;&#39; == false // is true but true == &quot;a&quot; is false &#39;&#39; === false // is false underfined、null、0、false、NaN、空字符串的逻辑结果均为false行尾使用分号实践中最好还是使用分号，忘了写也没事，大部分情况下JavaScript解释器都会自动添加。对于为何要使用分号，可参考文章JavaScript中关于分号的真相 使用对象构造器function Person(firstName, lastName){ this.firstName = firstName; this.lastName = lastName; } var Saad = new Person(&quot;Saad&quot;, &quot;Mousliki&quot;); 小心使用typeof、instanceof和contructor typeof：JavaScript一元操作符，用于以字符串的形式返回变量的原始类型，注意，typeof null也会返回object，大多数的对象类型（数组Array、时间Date等）也会返回object contructor：内部原型属性，可以通过代码重写 instanceof：JavaScript操作符，会在原型链中的构造器中搜索，找到则返回true，否则返回false var arr = [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; typeof arr; // 返回 &quot;object&quot; arr instanceof Array // true arr.constructor(); //[] 使用自调用函数函数在创建之后直接自动执行，通常称之为自调用匿名函数（Self-Invoked Anonymous Function）或直接调用函数表达式（Immediately Invoked Function Expression ）。格式如下： (function(){ // 置于此处的代码将自动执行 })(); (function(a,b){ var result = a+b; return result; })(10,20) 从数组中随机获取成员var items = [12, 548 , &#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; , 2145 , 119]; var randomItem = items[Math.floor(Math.random() * items.length)]; console.log(randomItem); 获取指定范围内的随机数这个功能在生成测试用的假数据时特别有数，比如介与指定范围内的工资数。 var x = Math.floor(Math.random() * (max - min + 1)) + min; 生成从0到指定值的数字数组var numbersArray = [] , max = 100; for( var i=1; numbersArray.push(i++) &lt; max;); // numbers = [1,2,3 ... 100] 生成随机的字母数字字符串function generateRandomAlphaNum(len) { var rdmString = &quot;&quot;; for( ; rdmString.length &lt; len; rdmString += Math.random().toString(36).substr(2)); return rdmString.substr(0, len); } 打乱数字数组的顺序var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; numbers = numbers.sort(function(){ return Math.random() - 0.5}); /* numbers 数组将类似于 [120, 5, 228, -215, 400, 458, -85411, 122205] */ 这里使用了JavaScript内置的数组排序函数，更好的办法是用专门的代码来实现（如Fisher-Yates算法 字符串去空格Java、C#和PHP等语言都实现了专门的字符串去空格函数，但JavaScript中是没有的，可以通过下面的代码来为String对象函数一个trim函数： String.prototype.trim = function(){return this.replace(/^\s+|\s+$/g, &quot;&quot;);}; 新的JavaScript引擎已经有了trim()的原生实现 数组之间追加var array1 = [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458]; var array2 = [&quot;Doe&quot; , 555 , 100]; Array.prototype.push.apply(array1, array2); /* array1 值为 [12 , &quot;foo&quot; , {name &quot;Joe&quot;} , -2458 , &quot;Doe&quot; , 555 , 100] */ 对象转换为数组var argArray = Array.prototype.slice.call(arguments); 验证是否是数字function isNumber(n){ return !isNaN(parseFloat(n)) &amp;&amp; isFinite(n); } 验证是否是数组function isArray(obj){ return Object.prototype.toString.call(obj) === &#39;[object Array]&#39; ; } 但如果toString()方法被重写过得话，就行不通了。也可以使用下面的方法： Array.isArray(obj); // its a new Array method 如果在浏览器中没有使用frame，还可以用instanceof，但如果上下文太复杂，也有可能出错。 var myFrame = document.createElement(&#39;iframe&#39;); document.body.appendChild(myFrame); var myArray = window.frames[window.frames.length-1].Array; var arr = new myArray(a,b,10); // [a,b,10] // myArray 的构造器已经丢失，instanceof 的结果将不正常 // 构造器是不能跨 frame 共享的 arr instanceof Array; // false 获取数组中的最大值和最小值var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; var maxInNumbers = Math.max.apply(Math, numbers); var minInNumbers = Math.min.apply(Math, numbers); 清空数组var myArray = [12 , 222 , 1000 ]; myArray.length = 0; // myArray will be equal to []. 不要直接从数组中delete或remove元素如果对数组元素直接使用delete，其实并没有删除，只是将元素置为了undefined。数组元素删除应使用splice。 切忌： var items = [12, 548 ,&#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; ,2154 , 119 ]; items.length; // return 11 delete items[3]; // return true items.length; // return 11 /* items 结果为 [12, 548, &quot;a&quot;, undefined × 1, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] */ 而应： var items = [12, 548 ,&#39;a&#39; , 2 , 5478 , &#39;foo&#39; , 8852, , &#39;Doe&#39; ,2154 , 119 ]; items.length; // return 11 items.splice(3,1) ; items.length; // return 10 /* items 结果为 [12, 548, &quot;a&quot;, 5478, &quot;foo&quot;, 8852, undefined × 1, &quot;Doe&quot;, 2154, 119] 删除对象的属性时可以使用delete。 使用length属性截断数组前面的例子中用length属性清空数组，同样还可用它来截断数组 var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ]; myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124]. 与此同时，如果把length属性变大，数组的长度值变会增加，会使用undefined来作为新的元素填充。length是一个可写的属性。 myArray.length = 10; // the new array length is 10 myArray[myArray.length - 1] ; // undefined 在条件中使用逻辑与或var foo = 10; foo == 10 &amp;&amp; doSomething(); // is the same thing as if (foo == 10) doSomething(); foo == 5 || doSomething(); // is the same thing as if (foo != 5) doSomething(); 逻辑或还可用来设置默认值，比如函数参数的默认值。 function doSomething(arg1){ arg1 = arg1 || 10; // arg1 will have 10 as a default value if it’s not already set } 使得map()函数方法对数据循环var squares = [1,2,3,4].map(function (val) { return val * val; }); // squares will be equal to [1, 4, 9, 16] 保留指定小数位数var num =2.443242342; num = num.toFixed(4); // num will be equal to 2.4432 注意，toFixec()返回的是字符串，不是数字。 浮点计算的问题0.1 + 0.2 === 0.3 // is false 9007199254740992 + 1 // is equal to 9007199254740992 9007199254740992 + 2 // is equal to 9007199254740994 为什么呢？因为0.1+0.2等于0.30000000000000004。JavaScript的数字都遵循IEEE 754标准构建，在内部都是64位浮点小数表示，具体可以参见JavaScript中的数字是如何编码的. 可以通过使用toFixed()和toPrecision()来解决这个问题 通过for-in循环检查对象的属性下面这样的用法，可以防止迭代的时候进入到对象的原型属性中。 for (var name in object) { if (object.hasOwnProperty(name)) { // do something with name } } 逗号操作符var a = 0; var b = ( a++, 99 ); console.log(a); // a will be equal to 1 console.log(b); // b is equal to 99 临时存储用于计算和查询的变量在jQuery选择器中，可以临时存储整个DOM元素 var navright = document.querySelector(&#39;#right&#39;); var navleft = document.querySelector(&#39;#left&#39;); var navup = document.querySelector(&#39;#up&#39;); var navdown = document.querySelector(&#39;#down&#39;); 提前检查传入 isFinite() 的参数isFinite(0/0) ; // false isFinite(&quot;foo&quot;); // false isFinite(&quot;10&quot;); // true isFinite(10); // true isFinite(undefined); // false isFinite(); // false isFinite(null); // true，这点当特别注意 避免在数组中使用负数做索引var numbersArray = [1,2,3,4,5]; var from = numbersArray.indexOf(&quot;foo&quot;) ; // from is equal to -1 numbersArray.splice(from,2); // will return [5] 注意传给splice的索引参数不要是负数，当是负数时，会从数组结尾处删除元素。 用JSON来序列化与反序列化var person = {name :&#39;Saad&#39;, age : 26, department : {ID : 15, name : &quot;R&amp;D&quot;} }; var stringFromPerson = JSON.stringify(person); /* stringFromPerson 结果为 &quot;{&quot;name&quot;:&quot;Saad&quot;,&quot;age&quot;:26,&quot;department&quot;:{&quot;ID&quot;:15,&quot;name&quot;:&quot;R&amp;D&quot;}}&quot; */ var personFromString = JSON.parse(stringFromPerson); /* personFromString 的值与 person 对象相同 */ 不要使用eval()或者函数构造器eval()和函数构造器（Function consturctor）的开销较大，每次调用，JavaScript引擎都要将源代码转换为可执行的代码。 var func1 = new Function(functionCode); var func2 = eval(functionCode); 避免使用with()使用with()可以把变量加入到全局作用域中，因此，如果有其它的同名变量，一来容易混淆，二来值也会被覆盖 不要对数组使用for-in避免： var sum = 0; for (var i in arrayNumbers) { sum += arrayNumbers[i]; } 而是: var sum = 0; for (var i = 0, len = arrayNumbers.length; i &lt; len; i++) { sum += arrayNumbers[i]; } 另外一个好处是，i和len两个变量是在for循环的第一个声明中，二者只会初始化一次，这要比下面这种写法快： for (var i = 0; i &lt; arrayNumbers.length; i++) 传给setInterval()和setTimeout()时使用函数而不是字符串如果传给setTimeout()和setInterval()一个字符串，他们将会用类似于eval方式进行转换，这肯定会要慢些，因此不要使用： setInterval(&#39;doSomethingPeriodically()&#39;, 1000); setTimeout(&#39;doSomethingAfterFiveSeconds()&#39;, 5000); 而是用： setInterval(doSomethingPeriodically, 1000); setTimeout(doSomethingAfterFiveSeconds, 5000); 使用switch/case代替一大叠的if/else当判断有超过两个分支的时候使用switch/case要更快一些，而且也更优雅，更利于代码的组织，当然，如果有超过10个分支，就不要使用switch/case了。 在switch/case中使用数字区间其实，switch/case中的case条件，还可以这样写： function getCategory(age) { var category = &quot;&quot;; switch (true) { case isNaN(age): category = &quot;not an age&quot;; break; case (age &gt;= 50): category = &quot;Old&quot;; break; case (age &lt;= 20): category = &quot;Baby&quot;; break; default: category = &quot;Young&quot;; break; }; return category; } getCategory(5); // 将返回 &quot;Baby&quot; 使用对象作为对象的原型下面这样，便可以给定对象作为参数，来创建以此为原型的新对象： function clone(object) { function OneShotConstructor(){}; OneShotConstructor.prototype = object; return new OneShotConstructor(); } clone(Array).prototype ; // [] HTML字段转换函数function escapeHTML(text) { var replacements= {&quot;&lt;&quot;: &quot;&amp;lt;&quot;, &quot;&gt;&quot;: &quot;&amp;gt;&quot;,&quot;&amp;&quot;: &quot;&amp;amp;&quot;, &quot;\&quot;&quot;: &quot;&amp;quot;&quot;}; return text.replace(/[&lt;&gt;&amp;&quot;]/g, function(character) { return replacements[character]; }); } 不要在循环内部使用try-catch-finallytry-catch-finally中catch部分在执行时会将异常赋给一个变量，这个变量会被构建成一个运行时作用域内的新的变量。切忌： var object = [&#39;foo&#39;, &#39;bar&#39;], i; for (i = 0, len = object.length; i &lt;len; i++) { try { // do something that throws an exception } catch (e) { // handle exception } } 而应该： var object = [&#39;foo&#39;, &#39;bar&#39;], i; try { for (i = 0, len = object.length; i &lt;len; i++) { // do something that throws an exception } } catch (e) { // handle exception } 使用XMLHttpRequests时注意设置超时XMLHttpRequests在执行时，当长时间没有响应（如出现网络问题等）时，应该中止掉连接，可以通过setTimeout()来完成这个工作： var xhr = new XMLHttpRequest (); xhr.onreadystatechange = function () { if (this.readyState == 4) { clearTimeout(timeout); // do something with response data } } var timeout = setTimeout( function () { xhr.abort(); // call error callback }, 60*1000 /* timeout after a minute */ ); xhr.open(&#39;GET&#39;, url, true); xhr.send(); 同时需要注意的是，不要同时发起多个XMLHttpRequests请求。 处理WebSocket的超时通常情况下，WebSocket连接创建后，如果30秒内没有任何活动，服务器端会对连接进行超时处理，防火墙也可以对单位周期没有活动的连接进行超时处理。 为了防止这种情况的发生，可以每隔一定时间，往服务器发送一条空的消息。可以通过下面这两个函数来实现这个需求，一个用于使连接保持活动状态，另一个专门用于结束这个状态。 var timerID = 0; function keepAlive() { var timeout = 15000; if (webSocket.readyState == webSocket.OPEN) { webSocket.send(&#39;&#39;); } timerId = setTimeout(keepAlive, timeout); } function cancelKeepAlive() { if (timerId) { cancelTimeout(timerId); } } keepAlive()函数可以放在WebSocket连接的onOpen()方法的最后面，cancelKeepAlive()放在onClose()方法的最末尾 时间注意原始操作符比函数调用快，使用VanillaJS比如，一般不要这样： var min = Math.min(a,b); A.push(v); 可以这样来代替： var min = a &lt; b ? a : b; A[A.length] = v; 开发时注意代码结构，上线前检查并压缩JavaScript代码可以使用JSLint或JSMin等工具来检查并压缩代码。]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10个最佳ES6特性]]></title>
    <url>%2F2018%2F02%2F26%2FJs%2F10%E4%B8%AA%E6%9C%80%E4%BD%B3ES6%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[10个最佳ES6特性原文地址 ES6，正式名称是ECMAScript2015，但是ES6这个名称更加简洁。ES6已经不再是JavaScript最新的标准，但是它已经广泛用于编程实践中。如果你还没用过ES6，现在还不算太晚… 函数参数默认值不使用ES6为函数设置默认值 function foo(height, color) { var height = height || 50; var color = color || &#39;red&#39;; //... } 这样写一般没问题，但是，当参数的布尔值为false时，是会出事情的！比如，我们这样调用foo函数： foo(0, &quot;&quot;, &quot;&quot;) 因为0的布尔值为false，这样height的取值将是50。同理color的取值为’red’。使用ES6 function foo(height = 50, color = &#39;red&#39;) { // ... } 模板字符串不使用ES6使用+号将变量拼接成字符串 var name = &#39;Your name is &#39; + first + &#39; &#39; + last + &#39;.&#39; 使用ES6将变量放到括号中 var name = `Your name is ${first} ${last}.` ES6的写法更加简洁、直观。 多行字符串不使用ES6使用”nt”将多行字符串拼接起来： var roadPoem = &#39;Then took the other, as just as fair,\n\t&#39; + &#39;And having perhaps the better claim\n\t&#39; + &#39;Because it was grassy and wanted wear,\n\t&#39; + &#39;Though as for that the passing there\n\t&#39; + &#39;Had worn them really about the same,\n\t&#39; 使用ES6将多行字符串放在反引号之间就好了： var roadPoem = `Then took the other, as just as fair, And having perhaps the better claim Because it was grassy and wanted wear, Though as for that the passing there Had worn them really about the same,` 解构赋值不使用ES6当需要获取某个对象的属性值时，需要单独获取： var data = $(&#39;body&#39;).data(); // data有house和mouse属性 var house = data.house; var mouse = data.mouse; 使用ES6一次性获取对象的子属性： var { house, mouse} = $(&#39;body&#39;).data() 对于数组也是一样的： var [col1, col2] = $(&#39;.column&#39;)； 对象属性简写不使用ES6对象中必须包含属性和值，显得非常多余： var bar = &#39;bar&#39;; var foo = function () { // ... } var baz = { bar: bar, foo: foo }; 使用ES6对象中直接写变量，非常简单： var bar = &#39;bar&#39;; var foo = function(){// ...} var baz = {bar,foo} 箭头函数不使用ES6普通函数体内的this，指向调用时所在的对象。 function foo(){ console.log(this.id); } var id = 1; foo(); // 输出1 foo.call({ id: 2 }); // 输出2 使用ES6箭头函数体内的this，就是定义时所在的对象，而不是调用时所在的对象。 var foo = () =&gt; { console.log(this.id); } var id = 1; foo(); // 输出1 foo.call({ id: 2 }); // 输出1 promise不使用ES6嵌套两个setTimeout回调函数： setTimeout(function() { console.log(&#39;Hello&#39;); // 1秒后输出&quot;Hello&quot; setTimeout(function() { console.log(&#39;Fundebug&#39;); // 2秒后输出&quot;Fundebug&quot; }, 1000); }, 1000); 使用ES6使用两个then是异步编程串行化，避免了回调地狱： var wait1000 = new Promise(function(resolve, reject) { setTimeout(resolve, 1000); }); wait1000 .then(function() { console.log(&quot;Hello&quot;); // 1秒后输出&quot;Hello&quot; return wait1000; }) .then(function() { console.log(&quot;Fundebug&quot;); // 2秒后输出&quot;Fundebug&quot; }); let与const使用Varvar定义的变量未函数级作用域： { var a = 10; } console.log(a); // 输出10 使用let与constlet定义的变量为块级作用域，因此会报错：(如果你希望实时监控JavaScript应用的错误，欢迎免费使用Fundebug) { let a = 10; } console.log(a); // 报错“ReferenceError: a is not defined” const与let一样，也是块级作用域。const是用来定义常量 类不使用ES6使用构造函数创建对象： function Point(x, y) { this.x = x; this.y = y; this.add = function() { return this.x + this.y; }; } var p = new Point(1, 2); console.log(p.add()); // 输出3 使用ES6使用Class定义类，更加规范，且你能够继承： class Point { constructor(x, y) { this.x = x; this.y = y; } add() { return this.x + this.y; } } var p = new Point(1, 2); console.log(p.add()); // 输出3 模块化JavaScript一直没有官方的模块化解决方案，开发者在实践中主要采用CommonJS和AMD规范。而ES6制定了模块(Module)功能。 不使用ES6Node.js采用CommenJS规范实现了模块化，而前端也可以采用，只是在部署时需要使用Browserify等工具打包。这里不妨介绍一下CommenJS规范。 module.js中使用module.exports导出port变量和getAccounts函数： module.exports = { port: 3000, getAccounts: function() { ... } } main.js中使用require导入module.js： var service = require(&#39;module.js&#39;) console.log(service.port) // 输出3000 使用ES6ES6中使用export与import关键词实现模块化。 module.js中使用export导出port变量和getAccounts函数： export var port = 3000 export function getAccounts(url) { ... } main.js中使用import导入module.js，可以指定需要导入的变量： import {port, getAccounts} from &#39;module&#39; console.log(port) // 输出3000 也可以将全部变量导入： import * as service from &#39;module&#39; console.log(service.port) // 3000]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React 技术栈]]></title>
    <url>%2F2018%2F02%2F25%2FReact%2FReact-%E6%8A%80%E6%9C%AF%E6%A0%88%2F</url>
    <content type="text"><![CDATA[React 技术栈系列原文地址 ES6教程 Bable教程 React教程 示例 Webpack Flex教程 示例 Css Modules 示例 React-router 示例 [Flux 架构] 示例 示例 Redux架构 教程一 教程二 教程三 Mocha测试框架 教程 示例 Istanbul 覆盖率框架教程 React 单元测试教程 示例]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp配置及使用]]></title>
    <url>%2F2018%2F02%2F24%2FTools%2Fgulp%E9%85%8D%E7%BD%AE%E5%8F%8A%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[gulp 入门指南1.全局安装 gulp：$ npm install --global gulp 2.作为项目的开发依赖（devDependencies）安装：$ npm install --save-dev gulp 3. 在项目根目录下创建一个名为 gulpfile.js 的文件：var gulp = require(&#39;gulp&#39;); gulp.task(&#39;default&#39;, function() { // 将你的默认的任务代码放在这 }); 4. 运行 gulp：$ gulp 五个gulp命令: gulp.task(name[, deps], fn) 定义任务 name：任务名称 deps：依赖任务名称 fn：回调函数gulp.run(tasks…)：尽可能多的并行运行多个taskgulp.watch(glob, fn)：当glob内容发生改变时，执行fngulp.src(glob)：置需要处理的文件的路径，可以是多个文件以数组的形式，也可以是正则gulp.dest(path[, options])：设置生成文件的路径 package.json文件{ &quot;name&quot;: &quot;yunbaodan&quot;, &quot;version&quot;: &quot;1.0.0&quot;, &quot;description&quot;: &quot;2.0升级&quot;, &quot;main&quot;: &quot;gulpfile.js&quot;, &quot;scripts&quot;: { &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot; }, &quot;author&quot;: &quot;zhang&quot;, &quot;license&quot;: &quot;ISC&quot;, &quot;devDependencies&quot;: { &quot;del&quot;: &quot;^3.0.0&quot;, &quot;gulp&quot;: &quot;^3.9.1&quot;, &quot;gulp-autoprefixer&quot;: &quot;^4.0.0&quot;, &quot;gulp-cache&quot;: &quot;^1.0.1&quot;, &quot;gulp-clean&quot;: &quot;^0.3.2&quot;, &quot;gulp-concat&quot;: &quot;^2.6.1&quot;, &quot;gulp-gh-pages&quot;: &quot;^0.5.4&quot;, &quot;gulp-htmlmin&quot;: &quot;^3.0.0&quot;, &quot;gulp-imagemin&quot;: &quot;^4.0.0&quot;, &quot;gulp-jshint&quot;: &quot;^2.0.4&quot;, &quot;gulp-less&quot;: &quot;^3.3.2&quot;, &quot;gulp-livereload&quot;: &quot;^3.8.1&quot;, &quot;gulp-minify-css&quot;: &quot;^1.2.4&quot;, &quot;gulp-notify&quot;: &quot;^3.0.0&quot;, &quot;gulp-postcss&quot;: &quot;^7.0.0&quot;, &quot;gulp-rename&quot;: &quot;^1.2.2&quot;, &quot;gulp-ruby-sass&quot;: &quot;^2.1.1&quot;, &quot;gulp-file-include&quot;: &quot;^2.0.0&quot;, &quot;gulp-sass&quot;: &quot;^3.1.0&quot;, &quot;gulp-uglify&quot;: &quot;^3.0.0&quot;, &quot;gulp-webserver&quot;: &quot;^0.9.1&quot;, &quot;jshint&quot;: &quot;^2.9.5&quot;, &quot;postcss-px-to-viewport&quot;: &quot;^0.0.3&quot;, &quot;postcss-write-svg&quot;: &quot;jonathantneal/postcss-write-svg&quot; } } gulpfile.js 配置/** * Created by mac on 2017/11/9. */ //导入工具包 require(&#39;node_modules里对应模块&#39;) var gulp = require(&#39;gulp&#39;), postcss = require(&#39;gulp-postcss&#39;), pxtoviewport = require(&#39;postcss-px-to-viewport&#39;),//将px单位换位vw单位 sass = require(&#39;gulp-sass&#39;),// CSS预处理/Sass编译 autoprefixer = require(&#39;gulp-autoprefixer&#39;),//添加前缀 minifycss = require(&#39;gulp-minify-css&#39;),//添加css压缩文件 jshint = require(&#39;gulp-jshint&#39;),//js代码校正 uglify = require(&#39;gulp-uglify&#39;),//js代码压缩 imagemin = require(&#39;gulp-imagemin&#39;),//图片压缩 rename = require(&#39;gulp-rename&#39;),//重命名 clean = require(&#39;gulp-clean&#39;),//清除原来文件 concat = require(&#39;gulp-concat&#39;),//合并文件 notify = require(&#39;gulp-notify&#39;),//处理报错 cache = require(&#39;gulp-cache&#39;),//文件对比 livereload = require(&#39;gulp-livereload&#39;),//监听文件发生变化，浏览器自动刷新 webserver = require(&#39;gulp-webserver&#39;),//开启服务器 ghPages = require(&#39;gulp-gh-pages&#39;),//README.md编译成html htmlmin = require(&#39;gulp-htmlmin&#39;),//html压缩 fileinclude = require(&#39;gulp-file-include&#39;);//html模板引擎 // 样式 gulp.task(&#39;styles&#39;, function() { var processors = [ pxtoviewport({ viewportWidth: 375, viewportUnit: &#39;vw&#39; }) ]; return gulp.src(&#39;src/styles/*.scss&#39;) .pipe(sass({ style: &#39;expanded&#39;, })) .pipe(autoprefixer(&#39;last 2 version&#39;, &#39;safari 5&#39;, &#39;ie 8&#39;, &#39;ie 9&#39;, &#39;opera 12.1&#39;, &#39;ios 6&#39;, &#39;android 4&#39;)) .pipe(gulp.dest(&#39;dist/styles&#39;)) .pipe(rename({ suffix: &#39;.min&#39; })) .pipe(minifycss()) .pipe(gulp.dest(&#39;dist/styles&#39;)) .pipe(notify({ message: &#39;Styles task complete&#39; })) .pipe(postcss(processors)) .pipe(gulp.dest(&#39;dist/styles&#39;)) .pipe( postcss([ require(&#39;postcss-write-svg&#39;)({ /* options */ }) ]) ).pipe( gulp.dest(&#39;dist/styles&#39;) ); }); // js gulp.task(&#39;scripts&#39;, function() { return gulp.src(&#39;src/scripts/*.js&#39;) .pipe(jshint.reporter(&#39;default&#39;))//检测js代码错误 .on(&#39;error&#39;, function (err) { console.error(&#39;Error!&#39;, err.message); // 显示错误信息 }) .pipe(rename({ suffix: &#39;.min&#39; }))// 重命名 .pipe(uglify()) .pipe(gulp.dest(&#39;dist/scripts&#39;)) .pipe(notify({ message: &#39;Scripts task complete&#39; })); }); // 图片 gulp.task(&#39;images&#39;, function() { return gulp.src(&#39;src/images/*&#39;) .pipe(cache(imagemin({ optimizationLevel: 3, progressive: true, interlaced: true }))) // .pipe(imagemin({ // progressive: true, // 无损压缩JPG图片 // svgoPlugins: [{removeViewBox: false}], // 不要移除svg的viewbox属性 // use: [pngquant()] // 深度压缩PNG // })) .pipe(gulp.dest(&#39;dist/images&#39;)) .pipe(notify({ message: &#39;Images task complete&#39; })); }); //html gulp.task(&#39;html&#39;,function () { return gulp.src(&#39;./*.html&#39;) .pipe(gulp.dest(&#39;./&#39;)) .pipe(notify({ message: &#39;html task complete&#39; })); }); gulp.task(&#39;fileinclude&#39;, function() { return gulp.src(&#39;./*.html&#39;) .pipe(fileinclude({ prefix: &#39;@@&#39;, basepath: &#39;@file&#39; })) .pipe(gulp.dest(&#39;dist&#39;)); }); // 清理 gulp.task(&#39;clean&#39;, function() { return gulp.src([&#39;dist/styles&#39;, &#39;dist/scripts&#39;, &#39;dist/images&#39;], {read: false}) .pipe(clean()); }); //自动刷新 gulp.task(&#39;webserver&#39;,[&#39;fileinclude&#39;],function () { return gulp.src( &#39;dist/&#39; ) // 服务器目录（./代表根目录） .pipe(webserver({ // 运行gulp-webserver livereload: true, // 启用LiveReload open: true // 服务器启动时自动打开网页 })); }); // 预设任务及监听 gulp.task(&#39;default&#39;, [&#39;webserver&#39;], function() { gulp.run(&#39;styles&#39;, &#39;scripts&#39;, &#39;images&#39;); // 看守所有.scss档 gulp.watch(&#39;src/styles/*.scss&#39;, [&#39;styles&#39;]); // 看守所有.js档 gulp.watch(&#39;src/scripts/*.js&#39;, [&#39;scripts&#39;]); // 看守所有图片档 gulp.watch(&#39;src/images/*.*&#39;, [&#39;images&#39;]); //监听根目录下的所有html文件 gulp.watch( &#39;*.html&#39;, [&#39;html&#39;]); // 监听根目录下所有.html文件 }); gulp.task(&#39;deploy&#39;, function() { return gulp.src(&#39;./dist/**/*&#39;) .pipe(ghPages()); }); gulp.task(&#39;testhtmlmin&#39;,function () { var options = { removeComments:true, collapseWhitespace:true, collapseBooleanAttributes:true, removeEmptyAttributes:true, removeScriptTypeAttributes:true, removeStyleLinkTypeAttributes:true, minifyJs:true, minifyCss:true } gulp.src(&#39;lemonhotel/*.html&#39;) .pipe(htmlmin(options)) .pipe(gulp.dest(&#39;html/build&#39;)) });]]></content>
      <categories>
        <category>Tools</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[只有20行Javascript代码！手把手教你写一个页面模板引擎]]></title>
    <url>%2F2018%2F02%2F24%2FJs%2F%E5%8F%AA%E6%9C%8920%E8%A1%8CJavascript%E4%BB%A3%E7%A0%81%EF%BC%81%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%86%99%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[原文地址 var TemplateEngine = function(html, options) { var re = /&lt;%([^%&gt;]+)?%&gt;/g, reExp = /(^( )?(if|for|else|switch|case|break|{|}))(.*)?/g, code = &#39;var r=[];\n&#39;, cursor = 0; //正则捕获所有以&lt;%开头，以%&gt;结尾的片段 var add = function(line, js) { js? (code += line.match(reExp) ? line + &#39;\n&#39; : &#39;r.push(&#39; + line + &#39;);\n&#39;) : (code += line != &#39;&#39; ? &#39;r.push(&quot;&#39; + line.replace(/&quot;/g, &#39;\\&quot;&#39;) + &#39;&quot;);\n&#39; : &#39;&#39;); return add; }//使用条件判断和循环,复杂逻辑 while(match = re.exec(html)) { add(html.slice(cursor, match.index))(match[1], true); cursor = match.index + match[0].length; } add(html.substr(cursor, html.length - cursor)); code += &#39;return r.join(&quot;&quot;);&#39;;//把所有的字符串放在一个数组里，在程序的最后把它们拼接起来。 return new Function(code.replace(/[\r\t\n]/g, &#39;&#39;)).apply(options);//把原本返回模板字符串的语句替换成如下的内容 }]]></content>
      <categories>
        <category>Js</category>
      </categories>
      <tags>
        <tag>Js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[后HTML5时代]]></title>
    <url>%2F2018%2F02%2F23%2FHTML5%2F%E5%90%8EHTML5%E6%97%B6%E4%BB%A3%2F</url>
    <content type="text"><![CDATA[HTML5 Device API原文地址 让音乐随心而动 - 音频处理 Web audio APIAudio对象提供的只是音频文件的播放，而Web Audio则是给了开发者对音频数据进行分析、处理的能力，比如混音、过滤。 系统要求 :ios6+、android chrome、android firefox 核心代码 : var context = new webkitAudioContext(); var source = context.createBufferSource(); // 创建一个声音源 source.buffer = buffer; // 告诉该源播放何物 createBufferSourcesource.connect(context.destination); // 将该源与硬件相连 source.start(0); //播放 技术分析 : 当我们加载完音频数据后，我们将创建一个全局的AudioContext对象来对音频进行处理，AudioContext可以创建各种不同功能类型的音频节点AudioNode 1.源节点（source node）1.audio标签var sound, audio = new Audio(); audio.addEventListener(&#39;canplay&#39;, function() { sound = context.createMediaElementSource(audio); sound.connect(context.destination); }); audio.src = &#39;/audio.mp3&#39;; 2.XMLHttpRequestvar sound, context = createAudioContext(); var audioURl = &#39;/audio.mp3&#39;; // 音频文件URL var xhr = new XMLHttpRequest(); xhr.open(&#39;GET&#39;, audioURL, true); xhr.responseType = &#39;arraybuffer&#39;; xhr.onload = function() { context.decodeAudioData(request.response, function (buffer) { source = context.createBufferSource(); source.buffer = buffer; source.connect(context.destination); } } xhr.send(); 2.分析节点（analyser node）var audioCtx = new (window.AudioContext || window.webkitAudioContext)(); var analyser = audioCtx.createAnalyser(); analyser.fftSize = 2048; var bufferLength = analyser.frequencyBinCount; var dataArray = new Uint8Array(bufferLength); analyser.getByteTimeDomainData(dataArray); function draw() { drawVisual = requestAnimationFrame(draw); analyser.getByteTimeDomainData(dataArray); // 将dataArray数据以canvas方式渲染出来 }; draw(); 3.处理节点（gain node、panner node、wave shaper node、delay node、convolver node等）不同的处理节点有不同的作用，比如使用BiquadFilterNode调整音色（大量滤波器）、使用ChannelSplitterNode分割左右声道、使用GainNode调整增益值实现音乐淡入淡出等等。需要了解更多的音频节点可能参考：https://developer.mozilla.org/en-US/docs/Web/API/Web_Audio_API 4.目的节点（destination node）所有被渲染音频流到达的最终地点 捕捉用户摄像头 - 媒体流 Media Capture通过getUserMedia捕捉用户摄像头获取视频流和通过麦克风获取用户声音。 系统要求 :android chrome、android firefox 核心代码 : 1、摄像头捕捉navigator.webkitGetUserMedia ({video: true}, function(stream) { video.src = window.URL.createObjectURL(stream); localMediaStream = stream; }, function(e){ }) 2、从视频流中拍照btnCapture.addEventListener(&#39;touchend&#39;, function(){ if (localMediaStream) { canvas.setAttribute(&#39;width&#39;, video.videoWidth); canvas.setAttribute(&#39;height&#39;, video.videoHeight); ctx.drawImage(video, 0, 0); } }, false); 3、用户声音录制navigator.getUserMedia({audio:true}, function(e) { context = new audioContext(); audioInput = context.createMediaStreamSource(e); volume = context.createGain(); recorder = context.createScriptProcessor(2048, 2, 2); recorder.onaudioprocess = function(e){ recordingLength += 2048; recorder.connect (context.destination); } }, function(error){}); 4、保存用户录制的声音var buffer = new ArrayBuffer(44 + interleaved.length * 2); var view = new DataView(buffer); fileReader.readAsDataURL(blob); // android chrome audio不支持blob … audio.src = event.target.result; 你是逗逼？ - 语音识别 Web Speech API将文本转换成语音；将语音识别为文本。 系统要求 :ios7+，android chrome，android firefox 核心代码 : 1、文本转换成语音，使用SpeechSynthesisUtterance对象.var msg = new SpeechSynthesisUtterance(); var voices = window.speechSynthesis.getVoices(); msg.volume = 1; // 0 to 1 msg.text = ‘识别的文本内容’; msg.lang = &#39;en-US&#39;; speechSynthesis.speak(msg); 2、语音转换为文本，使用SpeechRecognition对象. var newRecognition = new webkitSpeechRecognition(); newRecognition.onresult = function(event){ var interim_transcript = &#39;&#39;; for (var i = event.resultIndex; i &lt; event.results.length; ++i) { final_transcript += event.results[i][0].transcript; } }; 测试结论：Android支持不稳定；语音识别测试失败（暂且认为是某些内置接口被墙所致）。 让我尽情呵护你 - 设备电量 Battery API查询用户设备电量及是否正在充电。 系统要求 :android firefox 核心代码 ： var battery = navigator.battery || navigator.webkitBattery || navigator.mozBattery || navigator.msBattery; var str = &#39;&#39;; if (battery) { str += &#39;&lt;p&gt;你的浏览器支持HTML5 Battery API&lt;/p&gt;&#39;; if(battery.charging) { str += &#39;&lt;p&gt;你的设备正在充电&lt;/p&gt;&#39;; } else { str += &#39;&lt;p&gt;你的设备未处于充电状态&lt;/p&gt;&#39;; } str += &#39;&lt;p&gt;你的设备剩余&#39;+ parseInt(battery.level*100)+&#39;%的电量&lt;/p&gt;&#39;; } else { str += &#39;&lt;p&gt;你的浏览器不支持HTML5 Battery API&lt;/p&gt;&#39;; } 测试结论 ：1、QQ浏览器与UC浏览器支持该接口，但未正确显示设备电池信息；2、caniuse显示android chrome42支持该接口，实测不支持。 获取用户位置 - 地理位置 Geolocation APIGeolocation API用于将用户当前地理位置信息共享给信任的站点，目前主流移动设备都能够支持。 系统要求 :ios6+、android2.3+ 核心代码： var domInfo = $(&quot;#info&quot;); // 获取位置坐标 if (navigator.geolocation) { navigator.geolocation.getCurrentPosition(showPosition,showError); } else{ domInfo.innerHTML=&quot;抱歉，你的浏览器不支持地理定位！&quot;; } // 使用腾讯地图显示位置 function showPosition(position) { var lat=position.coords.latitude; var lon=position.coords.longitude; mapholder = $(&#39;#mapholder&#39;) mapholder.style.height=&#39;250px&#39;; mapholder.style.width = document.documentElement.clientWidth + &#39;px&#39;; var center = new soso.maps.LatLng(lat, lon); var map = new soso.maps.Map(mapholder,{ center: center, zoomLevel: 13 }); var geolocation = new soso.maps.Geolocation(); var marker = null; geolocation.position({}, function(results, status) { console.log(results); var city = $(&quot;#info&quot;); if (status == soso.maps.GeolocationStatus.OK) { map.setCenter(results.latLng); domInfo.innerHTML = &#39;你当前所在城市: &#39; + results.name; if (marker != null) { marker.setMap(null); } // 设置标记 marker = new soso.maps.Marker({ map: map, position:results.latLng }); } else { alert(&quot;检索没有结果，原因: &quot; + status); } }); } 测试结论： 1、Geolocation API的位置信息来源包括GPS、IP地址、RFID、WIFI和蓝牙的MAC地址、以及GSM/CDMS的ID等等。规范中没有规定使用这些设备的先后顺序。2、初测3g环境下比wifi环境理定位更准确；3、测试三星 GT-S6358(android2.3) geolocation存在，但显示位置信息不可用POSITION_UNAVAILABLE。 把用户捧在手心 - 环境光 Ambient Light APIAmbient Light API定义了一些事件，这些时间可以提供源于周围光亮程度的信息，这通常是由设备的光感应器来测量的。设备的光感应器会提取出辉度信息。 系统要求 :android firefox 核心代码：这段代码实现感应用前当前环境光强度，调整网页背景和文字颜色。 var domInfo = $(&#39;#info&#39;); if (!(&#39;ondevicelight&#39; in window)) { domInfo.innerHTML = &#39;你的设备不支持环境光Ambient Light API&#39;; } else { var lightValue = document.getElementById(&#39;dl-value&#39;); window.addEventListener(&#39;devicelight&#39;, function(event) { domInfo.innerHTML = &#39;当前环境光线强度为：&#39; + Math.round(event.value) + &#39;lux&#39;; var backgroundColor = &#39;rgba(0,0,0,&#39;+(1-event.value/100) +&#39;)&#39;; document.body.style.backgroundColor = backgroundColor; if(event.value &lt; 50) { document.body.style.color = &#39;#fff&#39; } else { document.body.style.color = &#39;#000&#39; } }); } 陀螺仪 Deviceorientation装逼说法：设备移动传感器。 通俗说法：检测设备运动及运动状况，可以通过该接口获取到设备运动的方向和速度等相关信息 核心代码 :这货其实就是一个事件，简单地通过事件监听就可以获取到相关的设备运动信息 window.addEventListener(&quot;devicemotion&quot;, function(event) {}, false); 最简单的设备运动，我们基本上可以认为是前后、左右、上下这么6个方向上的，装换成3D环境中来讲的话，就是在x、y和z轴上运动，这三个轴上的信息，都包含在了event对象中。我们可以通过这种方式获得 window.addEventListener(&quot;devicemotion&quot;, function(event) { var eventacceleration = event.acceleration; document.querySelector(&#39;#devicemotion&#39;).innerHTML = &quot;acceleration:&lt;br&gt;&quot;+ eventacceleration.x+&quot;&lt;br&gt;&quot;+ eventacceleration.y+&quot;&lt;br&gt;&quot;+ eventacceleration.z }, false); 不要问我为什么手机躺在桌面上，上面的数字还在不停地抖动，咱们文化人应该都知道什么叫相对静止。上面的三个不断变化的数字，就是你设备的运动数据了。如果你在惊讶为什么我都已经移动过手机，为什么上面的数字貌似也没什么大的变化~那么我会告诉你说：有本事你的眼睛跟着你的手机一样快速移动啊，运动过程中你就能发现这个值的变化了。没有这个本事吧！~自己尝试修改下那个demo。把运动中值的变化都记录下来看看。。。（PS：反正我不弄。） 还有一种比较理想的设备运动方式就是不产生位移，只是快速的旋转手机。这个旋转的信息同样也被反馈在了event对象中 window.addEventListener(&quot;devicemotion&quot;, function(event) { eventrotationRate = event.rotationRate; document.querySelector(&#39;#devicemotion&#39;).innerHTML = &#39;rotationRate:&lt;br&gt;&#39;+ eventrotationRate.alpha+&#39;&lt;br&gt;&#39;+ eventrotationRate.beta+&quot;&lt;br&gt;&quot;+ eventrotationRate.gamma }, false); 可能有的童鞋会觉得~有了这个旋转应该就能实现一些手机左右旋转产生视差的效果了，其实是不行的~因为这货和上面的一样，设备停止后，我们可以认为他的值归0~。真正想要实现手机旋转视差，我们需要用到的就是另外一个event的属性accelerationIncludingGravity。从字面上理解这个属性就是重力加速度。 window.addEventListener(&quot;devicemotion&quot;, function(event) { eventaccelerationIncludingGravity = event.accelerationIncludingGravity; document.querySelector(&#39;#devicemotion&#39;).innerHTML = &quot;accelerationIncludingGravity:&lt;br&gt;&quot;+ eventaccelerationIncludingGravity.x+&quot;&lt;br&gt;&quot;+ eventaccelerationIncludingGravity.y+&quot;&lt;br&gt;&quot;+ eventaccelerationIncludingGravity.z }, false); 其实，devicemotion还有一个好基友，这里也推荐给大家看一眼吧： deviceorientation这个事件和devicemotion的使用方法基本一致 window.addEventListener(&quot;deviceorientation&quot;, function(event) { document.querySelector(&#39;#deviceorientation&#39;).innerHTML = event.alpha+&#39;&lt;br&gt;&#39;+ event.beta+&quot;&lt;br&gt;&quot;+ event.gamma+&#39;&lt;br&gt;&#39;; }, false); 有前面devicemotion好基友的帮忙，似乎能做的东西又可以更多一点了。咱们前面貌似提及过&ldquo;喝前摇一摇&rdquo;。摇完之后，自然是要打开瓶盖痛饮一番了，结合旋转加速度，我们是不是可以尝试些一个拧瓶盖比赛的游戏了？怕长胖？要不，拧个螺丝钉也行。 Websocket浏览器与服务器全双工通信(full-duplex)。 核心代码 ： var ws = new WebSocket(&#39;ws://127.0.0.1:8808/&#39;);//建立服务器连接ws.onopen = function(){ systemInfo.innerHTML = &#39;&lt;p&gt;和websocket服务器连接成功&lt;/p&gt;&#39;; }//接收到服务器返回的数据ws.onmessage = function(e){ systemInfo.innerHTML += &#39;&lt;p&gt;&#39;+e.data+&#39;&lt;/p&gt;&#39;; }//断开服务器连接ws.onclose = function(){ systemInfo.innerHTML += &#39;&lt;p&gt;WebSocket服务器连接关闭&lt;/p&gt;&#39;; }//ws发生错误ws.onerror = function(e){ console.log(e); systemInfo.innerHTML += &#39;&lt;p&gt;WebSocket发生错误&lt;/p&gt;&#39;; } 我们可以通过事件的监听，去实时获取到网络状态的变化 window.addEventListener(&#39;offline&#39;, function(e) {alert(&#39;offline&#39;);}) window.addEventListener(&#39;online&#39;, function(e) {alert(&#39;online&#39;);}) NFC近场通信/近距离无线通信技术。 其实说实在的，这个功能我并没有在我的页面里面调试出来。主要的一个原因是~这货目前只是在firefox os系统里面的firefox浏览器里面实现了，手头上没这设备。不过从他们官网的例子中，我大概地可以感受得到这货的好用，有兴趣的同学自行前往学习：[https://developer.mozilla.org/en-US/docs/Web/API/NFC_API/Using_the_NFC_API]https://developer.mozilla.org/en-US/docs/Web/API/NFC_API/Using_the_NFC_API. 震动 - Vibration API设备震动 核心代码 : navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate; navigator.vibrate(value); navigator.vibrate(0); vibrate的参数为震动的时间， 如果值为0，说明停止震动 值为一个数组的话，奇数项表示的是震动时间，偶数项表示的为间隔时间。 比如：vibrate(1000,1000,2000) 就是表示震动1秒之后暂停1秒，再震动2秒 网络环境 Connection API]]></content>
      <categories>
        <category>HTML5</category>
      </categories>
      <tags>
        <tag>HTML5</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native UI组件]]></title>
    <url>%2F2018%2F02%2F11%2Freact-native%2Freact-native%20Components%2F</url>
    <content type="text"><![CDATA[React-native Components(自己理解)react-native 官网react-native 中文官网 1.ActivityIndicator 显示一个圆形的loading提示符号。2.Button 按钮3.DataPickerIOS ios日期选择组件4.DrawerLayoutAndriod andriod抽屉导航5.FlatList 高性能简单列表组件6.Image 图片组件7.KeybordAvoiding View 手机上弹出的键盘常常会挡住当前的视图。本组件可以自动根据键盘的位置，调整自身的position或底部的padding，以避免被遮挡8.ListView 此组件已过期 请用selection 或 FlatLIst 替换9.MaskedViewIOS 遮罩渲染子视图（添加炫酷的背景）10.Modal Modal组件可以用来覆盖包含React Native根视图的原生视图 (可用作弹框遮罩)11.NavigatorIOS IOS 导航设置12.Picker 渲染原生的选择器（类似滚动地址选择）13.PickerIOS IOS选择器14.ProgressBarAndroid 安卓loading图标15.ProgressViewIOS IOS进度条16.RefreshControl 这一组件可以用在ScrollView或ListView内部，为其添加下拉刷新的功能。当ScrollView处于竖直方向的起点位置（scrollY: 0），此时下拉会触发一个onRefresh事件。17.ScrollView 滚动视图列表18.sectionList 分组列表(例如电话本的列表)19.SegmentedControlIOS IOS分段选择器20.Slider 用于选择一个范围值的组件。（例如选择音量的bar）21.SnapshotViewIOS IOS截图22.StatusBar 用于控制应用状态栏的组件。23.Switch 开关按钮24.TabBarIOS 带IOS或Android后缀的组件(底部导航及)25.TabBarIOS.Item （底部导航的新消息通知数量）26.Text 文本标签27.TextInput 文本输入框28.ToolbarAndroid 一个Toolbar可以显示一个徽标，一个导航图标（譬如汉堡形状的菜单按钮），一个标题与副标题，以及一个功能列表。29.TouchableHighlight 本组件用于封装视图，使其可以正确响应触摸操作。当按下的时候，封装的视图的不透明度会降低，同时会有一个底层的颜色透过而被用户看到，使得视图变暗或变亮。30.TouchableWithoutFeedback 响应用户的点击事件，如果你想在处理点击事件的同时不显示任何视觉反馈，使用它是个不错的选择。31. TouchableOpacity 相比TouchableHighlight在按下去会使背景变暗的效果，TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色32.TouchableNativeFeedback 它会在用户手指按下时形成类似水波纹的视觉效果。注意，此组件只支持Android。33.View 呈现的视图34.ViewPagerAndroid 一个允许在子视图之间左右翻页的容器。每一个ViewPagerAndroid的子容器会被视作一个单独的页，并且会被拉伸填满ViewPagerAndroid。（注意所有的子视图都必须是纯View）35.VirtualizedList FlatList and SectionList 的底层实现。 通过维护一个有限的渲染窗口（其中包含可见的元素），并将渲染窗口之外的元素全部用合适的定长空白空间代替的方式，极大的改善了内存消耗以及在有大量数据情况下的使用性能。36.WebView 用于包裹html的标签 （1.网址 2.引用路径 3.直接写html）]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[React-native API]]></title>
    <url>%2F2018%2F02%2F11%2Freact-native%2FReact-native-API%2F</url>
    <content type="text"><![CDATA[React-native API(自己理解)最近在学习react-native,而且重新利用hexo 构建了自己的主页。 之前也在csdn,简书也写过博客，打算利用空闲时间把博客迁移进来。 进入主题吧。react-native 官网react-native 中文官网 1.AccessibilityInfo 无障碍功能 给残障人士使用 2.ActionSheetIOS IOS底部弹出选择框 （分享，选择） 3.Alert 调用手机原生弹框 4.AlertIOS 启动一个提示对话框，包含对应的标题和信息。 5.Animated Animated库使得开发者可以非常容易地实现各种各样的动画和交互方式，并且具备极高的性能 6.AppRegistry AppRegistry是JS运行所有React Native应用的入口。 7.AppState AppState能告诉你应用当前是在前台还是在后台，并且能在状态变化的时候通知你。AppState通常在处理推送通知的时候用来决定内容和对应的行为。 8.AsyncStorage AsyncStorage是一个简单的、异步的、持久化的Key-Value存储系统，它对于App来说是全局性的。它用来代替LocalStorage。(react-native-storage模块，提供了较多便利功能。) 9.BackHandler 监听设备上的后退按钮事件。(仅限安卓) 10.CameraRoll CameraRoll模块提供了访问本地相册的功能 11.Clipboard Clipboard组件可以在iOS和Android的剪贴板中读写内容。 12.DatePickerAndroid 一个标准的Android日期选择器的对话框。 13.Dimensions 用于获取设备屏幕的宽高。 14.Easing 用于动画幅度 15.Geolocation 请求访问地理位置的权限 16.ImageEditor 根据指定的URI参数剪裁对应的图片 17.ImagePickerIOS 一个获取图片的 API（须百度详情） 18.ImageStore 图片缓存库 19.Image Style Props 可设置图片的属性样式 20.InteractionManager 提升用户体验和交互效果的模块InteractionMnager(交互管理器) 使用InteractionManager可以让一些耗时的任务在交互操作或者动画完成之后进行执行，这样使用可以保证我们的JavaScript的动画效果可以平滑流畅的执行。可以大大提升用户体验。（百度详情） 21.Keyboard Keyboard组件可以用来控制键盘相关的事件。 22.LayoutAnimation 当布局变化时，自动将视图运动到它们新的位置上。 23.Layout Props 可以设置的动画样式参数 24.Linking 直接打开网址，电话，短信的链接。Linking模块给我们提供了Android和iOS双平台通用的接口进行处理App进入和传出的链接。(百度详情) 25.ListViewDataSource 为ListView组件提供高性能的数据处理和访问 26.NativeMethodsMixin NativeMethodsMixin提供了一些用于直接访问底层原生组件的方法 27.NetInfo 模块可以获知设备联网或离线的状态信息。 28.PanResponder 可以将多点触摸操作协调成一个手势。它使得一个单点触摸可以接受更多的触摸操作，也可以用于识别简单的多点触摸手势。(百度详情) 29.PermissionsAndroid Permissions权限适配 30.PixelRatio 根据像素密度获取指定大小的图片 31.PushNotificationIOS 本模块帮助你处理应用的推送通知，包括权限控制以及应用图标上的角标数（未读消息数）。（查看ApI或百度详情） 32.Settings 设置 （获取，设置，监听，清除key值） 33.Shadow Props 设置阴影样式参数 34.Share 打开一个对话框来共享文本内容。 35.StatusBarIOS 用于控制应用状态栏的组件。 36.StyleSheet 设置样式的属性 37.Systrace 内存优化 38.Text Style Props 文本样式参数 39.TimePickerAndroid 安卓日期选择 40.ToastAndroid 用于在Android设备上显示一个悬浮的提示信息 41.Transforms 动画样式参数 42.Vibration 用于控制设备震动 43.VibrationIOS IOS版用于控制设备震动 44.View Style Props 设置视图样式参数从]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
</search>
