---
title: 什么是作用域和执行上下文
date: 2018-04-09 11:40:28
tags: "Js"
categories: "Js"
---

# 作用域

首先我们说下作用域，简单地来说作用域指的是一个区域，里面包括变量，函数，常量等等定义信息和赋值信息，以及这个区域内代码书写的结构信息。作用域可以嵌套，我们通常知道js函数内是可以产生作用域的。
下面我们用具体代码来示例下：

![scope](https://image-static.segmentfault.com/114/508/1145089023-5923b87dde95f_articlex)


`全局作用域`（global scope）里面定义了两个变量，一个函数。walk 函数生成的作用域里面定义了一个变量，两个函数。innerFunc 和 anotherInnerFunc 这两个函数生成的作用域里面分别定义了一个变量。在规范中作用域更官方的叫法是词法环境（Lexical Environments）。什么意思？就是作用域包含哪些内容取决于你代码怎么写，你把定义 go 变量写在了 walk 函数里面，那么 go 变量就属于` walk 函数作用域`。

> 作用域其实由两部分组成(全局作用域，局部作用域)
1.记录作用域内变量信息（我们假设变量，常量，函数等统称为变量）和代码结构信息的东西，称之为 Environment Record。
2.一个引用 `__outer__`，这个引用指向当前作用域的父作用域。拿上面代码为例。innerFunc 的函数作用域有一个引用指向 walk 函数作用域，walk 函数作用域有一个引用指向全局作用域。全局作用域的 `__outer__ `为 null。

## 生成作用域的语法
<!-- more -->
1.函数声明
```javascript
function f(){
    var inner = 'inner';
    console.log(inner);
}
f();//inner
console.log( inner );//Uncaught ReferenceError: inner is not defined
```

2.catch语句
```javascript

try {
  throw new Error( 'customized error' );
} catch( err ) {
  var iamnoterror = 'not error';
  console.log( iamnoterror ); // not error
  console.log( err ); // Error: customized error
}
console.log( iamnoterror ); // not error
console.log( err ); // Uncaught ReferenceError: e is not defined

```

catch语句生成的作用域只会框住参数部分的变量，使其不能在外部访问。对于 catch 语句体里面声明的变量并不起作用

3.语句块
```javascript
if ( true ) {
  let bv = 'bv';
  const B_C = 'BC';
  let blockFunc = function() {}
  function notBlockFunc() {}

  console.log( bv ); // bv
  console.log( B_C ); // BC
  console.log( notBlockFunc ); // function notBlockFunc() {}
  console.log( blockFunc ); // function () {}
  
}
console.log( bv ); // Uncaught ReferenceError: bv is not defined
console.log( B_C ); // Uncaught ReferenceError: B_C is not defined
console.log( notBlockFunc ); // function notBlockFunc() {}
console.log( blockFunc ); // ReferenceError: blockFunc is not defined
```

语句块 {} 会生成一个新的作用域，但是这个作用域只绑定块级变量，常量等，即 let，const 声明的属于块级作用域，而 var 声明的还是属于块级作用域的父作用域。

# 执行上下文（execution context）

执行上下文是用于跟踪代码的运行情况，其特征如下:

> * 一段代码块对应一个执行上下文，被封装成函数的代码被视作一段代码块，或者全局作用域也被视作一个代码块。

> * 当程序运行，进入到某段代码块时，一个新的执行上下文被创建，并被放入一个 stack 中。当程序运行到这段代码块结尾后，对应的执行上下文被弹出 stack

> * 当程序在某段代码块中运行到某个点需要转到了另一个代码块时（调用了另一个函数），那么当前的可执行上下文的状态会被置为挂起，然后生成一个新的可执行上下文放入 stack 的顶部。

> * stack 最顶部的可执行上下文被称为 running execution context。当顶部的可执行上下文被弹出后，上一个挂起的可执行上下文继续执行。

我们用代码来示例下（从 outer 调用到 level1 调用，再逐层返回）：
![outer](https://image-static.segmentfault.com/184/331/1843310870-5923b8a26d26a_articlex)


执行上下文对象的内部属性：

[[code evaluation]]：当前代码块执行的状态：prerform，suspend，resume。

[[Function]]：如果当前执行上下文对应的是一个函数，那么这个属性就保存的这个函数对象。如果对应的是全局环境（可以是一个 script 或者 module），属性值是 null。

[[Real]]：类似与沙箱的概念？（我还没有看懂，不过不太影响此篇的内容）

如果程序执行到某个点抛出异常了，那么我们可以用这个记录执行上下文的 stack 来追踪到底哪里出错了，可以看到整个调用栈，此时内部属性 [[Function]] 就起到作用了：

如果程序执行到某个点抛出异常了，那么我们可以用这个记录执行上下文的 stack 来追踪到底哪里出错了，可以看到整个调用栈，此时内部属性 [[Function]] 就起到作用了：

![error](https://image-static.segmentfault.com/604/427/604427279-5923b8b23e1a4_articlex)

# 作用域与执行上下文的关系

因为在一个函数被执行时，创建的执行上下文对象除了保存了些代码执行的信息，还会把当前的作用域保存在执行上下文中，所以他们的关系只是存储关系。


## 变量查找
结合作用域和执行上下文，我们再来看下变量查找的过程。其实第一步不是到作用域里面找 Environment Record，而是先从当前的执行上下文中找保存的作用域（对象），然后再是通过作用域链向上查找变量。而且同一个执行上下文保存的作用域（对象）是可变的，当代码在同一个执行上下文中执行的时候，如果碰到有必要生成一个新作用域的时候，这个新的作用域会被添加到作用域链的头部，然后执行上下文就保存的作用域对象就更新成这个新的作用域。等这个新的作用域生命周期完成后，作用域链又会恢复到之前的状况，然后执行上下文保存的作用域也会恢复成之前的
![示例](https://image-static.segmentfault.com/362/224/362224718-5923b8c5ad74b_articlex)

## this
网上有把执行上下文等同于 this 的文章，其实 this 的值是通过当前执行上下文中保存的作用域（对象）来获取到的，规范如下。

> ResolveThisBinding ( )
The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context. ResolveThisBinding performs the following steps:

1.Let envRec be GetThisEnvironment( ).

2.Return envRec.GetThisBinding().

[原文地址](https://segmentfault.com/a/1190000009522006)