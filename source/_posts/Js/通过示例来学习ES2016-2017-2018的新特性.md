---
title: '通过示例来学习ES2016, 2017, 2018的新特性'
date: 2018-07-17 18:27:44
tags: "ES6"
categories: "Js"
---
![es678](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/es_16_17_18.png)

# 前言

本文会辅以有用的例子来讲述TC39中的18个特性，它们分别在ES2016, ES2017和ES2018中加入。
鉴于本文内容很长，我们将分为两个部分来介绍，此为第一部分。

## ES6

### Array.prototype.includes

includes是一个Array上很有用的函数，用于快速查找数组中是否包含某个元素。(包括NaN，所以和indexOf不一样)。

![includes](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/includes.png)

### 指数函数的中缀形式

加/减法我们通常都是用其中缀形式，直观易懂。在ECMAScript2016中，我们可以使用`**`来替代`Math.pow`。

![pow](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/pow.png)
<!-- more -->

## ES7

### Object.values()

`Object.values()`函数和`Object.keys()`很相似，它返回一个对象中自己属性的所有值(通过原型链继承的不算)。

![objvalues](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/objvalues.png)

### Object.entries()

`Object.entries()`和`Object.keys`相关，不过entries()函数会将key和value以数组的形式都返回。这样，使用循环或则将对象转为Map就很方便了。

![objentry1](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/objentry1.png)

![objentry2](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/objentry2.png)

### 字符串追加

提供了两个字符串追加的方法`String.prototype.padStart`和`String.prototype.padEnd`，方便我们将一个新的字符串追加到某个字符串的头尾。

```js
'someString'.padStart(numberOfCharcters [,stringForPadding]);
'5'.padStart(10) // '          5'
'5'.padStart(10, '=*') //'=*=*=*=*=5'
'5'.padEnd(10) // '5         '
'5'.padEnd(10, '=*') //'5=*=*=*=*='
```

这个对于格式化输出很有用！

#### padStart例子

我们有一个不同长度元素的数组，我们可以往前面追加0来使得他们打印的长度都为10。

![padStart](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/padStart.png)

#### padEnd例子

![padEnd例子](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/padEnd.png)

```js
const cars = {
  '🚙BMW': '10',
  '🚘Tesla': '5',
  '🚖Lamborghini': '0'
}
Object.entries(cars).map(([name, count]) => {
  //padEnd appends ' -' until the name becomes 20 characters
  //padStart prepends '0' until the count becomes 3 characters.
  console.log(`${name.padEnd(20, ' -')} Count: ${count.padStart(3, '0')}`)
});
//Prints..
// 🚙BMW - - - - - - -  Count: 010
// 🚘Tesla - - - - - -  Count: 005
// 🚖Lamborghini - - -  Count: 000

```

#### 使用padStart和padEnd来格式化Emojis和其他宽字符

Emojis和宽字符使用多个字节来表示，因此可能使用padStart和padEnd的结果并非如你所愿。

比如：我们追加❤️到heart前面：

```js
//你会发现不仅没有5个桃心，有一个桃心还很奇怪。
'heart'.padStart(10, "❤️"); // prints.. '❤️❤️❤heart'
```

这是因为❤️占有2个字节(‘\u2764\uFE0F’)，而heart本身有5个字节，因此只有5个字节的余地。所以只是追加了2个半的桃心。最后追加的’\u2764’会显示为小黑桃心。

### Object.getOwnPropertyDescriptors

该函数返回一个对象所有的属性，甚至包括get/set函数。ES2017加入这个函数的主要动机在于方便将一个对象深度拷贝给另一个对象，同时可以将getter/setter拷贝。和Object.assign不同。

Object.assign将一个对象除了getter/setter以外的都深度拷贝了。

将原对象Car拷贝到ElectricCar，你就会发现Object.getOwnPropertyDescriptors拷贝了 getter和setter，而Object.assign没有。

![objcopy](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/objcopy.png)

![objcopy2](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/objcopy2.png)

### 允许在函数参数最后添加逗号

这是一个很小的改动，方便git算法更加方便区分代码职责。我们用一个详细的例子来理解：

![gitcomma](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/gitcomma.png)

值得一提的是，在函数调用的时候，也可以在最后添加逗号。

### Async/Await

迄今为止，我介绍的特性中最有用的就属这个功能了。Async函数可以帮助我们摆脱“回调地狱”，并且整个代码会更加简洁。

async关键字告诉JavaScript编译器对于标定的函数要区别对待。当编译器遇到await函数的时候会暂停。它会等到await标定的函数返回的promise。该promise要么得到结果、要么reject。

在下面的例子中，getAmount函数调用getUser和getBankBalance两个异步函数。我们可以用promise来实现它，不过用async await更加简洁。

![async_await](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/async_await.png)

#### async函数返回Promise

如果你想获取一个async函数的结果，你需要使用Promise的then语法。

在下面的例子中，我们想用console.log来打印doubleAndAdd的结果，可以使用then语法，将console.log函数作为参数传入。

![async_promise](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/async_promise.png)

#### 并行处理

在上面的例子中，我们显示地调用了await两次，因为每次都等待了1秒钟，因此总计两秒钟。现在，我们可以使用Promise.all函数来让他们并行处理。

![await_parallel](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/await_parallel.png)

#### async/await的错误处理

有很多方法来处理错误。

* 方法1：在函数中使用try-catch

![trycatch](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/trycatch.png)

* 方法2：catch每一个await表达式

因为每一个await表达式都会返回Promise，你可以对一个进行catch操作。

![await_catch](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/await_catch.png)

* 方法3：catch整个async-await函数

![catch_all](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/catch_all.png)

[原文地址](https://blog.fundebug.com/2018/07/17/new_in_es16_17_18/)