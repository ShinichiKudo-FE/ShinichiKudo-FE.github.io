---
title: 前端性能优化
date: 2018-03-11 22:21:37
tags: "性能优化"
categories: "性能优化"
---
前端优化的目的是什么？

1. 从用户角度而言，优化能够让页面加载得更快、对用户的操作响应得更及时，能够给用户提供更为友好的体验。　
　
2. 从服务商角度而言，优化能够减少页面请求数、或者减小请求所占带宽，能够节省可观的资源。　　

总之，恰当的优化不仅能够改善站点的用户体验并且能够节省相当的资源利用。

---------


## 页面级优化

### 减少http请求
**减少http请求数的主要途径包括：**

> * (1). 从设计实现层面简化页面
　　 如果你的页面像百度首页一样简单，那么接下来的规则基本上都用不着了。保持页面简洁、减少资源的使用时最直接的。如果不是这样，你的页面需要华丽的皮肤，则继续阅读下面的内容。

> * (2). 合理设置 HTTP缓存　　
    缓存的力量是强大的，恰当的缓存设置可以大大的减少 HTTP请求。以有啊首页为例，当浏览器没有缓存的时候访问一共会发出 78个请求，共 600多 K数据 (如图 1.1)，而当第二次访问即浏览器已缓存之后访问则仅有 10个请求，共 20多 K数据 (如图 1.2)。 (这里需要说明的是，如果直接 F5刷新页面的话效果是不一样的，这种情况下请求数还是一样，不过被缓存资源的请求服务器是 304响应，只有 Header没有Body ，可以节省带宽 )

> * (3). 资源合并与压缩
　　 如果可以的话，尽可能的将外部的脚本、样式进行合并，多个合为一个。另外， CSS、 Javascript、Image 都可以用相应的工具进行压缩，压缩后往往能省下不少空间。

> * (4). CSS Sprites
　　 合并 CSS图片，减少请求数的又一个好办法。 

> * (5). Inline Images　　
    使用 data: URL scheme的方式将图片嵌入到页面或 CSS中，如果不考虑资源管理上的问题的话，不失为一个好办法。如果是嵌入页面的话换来的是增大了页面的体积，而且无法利用浏览器缓存。使用在 CSS中的图片则更为理想一些。

> * (6). Lazy Load Images（自己对这一块的内容还是不了解）
    这条策略实际上并不一定能减少 HTTP请求数，但是却能在某些条件下或者页面刚加载时减少 HTTP请求数。对于图片而言，在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片。这样一来，假如用户只对第一屏的内容感兴趣时，那剩余的图片请求就都节省了。 有啊首页 曾经的做法是在加载的时候把第一屏之后的图片地址缓存在 Textarea标签中，待用户往下滚屏的时候才 “惰性” 加载。

<!-- more -->

### 将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
如果将脚本放在比较靠前的位置，则会影响整个页面的加载速度从而影响用户体验。解决这一问题的方法有很多，在 这里有比较详细的介绍 (这里是译文和 更详细的例子 )，而最简单可依赖的方法就是将脚本尽可能的往后挪，减少对并发下载的影响。

### 异步执行 inline脚本(其实原理和上面是一样，保证脚本在页面内容后面加载。)

### Lazy Load Javascript（只有在需要加载的时候加载，在一般情况下并不加载信息内容。）

### 将 CSS放在 HEAD中
    如果将 CSS放在其他地方比如 BODY中，则浏览器有可能还未下载和解析到 CSS就已经开始渲染页面了，这就导致页面由无 CSS状态跳转到 CSS状态，用户体验比较糟糕。除此之外，有些浏览器会在 CSS下载完成后才开始渲染页面，如果 CSS放在靠下的位置则会导致浏览器将渲染时间推迟。

### 异步请求 Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）

### 减少不必要的 HTTP跳转
    对于以目录形式访问的 HTTP链接，很多人都会忽略链接最后是否带 ’/'，假如你的服务器对此是区别对待的话，那么你也需要注意，这其中很可能隐藏了 301跳转，增加了多余请求。具体参见下图，其中第一个链接是以无 ’/'结尾的方式访问的，于是服务器有了一次跳转

### 避免重复的资源请求
    这种情况主要是由于疏忽或页面由多个模块拼接而成，然后每个模块中请求了同样的资源时，会导致资源的重复请求


## 代码级优化

### Javascript

#### DOM　　
DOM操作应该是脚本中最耗性能的一类操作，例如增加、修改、删除 DOM元素或者对 DOM集合进行操作。
如果脚本中包含了大量的 DOM操作则需要注意以下几点：　　

##### HTML Collection（HTML收集器，返回的是一个数组内容信息）　
　 在脚本中 document.images、document.forms 、getElementsByTagName()返回的都是 HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的 “访问集合” 包括读取集合的 length属性、访问集合中的元素。
　　
因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。　

　
##### reflow(回流)和 repaint(重绘)

简要：整个在浏览器的渲染过程中（页面初始化，用户行为改变界面样式，动画改变界面样式等）reflow(回流)和repaint(重绘) 会大大影响web性能，尤其是手机页面。因此我们在页面设计的时候要尽量减少reflow和repaint。

**什么是reflow和repain**

<font color = "blue">reflow：例如某个子元素样式发生改变，直接影响到了其父元素以及往上追溯很多祖先元素（包括兄弟元素），这个时候浏览器要重新去渲染这个子元素相关联的所有元素的过程称为回流。</font>

<font color = "blue">reflow：几乎是无法避免的。现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。</font>

<font color = "blue">repaint：如果只是改变某个元素的背景色、文 字颜色、边框颜色等等不影响它周围或内部布局的属性，将只会引起浏览器 repaint（重绘）。repaint 的速度明显快于 reflow</font>


下面情况会导致<font color = "red">reflow</font>发生

> * 1：改变窗口大小

> * 2：改变文字大小

> * 3：内容的改变，如用户在输入框中敲字

> * 4：激活伪类，如:hover

> * 5：操作class属性

> * 6：脚本操作DOM

> * 7：计算offsetWidth和offsetHeight

> * 8：设置style属性


**那么为了减少回流要注意哪些方式呢**？

> * 1：不要通过父级来改变子元素样式，最好直接改变子元素样式，改变子元素样式尽可能不要影响父元素和兄弟元素的大小和尺寸

> * 2：尽量通过class来设计元素样式，切忌用style


> * 3：实现元素的动画，对于经常要进行回流的组件，要抽离出来，它的position属性应当设为fixed或absolute

> * 4：权衡速度的平滑。比如实现一个动画，以1个像素为单位移动这样最平滑，但reflow就会过于频繁，CPU很快就会被完全占用。如果以3个像素为单位移动就会好很多。

> * 5：不要用tables布局的另一个原因就是tables中某个元素一旦触发reflow就会导致table里所有的其它元素reflow。在适合用table的场合，可以设置table-layout为auto或fixed，

> * 6：这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。

> * 7：css里不要有表达式expression

> * 8：减少不必要的 DOM 层级（DOM depth）。改变 DOM 树中的一级会导致所有层级的改变，上至根部，下至被改变节点的子节点。这导致大量时间耗费在执行 reflow 上面。

> * 9：避免不必要的复杂的 CSS 选择器，尤其是后代选择器（descendant selectors），因为为了匹配选择器将耗费更多的 CPU。

> * 10: 尽量不要过多的频繁的去增加，修改，删除元素，因为这可能会频繁的导致页面reflow，可以先把该dom节点抽离到内存中进行复杂的操作然后再display到页面上。


> * 11：请求如下值offsetTop, offsetLeft, offsetWidth, offsetHeight，scrollTop/Left/Width/Height，clientTop/Left/Width/Height，浏览器会发生reflow，建议将他们合并到一起操作，可以减少回流的次数。

如果我们要经常去获取和操作这些值，则可以先将这些值缓存起来例如：
```javascript
var windowHeight = window.innerHeight;//reflow

for(i=0;i<10;i++){

　　$body.height(windowHeight++);

　　一系列关于windowHeight的操作.......

}
```


(2). 慎用 with       
with(obj){ p = 1}; 代码块的行为实际上是修改了代码块中的 执行环境 ，将obj放在了其作用域链的最前端，在 with代码块中访问非局部变量是都是先从 obj上开始查找，如果没有再依次按作用域链向上查找，因此使用 with相当于增加了作用域链长度。而每次查找作用域链都是要消耗时间的，过长的作用域链会导致查找性能下降。　
　
因此，除非你能肯定在 with代码中只访问 obj中的属性，否则慎用 with，替代的可以使用局部变量缓存需要访问的属性。
　　
(3). 避免使用 eval和 Function　　
每次 eval 或 Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。　
　
eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。　　

Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。　　此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。　　

(4). 减少作用域链查找（这方面设计到一些内容的相关问题）　　
前文谈到了作用域链查找问题，这一点在循环中是尤其需要注意的问题。如果在循环中需要访问非本作用域下的变量时请在遍历之前用局部变量缓存该变量，并在遍历结束后再重写那个变量，这一点对全局变量尤其重要，因为全局变量处于作用域链的最顶端，访问时的查找次数是最多的。

**低效率的写法：**
```javascript
// 全局变量 var globalVar = 1; function myCallback(info){   
     for( var i = 100000; i--;){      
          //每次访问 globalVar 都需要查找到作用域链最顶端，本例中需要访问 100000 次   
        globalVar += i;    }
    } 　　
```


**更高效的写法：**
```javascript
// 全局变量 
var globalVar = 1; 
function myCallback(info){ 
       //局部变量缓存全局变量  
    var localVar = globalVar;  
    for( var i = 100000; i--;){     
        //访问局部变量是最快的        
        localVar += i;   
        }    
        //本例中只需要访问 2次全局变量在函数中只需要将 globalVar中内容的值赋给localVar 中区  
        globalVar = localVar; 
    }　　
```

此外，要减少作用域链查找还应该减少闭包的使用。

(5). 数据访问　
　Javascript中的数据访问包括直接量 (字符串、正则表达式 )、变量、对象属性以及数组，其中对直接量和局部变量的访问是最快的，对对象属性以及数组的访问需要更大的开销。当出现以下情况时，建议将数据放入局部变量：
　　
a. 对任何对象属性的访问超过 1次　　
b. 对任何数组成员的访问次数超过 1次　

另外，还应当尽可能的减少对对象以及数组深度查找。

(6). 字符串拼接　　
在 Javascript中使用"+" 号来拼接字符串效率是比较低的，因为每次运行都会开辟新的内存并生成新的字符串变量，然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。

不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。

### CSS选择符
在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如#toc A { color: #444; }　　这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项

### HTML
对 HTML本身的优化现如今也越来越多的受人关注了，详情可以参见这篇[总结性文章](https://www.cnblogs.com/zhangyongl/p/6154981.html)

### Image压缩
[一个非常实用的Image压缩的网站](https://tinypng.com/)

图片压缩是个技术活，不过现如今这方面的工具也非常多，压缩之后往往能带来不错的效果，具体的压缩原理以及方法在《 Even Faster Web Sites》第10 章有很详细的介绍，有兴趣的可以去看看。 


《高性能网站建设指南》提出的规则

规则1-------减少HTTP请求

规则2-------使用内容发布网络

规则3-------添加Expires头控制缓存

规则4-------压缩组件

规则5-------将样式表放在顶部

规则6-------将脚步放在底部

规则7-------避免css表达式

规则8-------使用外部javaScript和CSS

规则9-------减少DNS查找

规则10-------精简javaScript

规则11-------避免重定向

规则12-------删除重复脚步

规则13-------配置ETag

规则14-------使Ajax可缓存

