<!DOCTYPE html>
<html lang="zh-Hans">


<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>
    React-router学习 | 默默默默燃
  </title>
  <meta name="description" content="一枚前端搬砖队队员的记录册">
  
  <meta name="keywords" content="
  React-router
  ">
  
  <meta name="author" content="张白告丶">

  <meta http-equiv="Cache-Control" content="no-transform"/>
  <meta http-equiv="Cache-Control" content="no-siteapp">
  <meta name="theme-color" content="#1e2327">
  <link rel="apple-touch-icon" href="https://github.githubassets.com/apple-touch-icon.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://github.githubassets.com/apple-touch-icon-180x180.png">

  <link rel="icon" type="image/x-icon" href="https://github.githubassets.com/favicon.ico">
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet"
        href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
  

  

  <script src="//cdnjs.cloudflare.com/ajax/libs/vue/1.0.25-csp/vue.min.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/moment.js/2.11.2/moment.min.js"></script>
</head>

<body id="replica-app">

<nav class="navbar-wrapper">
  <div class="navbar">
    <div class="container clearfix">
      <a href="/" class="navbar-logo"><i class="fa fa-github"></i></a>

      <div class="navbar-search float-left desktop-only">
        <div class="navbar-search-form">
          <label for="gsc-i-id1">This website</label>
          <div id="google-search">
            <gcse:search></gcse:search>
          </div>
        </div>
      </div>

      <ul class="navbar-nav float-left">
        
        <li><a href="/archives">Archives</a></li>
        
        
        <li><a href="/categories">Categories</a></li>
        
        
        <li><a href="/tags">Tags</a></li>
        
        
        <li class="desktop-only"><a href="/atom.xml" target="_blank">RSS</a></li>
        
      </ul>

      <ul class="navbar-nav user-nav float-right desktop-only">
        <li class="user-nav-notification">
          <a><span class="user-nav-unread"></span><i class="fa fa-bell"></i></a>
        </li>
        <li>
          <a><i class="fa fa-plus"></i> <i class="fa fa-caret-down"></i></a>
        </li>
        <li class="user-nav-logo">
          <a><img src="https://octodex.github.com/images/baracktocat.jpg"> <i class="fa fa-caret-down"></i></i></a>
        </li>
      </ul>
    </div>
  </div>
</nav>

<div class="main-container">
  <header class="header-wrapper desktop-only">
  <div class="container header-site-detail">
    <ul class="header-toolbar">
      <li class="clearfix">
        <a href="/archives" class="header-toolbar-left"><i
                  class="fa fa-file-text"></i> Posts </a>
        <a href="/archives"
           class="header-toolbar-right"> 147 </a>
      </li>
      <li>
        <a href="/tags" class="header-toolbar-left"><i
                  class="fa fa-tags"></i> Tags </a>
        <a href="/tags"
           class="header-toolbar-right"> 47 </a>
      </li>
      <li>
        <a href="/categories" class="header-toolbar-left"><i
                  class="fa fa-folder-open"></i> Categories </a>
        <a href="/categories"
           class="header-toolbar-right"> 23 </a>
      </li>
    </ul>
    <h2 class="header-title">
      <i class="fa fa-book text-muted"></i>
      <a href="/">默默默默燃</a>
      
      
    </h2>
  </div>

  <div class="container">
    <div class="header-tab-wrapper clearfix">
      <span class="header-tab header-tab-selected"><i class="fa fa-thumbs-o-up"></i> Like</span>
      <span class="header-tab"><i class="fa fa-share-alt"></i> Share</span>
      <span class="header-tab"><i class="fa fa-comments-o"></i> Discussion</span>
      <span class="header-tab"><i class="fa fa-bookmark-o"></i> Bookmark </span>
      <span class="header-tab"><i class="fa fa-smile-o"></i> Smile <i class="fa fa-caret-down"></i></span>
    </div>
  </div>
</header>


<div class="post-container container">
  <h3>
    <i class="fa fa-user-o"></i>
    张白告丶

    <span class="post-date float-right" title="{{moment(1520489803000).format('MMM DD, YYYY, h:mm:ss A')}}">
      
          <i class="fa fa-pencil-square-o"></i>
      
      {{moment(1520489803000).fromNow()}}
    </span>
  </h3>

  <article class="post-content">
    <h1>React-router学习</h1>
    <h1 id="React-router-API接口"><a href="#React-router-API接口" class="headerlink" title="React-router API接口"></a>React-router API接口</h1><p><a href="https://reacttraining.com/react-router/web/example/basic" target="_blank" rel="noopener">demo 地址</a></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>React Router 的重要组件。它能保持 UI 和 URL 的同步。</p>
<h4 id="Props-children-required"><a href="#Props-children-required" class="headerlink" title="Props children(required)"></a><strong>Props</strong> <em>children(required)</em></h4><p>一个或多个的 Route 或 PlainRoute。当 history 改变时， <router> 会匹配出 Route 的一个分支，并且渲染这个分支中配置的组件，渲染时保持父 route 组件嵌套子 route 组件。</router></p>
<h5 id="routes"><a href="#routes" class="headerlink" title="routes"></a><strong>routes</strong></h5><p>children 的别名。</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a><strong>history</strong></h5><p>Router 监听的 history 对象，由 history 包提供。<br>关于history的五个函数</p>
<blockquote>
<ul>
<li>createElement(Component, props)</li>
</ul>
</blockquote>
<p>当 route 准备渲染 route 组件的一个分支时，就会用这个函数来创建 element。当你使用某种形式的数据进行抽象时，你可以想要获取创建 element 的控制权，例如在这里设置组件监听 store 的变化，或者使用 props 为每个组件传入一些应用模块。</p>
<blockquote>
<ul>
<li>stringifyQuery(queryObject)</li>
</ul>
</blockquote>
<p>一个用于把 Link 或调用 transitionTo 函数的对象转化成 URL query 字符串的函数。</p>
<blockquote>
<ul>
<li>parseQueryString(queryString)</li>
</ul>
</blockquote>
<p>一个用于把 query 字符串转化成对象，并传递给 route 组件 props 的函数。</p>
<blockquote>
<ul>
<li>onError(error)</li>
</ul>
</blockquote>
<p>当路由匹配到时，也有可能会抛出错误，此时你就可以捕获和处理这些错误。通常，它们会来自那些异步的特性，如 route.getComponents，route.getIndexRoute，和 route.getChildRoutes。</p>
<blockquote>
<ul>
<li>onUpdate()</li>
</ul>
</blockquote>
<p>当 URL 改变时，需要更新路由的 state 时会被调用。</p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>允许用户浏览应用的主要方式。<link> 以适当的 href 去渲染一个可访问的锚标签。</p>
<p><link> 可以知道哪个 route 的链接是激活状态的，并可以自动为该链接添加 activeClassName 或 activeStyle。</p>
<a id="more"></a>
<h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a><strong>Props</strong></h4><h5 id="to"><a href="#to" class="headerlink" title="to"></a><em>to</em></h5><p>跳转链接的路径，如 /users/123。</p>
<h5 id="query"><a href="#query" class="headerlink" title="query"></a><em>query</em></h5><p>已经转化成字符串的键值对的对象。</p>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a><em>hash</em></h5><p>URL 的 hash 值，如 #a-hash。</p>
<font color="red">注意：React Router 目前还不能管理滚动条的位置，并且不会自动滚动到 hash 对应的元素上。如果需要管理滚动条位置，可以使用 <a href="https://github.com/taion/scroll-behavior" target="_blank" rel="noopener">scroll-behavior</a> 这个库。<br></font>

<h5 id="state"><a href="#state" class="headerlink" title="state"></a><em>state</em></h5><p>保存在 location 中的 state</p>
<h5 id="activeClassName"><a href="#activeClassName" class="headerlink" title="activeClassName"></a><em>activeClassName</em></h5><p>当某个 route 是激活状态时，<link> 可以接收传入的 className。失活状态下是默认的 class。</p>
<h5 id="activeStyle"><a href="#activeStyle" class="headerlink" title="activeStyle"></a><em>activeStyle</em></h5><p>当某个 route 是激活状态时，可以将样式添加到链接元素上。</p>
<h5 id="onClick-e"><a href="#onClick-e" class="headerlink" title="onClick(e)"></a><em>onClick(e)</em></h5><p>自定义点击事件的处理方法。如处理 <a> 标签一样 - 调用 <strong>e.preventDefault()</strong>来防止过度的点击，同时 <strong>e.stopPropagation()</strong>可以阻止冒泡的事件。</a></p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a><em>其他</em></h5><p>你也可以在 <a> 标签上传入一些你想要的 props，如 title，id，className 等等。</a></p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><p>如 <route path="/users/:userId"> 这样的 route：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=&#123;<span class="string">`/users/<span class="subst">$&#123;user.id&#125;</span>`</span>&#125; activeClassName=<span class="string">"active"</span>&gt;&#123;user.name&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 变成它们其中一个依赖在 History 上，当这个 route 是</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 激活状态的</span></span><br><span class="line"><span class="regexp">&lt;a href="/u</span>sers/<span class="number">123</span><span class="string">" class="</span>active<span class="string">"&gt;Michael&lt;/a&gt;</span></span><br><span class="line">&lt;a href="#/users/123"&gt;Michael&lt;/a&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 修改 activeClassName</span></span><br><span class="line">&lt;Link to=&#123;<span class="string">`/users/<span class="subst">$&#123;user.id&#125;</span>`</span>&#125; activeClassName=<span class="string">"current"</span>&gt;&#123;user.name&#125;&lt;<span class="regexp">/Link&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ 当链接激活时，修改它的样式</span></span><br><span class="line"><span class="regexp">&lt;Link to="/u</span>sers<span class="string">" style=&#123;&#123;color: 'white'&#125;&#125; activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;Users&lt;/Link&gt;</span></span><br></pre></td></tr></table></figure></route></p>
<h3 id="IndexLink"><a href="#IndexLink" class="headerlink" title="IndexLink"></a>IndexLink</h3><p>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。</p>
<p>这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;IndexLink to=<span class="string">"/"</span> activeClassName=<span class="string">"active"</span>&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;<span class="regexp">/IndexLink&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，根路由只会在精确匹配时，才具有activeClassName。</p>
<p>另一种方法是使用Link组件的onlyActiveOnIndex属性，也能达到同样效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link to=<span class="string">"/"</span> activeClassName=<span class="string">"active"</span> onlyActiveOnIndex=&#123;<span class="literal">true</span>&#125;&gt;</span><br><span class="line">  Home</span><br><span class="line">&lt;<span class="regexp">/Link&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="RoutingContext"><a href="#RoutingContext" class="headerlink" title="RoutingContext"></a>RoutingContext</h3><p>在 context 中给定路由的 state、设置 history 对象和当前的 location，<routingcontext> 就会去渲染组件树。</routingcontext></p>
<h2 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h2><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>Route 是用于声明路由映射到应用程序的组件层。</p>
<h4 id="Props-1"><a href="#Props-1" class="headerlink" title="Props"></a><strong>Props</strong></h4><h5 id="path"><a href="#path" class="headerlink" title="path"></a><em>path</em></h5><p>URL 中的路径。</p>
<p>它会组合父 route 的路径，除非它是从 / 开始的， 将它变成一个绝对路径。</p>
<p>注意：在动态路由中，绝对路径可能不适用于 route 配置中。</p>
<p>如果它是 undefined，路由会去匹配子 route。</p>
<p><em>component</em><br>当匹配到 URL 时，单个的组件会被渲染。它可以 被父 route 组件的 this.props.children 渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> routes = (</span><br><span class="line">  &lt;Route component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"groups"</span> component=&#123;Groups&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"users"</span> component=&#123;Users&#125;/&gt;</span><br><span class="line">  &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 这会是 &lt;Users&gt; 或 &lt;Groups&gt; *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="components"><a href="#components" class="headerlink" title="components"></a><em>components</em></h5><p>Route 可以定义一个或多个已命名的组件，当路径匹配到 URL 时， 它们作为 name:component 对的一个对象去渲染。它们可以被 父 route 组件的 this.props[name] 渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 想想路由外部的 context — 如果你可拔插</span></span><br><span class="line"><span class="comment">// `render` 的部分，你可能需要这么做：</span></span><br><span class="line"><span class="comment">// &lt;App main=&#123;&lt;Users /&gt;&#125; sidebar=&#123;&lt;UsersSidebar /&gt;&#125; /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = (</span><br><span class="line">  &lt;Route component=&#123;App&#125;&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"groups"</span> components=&#123;&#123;<span class="attr">main</span>: Groups, <span class="attr">sidebar</span>: GroupsSidebar&#125;&#125;/&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"users"</span> components=&#123;&#123;<span class="attr">main</span>: Users, <span class="attr">sidebar</span>: UsersSidebar&#125;&#125;&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"users/:userId"</span> component=&#123;Profile&#125;/&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Route&gt;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; main, sidebar &#125; = <span class="keyword">this</span>.props</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"Main"</span>&gt;</span><br><span class="line">          &#123;main&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="Sidebar"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;sidebar&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class Users extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render () &#123;</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* 当路径是 <span class="string">"/users/123"</span> 是 <span class="string">`children`</span> 会是 &lt;Profile&gt; *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>* UsersSidebar 也可以获取作为 <span class="keyword">this</span>.props.children 的 &lt;Profile&gt; ，</span><br><span class="line">            所以这有点奇怪，但你可以决定哪一个可以</span><br><span class="line">            继续这种嵌套 *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &#123;this.props.children&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="getComponent-location-callback"><a href="#getComponent-location-callback" class="headerlink" title="getComponent(location, callback)"></a><em>getComponent(location, callback)</em></h5><p>与 component 一样，但是是异步的，对于 code-splitting 很有用。</p>
<p><strong>callback signature</strong><br>cb(err, component)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"courses/:courseId"</span> getComponent=&#123;(location, cb) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 做一些异步操作去查找组件</span></span><br><span class="line">  cb(<span class="literal">null</span>, Course)</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>
<h5 id="getComponents-location-callback"><a href="#getComponents-location-callback" class="headerlink" title="getComponents(location, callback)"></a><em>getComponents(location, callback)</em></h5><p>与 component 一样，但是是异步的，对于 code-splitting 很有用。</p>
<p><strong>callback signature</strong><br>cb(err, components)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"courses/:courseId"</span> getComponent=&#123;(location, cb) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 做一些异步操作去查找组件</span></span><br><span class="line">  cb(<span class="literal">null</span>, &#123;<span class="attr">sidebar</span>: CourseSidebar, <span class="attr">content</span>: Course&#125;)</span><br><span class="line">&#125;&#125;/&gt;</span><br></pre></td></tr></table></figure>
<h5 id="children"><a href="#children" class="headerlink" title="children"></a><em>children</em></h5><p>Route 可以被嵌套，this.props.children 包含了从子 route 组件创建的元素。由于这是路由设计中非常重要的部分，请参考 Route 配置。</p>
<p>两个路由钩子：</p>
<font color="red">onEnter(nextState, replaceState, callback?)</font>

<p>当 route 即将进入时调用。它提供了下一个路由的 state，一个函数重定向到另一个路径。this 会触发钩子去创建 route 实例。<br>当 callback 作为函数的第三个参数传入时，这个钩子将是异步执行的，并且跳转会阻塞直到 callback 被调用。</p>
<font color="red">onLeave()</font><br>当 route 即将退出时调用。<br><br>### PlainRoute<br>route 定义的一个普通的 JavaScript 对象。 Router 把 JSX 的 <route> 转化到这个对象中，如果你喜欢，你可以直接使用它们。 所有的 props 都和 <route> 的 props 一样，除了那些列在这里的。<br><br>#### <strong>props</strong><br><br>##### <em>childRoutes</em><br><br>子 route 的一个数组，与在 JSX route 配置中的 children 一样。<br><br><font color="red">getChildRoutes(location, callback)</font>

<p>与 childRoutes 一样，但是是异步的，并且可以接收 location。对于 code-splitting 和动态路由匹配很有用（给定一些 state 或 session 数据会返回不同的子 route）。</p>
<p><em>callback signature</em><br>cb(err, routesArray)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myRoute = &#123;</span><br><span class="line">  path: <span class="string">'course/:courseId'</span>,</span><br><span class="line">  childRoutes: [</span><br><span class="line">    announcementsRoute,</span><br><span class="line">    gradesRoute,</span><br><span class="line">    assignmentsRoute</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步的子 route</span></span><br><span class="line"><span class="keyword">let</span> myRoute = &#123;</span><br><span class="line">  path: <span class="string">'course/:courseId'</span>,</span><br><span class="line">  getChildRoutes(location, cb) &#123;</span><br><span class="line">    <span class="comment">// 做一些异步操作去查找子 route</span></span><br><span class="line">    cb(<span class="literal">null</span>, [ announcementsRoute, gradesRoute, assignmentsRoute ])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以根据一些 state</span></span><br><span class="line"><span class="comment">// 跳转到依赖的子 route</span></span><br><span class="line">&lt;Link to=<span class="string">"/picture/123"</span> state=&#123;&#123; <span class="attr">fromDashboard</span>: <span class="literal">true</span> &#125;&#125;/&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myRoute = &#123;</span><br><span class="line">  path: <span class="string">'picture/:id'</span>,</span><br><span class="line">  getChildRoutes(location, cb) &#123;</span><br><span class="line">    <span class="keyword">let</span> &#123; state &#125; = location</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (state &amp;&amp; state.fromDashboard) &#123;</span><br><span class="line">      cb(<span class="literal">null</span>, [dashboardPictureRoute])</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cb(<span class="literal">null</span>, [pictureRoute])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="indexRoute"><a href="#indexRoute" class="headerlink" title="indexRoute"></a><em>indexRoute</em></h5><p>index route。这与在使用 JSX route 配置时指定一个 <indexroute> 子集一样。</indexroute></p>
<font color="red">getIndexRoute(location, callback)</font><br>与 indexRoute 一样，但是是异步的，并且可以接收 location。与 getChildRoutes 一样，对于 code-splitting 和动态路由匹配很有用<br><br><em>callback signature</em><br>cb(err, route)<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例如：</span></span><br><span class="line"><span class="keyword">let</span> myIndexRoute = &#123;</span><br><span class="line">  component: MyIndex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myRoute = &#123;</span><br><span class="line">  path: <span class="string">'courses'</span>,</span><br><span class="line">  indexRoute: myIndexRoute</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步的 index route</span></span><br><span class="line"><span class="keyword">let</span> myRoute = &#123;</span><br><span class="line">  path: <span class="string">'courses'</span>,</span><br><span class="line">  getIndexRoute(location, cb) &#123;</span><br><span class="line">    <span class="comment">// 做一些异步操作</span></span><br><span class="line">    cb(<span class="literal">null</span>, myIndexRoute)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><br>### Redirect<br>在应用中 <redirect> 可以设置重定向到其他 route 而不改变旧的 URL。<br><br>#### <strong>Props</strong><br><br>##### from<br>你想由哪个路径进行重定向，包括动态段。<br><br>##### to<br>你想重定向的路径。<br><br>##### query<br>默认情况下，query 的参数只会经过，但如果你需要你可以指定它们。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们需要从 `/profile/123` 改变到 `/about/123`</span></span><br><span class="line"><span class="comment">// 并且由 `/get-in-touch` 重定向到 `/contact`</span></span><br><span class="line">&lt;Route component=&#123;App&#125;&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"about/:userId"</span> component=&#123;UserProfile&#125;/&gt;</span><br><span class="line">  &#123;<span class="comment">/* /profile/123 -&gt; /about/123 */</span>&#125;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">"profile/:userId"</span> to=<span class="string">"about/:userId"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure><br><br>注意，在 route 层 <redirect> 可以被放在任何地方，尽管<font color="blue">正常的优先</font> 规则仍适用。如果你喜欢将下一个重定向到它各自的 route 上，from 的路径会匹配到一个与 path 一样的正常路径。<br><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;Route path=<span class="string">"course/:courseId"</span>&gt;</span><br><span class="line">  &lt;Route path=<span class="string">"dashboard"</span> /&gt;</span><br><span class="line">  &#123;<span class="comment">/* /course/123/home -&gt; /course/123/dashboard */</span>&#125;</span><br><span class="line">  &lt;Redirect <span class="keyword">from</span>=<span class="string">"home"</span> to=<span class="string">"dashboard"</span> /&gt;</span><br><span class="line">&lt;<span class="regexp">/Route&gt;</span></span><br></pre></td></tr></table></figure><br><br>### IndexRoute<br>当用户在父 route 的 URL 时， Index Routes 允许你为父 route 提供一个默认的 “child”， 并且为使<indexlink> 能用提供了约定<br><br>####Props<br>与 Route 的 props 一样，除了 path。<br><br>### IndexRedirect<br>Index Redirects 允许你从一个父 route 的 URL 重定向到其他 route。 它们被用于允许子 route 作为父 route 的默认 route， 同时保持着不同的 URL。<br><br>#### Props<br>与 <strong>Redirect</strong> 的 props 一样，除了 from。<br><br>## Route Components<br>当 route 匹配到 URL 时会渲染一个 route 的组件。路由会在渲染时将以下属性注入组件中：<br><br>#### history<br>Router 的 history history。<br>对于跳转很有用的 this.props.history.pushState(state, path, query)<br><br>#### location<br>当前的 location。<br><br>#### params<br>URL 的动态段。<br><br>#### route<br>渲染组件的 route。<br><br>#### routeParams<br>this.props.params 是直接在组件中指定 route 的一个子集。例如，如果 route 的路径是 users/:userId 而 URL 是 /users/123/portfolios/345，那么 this.props.routeParams 会是 {userId: ‘123’}，并且 this.props.params 会是 {userId: ‘123’, portfolioId: 345}。<br><br>#### children<br>匹配到子 route 的元素将被渲染。如果 route 有已命名的组件，那么此属性会是 undefined，并且可用的组件会被直接替换到 this.props 上。<br><br>#### 示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">render((</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"groups"</span> component=&#123;Groups&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"users"</span> component=&#123;Users&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Router&gt;</span><br><span class="line">), node)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 这可能是 &lt;Users&gt; 或 &lt;Groups&gt; */</span>&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br>### 已命名的组件<br>当一个 route 有一个或多个已命名的组件时，其子元素的可用性是通过 this.props 命名的。因此 this.props.children 将会是 undefined。那么所有的 route 组件都可以参与嵌套。<br><br>#### 示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">render((</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Route path=<span class="string">"/"</span> component=&#123;App&#125;&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"groups"</span> components=&#123;&#123;<span class="attr">main</span>: Groups, <span class="attr">sidebar</span>: GroupsSidebar&#125;&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"users"</span> components=&#123;&#123;<span class="attr">main</span>: Users, <span class="attr">sidebar</span>: UsersSidebar&#125;&#125;&gt;</span><br><span class="line">        &lt;Route path=<span class="string">"users/:userId"</span> component=&#123;Profile&#125; /&gt;</span><br><span class="line">      &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>Route&gt;</span><br><span class="line">  &lt;<span class="regexp">/Router&gt;</span></span><br><span class="line"><span class="regexp">), node)</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ 在父 route 中，被匹配的子 route 变成 props</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div className="Main"&gt;</span></span><br><span class="line"><span class="regexp">          &#123;/</span>* 这可能是 &lt;Groups&gt; 或 &lt;Users&gt; *<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">          &#123;this.props.main&#125;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>div&gt;</span><br><span class="line">        &lt;div className=<span class="string">"Sidebar"</span>&gt;</span><br><span class="line">          &#123;<span class="comment">/* 这可能是 &lt;GroupsSidebar&gt; 或 &lt;UsersSidebar&gt; */</span>&#125;</span><br><span class="line">          &#123;<span class="keyword">this</span>.props.sidebar&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Users</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &#123;<span class="comment">/* 如果在 "/users/123" 路径上这会是 &lt;Profile&gt; */</span>&#125;</span><br><span class="line">        &#123;<span class="comment">/* UsersSidebar 也会获取到作为 this.props.children 的 &lt;Profile&gt; 。</span></span><br><span class="line"><span class="comment">            你可以把它放这渲染 */</span>&#125;</span><br><span class="line">        &#123;<span class="keyword">this</span>.props.children&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><br><br>## Mixins<br>### 生命周期<br>在组件中添加一个钩子，当路由要从 route 组件的配置中跳转出来时被调用，并且有机会去取消这次跳转。主要用于表单的部分填写。<br><br>在常规的跳转中， <em>routerWillLeave</em> 会接收到一个单一的参数：我们正要跳转的 location。去取消此次跳转，返回 false。<br><br>提示用户确认，返回一个提示信息（字符串）。在 web 浏览器 beforeunload 事件发生时，<em>routerWillLeave</em> 不会接收到一个 location 的对象（假设你正在使用 useBeforeUnload history 的增强方法）。在此之上，我们是不可能知道要跳转的 location，因此 <em>outerWillLeave</em> 必须在用户关闭标签之前返回一个提示信息。<br>#### 生命周期方法<br><font color="red">routerWillLeave(nextLocation)</font>

<p>当路由尝试从一个 route 跳转到另一个并且渲染这个组件时被调用。</p>
<p><strong>arguments</strong></p>
<blockquote>
<ul>
<li>nextLocation - 下一个 location</li>
</ul>
</blockquote>
<h3 id="History-Mixins"><a href="#History-Mixins" class="headerlink" title="History Mixins"></a>History Mixins</h3><p>在组件中添加路由的 history 对象。<br>常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。</p>
<blockquote>
<ul>
<li><p>browserHistory(Browser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。)</p>
</li>
<li><p>hashHistory(路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path)</p>
</li>
<li><p>createMemoryHistory(主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。)</p>
</li>
</ul>
</blockquote>
<p>你可以从 React Router 中引入它们：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JavaScript 模块导入（译者注：ES6 形式）</span></span><br><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br></pre></td></tr></table></figure></p>
<p>然后将它们传递给<router>:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></router></p>
<p><strong>实现示例</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> &#123; render &#125; <span class="keyword">from</span> <span class="string">'react-dom'</span></span><br><span class="line"><span class="keyword">import</span> &#123; browserHistory, Router, Route, IndexRoute &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">'../components/App'</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">'../components/Home'</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">'../components/About'</span></span><br><span class="line"><span class="keyword">import</span> Features <span class="keyword">from</span> <span class="string">'../components/Features'</span></span><br><span class="line"></span><br><span class="line">render(</span><br><span class="line">  &lt;Router history=&#123;browserHistory&#125;&gt;</span><br><span class="line">    &lt;Route path=<span class="string">'/'</span> component=&#123;App&#125;&gt;</span><br><span class="line">      &lt;IndexRoute component=&#123;Home&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">'about'</span> component=&#123;About&#125; /&gt;</span><br><span class="line">      &lt;Route path=<span class="string">'features'</span> component=&#123;Features&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/Route&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>Router&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'app'</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p><strong>注意</strong>：你的 route components 不需要这个 mixin，它在 this.props.history 中已经是可用的了。这是为了组件更深次的渲染树中需要访问路由的 history 对象。</p>
<h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><h5 id="pushState-state-pathname-query"><a href="#pushState-state-pathname-query" class="headerlink" title="pushState(state, pathname, query)"></a>pushState(state, pathname, query)</h5><p>跳转至一个新的 URL。</p>
<p><strong>arguments</strong></p>
<blockquote>
<ul>
<li>state - location 的 state。</li>
<li>pathname - 没有 query 完整的 URL。<br>*query - 通过路由字符串化的一个对象。</li>
</ul>
</blockquote>
<h5 id="replaceState-state-pathname-query"><a href="#replaceState-state-pathname-query" class="headerlink" title="replaceState(state, pathname, query)"></a>replaceState(state, pathname, query)</h5><p>在不影响 history 长度的情况下（如一个重定向），用新的 URL 替换当前这个。</p>
<p><strong>参数</strong></p>
<blockquote>
<ul>
<li>state - location 的 state。</li>
<li>pathname - 没有 query 完整的 URL。</li>
<li>query - 通过路由字符串化的一个对象。</li>
</ul>
</blockquote>
<h5 id="go-n"><a href="#go-n" class="headerlink" title="go(n)"></a>go(n)</h5><p>在 history 中后退。</p>
<h5 id="goForward"><a href="#goForward" class="headerlink" title="goForward()"></a>goForward()</h5><p>在 history 中前进。</p>
<h5 id="createPath-pathname-query"><a href="#createPath-pathname-query" class="headerlink" title="createPath(pathname, query)"></a>createPath(pathname, query)</h5><p>使用路由配置，将 query 字符串化加到路径名中。</p>
<h5 id="createHref-pathname-query"><a href="#createHref-pathname-query" class="headerlink" title="createHref(pathname, query)"></a>createHref(pathname, query)</h5><p>使用路由配置，创建一个 URL。例如，它会在 pathname 的前面加上 #/ 给 hash history。</p>
<h5 id="isActive-pathname-query-indexOnly"><a href="#isActive-pathname-query-indexOnly" class="headerlink" title="isActive(pathname, query, indexOnly)"></a>isActive(pathname, query, indexOnly)</h5><p>根据当前路径是否激活返回 true 或 false。通过 pathname 匹配到 route 分支下的每个 route 将会是 true（子 route 是激活的情况下，父 route 也是激活的），除非 indexOnly 已经指定了，在这种情况下，它只会匹配到具体的路径。<br><strong>参数</strong></p>
<blockquote>
<ul>
<li>pathname - 没有 query 完整的 URL。</li>
<li>query - 如果没有指定，那会是一个包含键值对的对象，并且在当前的 query 中是激活状态的 - 在当前的 query 中明确是 undefined 的值会丢失相应的键或 undefined<br>*indexOnly - 一个 boolean（默认：false）。</li>
</ul>
</blockquote>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; History &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line">React.createClass(&#123;</span><br><span class="line">  mixins: [ History ],</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;div onClick=&#123;() =&gt; <span class="keyword">this</span>.history.pushState(<span class="literal">null</span>, <span class="string">'/foo'</span>)&#125;&gt;Go to foo&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div onClick=&#123;() =&gt; this.history.replaceState(null, 'bar')&#125;&gt;Go to bar without creating a new history entry&lt;/</span>div&gt;</span><br><span class="line">        &lt;div onClick=&#123;() =&gt; <span class="keyword">this</span>.history.goBack()&#125;&gt;Go back&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">     &lt;/</span>div&gt;</span><br><span class="line">   )</span><br><span class="line"> &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>在应用中少数组件由于 History mixin 的缘故而用得不爽，此时有以下几个选项：</p>
<blockquote>
<ul>
<li>让 this.props.history 通过 route 组件到达需要它的组件中。</li>
<li>使用 context</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; PropTypes &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  doStuff() &#123;</span><br><span class="line">    <span class="keyword">this</span>.context.history.pushState(<span class="literal">null</span>, <span class="string">'/some/path'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyComponent.contextTypes = &#123; <span class="attr">history</span>: PropTypes.history &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>确保你的 history 是一个 module</li>
<li>创建一个高阶的组件，我们可能用它来结束跳转和阻止 history，只是没有时间去思考所有的方法。</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">connectHistory</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> React.createClass(&#123;</span><br><span class="line">    mixins: [ History ],</span><br><span class="line">    render() &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...this.props</span>&#125; <span class="attr">history</span>=<span class="string">&#123;this.history&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">  &#125;)</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">// 其他文件</span></span><br><span class="line"><span class="xml">import connectHistory from './connectHistory'</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class MyComponent extends React.Component &#123;</span></span><br><span class="line"><span class="xml">  doStuff() &#123;</span></span><br><span class="line"><span class="xml">    this.props.history.pushState(null, '/some/where')</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">export default connectHistory(MyComponent)</span></span><br></pre></td></tr></table></figure>
<h3 id="RouteContext-Mixins"><a href="#RouteContext-Mixins" class="headerlink" title="RouteContext Mixins"></a>RouteContext Mixins</h3><p>RouteContext mixin 提供了一个将 route 组件设置到 context 中的便捷方法。这对于 route 渲染元素并且希望用 生命周期 mixin 来阻止跳转是很有必要的。</p>
<p>简单地将 this.context.route 添加到组件中。</p>
<h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><p>Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？</p>
<p>下面是一个表单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;form onSubmit=&#123;<span class="keyword">this</span>.handleSubmit&#125;&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"userName"</span>/&gt;</span><br><span class="line">  &lt;input type=<span class="string">"text"</span> placeholder=<span class="string">"repo"</span>/&gt;</span><br><span class="line">  &lt;button type=<span class="string">"submit"</span>&gt;Go&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>form&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>第一种方法是使用browserHistory.push</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; browserHistory &#125; <span class="keyword">from</span> <span class="string">'react-router'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">    <span class="keyword">const</span> userName = event.target.elements[<span class="number">0</span>].value</span><br><span class="line">    <span class="keyword">const</span> repo = event.target.elements[<span class="number">1</span>].value</span><br><span class="line">    <span class="keyword">const</span> path = <span class="string">`/repos/<span class="subst">$&#123;userName&#125;</span>/<span class="subst">$&#123;repo&#125;</span>`</span></span><br><span class="line">    browserHistory.push(path)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure></p>
<p><strong>第二种方法是使用context对象。</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.createClass(&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ask for `router` from context</span></span><br><span class="line">  contextTypes: &#123;</span><br><span class="line">    router: React.PropTypes.object</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  handleSubmit(event) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">this</span>.context.router.push(path)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a>Utilities</h2><h3 id="useRoutes-createHistory"><a href="#useRoutes-createHistory" class="headerlink" title="useRoutes(createHistory)"></a>useRoutes(createHistory)</h3><p>返回一个新的 createHistory 函数，它可以用来创建读取 route 的 history 对象。</p>
<blockquote>
<ul>
<li>listen((error, nextState) =&gt; {})</li>
<li>listenBeforeLeavingRoute(route, (nextLocation) =&gt; {})</li>
<li>(location, (error, redirectLocation, nextState) =&gt; {})</li>
<li>isActive(pathname, query, indexOnly=false)</li>
</ul>
</blockquote>
<h3 id="matchmatch-location-cb"><a href="#matchmatch-location-cb" class="headerlink" title="matchmatch(location, cb)"></a>matchmatch(location, cb)</h3><p>这个函数被用于服务端渲染。它在渲染之前会匹配一组 route 到一个 location，并且在完成时调用 <em>callback(error, redirectLocation, renderProps)</em>。</p>
<p>传给回调函数去 match 的三个参数如下：</p>
<blockquote>
<ul>
<li>error：如果报错时会出现一个 Javascript 的 Error 对象，否则是 undefined。</li>
<li>redirectLocation：如果 route 重定向时会有一个 Location 对象，否则是 undefined。</li>
<li>renderProps：当匹配到 route 时 props 应该通过路由的 context，否则是 undefined。</li>
</ul>
</blockquote>
<p>如果这三个参数都是 undefined，这就意味着在给定的 location 中没有 route 被匹配到。</p>
<font color="red" r="">注意：你可能不想在浏览器中用它，除非你做的是异步 route 的服务端渲染。</font>

<h3 id="createRoutes-routes"><a href="#createRoutes-routes" class="headerlink" title="createRoutes(routes)"></a>createRoutes(routes)</h3><p>创建并返回一个从给定对象 route 的数组，它可能是 JSX 的 route，一个普通对象的 route，或是其他的数组。</p>
<h5 id="params"><a href="#params" class="headerlink" title="params"></a>params</h5><p><em>routes</em><br>一个或多个的 Route 或 PlainRoute。</p>
<p><strong>更多资源</strong><br><a href="https://react-guide.github.io/react-router-cn/" target="_blank" rel="noopener">react-router中文文档</a><br><a href="http://www.ruanyifeng.com/blog/2016/05/react_router.html" target="_blank" rel="noopener">阮一峰React-router</a></p>
</indexlink></redirect></redirect></route></route>
  </article>
</div>


    




</div>

<div class="footer-wrapper container">
  <footer class="footer clearfix">
    <div class="clearfix">
    <a href="https://zhanghao-web.github.io" class="footer-logo">
      <i class="fa fa-github"></i>
    </a>
    <ul class="footer-social-link">
      <li>© 2019 张白告丶</li>
      <li><a href="https://zhanghao-web.github.io">Home</a></li>
      
    </ul>
    <div class="footer-theme-info">
      Theme <a href="//github.com/sabrinaluo/hexo-theme-replica">Replica</a>
      by <a href="//github.com/sabrinaluo">Hiitea</a> ❤ Powered by Hexo
    </div>
    </div>
    
  </footer>
</div>




<script src="/js/main.js"></script>

</body>
</html>
