
<!DOCTYPE html>
<html lang="zh-Hans" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>React-router学习 - 默默默默燃</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="TriDiamond Obsidian,"> 
    <meta name="description" content="一枚前端搬砖队队员的记录册,React-router API接口demo 地址
组件RouterReact Router 的重要组件。它能保持 UI 和 URL 的同步。
Props children(required)一个或,"> 
    <meta name="author" content="张白告丶"> 
    <link rel="alternative" href="atom.xml" title="默默默默燃" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    <link href="https://fonts.loli.net/css?family=Roboto+Mono|Rubik&display=swap" rel="stylesheet">
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1429596_nzgqgvnmkjb.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/animate.css/3.7.2/animate.min.css">

    
<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/css/share.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/codemirror.min.css">

    
<link rel="stylesheet" href="//cdn.bootcss.com/codemirror/5.48.4/theme/dracula.css">

    
<link rel="stylesheet" href="/css/obsidian.css">

    
<link rel="stylesheet" href="/css/ball-atom.min.css">

<meta name="generator" content="Hexo 5.1.1"></head>


<body class="loading">
    <div class="loader">
        <div class="la-ball-atom la-2x">
            <div></div>
            <div></div>
            <div></div>
            <div></div>
        </div>
    </div>
    <span id="config-title" style="display:none">默默默默燃</span>
    <div id="loader"></div>
    <div id="single">
    <div class="scrollbar gradient-bg-rev"></div>
<div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <div class="navigation animated fadeIn fast delay-1s">
        <img id="home-icon" class="icon-home" src="/img/favicon.png" alt="" data-url="https://ShinichiKudo-FE.github.io">
        <div id="play-icon" title="Play/Pause" class="iconfont icon-play"></div>
        <h3 class="subtitle">React-router学习</h3>
        <div class="social">
            <!--        <div class="like-icon">-->
            <!--            <a href="javascript:;" class="likeThis active"><span class="icon-like"></span><span class="count">76</span></a>-->
            <!--        </div>-->
            <div>
                <div class="share">
                    
                        <a href="javascript:;" class="iconfont icon-share1"></a>
                        <div class="share-component-cc" data-disabled="facebook,douban,linkedin,diandian,tencent,google"></div>
                    
                </div>
            </div>
        </div>
    </div>
</div>

    <div class="section">
        <div class=article-header-wrapper>
    <div class="article-header">
        <div class="article-cover animated fadeIn" style="
            animation-delay: 600ms;
            animation-duration: 1.2s;
            background-image: 
                radial-gradient(ellipse closest-side, rgba(0, 0, 0, 0.65), #100e17),
                url(/img/cover.jpg) ">
        </div>
        <div class="else">
            <p class="animated fadeInDown">
                
                <a href="/categories/React-router"><b>「
                    </b>REACT-ROUTER<b> 」</b></a>
                
                March 08, 2018
            </p>
            <h3 class="post-title animated fadeInDown"><a href="/2018/03/08/React/React-router/React-router%E5%AD%A6%E4%B9%A0/" title="React-router学习" class="">React-router学习</a>
            </h3>
            
            <p class="post-count animated fadeInDown">
                
                <span>
                    <b class="iconfont icon-text2"></b> <i>Words count</i>
                    28k
                </span>
                
                
                <span>
                    <b class="iconfont icon-timer__s"></b> <i>Reading time</i>
                    25 mins.
                </span>
                
                
                
                <span id="busuanzi_container_page_pv">
                    <b class="iconfont icon-read"></b> <i>Read count</i>
                    <span id="busuanzi_value_page_pv">0</span>
                </span>
                
            </p>
            
            
            <ul class="animated fadeInDown post-tags-list" itemprop="keywords"><li class="animated fadeInDown post-tags-list-item"><a class="animated fadeInDown post-tags-list-link" href="/tags/React-router/" rel="tag">React-router</a></li></ul>
            
        </div>
    </div>
</div>

<div class="screen-gradient-after">
    <div class="screen-gradient-content">
        <div class="screen-gradient-content-inside">
            <div class="bold-underline-links screen-gradient-sponsor">
                <p>
                    <span class="animated fadeIn delay-1s"></span>
                </p>
            </div>
        </div>
    </div>
</div>

<div class="article">
    <div class='main'>
        <div class="content markdown animated fadeIn">
            <h1 id="React-router-API接口"><a href="#React-router-API接口" class="headerlink" title="React-router API接口"></a>React-router API接口</h1><p><a target="_blank" rel="noopener" href="https://reacttraining.com/react-router/web/example/basic">demo 地址</a></p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>React Router 的重要组件。它能保持 UI 和 URL 的同步。</p>
<h4 id="Props-children-required"><a href="#Props-children-required" class="headerlink" title="Props children(required)"></a><strong>Props</strong> <em>children(required)</em></h4><p>一个或多个的 Route 或 PlainRoute。当 history 改变时， <code>&lt;Router&gt;</code> 会匹配出 Route 的一个分支，并且渲染这个分支中配置的组件，渲染时保持父 route 组件嵌套子 route 组件。</p>
<h5 id="routes"><a href="#routes" class="headerlink" title="routes"></a><strong>routes</strong></h5><p>children 的别名。</p>
<h5 id="history"><a href="#history" class="headerlink" title="history"></a><strong>history</strong></h5><p>Router 监听的 history 对象，由 history 包提供。<br>关于history的五个函数</p>
<blockquote>
<ul>
<li>createElement(Component, props)</li>
</ul>
</blockquote>
<p>当 route 准备渲染 route 组件的一个分支时，就会用这个函数来创建 element。当你使用某种形式的数据进行抽象时，你可以想要获取创建 element 的控制权，例如在这里设置组件监听 store 的变化，或者使用 props 为每个组件传入一些应用模块。</p>
<blockquote>
<ul>
<li>stringifyQuery(queryObject)</li>
</ul>
</blockquote>
<p>一个用于把 Link 或调用 transitionTo 函数的对象转化成 URL query 字符串的函数。</p>
<blockquote>
<ul>
<li>parseQueryString(queryString)</li>
</ul>
</blockquote>
<p>一个用于把 query 字符串转化成对象，并传递给 route 组件 props 的函数。</p>
<blockquote>
<ul>
<li>onError(error)</li>
</ul>
</blockquote>
<p>当路由匹配到时，也有可能会抛出错误，此时你就可以捕获和处理这些错误。通常，它们会来自那些异步的特性，如 route.getComponents，route.getIndexRoute，和 route.getChildRoutes。</p>
<blockquote>
<ul>
<li>onUpdate()</li>
</ul>
</blockquote>
<p>当 URL 改变时，需要更新路由的 state 时会被调用。</p>
<h3 id="Link"><a href="#Link" class="headerlink" title="Link"></a>Link</h3><p>允许用户浏览应用的主要方式。<code>&lt;Link&gt;</code> 以适当的 href 去渲染一个可访问的锚标签。</p>
<p><code>&lt;Link&gt;</code> 可以知道哪个 route 的链接是激活状态的，并可以自动为该链接添加 activeClassName 或 activeStyle。</p>
<a id="more"></a>
<h4 id="Props"><a href="#Props" class="headerlink" title="Props"></a><strong>Props</strong></h4><h5 id="to"><a href="#to" class="headerlink" title="to"></a><em>to</em></h5><p>跳转链接的路径，如 /users/123。</p>
<h5 id="query"><a href="#query" class="headerlink" title="query"></a><em>query</em></h5><p>已经转化成字符串的键值对的对象。</p>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a><em>hash</em></h5><p>URL 的 hash 值，如 #a-hash。<br><code>&lt;font color = &quot;red&quot;&gt;</code>注意：React Router 目前还不能管理滚动条的位置，并且不会自动滚动到 hash 对应的元素上。如果需要管理滚动条位置，可以使用 <a target="_blank" rel="noopener" href="https://github.com/taion/scroll-behavior">scroll-behavior</a> 这个库。<br><code>&lt;/font&gt;</code></p>
<h5 id="state"><a href="#state" class="headerlink" title="state"></a><em>state</em></h5><p>保存在 location 中的 state</p>
<h5 id="activeClassName"><a href="#activeClassName" class="headerlink" title="activeClassName"></a><em>activeClassName</em></h5><p>当某个 route 是激活状态时，<code>&lt;Link&gt;</code> 可以接收传入的 className。失活状态下是默认的 class。</p>
<h5 id="activeStyle"><a href="#activeStyle" class="headerlink" title="activeStyle"></a><em>activeStyle</em></h5><p>当某个 route 是激活状态时，可以将样式添加到链接元素上。</p>
<h5 id="onClick-e"><a href="#onClick-e" class="headerlink" title="onClick(e)"></a><em>onClick(e)</em></h5><p>自定义点击事件的处理方法。如处理 <code>&lt;a&gt;</code> 标签一样 - 调用 **e.preventDefault()**来防止过度的点击，同时 **e.stopPropagation()**可以阻止冒泡的事件。</p>
<h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a><em>其他</em></h5><p>你也可以在 <code>&lt;a&gt;</code> 标签上传入一些你想要的 props，如 title，id，className 等等。</p>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a><strong>示例</strong></h5><p>如 <code>&lt;Route path=&quot;/users/:userId&quot; /&gt;</code> 这样的 route：</p>
<pre><code class="html">&lt;Link to=&#123;`/users/$&#123;user.id&#125;`&#125; activeClassName=&quot;active&quot;&gt;&#123;user.name&#125;&lt;/Link&gt;
// 变成它们其中一个依赖在 History 上，当这个 route 是
// 激活状态的
&lt;a href=&quot;/users/123&quot; class=&quot;active&quot;&gt;Michael&lt;/a&gt;
&lt;a href=&quot;#/users/123&quot;&gt;Michael&lt;/a&gt;

// 修改 activeClassName
&lt;Link to=&#123;`/users/$&#123;user.id&#125;`&#125; activeClassName=&quot;current&quot;&gt;&#123;user.name&#125;&lt;/Link&gt;

// 当链接激活时，修改它的样式
&lt;Link to=&quot;/users&quot; style=&#123;&#123;color: 'white'&#125;&#125; activeStyle=&#123;&#123;color: 'red'&#125;&#125;&gt;Users&lt;/Link&gt;</code></pre>
<h3 id="IndexLink"><a href="#IndexLink" class="headerlink" title="IndexLink"></a>IndexLink</h3><p>如果链接到根路由/，不要使用Link组件，而要使用IndexLink组件。</p>
<p>这是因为对于根路由来说，activeStyle和activeClassName会失效，或者说总是生效，因为/会匹配任何子路由。而IndexLink组件会使用路径的精确匹配。</p>
<pre><code class="html">&lt;IndexLink to=&quot;/&quot; activeClassName=&quot;active&quot;&gt;
  Home
&lt;/IndexLink&gt;</code></pre>
<p>上面代码中，根路由只会在精确匹配时，才具有activeClassName。</p>
<p>另一种方法是使用Link组件的onlyActiveOnIndex属性，也能达到同样效果。</p>
<pre><code class="html">&lt;Link to=&quot;/&quot; activeClassName=&quot;active&quot; onlyActiveOnIndex=&#123;true&#125;&gt;
  Home
&lt;/Link&gt;</code></pre>
<h3 id="RoutingContext"><a href="#RoutingContext" class="headerlink" title="RoutingContext"></a>RoutingContext</h3><p>在 context 中给定路由的 state、设置 history 对象和当前的 location，<code>&lt;RoutingContext&gt;</code> 就会去渲染组件树。</p>
<h2 id="组件配置"><a href="#组件配置" class="headerlink" title="组件配置"></a>组件配置</h2><h3 id="route"><a href="#route" class="headerlink" title="route"></a>route</h3><p>Route 是用于声明路由映射到应用程序的组件层。</p>
<h4 id="Props-1"><a href="#Props-1" class="headerlink" title="Props"></a><strong>Props</strong></h4><h5 id="path"><a href="#path" class="headerlink" title="path"></a><em>path</em></h5><p>URL 中的路径。</p>
<p>它会组合父 route 的路径，除非它是从 / 开始的， 将它变成一个绝对路径。</p>
<p>注意：在动态路由中，绝对路径可能不适用于 route 配置中。</p>
<p>如果它是 undefined，路由会去匹配子 route。</p>
<p><em>component</em><br>当匹配到 URL 时，单个的组件会被渲染。它可以 被父 route 组件的 this.props.children 渲染。</p>
<pre><code class="javascript">const routes = (
  &lt;Route component=&#123;App&#125;&gt;
    &lt;Route path=&quot;groups&quot; component=&#123;Groups&#125;/&gt;
    &lt;Route path=&quot;users&quot; component=&#123;Users&#125;/&gt;
  &lt;/Route&gt;
)

class App extends React.Component &#123;
  render () &#123;
    return (
      &lt;div&gt;
        &#123;/* 这会是 &lt;Users&gt; 或 &lt;Groups&gt; */&#125;
        &#123;this.props.children&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;</code></pre>
<h5 id="components"><a href="#components" class="headerlink" title="components"></a><em>components</em></h5><p>Route 可以定义一个或多个已命名的组件，当路径匹配到 URL 时， 它们作为 name:component 对的一个对象去渲染。它们可以被 父 route 组件的 <code>this.props[name]</code>渲染。</p>
<pre><code class="javascript">// 想想路由外部的 context — 如果你可拔插
// `render` 的部分，你可能需要这么做：
// &lt;App main=&#123;&lt;Users /&gt;&#125; sidebar=&#123;&lt;UsersSidebar /&gt;&#125; /&gt;

const routes = (
  &lt;Route component=&#123;App&#125;&gt;
    &lt;Route path=&quot;groups&quot; components=&#123;&#123;main: Groups, sidebar: GroupsSidebar&#125;&#125;/&gt;
    &lt;Route path=&quot;users&quot; components=&#123;&#123;main: Users, sidebar: UsersSidebar&#125;&#125;&gt;
      &lt;Route path=&quot;users/:userId&quot; component=&#123;Profile&#125;/&gt;
    &lt;/Route&gt;
  &lt;/Route&gt;
)

class App extends React.Component &#123;
  render () &#123;
    const &#123; main, sidebar &#125; = this.props
    return (
      &lt;div&gt;
        &lt;div className=&quot;Main&quot;&gt;
          &#123;main&#125;
        &lt;/div&gt;
        &lt;div className=&quot;Sidebar&quot;&gt;
          &#123;sidebar&#125;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

class Users extends React.Component &#123;
  render () &#123;
    return (
      &lt;div&gt;
        &#123;/* 当路径是 &quot;/users/123&quot; 是 `children` 会是 &lt;Profile&gt; */&#125;
        &#123;/* UsersSidebar 也可以获取作为 this.props.children 的 &lt;Profile&gt; ，
            所以这有点奇怪，但你可以决定哪一个可以
            继续这种嵌套 */&#125;
        &#123;this.props.children&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;
</code></pre>
<h5 id="getComponent-location-callback"><a href="#getComponent-location-callback" class="headerlink" title="getComponent(location, callback)"></a><em>getComponent(location, callback)</em></h5><p>与 component 一样，但是是异步的，对于 code-splitting 很有用。</p>
<p><strong>callback signature</strong><br><code>cb(err, component)</code></p>
<pre><code class="javascript">&lt;Route path=&quot;courses/:courseId&quot; getComponent=&#123;(location, cb) =&gt; &#123;
  // 做一些异步操作去查找组件
  cb(null, Course)
&#125;&#125;/&gt;
</code></pre>
<h5 id="getComponents-location-callback"><a href="#getComponents-location-callback" class="headerlink" title="getComponents(location, callback)"></a><em>getComponents(location, callback)</em></h5><p>与 component 一样，但是是异步的，对于 code-splitting 很有用。</p>
<p><strong>callback signature</strong><br><code>cb(err, components)</code></p>
<pre><code class="javascript">&lt;Route path=&quot;courses/:courseId&quot; getComponent=&#123;(location, cb) =&gt; &#123;
  // 做一些异步操作去查找组件
  cb(null, &#123;sidebar: CourseSidebar, content: Course&#125;)
&#125;&#125;/&gt;</code></pre>
<h5 id="children"><a href="#children" class="headerlink" title="children"></a><em>children</em></h5><p>Route 可以被嵌套，this.props.children 包含了从子 route 组件创建的元素。由于这是路由设计中非常重要的部分，请参考 Route 配置。</p>
<p>两个路由钩子：<br><code>&lt;font color = &quot;red&quot;&gt;onEnter(nextState, replaceState, callback?)&lt;/font&gt;</code></p>
<p>当 route 即将进入时调用。它提供了下一个路由的 state，一个函数重定向到另一个路径。this 会触发钩子去创建 route 实例。<br>当 callback 作为函数的第三个参数传入时，这个钩子将是异步执行的，并且跳转会阻塞直到 callback 被调用。</p>
<p><code>&lt;font color = &quot;red&quot;&gt;onLeave()&lt;/font&gt;</code><br>当 route 即将退出时调用。</p>
<h3 id="PlainRoute"><a href="#PlainRoute" class="headerlink" title="PlainRoute"></a>PlainRoute</h3><p>route 定义的一个普通的 JavaScript 对象。 Router 把 JSX 的 <code>&lt;Route&gt;</code> 转化到这个对象中，如果你喜欢，你可以直接使用它们。 所有的 props 都和 <code>&lt;Route&gt;</code> 的 props 一样，除了那些列在这里的。</p>
<h4 id="props"><a href="#props" class="headerlink" title="props"></a><strong>props</strong></h4><h5 id="childRoutes"><a href="#childRoutes" class="headerlink" title="childRoutes"></a><em>childRoutes</em></h5><p>子 route 的一个数组，与在 JSX route 配置中的 children 一样。</p>
<p><code>&lt;font color = &quot;red&quot;&gt;getChildRoutes(location, callback)&lt;/font&gt;</code></p>
<p>与 childRoutes 一样，但是是异步的，并且可以接收 location。对于 code-splitting 和动态路由匹配很有用（给定一些 state 或 session 数据会返回不同的子 route）。</p>
<p><em>callback signature</em><br>cb(err, routesArray)</p>
<pre><code class="javascript">let myRoute = &#123;
  path: &#39;course/:courseId&#39;,
  childRoutes: [
    announcementsRoute,
    gradesRoute,
    assignmentsRoute
  ]
&#125;

// 异步的子 route
let myRoute = &#123;
  path: &#39;course/:courseId&#39;,
  getChildRoutes(location, cb) &#123;
    // 做一些异步操作去查找子 route
    cb(null, [ announcementsRoute, gradesRoute, assignmentsRoute ])
  &#125;
&#125;

// 可以根据一些 state
// 跳转到依赖的子 route
&lt;Link to=&quot;/picture/123&quot; state=&#123;&#123; fromDashboard: true &#125;&#125;/&gt;

let myRoute = &#123;
  path: &#39;picture/:id&#39;,
  getChildRoutes(location, cb) &#123;
    let &#123; state &#125; = location

    if (state &amp;&amp; state.fromDashboard) &#123;
      cb(null, [dashboardPictureRoute])
    &#125; else &#123;
      cb(null, [pictureRoute])
    &#125;
  &#125;
&#125;</code></pre>
<h5 id="indexRoute"><a href="#indexRoute" class="headerlink" title="indexRoute"></a><em>indexRoute</em></h5><p>index route。这与在使用 JSX route 配置时指定一个 <IndexRoute> 子集一样。</p>
<p><code>&lt;font color = &quot;red&quot;&gt;getIndexRoute(location, callback)&lt;/font&gt;</code><br>与 indexRoute 一样，但是是异步的，并且可以接收 location。与 getChildRoutes 一样，对于 code-splitting 和动态路由匹配很有用</p>
<p><em>callback signature</em><br>cb(err, route)</p>
<pre><code class="javascript">// 例如：
let myIndexRoute = &#123;
  component: MyIndex
&#125;

let myRoute = &#123;
  path: &#39;courses&#39;,
  indexRoute: myIndexRoute
&#125;

// 异步的 index route
let myRoute = &#123;
  path: &#39;courses&#39;,
  getIndexRoute(location, cb) &#123;
    // 做一些异步操作
    cb(null, myIndexRoute)
  &#125;
&#125;</code></pre>
<h3 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h3><p>在应用中 <code>&lt;Redirect&gt;</code> 可以设置重定向到其他 route 而不改变旧的 URL。</p>
<h4 id="Props-2"><a href="#Props-2" class="headerlink" title="Props"></a><strong>Props</strong></h4><h5 id="from"><a href="#from" class="headerlink" title="from"></a>from</h5><p>你想由哪个路径进行重定向，包括动态段。</p>
<h5 id="to-1"><a href="#to-1" class="headerlink" title="to"></a>to</h5><p>你想重定向的路径。</p>
<h5 id="query-1"><a href="#query-1" class="headerlink" title="query"></a>query</h5><p>默认情况下，query 的参数只会经过，但如果你需要你可以指定它们。</p>
<pre><code class="javascript">// 我们需要从 `/profile/123` 改变到 `/about/123`
// 并且由 `/get-in-touch` 重定向到 `/contact`
&lt;Route component=&#123;App&#125;&gt;
  &lt;Route path=&quot;about/:userId&quot; component=&#123;UserProfile&#125;/&gt;
  &#123;/* /profile/123 -&gt; /about/123 */&#125;
  &lt;Redirect from=&quot;profile/:userId&quot; to=&quot;about/:userId&quot; /&gt;
&lt;/Route&gt;</code></pre>
<p>注意，在 route 层 <code>&lt;Redirect&gt;</code> 可以被放在任何地方，尽管<font color= "blue">正常的优先</font> 规则仍适用。如果你喜欢将下一个重定向到它各自的 route 上，from 的路径会匹配到一个与 path 一样的正常路径。</p>
<pre><code class="javascript">&lt;Route path=&quot;course/:courseId&quot;&gt;
  &lt;Route path=&quot;dashboard&quot; /&gt;
  &#123;/* /course/123/home -&gt; /course/123/dashboard */&#125;
  &lt;Redirect from=&quot;home&quot; to=&quot;dashboard&quot; /&gt;
&lt;/Route&gt;</code></pre>
<h3 id="IndexRoute"><a href="#IndexRoute" class="headerlink" title="IndexRoute"></a>IndexRoute</h3><p>当用户在父 route 的 URL 时， Index Routes 允许你为父 route 提供一个默认的 “child”， 并且为使<code>&lt;IndexLink&gt;</code> 能用提供了约定</p>
<p>####Props<br>与 Route 的 props 一样，除了 path。</p>
<h3 id="IndexRedirect"><a href="#IndexRedirect" class="headerlink" title="IndexRedirect"></a>IndexRedirect</h3><p>Index Redirects 允许你从一个父 route 的 URL 重定向到其他 route。 它们被用于允许子 route 作为父 route 的默认 route， 同时保持着不同的 URL。</p>
<h4 id="Props-3"><a href="#Props-3" class="headerlink" title="Props"></a>Props</h4><p>与 <strong>Redirect</strong> 的 props 一样，除了 from。</p>
<h2 id="Route-Components"><a href="#Route-Components" class="headerlink" title="Route Components"></a>Route Components</h2><p>当 route 匹配到 URL 时会渲染一个 route 的组件。路由会在渲染时将以下属性注入组件中：</p>
<h4 id="history-1"><a href="#history-1" class="headerlink" title="history"></a>history</h4><p>Router 的 history history。<br>对于跳转很有用的 this.props.history.pushState(state, path, query)</p>
<h4 id="location"><a href="#location" class="headerlink" title="location"></a>location</h4><p>当前的 location。</p>
<h4 id="params"><a href="#params" class="headerlink" title="params"></a>params</h4><p>URL 的动态段。</p>
<h4 id="route-1"><a href="#route-1" class="headerlink" title="route"></a>route</h4><p>渲染组件的 route。</p>
<h4 id="routeParams"><a href="#routeParams" class="headerlink" title="routeParams"></a>routeParams</h4><p>this.props.params 是直接在组件中指定 route 的一个子集。例如，如果 route 的路径是 <code>users/:userId</code> 而 URL 是 <code>/users/123/portfolios/345</code>，那么 <code>this.props.routeParams 会是 &#123;userId: &#39;123&#39;&#125;</code>，并且 <code>this.props.params</code> 会是 <code>&#123;userId: &#39;123&#39;, portfolioId: 345&#125;</code>。</p>
<h4 id="children-1"><a href="#children-1" class="headerlink" title="children"></a>children</h4><p>匹配到子 route 的元素将被渲染。如果 route 有已命名的组件，那么此属性会是 undefined，并且可用的组件会被直接替换到 this.props 上。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><pre><code class="javascript">render((
  &lt;Router&gt;
    &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;
      &lt;Route path=&quot;groups&quot; component=&#123;Groups&#125; /&gt;
      &lt;Route path=&quot;users&quot; component=&#123;Users&#125; /&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), node)

class App extends React.Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &#123;/* 这可能是 &lt;Users&gt; 或 &lt;Groups&gt; */&#125;
        &#123;this.props.children&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;</code></pre>
<h3 id="已命名的组件"><a href="#已命名的组件" class="headerlink" title="已命名的组件"></a>已命名的组件</h3><p>当一个 <code>route</code> 有一个或多个已命名的组件时，其子元素的可用性是通过 <code>this.props</code> 命名的。因此 <code>this.props.children</code> 将会是 undefined。那么所有的 <code>route</code> 组件都可以参与嵌套。</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><pre><code class="js">// 注释里的内容有效，为了解决博客打包未知错误
/*render((
  &lt;Router&gt;
    &lt;Route path=&quot;/&quot; component=&#123;App&#125;&gt;
      &lt;Route path=&quot;groups&quot; components=&#123;&#123;main: Groups, sidebar: GroupsSidebar&#125;&#125; /&gt;
      &lt;Route path=&quot;users&quot; components=&#123;&#123;main: Users, sidebar: UsersSidebar&#125;&#125;&gt;
        &lt;Route path=&quot;users/:userId&quot; component=&#123;Profile&#125; /&gt;
      &lt;/Route&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;
), node)

class App extends React.Component &#123;
  render() &#123;
    // 在父 route 中，被匹配的子 route 变成 props
    return (
      &lt;div&gt;
        &lt;div className=&quot;Main&quot;&gt;
          &#123;// 这可能是 &lt;Groups&gt; 或 &lt;Users&gt;&#125;
          &#123;this.props.main&#125;
        &lt;/div&gt;
        &lt;div className=&quot;Sidebar&quot;&gt;
          &#123;// 这可能是 &lt;GroupsSidebar&gt; 或 &lt;UsersSidebar&gt;&#125;
          &#123;this.props.sidebar&#125;
        &lt;/div&gt;
      &lt;/div&gt;
    )
  &#125;
&#125;

class Users extends React.Component &#123;
  render() &#123;
    return (
      &lt;div&gt;
        &#123;// 如果在 &quot;/users/123&quot; 路径上这会是 &lt;Profile&gt; &#125;
        &#123;// UsersSidebar 也会获取到作为 this.props.children 的 &lt;Profile&gt; 。
            你可以把它放这渲染 &#125;
        &#123;this.props.children&#125;
      &lt;/div&gt;
    )
  &#125;
&#125;*/</code></pre>
<h2 id="Mixins"><a href="#Mixins" class="headerlink" title="Mixins"></a>Mixins</h2><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>在组件中添加一个钩子，当路由要从 route 组件的配置中跳转出来时被调用，并且有机会去取消这次跳转。主要用于表单的部分填写。</p>
<p>在常规的跳转中， <em>routerWillLeave</em> 会接收到一个单一的参数：我们正要跳转的 location。去取消此次跳转，返回 false。</p>
<p>提示用户确认，返回一个提示信息（字符串）。在 web 浏览器 beforeunload 事件发生时，<em>routerWillLeave</em> 不会接收到一个 location 的对象（假设你正在使用 useBeforeUnload history 的增强方法）。在此之上，我们是不可能知道要跳转的 location，因此 <em>outerWillLeave</em> 必须在用户关闭标签之前返回一个提示信息。</p>
<h4 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h4><p><font color = "red">routerWillLeave(nextLocation)</font></p>
<p>当路由尝试从一个 route 跳转到另一个并且渲染这个组件时被调用。</p>
<p><strong>arguments</strong></p>
<blockquote>
<ul>
<li>nextLocation - 下一个 location</li>
</ul>
</blockquote>
<h3 id="History-Mixins"><a href="#History-Mixins" class="headerlink" title="History Mixins"></a>History Mixins</h3><p>在组件中添加路由的 history 对象。<br>常用的 history 有三种形式， 但是你也可以使用 React Router 实现自定义的 history。</p>
<blockquote>
<ul>
<li>browserHistory(Browser history 是使用 React Router 的应用推荐的 history。它使用浏览器中的 History API 用于处理 URL，创建一个像example.com/some/path这样真实的 URL 。)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>hashHistory(路由将通过URL的hash部分（#）切换，URL的形式类似example.com/#/some/path)</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>createMemoryHistory(主要用于服务器渲染。它创建一个内存中的history对象，不与浏览器URL互动。)</li>
</ul>
</blockquote>
<p>你可以从 React Router 中引入它们：</p>
<pre><code class="javascript">// JavaScript 模块导入（译者注：ES6 形式）
import &#123; browserHistory &#125; from &#39;react-router&#39;</code></pre>
<p>然后将它们传递给<Router>:</p>
<pre><code class="javascript">render(
  &lt;Router history=&#123;browserHistory&#125; routes=&#123;routes&#125; /&gt;,
  document.getElementById(&#39;app&#39;)
)</code></pre>
<p><strong>实现示例</strong></p>
<pre><code class="javascript">import React from &#39;react&#39;
import &#123; render &#125; from &#39;react-dom&#39;
import &#123; browserHistory, Router, Route, IndexRoute &#125; from &#39;react-router&#39;

import App from &#39;../components/App&#39;
import Home from &#39;../components/Home&#39;
import About from &#39;../components/About&#39;
import Features from &#39;../components/Features&#39;

render(
  &lt;Router history=&#123;browserHistory&#125;&gt;
    &lt;Route path=&#39;/&#39; component=&#123;App&#125;&gt;
      &lt;IndexRoute component=&#123;Home&#125; /&gt;
      &lt;Route path=&#39;about&#39; component=&#123;About&#125; /&gt;
      &lt;Route path=&#39;features&#39; component=&#123;Features&#125; /&gt;
    &lt;/Route&gt;
  &lt;/Router&gt;,
  document.getElementById(&#39;app&#39;)
)</code></pre>
<p><strong>注意</strong>：你的 route components 不需要这个 mixin，它在 this.props.history 中已经是可用的了。这是为了组件更深次的渲染树中需要访问路由的 history 对象。</p>
<h4 id="Methods"><a href="#Methods" class="headerlink" title="Methods"></a>Methods</h4><h5 id="pushState-state-pathname-query"><a href="#pushState-state-pathname-query" class="headerlink" title="pushState(state, pathname, query)"></a>pushState(state, pathname, query)</h5><p>跳转至一个新的 URL。</p>
<p><strong>arguments</strong></p>
<blockquote>
<ul>
<li>state - location 的 state。</li>
<li>pathname - 没有 query 完整的 URL。</li>
<li>query - 通过路由字符串化的一个对象。</li>
</ul>
</blockquote>
<h5 id="replaceState-state-pathname-query"><a href="#replaceState-state-pathname-query" class="headerlink" title="replaceState(state, pathname, query)"></a>replaceState(state, pathname, query)</h5><p>在不影响 history 长度的情况下（如一个重定向），用新的 URL 替换当前这个。</p>
<p><strong>参数</strong></p>
<blockquote>
<ul>
<li>state - location 的 state。</li>
<li>pathname - 没有 query 完整的 URL。</li>
<li>query - 通过路由字符串化的一个对象。</li>
</ul>
</blockquote>
<h5 id="go-n"><a href="#go-n" class="headerlink" title="go(n)"></a>go(n)</h5><p>在 history 中后退。</p>
<h5 id="goForward"><a href="#goForward" class="headerlink" title="goForward()"></a>goForward()</h5><p>在 history 中前进。</p>
<h5 id="createPath-pathname-query"><a href="#createPath-pathname-query" class="headerlink" title="createPath(pathname, query)"></a>createPath(pathname, query)</h5><p>使用路由配置，将 query 字符串化加到路径名中。</p>
<h5 id="createHref-pathname-query"><a href="#createHref-pathname-query" class="headerlink" title="createHref(pathname, query)"></a>createHref(pathname, query)</h5><p>使用路由配置，创建一个 URL。例如，它会在 pathname 的前面加上 #/ 给 hash history。</p>
<h5 id="isActive-pathname-query-indexOnly"><a href="#isActive-pathname-query-indexOnly" class="headerlink" title="isActive(pathname, query, indexOnly)"></a>isActive(pathname, query, indexOnly)</h5><p>根据当前路径是否激活返回 true 或 false。通过 pathname 匹配到 route 分支下的每个 route 将会是 true（子 route 是激活的情况下，父 route 也是激活的），除非 indexOnly 已经指定了，在这种情况下，它只会匹配到具体的路径。<br><strong>参数</strong></p>
<blockquote>
<ul>
<li>pathname - 没有 query 完整的 URL。</li>
<li>query - 如果没有指定，那会是一个包含键值对的对象，并且在当前的 query 中是激活状态的 - 在当前的 query 中明确是 undefined 的值会丢失相应的键或 undefined</li>
<li>indexOnly - 一个 boolean（默认：false）。</li>
</ul>
</blockquote>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><pre><code class="javascript">import &#123; History &#125; from &#39;react-router&#39;

React.createClass(&#123;
  mixins: [ History ],
  render() &#123;
    return (
      &lt;div&gt;
        &lt;div onClick=&#123;() =&gt; this.history.pushState(null, &#39;/foo&#39;)&#125;&gt;Go to foo&lt;/div&gt;
        &lt;div onClick=&#123;() =&gt; this.history.replaceState(null, &#39;bar&#39;)&#125;&gt;Go to bar without creating a new history entry&lt;/div&gt;
        &lt;div onClick=&#123;() =&gt; this.history.goBack()&#125;&gt;Go back&lt;/div&gt;
     &lt;/div&gt;
   )
 &#125;
&#125;)</code></pre>
<p>在应用中少数组件由于 History mixin 的缘故而用得不爽，此时有以下几个选项：</p>
<blockquote>
<ul>
<li>让 this.props.history 通过 route 组件到达需要它的组件中。</li>
<li>使用 context</li>
</ul>
</blockquote>
<pre><code class="javascript">import &#123; PropTypes &#125; from &#39;react-router&#39;

class MyComponent extends React.Component &#123;
  doStuff() &#123;
    this.context.history.pushState(null, &#39;/some/path&#39;)
  &#125;
&#125;

MyComponent.contextTypes = &#123; history: PropTypes.history &#125;</code></pre>
<blockquote>
<ul>
<li>确保你的 history 是一个 module</li>
<li>创建一个高阶的组件，我们可能用它来结束跳转和阻止 history，只是没有时间去思考所有的方法。</li>
</ul>
</blockquote>
<pre><code class="javascript">function connectHistory(Component) &#123;
  return React.createClass(&#123;
    mixins: [ History ],
    render() &#123;
      return &lt;Component &#123;...this.props&#125; history=&#123;this.history&#125; /&gt;
    &#125;
  &#125;)
&#125;

// 其他文件
import connectHistory from &#39;./connectHistory&#39;

class MyComponent extends React.Component &#123;
  doStuff() &#123;
    this.props.history.pushState(null, &#39;/some/where&#39;)
  &#125;
&#125;

export default connectHistory(MyComponent)</code></pre>
<h3 id="RouteContext-Mixins"><a href="#RouteContext-Mixins" class="headerlink" title="RouteContext Mixins"></a>RouteContext Mixins</h3><p>RouteContext mixin 提供了一个将 route 组件设置到 context 中的便捷方法。这对于 route 渲染元素并且希望用 生命周期 mixin 来阻止跳转是很有必要的。</p>
<p>简单地将 this.context.route 添加到组件中。</p>
<h2 id="表单处理"><a href="#表单处理" class="headerlink" title="表单处理"></a>表单处理</h2><p>Link组件用于正常的用户点击跳转，但是有时还需要表单跳转、点击按钮跳转等操作。这些情况怎么跟React Router对接呢？</p>
<p>下面是一个表单。</p>
<pre><code class="javascript">
&lt;form onSubmit=&#123;this.handleSubmit&#125;&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;userName&quot;/&gt;
  &lt;input type=&quot;text&quot; placeholder=&quot;repo&quot;/&gt;
  &lt;button type=&quot;submit&quot;&gt;Go&lt;/button&gt;
&lt;/form&gt;</code></pre>
<p><strong>第一种方法是使用browserHistory.push</strong></p>
<pre><code class="javascript">import &#123; browserHistory &#125; from &#39;react-router&#39;

// ...
  handleSubmit(event) &#123;
    event.preventDefault()
    const userName = event.target.elements[0].value
    const repo = event.target.elements[1].value
    const path = `/repos/$&#123;userName&#125;/$&#123;repo&#125;`
    browserHistory.push(path)
  &#125;,</code></pre>
<p><strong>第二种方法是使用context对象。</strong></p>
<pre><code class="javascript">export default React.createClass(&#123;

  // ask for `router` from context
  contextTypes: &#123;
    router: React.PropTypes.object
  &#125;,

  handleSubmit(event) &#123;
    // ...
    this.context.router.push(path)
  &#125;,
&#125;)</code></pre>
<h2 id="Utilities"><a href="#Utilities" class="headerlink" title="Utilities"></a>Utilities</h2><h3 id="useRoutes-createHistory"><a href="#useRoutes-createHistory" class="headerlink" title="useRoutes(createHistory)"></a>useRoutes(createHistory)</h3><p>返回一个新的 createHistory 函数，它可以用来创建读取 route 的 history 对象。</p>
<blockquote>
<ul>
<li>listen((error, nextState) =&gt; {})</li>
<li>listenBeforeLeavingRoute(route, (nextLocation) =&gt; {})</li>
<li>(location, (error, redirectLocation, nextState) =&gt; {})</li>
<li>isActive(pathname, query, indexOnly=false)</li>
</ul>
</blockquote>
<h3 id="matchmatch-location-cb"><a href="#matchmatch-location-cb" class="headerlink" title="matchmatch(location, cb)"></a>matchmatch(location, cb)</h3><p>这个函数被用于服务端渲染。它在渲染之前会匹配一组 route 到一个 location，并且在完成时调用 *callback(error, redirectLocation, renderProps)*。</p>
<p>传给回调函数去 match 的三个参数如下：</p>
<blockquote>
<ul>
<li>error：如果报错时会出现一个 Javascript 的 Error 对象，否则是 undefined。</li>
<li>redirectLocation：如果 route 重定向时会有一个 Location 对象，否则是 undefined。</li>
<li>renderProps：当匹配到 route 时 props 应该通过路由的 context，否则是 undefined。</li>
</ul>
</blockquote>
<p>如果这三个参数都是 undefined，这就意味着在给定的 location 中没有 route 被匹配到。</p>
<p><code>&lt;font color = &quot;red&quot;r&gt;注意：你可能不想在浏览器中用它，除非你做的是异步 route 的服务端渲染。&lt;/font&gt;</code></p>
<h3 id="createRoutes-routes"><a href="#createRoutes-routes" class="headerlink" title="createRoutes(routes)"></a>createRoutes(routes)</h3><p>创建并返回一个从给定对象 route 的数组，它可能是 JSX 的 route，一个普通对象的 route，或是其他的数组。</p>
<h5 id="params-1"><a href="#params-1" class="headerlink" title="params"></a>params</h5><p><em>routes</em><br>一个或多个的 Route 或 PlainRoute。</p>
<p><strong>更多资源</strong><br><a target="_blank" rel="noopener" href="https://react-guide.github.io/react-router-cn/">react-router中文文档</a><br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2016/05/react_router.html">阮一峰React-router</a></p>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls"
                data-autoplay="false">
                <source type="audio/mpeg" src="">
            </audio>
            
            <ul id="audio-list" style="display:none">
                
                
                <li title='0' data-url='/statics/chengdu.mp3'></li>
                
                    
            </ul>
            
            
            
    <div id='gitalk-container' class="comment link"
        data-ae='true'
        data-ci='ec894e2b66f752e8b7fb'
        data-cs='3ccc2e92bb350688fe2c2dc2930189b62622bfb1'
        data-r='blog-comments'
        data-o='TriDiamond'
        data-a='TriDiamond'
        data-d=''
    >Comments</div>


            
            
        </div>
        <div class="sidebar">
            <div class="box animated fadeInRight">
                <div class="subbox">
                    <img src="/img/favicon.png" height=300 width=300></img>
                    <p>张白告丶</p>
                    <span>Think like an artist, develop like an artisan</span>
                    <dl>
                        <dd><a href="https://github.com/zhanghao-web" target="_blank"><span
                                    class=" iconfont icon-github"></span></a></dd>
                        <!-- <dd><a href="" target="_blank"><span
                                    class=" iconfont icon-twitter"></span></a></dd>
                        <dd><a href="" target="_blank"><span
                                    class=" iconfont icon-stack-overflow"></span></a></dd> -->
                    </dl>
                </div>
                <ul>
                    <li><a href="/">172 <p>Articles</p></a></li>
                    <li><a href="/categories">27 <p>Categories</p></a></li>
                    <li><a href="/tags">54 <p>Tags</p></a></li>
                </ul>
            </div>
            
            
            
            <div class="box sticky animated fadeInRight faster">
                <div id="toc" class="subbox">
                    <h4>Contents</h4>
                    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#React-router-API%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.</span> <span class="toc-text">React-router API接口</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text">组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Router"><span class="toc-number">1.1.1.</span> <span class="toc-text">Router</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Link"><span class="toc-number">1.1.2.</span> <span class="toc-text">Link</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexLink"><span class="toc-number">1.1.3.</span> <span class="toc-text">IndexLink</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RoutingContext"><span class="toc-number">1.1.4.</span> <span class="toc-text">RoutingContext</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">1.2.</span> <span class="toc-text">组件配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#route"><span class="toc-number">1.2.1.</span> <span class="toc-text">route</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PlainRoute"><span class="toc-number">1.2.2.</span> <span class="toc-text">PlainRoute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Redirect"><span class="toc-number">1.2.3.</span> <span class="toc-text">Redirect</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexRoute"><span class="toc-number">1.2.4.</span> <span class="toc-text">IndexRoute</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IndexRedirect"><span class="toc-number">1.2.5.</span> <span class="toc-text">IndexRedirect</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Route-Components"><span class="toc-number">1.3.</span> <span class="toc-text">Route Components</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%B2%E5%91%BD%E5%90%8D%E7%9A%84%E7%BB%84%E4%BB%B6"><span class="toc-number">1.3.1.</span> <span class="toc-text">已命名的组件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Mixins"><span class="toc-number">1.4.</span> <span class="toc-text">Mixins</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#History-Mixins"><span class="toc-number">1.4.2.</span> <span class="toc-text">History Mixins</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RouteContext-Mixins"><span class="toc-number">1.4.3.</span> <span class="toc-text">RouteContext Mixins</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E5%8D%95%E5%A4%84%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">表单处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Utilities"><span class="toc-number">1.6.</span> <span class="toc-text">Utilities</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#useRoutes-createHistory"><span class="toc-number">1.6.1.</span> <span class="toc-text">useRoutes(createHistory)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#matchmatch-location-cb"><span class="toc-number">1.6.2.</span> <span class="toc-text">matchmatch(location, cb)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createRoutes-routes"><span class="toc-number">1.6.3.</span> <span class="toc-text">createRoutes(routes)</span></a></li></ol></li></ol></li></ol>
                </div>
            </div>
            
            
        </div>
    </div>
</div>
    </div>
</div>
    <div id="back-to-top" class="animated fadeIn faster">
        <div class="flow"></div>
        <span class="percentage animated fadeIn faster">0%</span>
        <span class="iconfont icon-top02 animated fadeIn faster"></span>
    </div>
</body>
<footer>
    <p class="copyright" id="copyright">
        &copy; 2020
        <span class="gradient-text">
            张白告丶
        </span>.
    </p>
</footer>

<script type="text/javascript" src="https://cdn.bootcss.com/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
    "HTML-CSS": {
      preferredFont: "TeX",
      availableFonts: ["STIX", "TeX"],
      linebreaks: {
        automatic: true
      },
      EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50)
    },
    tex2jax: {
      inlineMath: [
        ["$", "$"],
        ["\\(", "\\)"]
      ],
      processEscapes: true,
      ignoreClass: "tex2jax_ignore|dno",
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      noUndefined: {
        attributes: {
          mathcolor: "red",
          mathbackground: "#FFEEEE",
          mathsize: "90%"
        }
      },
      Macros: {
        href: "{}"
      }
    },
    messageStyle: "none"
  });
</script>
<script>
  function initialMathJax() {
    MathJax.Hub.Queue(function () {
      var all = MathJax.Hub.getAllJax(),
        i;
      // console.log(all);
      for (i = 0; i < all.length; i += 1) {
        console.log(all[i].SourceElement().parentNode)
        all[i].SourceElement().parentNode.className += ' has-jax';
      }
    });
  }

  function reprocessMathJax() {
    if (typeof MathJax !== 'undefined') {
      MathJax.Hub.Queue(["Typeset", MathJax.Hub]);
    }
  }
</script>



    
<link rel="stylesheet" href="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.css">

    
<script src="//cdn.bootcss.com/gitalk/1.5.0/gitalk.min.js"></script>



<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/obsidian.js"></script>
<script src="/js/jquery.truncate.js"></script>
<script src="/js/search.js"></script>


<script src="//cdn.bootcss.com/typed.js/2.0.10/typed.min.js"></script>


<script src="//cdn.bootcss.com/blueimp-md5/2.12.0/js/md5.min.js"></script>


<script src="//cdnjs.cloudflare.com/ajax/libs/social-share.js/1.0.16/js/social-share.min.js"></script>


<script src="https://cdn.bootcss.com/codemirror/5.48.4/codemirror.min.js"></script>

    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/javascript/javascript.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/css/css.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/xml/xml.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/htmlmixed/htmlmixed.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/clike/clike.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/php/php.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/shell/shell.min.js"></script>


    
<script src="//cdn.bootcss.com/codemirror/5.48.4/mode/python/python.min.js"></script>




    
<script src="/js/busuanzi.min.js"></script>

    <script>
        $(document).ready(function () {
            if ($('span[id^="busuanzi_"]').length) {
                initialBusuanzi();
            }
        });
    </script>



<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.css">
<link rel="stylesheet" href="//cdn.bootcss.com/photoswipe/4.1.3/default-skin/default-skin.min.css">


<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe.min.js"></script>
<script src="//cdn.bootcss.com/photoswipe/4.1.3/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="//www.googletagmanager.com/gtag/js?id=UA-149874671-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-149874671-1');
    </script>





<script>
    function initialTyped () {
        var typedTextEl = $('.typed-text');
        if (typedTextEl && typedTextEl.length > 0) {
            var typed = new Typed('.typed-text', {
                strings: ["Think like an artist, develop like an artisan", "艺术家思维去思考问题，工匠创造精神去开发"],
                typeSpeed: 90,
                loop: true,
                loopCount: Infinity,
                backSpeed: 20,
            });
        }
    }

    if ($('.article-header') && $('.article-header').length) {
        $(document).ready(function () {
            initialTyped();
        });
    }
</script>




</html>
